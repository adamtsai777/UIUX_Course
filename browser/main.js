import {
  ANIMATION_MODULE_TYPE,
  APP_BOOTSTRAP_LISTENER,
  APP_ID,
  ActiveDescendantKeyManager,
  ApplicationModule,
  ApplicationRef,
  AsyncPipe,
  Attribute,
  BACKSPACE,
  BehaviorSubject,
  BidiModule,
  BlockScrollStrategy,
  CDK_TABLE,
  CSP_NONCE,
  CdkCell,
  CdkCellDef,
  CdkCellOutlet,
  CdkColumnDef,
  CdkFooterCell,
  CdkFooterCellDef,
  CdkFooterRow,
  CdkFooterRowDef,
  CdkHeaderCell,
  CdkHeaderCellDef,
  CdkHeaderRow,
  CdkHeaderRowDef,
  CdkPortal,
  CdkPortalOutlet,
  CdkRow,
  CdkRowDef,
  CdkTable,
  CdkTableModule,
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  CommonModule,
  Compiler,
  Component,
  ComponentPortal,
  ConnectableObservable,
  Console,
  ContentChild,
  ContentChildren,
  DELETE,
  DOCUMENT,
  DataRowOutlet,
  DataSource,
  DatePipe,
  DefaultValueAccessor,
  DestroyRef,
  Directionality,
  Directive,
  DomAdapter,
  EMPTY,
  ENTER,
  ENVIRONMENT_INITIALIZER,
  ESCAPE,
  ElementRef,
  EmptyError,
  EnvironmentInjector,
  ErrorHandler,
  EventEmitter,
  FlexibleConnectedPositionStrategy,
  FocusKeyManager,
  FocusMonitor,
  FocusTrap,
  FocusTrapFactory,
  FooterRowOutlet,
  FormStyle,
  FormatWidth,
  FormsModule,
  GlobalPositionStrategy,
  HashLocationStrategy,
  HeaderRowOutlet,
  Host,
  HostAttributeToken,
  HostBinding,
  HostListener,
  INJECTOR_SCOPE,
  INTERNAL_APPLICATION_ERROR_HANDLER,
  IS_ENABLED_BLOCKING_INITIAL_NAVIGATION,
  Inject,
  Injectable,
  InjectionToken,
  Injector,
  Input,
  InteractivityChecker,
  IterableDiffers,
  LOCALE_ID,
  LOCATION_INITIALIZED,
  Location,
  LocationStrategy,
  MatButton,
  MatCard,
  MatCardContent,
  MatCardTitle,
  MatFormField,
  MatInput,
  MatLabel,
  MatOption,
  MatSelect,
  NG_VALIDATORS,
  NG_VALUE_ACCESSOR,
  NgClass,
  NgControlStatus,
  NgControlStatusGroup,
  NgForOf,
  NgForm,
  NgIf,
  NgModel,
  NgModule,
  NgModuleFactory$1,
  NgSwitch,
  NgSwitchCase,
  NgSwitchDefault,
  NgTemplateOutlet,
  NgZone,
  NoDataRowOutlet,
  Observable,
  Optional,
  Output,
  Overlay,
  OverlayContainer,
  OverlayModule,
  OverlayPositionBuilder,
  PLATFORM_BROWSER_ID,
  PLATFORM_ID,
  PLATFORM_INITIALIZER,
  PathLocationStrategy,
  PendingTasksInternal,
  Pipe,
  Platform,
  PortalModule,
  Renderer2,
  RendererFactory2,
  RendererStyleFlags2,
  ReplaySubject,
  RuntimeError,
  SPACE,
  STICKY_POSITIONING_LISTENER,
  ScrollDispatcher,
  ScrollStrategyOptions,
  SecurityContext,
  SimpleChange,
  SkipSelf,
  Subject,
  Subscription,
  TESTABILITY,
  TESTABILITY_GETTER,
  TemplatePortal,
  TemplateRef,
  Testability,
  TestabilityRegistry,
  TracingService,
  TranslationWidth,
  Type,
  Validators,
  Version,
  ViewChild,
  ViewChildren,
  ViewContainerRef,
  ViewEncapsulation,
  ViewportRuler,
  ViewportScroller,
  XSS_SECURITY_URL,
  XhrFactory,
  _DisposeViewRepeaterStrategy,
  _VIEW_REPEATER_STRATEGY,
  __async,
  __commonJS,
  __objRest,
  __spreadProps,
  __spreadValues,
  __toESM,
  _global,
  _sanitizeHtml,
  _sanitizeUrl,
  afterNextRender,
  allLeavingAnimations,
  allowSanitizationBypassAndThrow,
  animationFrameScheduler,
  booleanAttribute,
  bypassSanitizationTrustHtml,
  bypassSanitizationTrustResourceUrl,
  bypassSanitizationTrustScript,
  bypassSanitizationTrustStyle,
  bypassSanitizationTrustUrl,
  catchError,
  coerceBooleanProperty,
  combineLatest,
  concat,
  concatMap,
  createEnvironmentInjector,
  createPlatformFactory,
  debounceTime,
  defaultIfEmpty,
  defer,
  delay,
  distinctUntilChanged,
  filter,
  finalize,
  first,
  forkJoin,
  formatRuntimeError,
  forwardRef,
  from,
  fromEvent,
  getDOM,
  getFirestore,
  getLocaleDayNames,
  getLocaleFirstDayOfWeek,
  getLocaleMonthNames,
  getLocaleTimeFormat,
  importProvidersFrom,
  initializeApp,
  inject,
  input,
  internalCreateApplication,
  interval,
  isDevMode,
  isInjectable,
  isNgModule,
  isObservable,
  isPlatformBrowser,
  isPromise,
  isStandalone,
  last,
  makeEnvironmentProviders,
  map,
  merge,
  mergeAll,
  mergeMap,
  observeOn,
  of,
  pairwise,
  parseCookieValue,
  performanceMarkFeature,
  pipe,
  platformCore,
  provideAppInitializer,
  provideFirebaseApp,
  provideFirestore,
  publish,
  publishExternalGlobalUtil,
  refCount,
  reflectComponentType,
  repeat,
  runInInjectionContext,
  scan,
  setClassMetadata,
  setDocument,
  setRootDomAdapter,
  share,
  signal,
  skip,
  startWith,
  switchMap,
  take,
  takeLast,
  takeUntil,
  takeWhile,
  tap,
  throttle,
  throwError,
  timer,
  untracked,
  unwrapSafeValue,
  ɵNgNoValidate,
  ɵsetClassDebugInfo,
  ɵɵInheritDefinitionFeature,
  ɵɵNgOnChangesFeature,
  ɵɵProvidersFeature,
  ɵɵadvance,
  ɵɵattribute,
  ɵɵclassMap,
  ɵɵclassProp,
  ɵɵcontentQuery,
  ɵɵdefineComponent,
  ɵɵdefineDirective,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdefinePipe,
  ɵɵdirectiveInject,
  ɵɵdomProperty,
  ɵɵelement,
  ɵɵelementContainer,
  ɵɵelementContainerEnd,
  ɵɵelementContainerStart,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵgetCurrentView,
  ɵɵgetInheritedFactory,
  ɵɵinject,
  ɵɵinjectAttribute,
  ɵɵinterpolate,
  ɵɵinterpolate1,
  ɵɵinvalidFactory,
  ɵɵlistener,
  ɵɵloadQuery,
  ɵɵnextContext,
  ɵɵpipe,
  ɵɵpipeBind1,
  ɵɵpipeBind2,
  ɵɵprojection,
  ɵɵprojectionDef,
  ɵɵproperty,
  ɵɵpureFunction1,
  ɵɵqueryRefresh,
  ɵɵreference,
  ɵɵresetView,
  ɵɵresolveWindow,
  ɵɵrestoreView,
  ɵɵsanitizeHtml,
  ɵɵsanitizeUrl,
  ɵɵsanitizeUrlOrResourceUrl,
  ɵɵstyleProp,
  ɵɵsyntheticHostProperty,
  ɵɵtemplate,
  ɵɵtemplateRefExtractor,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵtextInterpolate1,
  ɵɵtwoWayBindingSet,
  ɵɵtwoWayListener,
  ɵɵtwoWayProperty,
  ɵɵviewQuery
} from "./chunk-EOB6S6W5.js";

// node_modules/eva-icons/eva.js
var require_eva = __commonJS({
  "node_modules/eva-icons/eva.js"(exports, module) {
    "use strict";
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define("eva", [], factory);
      else if (typeof exports === "object")
        exports["eva"] = factory();
      else
        root["eva"] = factory();
    })(typeof self !== "undefined" ? self : exports, function() {
      return (
        /******/
        (function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module2 = installedModules[moduleId] = {
              /******/
              i: moduleId,
              /******/
              l: false,
              /******/
              exports: {}
              /******/
            };
            modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
            module2.l = true;
            return module2.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.d = function(exports2, name, getter) {
            if (!__webpack_require__.o(exports2, name)) {
              Object.defineProperty(exports2, name, { enumerable: true, get: getter });
            }
          };
          __webpack_require__.r = function(exports2) {
            if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
              Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
            }
            Object.defineProperty(exports2, "__esModule", { value: true });
          };
          __webpack_require__.t = function(value, mode) {
            if (mode & 1) value = __webpack_require__(value);
            if (mode & 8) return value;
            if (mode & 4 && typeof value === "object" && value && value.__esModule) return value;
            var ns = /* @__PURE__ */ Object.create(null);
            __webpack_require__.r(ns);
            Object.defineProperty(ns, "default", { enumerable: true, value });
            if (mode & 2 && typeof value != "string") for (var key in value) __webpack_require__.d(ns, key, (function(key2) {
              return value[key2];
            }).bind(null, key));
            return ns;
          };
          __webpack_require__.n = function(module2) {
            var getter = module2 && module2.__esModule ? (
              /******/
              function getDefault() {
                return module2["default"];
              }
            ) : (
              /******/
              function getModuleExports() {
                return module2;
              }
            );
            __webpack_require__.d(getter, "a", getter);
            return getter;
          };
          __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __webpack_require__.p = "";
          return __webpack_require__(__webpack_require__.s = "./package/src/index.js");
        })({
          /***/
          "./node_modules/classnames/dedupe.js": (
            /*!*******************************************!*\
              !*** ./node_modules/classnames/dedupe.js ***!
              \*******************************************/
            /*! no static exports found */
            /***/
            (function(module2, exports2, __webpack_require__) {
              var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
              (function() {
                "use strict";
                var classNames = (function() {
                  function StorageObject() {
                  }
                  StorageObject.prototype = /* @__PURE__ */ Object.create(null);
                  function _parseArray(resultSet, array) {
                    var length = array.length;
                    for (var i = 0; i < length; ++i) {
                      _parse(resultSet, array[i]);
                    }
                  }
                  var hasOwn = {}.hasOwnProperty;
                  function _parseNumber(resultSet, num) {
                    resultSet[num] = true;
                  }
                  function _parseObject(resultSet, object) {
                    for (var k in object) {
                      if (hasOwn.call(object, k)) {
                        resultSet[k] = !!object[k];
                      }
                    }
                  }
                  var SPACE2 = /\s+/;
                  function _parseString(resultSet, str) {
                    var array = str.split(SPACE2);
                    var length = array.length;
                    for (var i = 0; i < length; ++i) {
                      resultSet[array[i]] = true;
                    }
                  }
                  function _parse(resultSet, arg) {
                    if (!arg) return;
                    var argType = typeof arg;
                    if (argType === "string") {
                      _parseString(resultSet, arg);
                    } else if (Array.isArray(arg)) {
                      _parseArray(resultSet, arg);
                    } else if (argType === "object") {
                      _parseObject(resultSet, arg);
                    } else if (argType === "number") {
                      _parseNumber(resultSet, arg);
                    }
                  }
                  function _classNames() {
                    var len = arguments.length;
                    var args = Array(len);
                    for (var i = 0; i < len; i++) {
                      args[i] = arguments[i];
                    }
                    var classSet = new StorageObject();
                    _parseArray(classSet, args);
                    var list = [];
                    for (var k in classSet) {
                      if (classSet[k]) {
                        list.push(k);
                      }
                    }
                    return list.join(" ");
                  }
                  return _classNames;
                })();
                if (typeof module2 !== "undefined" && module2.exports) {
                  classNames.default = classNames;
                  module2.exports = classNames;
                } else if (true) {
                  !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
                    return classNames;
                  }).apply(exports2, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                } else {
                }
              })();
            })
          ),
          /***/
          "./node_modules/css-loader/index.js!./node_modules/sass-loader/lib/loader.js!./package/src/animation.scss": (
            /*!*******************************************************************************************************!*\
              !*** ./node_modules/css-loader!./node_modules/sass-loader/lib/loader.js!./package/src/animation.scss ***!
              \*******************************************************************************************************/
            /*! no static exports found */
            /***/
            (function(module2, exports2, __webpack_require__) {
              exports2 = module2.exports = __webpack_require__(
                /*! ../../node_modules/css-loader/lib/css-base.js */
                "./node_modules/css-loader/lib/css-base.js"
              )(false);
              exports2.push([module2.i, "/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n.eva-animation {\n  animation-duration: 1s;\n  animation-fill-mode: both; }\n\n.eva-infinite {\n  animation-iteration-count: infinite; }\n\n.eva-icon-shake {\n  animation-name: eva-shake; }\n\n.eva-icon-zoom {\n  animation-name: eva-zoomIn; }\n\n.eva-icon-pulse {\n  animation-name: eva-pulse; }\n\n.eva-icon-flip {\n  animation-name: eva-flipInY; }\n\n.eva-hover {\n  display: inline-block; }\n\n.eva-hover:hover .eva-icon-hover-shake, .eva-parent-hover:hover .eva-icon-hover-shake {\n  animation-name: eva-shake; }\n\n.eva-hover:hover .eva-icon-hover-zoom, .eva-parent-hover:hover .eva-icon-hover-zoom {\n  animation-name: eva-zoomIn; }\n\n.eva-hover:hover .eva-icon-hover-pulse, .eva-parent-hover:hover .eva-icon-hover-pulse {\n  animation-name: eva-pulse; }\n\n.eva-hover:hover .eva-icon-hover-flip, .eva-parent-hover:hover .eva-icon-hover-flip {\n  animation-name: eva-flipInY; }\n\n@keyframes eva-flipInY {\n  from {\n    transform: perspective(400px) rotate3d(0, 1, 0, 90deg);\n    animation-timing-function: ease-in;\n    opacity: 0; }\n  40% {\n    transform: perspective(400px) rotate3d(0, 1, 0, -20deg);\n    animation-timing-function: ease-in; }\n  60% {\n    transform: perspective(400px) rotate3d(0, 1, 0, 10deg);\n    opacity: 1; }\n  80% {\n    transform: perspective(400px) rotate3d(0, 1, 0, -5deg); }\n  to {\n    transform: perspective(400px); } }\n\n@keyframes eva-shake {\n  from,\n  to {\n    transform: translate3d(0, 0, 0); }\n  10%,\n  30%,\n  50%,\n  70%,\n  90% {\n    transform: translate3d(-3px, 0, 0); }\n  20%,\n  40%,\n  60%,\n  80% {\n    transform: translate3d(3px, 0, 0); } }\n\n@keyframes eva-pulse {\n  from {\n    transform: scale3d(1, 1, 1); }\n  50% {\n    transform: scale3d(1.2, 1.2, 1.2); }\n  to {\n    transform: scale3d(1, 1, 1); } }\n\n@keyframes eva-zoomIn {\n  from {\n    opacity: 1;\n    transform: scale3d(0.5, 0.5, 0.5); }\n  50% {\n    opacity: 1; } }\n", ""]);
            })
          ),
          /***/
          "./node_modules/css-loader/lib/css-base.js": (
            /*!*************************************************!*\
              !*** ./node_modules/css-loader/lib/css-base.js ***!
              \*************************************************/
            /*! no static exports found */
            /***/
            (function(module2, exports2) {
              module2.exports = function(useSourceMap) {
                var list = [];
                list.toString = function toString() {
                  return this.map(function(item) {
                    var content = cssWithMappingToString(item, useSourceMap);
                    if (item[2]) {
                      return "@media " + item[2] + "{" + content + "}";
                    } else {
                      return content;
                    }
                  }).join("");
                };
                list.i = function(modules, mediaQuery) {
                  if (typeof modules === "string")
                    modules = [[null, modules, ""]];
                  var alreadyImportedModules = {};
                  for (var i = 0; i < this.length; i++) {
                    var id = this[i][0];
                    if (typeof id === "number")
                      alreadyImportedModules[id] = true;
                  }
                  for (i = 0; i < modules.length; i++) {
                    var item = modules[i];
                    if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
                      if (mediaQuery && !item[2]) {
                        item[2] = mediaQuery;
                      } else if (mediaQuery) {
                        item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
                      }
                      list.push(item);
                    }
                  }
                };
                return list;
              };
              function cssWithMappingToString(item, useSourceMap) {
                var content = item[1] || "";
                var cssMapping = item[3];
                if (!cssMapping) {
                  return content;
                }
                if (useSourceMap && typeof btoa === "function") {
                  var sourceMapping = toComment(cssMapping);
                  var sourceURLs = cssMapping.sources.map(function(source) {
                    return "/*# sourceURL=" + cssMapping.sourceRoot + source + " */";
                  });
                  return [content].concat(sourceURLs).concat([sourceMapping]).join("\n");
                }
                return [content].join("\n");
              }
              function toComment(sourceMap) {
                var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
                var data = "sourceMappingURL=data:application/json;charset=utf-8;base64," + base64;
                return "/*# " + data + " */";
              }
            })
          ),
          /***/
          "./node_modules/isomorphic-style-loader/insertCss.js": (
            /*!***********************************************************!*\
              !*** ./node_modules/isomorphic-style-loader/insertCss.js ***!
              \***********************************************************/
            /*! no static exports found */
            /***/
            (function(module2, exports2, __webpack_require__) {
              "use strict";
              var inserted = {};
              function b64EncodeUnicode(str) {
                return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function(match2, p1) {
                  return String.fromCharCode("0x" + p1);
                }));
              }
              function removeCss(ids) {
                ids.forEach(function(id) {
                  if (--inserted[id] <= 0) {
                    var elem = document.getElementById(id);
                    if (elem) {
                      elem.parentNode.removeChild(elem);
                    }
                  }
                });
              }
              function insertCss(styles, _temp) {
                var _ref = _temp === void 0 ? {} : _temp, _ref$replace = _ref.replace, replace = _ref$replace === void 0 ? false : _ref$replace, _ref$prepend = _ref.prepend, prepend = _ref$prepend === void 0 ? false : _ref$prepend, _ref$prefix = _ref.prefix, prefix = _ref$prefix === void 0 ? "s" : _ref$prefix;
                var ids = [];
                for (var i = 0; i < styles.length; i++) {
                  var _styles$i = styles[i], moduleId = _styles$i[0], css = _styles$i[1], media = _styles$i[2], sourceMap = _styles$i[3];
                  var id = "" + prefix + moduleId + "-" + i;
                  ids.push(id);
                  if (inserted[id]) {
                    if (!replace) {
                      inserted[id]++;
                      continue;
                    }
                  }
                  inserted[id] = 1;
                  var elem = document.getElementById(id);
                  var create = false;
                  if (!elem) {
                    create = true;
                    elem = document.createElement("style");
                    elem.setAttribute("type", "text/css");
                    elem.id = id;
                    if (media) {
                      elem.setAttribute("media", media);
                    }
                  }
                  var cssText = css;
                  if (sourceMap && typeof btoa === "function") {
                    cssText += "\n/*# sourceMappingURL=data:application/json;base64," + b64EncodeUnicode(JSON.stringify(sourceMap)) + "*/";
                    cssText += "\n/*# sourceURL=" + sourceMap.file + "?" + id + "*/";
                  }
                  if ("textContent" in elem) {
                    elem.textContent = cssText;
                  } else {
                    elem.styleSheet.cssText = cssText;
                  }
                  if (create) {
                    if (prepend) {
                      document.head.insertBefore(elem, document.head.childNodes[0]);
                    } else {
                      document.head.appendChild(elem);
                    }
                  }
                }
                return removeCss.bind(null, ids);
              }
              module2.exports = insertCss;
            })
          ),
          /***/
          "./package-build/eva-icons.json": (
            /*!**************************************!*\
              !*** ./package-build/eva-icons.json ***!
              \**************************************/
            /*! exports provided: activity, alert-circle, alert-triangle, archive, arrow-back, arrow-circle-down, arrow-circle-left, arrow-circle-right, arrow-circle-up, arrow-down, arrow-downward, arrow-forward, arrow-ios-back, arrow-ios-downward, arrow-ios-forward, arrow-ios-upward, arrow-left, arrow-right, arrow-up, arrow-upward, arrowhead-down, arrowhead-left, arrowhead-right, arrowhead-up, at, attach-2, attach, award, backspace, bar-chart-2, bar-chart, battery, behance, bell-off, bell, bluetooth, book-open, book, bookmark, briefcase, browser, brush, bulb, calendar, camera, car, cast, charging, checkmark-circle-2, checkmark-circle, checkmark-square-2, checkmark-square, checkmark, chevron-down, chevron-left, chevron-right, chevron-up, clipboard, clock, close-circle, close-square, close, cloud-download, cloud-upload, code-download, code, collapse, color-palette, color-picker, compass, copy, corner-down-left, corner-down-right, corner-left-down, corner-left-up, corner-right-down, corner-right-up, corner-up-left, corner-up-right, credit-card, crop, cube, diagonal-arrow-left-down, diagonal-arrow-left-up, diagonal-arrow-right-down, diagonal-arrow-right-up, done-all, download, droplet-off, droplet, edit-2, edit, email, expand, external-link, eye-off-2, eye-off, eye, facebook, file-add, file-remove, file-text, file, film, flag, flash-off, flash, flip-2, flip, folder-add, folder-remove, folder, funnel, gift, github, globe-2, globe-3, globe, google, grid, hard-drive, hash, headphones, heart, home, image-2, image, inbox, info, keypad, layers, layout, link-2, link, linkedin, list, lock, log-in, log-out, map, maximize, menu-2, menu-arrow, menu, message-circle, message-square, mic-off, mic, minimize, minus-circle, minus-square, minus, monitor, moon, more-horizontal, more-vertical, move, music, navigation-2, navigation, npm, options-2, options, pantone, paper-plane, pause-circle, people, percent, person-add, person-delete, person-done, person-remove, person, phone-call, phone-missed, phone-off, phone, pie-chart-2, pie-chart, pin, play-circle, plus-circle, plus-square, plus, power, pricetags, printer, question-mark-circle, question-mark, radio-button-off, radio-button-on, radio, recording, refresh, repeat, rewind-left, rewind-right, save, scissors, search, settings-2, settings, shake, share, shield-off, shield, shopping-bag, shopping-cart, shuffle-2, shuffle, skip-back, skip-forward, slash, smartphone, smiling-face, speaker, square, star, stop-circle, sun, swap, sync, text, thermometer-minus, thermometer-plus, thermometer, toggle-left, toggle-right, trash-2, trash, trending-down, trending-up, tv, twitter, umbrella, undo, unlock, upload, video-off, video, volume-down, volume-mute, volume-off, volume-up, wifi-off, wifi, activity-outline, alert-circle-outline, alert-triangle-outline, archive-outline, arrow-back-outline, arrow-circle-down-outline, arrow-circle-left-outline, arrow-circle-right-outline, arrow-circle-up-outline, arrow-down-outline, arrow-downward-outline, arrow-forward-outline, arrow-ios-back-outline, arrow-ios-downward-outline, arrow-ios-forward-outline, arrow-ios-upward-outline, arrow-left-outline, arrow-right-outline, arrow-up-outline, arrow-upward-outline, arrowhead-down-outline, arrowhead-left-outline, arrowhead-right-outline, arrowhead-up-outline, at-outline, attach-2-outline, attach-outline, award-outline, backspace-outline, bar-chart-2-outline, bar-chart-outline, battery-outline, behance-outline, bell-off-outline, bell-outline, bluetooth-outline, book-open-outline, book-outline, bookmark-outline, briefcase-outline, browser-outline, brush-outline, bulb-outline, calendar-outline, camera-outline, car-outline, cast-outline, charging-outline, checkmark-circle-2-outline, checkmark-circle-outline, checkmark-outline, checkmark-square-2-outline, checkmark-square-outline, chevron-down-outline, chevron-left-outline, chevron-right-outline, chevron-up-outline, clipboard-outline, clock-outline, close-circle-outline, close-outline, close-square-outline, cloud-download-outline, cloud-upload-outline, code-download-outline, code-outline, collapse-outline, color-palette-outline, color-picker-outline, compass-outline, copy-outline, corner-down-left-outline, corner-down-right-outline, corner-left-down-outline, corner-left-up-outline, corner-right-down-outline, corner-right-up-outline, corner-up-left-outline, corner-up-right-outline, credit-card-outline, crop-outline, cube-outline, diagonal-arrow-left-down-outline, diagonal-arrow-left-up-outline, diagonal-arrow-right-down-outline, diagonal-arrow-right-up-outline, done-all-outline, download-outline, droplet-off-outline, droplet-outline, edit-2-outline, edit-outline, email-outline, expand-outline, external-link-outline, eye-off-2-outline, eye-off-outline, eye-outline, facebook-outline, file-add-outline, file-outline, file-remove-outline, file-text-outline, film-outline, flag-outline, flash-off-outline, flash-outline, flip-2-outline, flip-outline, folder-add-outline, folder-outline, folder-remove-outline, funnel-outline, gift-outline, github-outline, globe-2-outline, globe-outline, google-outline, grid-outline, hard-drive-outline, hash-outline, headphones-outline, heart-outline, home-outline, image-outline, inbox-outline, info-outline, keypad-outline, layers-outline, layout-outline, link-2-outline, link-outline, linkedin-outline, list-outline, loader-outline, lock-outline, log-in-outline, log-out-outline, map-outline, maximize-outline, menu-2-outline, menu-arrow-outline, menu-outline, message-circle-outline, message-square-outline, mic-off-outline, mic-outline, minimize-outline, minus-circle-outline, minus-outline, minus-square-outline, monitor-outline, moon-outline, more-horizontal-outline, more-vertical-outline, move-outline, music-outline, navigation-2-outline, navigation-outline, npm-outline, options-2-outline, options-outline, pantone-outline, paper-plane-outline, pause-circle-outline, people-outline, percent-outline, person-add-outline, person-delete-outline, person-done-outline, person-outline, person-remove-outline, phone-call-outline, phone-missed-outline, phone-off-outline, phone-outline, pie-chart-outline, pin-outline, play-circle-outline, plus-circle-outline, plus-outline, plus-square-outline, power-outline, pricetags-outline, printer-outline, question-mark-circle-outline, question-mark-outline, radio-button-off-outline, radio-button-on-outline, radio-outline, recording-outline, refresh-outline, repeat-outline, rewind-left-outline, rewind-right-outline, save-outline, scissors-outline, search-outline, settings-2-outline, settings-outline, shake-outline, share-outline, shield-off-outline, shield-outline, shopping-bag-outline, shopping-cart-outline, shuffle-2-outline, shuffle-outline, skip-back-outline, skip-forward-outline, slash-outline, smartphone-outline, smiling-face-outline, speaker-outline, square-outline, star-outline, stop-circle-outline, sun-outline, swap-outline, sync-outline, text-outline, thermometer-minus-outline, thermometer-outline, thermometer-plus-outline, toggle-left-outline, toggle-right-outline, trash-2-outline, trash-outline, trending-down-outline, trending-up-outline, tv-outline, twitter-outline, umbrella-outline, undo-outline, unlock-outline, upload-outline, video-off-outline, video-outline, volume-down-outline, volume-mute-outline, volume-off-outline, volume-up-outline, wifi-off-outline, wifi-outline, default */
            /***/
            (function(module2) {
              module2.exports = { "activity": '<g data-name="Layer 2"><g data-name="activity"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M14.33 20h-.21a2 2 0 0 1-1.76-1.58L9.68 6l-2.76 6.4A1 1 0 0 1 6 13H3a1 1 0 0 1 0-2h2.34l2.51-5.79a2 2 0 0 1 3.79.38L14.32 18l2.76-6.38A1 1 0 0 1 18 11h3a1 1 0 0 1 0 2h-2.34l-2.51 5.79A2 2 0 0 1 14.33 20z"/></g></g>', "alert-circle": '<g data-name="Layer 2"><g data-name="alert-circle"><rect width="24" height="24" opacity="0"/><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 15a1 1 0 1 1 1-1 1 1 0 0 1-1 1zm1-4a1 1 0 0 1-2 0V8a1 1 0 0 1 2 0z"/></g></g>', "alert-triangle": '<g data-name="Layer 2"><g data-name="alert-triangle"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M22.56 16.3L14.89 3.58a3.43 3.43 0 0 0-5.78 0L1.44 16.3a3 3 0 0 0-.05 3A3.37 3.37 0 0 0 4.33 21h15.34a3.37 3.37 0 0 0 2.94-1.66 3 3 0 0 0-.05-3.04zM12 17a1 1 0 1 1 1-1 1 1 0 0 1-1 1zm1-4a1 1 0 0 1-2 0V9a1 1 0 0 1 2 0z"/></g></g>', "archive": '<g data-name="Layer 2"><g data-name="archive"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M18 3H6a3 3 0 0 0-2 5.22V18a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3V8.22A3 3 0 0 0 18 3zm-3 10.13a.87.87 0 0 1-.87.87H9.87a.87.87 0 0 1-.87-.87v-.26a.87.87 0 0 1 .87-.87h4.26a.87.87 0 0 1 .87.87zM18 7H6a1 1 0 0 1 0-2h12a1 1 0 0 1 0 2z"/></g></g>', "arrow-back": '<g data-name="Layer 2"><g data-name="arrow-back"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M19 11H7.14l3.63-4.36a1 1 0 1 0-1.54-1.28l-5 6a1.19 1.19 0 0 0-.09.15c0 .05 0 .08-.07.13A1 1 0 0 0 4 12a1 1 0 0 0 .07.36c0 .05 0 .08.07.13a1.19 1.19 0 0 0 .09.15l5 6A1 1 0 0 0 10 19a1 1 0 0 0 .64-.23 1 1 0 0 0 .13-1.41L7.14 13H19a1 1 0 0 0 0-2z"/></g></g>', "arrow-circle-down": '<g data-name="Layer 2"><g data-name="arrow-circle-down"><rect width="24" height="24" opacity="0"/><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm3.69 11.86l-3 2.86a.49.49 0 0 1-.15.1.54.54 0 0 1-.16.1.94.94 0 0 1-.76 0 1 1 0 0 1-.33-.21l-3-3a1 1 0 0 1 1.42-1.42l1.29 1.3V8a1 1 0 0 1 2 0v5.66l1.31-1.25a1 1 0 0 1 1.38 1.45z"/></g></g>', "arrow-circle-left": '<g data-name="Layer 2"><g data-name="arrow-circle-left"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M22 12a10 10 0 1 0-10 10 10 10 0 0 0 10-10zm-11.86 3.69l-2.86-3a.49.49 0 0 1-.1-.15.54.54 0 0 1-.1-.16.94.94 0 0 1 0-.76 1 1 0 0 1 .21-.33l3-3a1 1 0 0 1 1.42 1.42L10.41 11H16a1 1 0 0 1 0 2h-5.66l1.25 1.31a1 1 0 0 1-1.45 1.38z"/></g></g>', "arrow-circle-right": '<g data-name="Layer 2"><g data-name="arrow-circle-right"><rect width="24" height="24" transform="rotate(-90 12 12)" opacity="0"/><path d="M2 12A10 10 0 1 0 12 2 10 10 0 0 0 2 12zm11.86-3.69l2.86 3a.49.49 0 0 1 .1.15.54.54 0 0 1 .1.16.94.94 0 0 1 0 .76 1 1 0 0 1-.21.33l-3 3a1 1 0 0 1-1.42-1.42l1.3-1.29H8a1 1 0 0 1 0-2h5.66l-1.25-1.31a1 1 0 0 1 1.45-1.38z"/></g></g>', "arrow-circle-up": '<g data-name="Layer 2"><g data-name="arrow-circle-up"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M12 22A10 10 0 1 0 2 12a10 10 0 0 0 10 10zM8.31 10.14l3-2.86a.49.49 0 0 1 .15-.1.54.54 0 0 1 .16-.1.94.94 0 0 1 .76 0 1 1 0 0 1 .33.21l3 3a1 1 0 0 1-1.42 1.42L13 10.41V16a1 1 0 0 1-2 0v-5.66l-1.31 1.25a1 1 0 0 1-1.38-1.45z"/></g></g>', "arrow-down": '<g data-name="Layer 2"><g data-name="arrow-downward"><rect width="24" height="24" transform="rotate(-90 12 12)" opacity="0"/><path d="M12 17a1.72 1.72 0 0 1-1.33-.64l-4.21-5.1a2.1 2.1 0 0 1-.26-2.21A1.76 1.76 0 0 1 7.79 8h8.42a1.76 1.76 0 0 1 1.59 1.05 2.1 2.1 0 0 1-.26 2.21l-4.21 5.1A1.72 1.72 0 0 1 12 17z"/></g></g>', "arrow-downward": '<g data-name="Layer 2"><g data-name="arrow-down"><rect width="24" height="24" opacity="0"/><path d="M18.77 13.36a1 1 0 0 0-1.41-.13L13 16.86V5a1 1 0 0 0-2 0v11.86l-4.36-3.63a1 1 0 1 0-1.28 1.54l6 5 .15.09.13.07a1 1 0 0 0 .72 0l.13-.07.15-.09 6-5a1 1 0 0 0 .13-1.41z"/></g></g>', "arrow-forward": '<g data-name="Layer 2"><g data-name="arrow-forward"><rect width="24" height="24" transform="rotate(-90 12 12)" opacity="0"/><path d="M5 13h11.86l-3.63 4.36a1 1 0 0 0 1.54 1.28l5-6a1.19 1.19 0 0 0 .09-.15c0-.05.05-.08.07-.13A1 1 0 0 0 20 12a1 1 0 0 0-.07-.36c0-.05-.05-.08-.07-.13a1.19 1.19 0 0 0-.09-.15l-5-6A1 1 0 0 0 14 5a1 1 0 0 0-.64.23 1 1 0 0 0-.13 1.41L16.86 11H5a1 1 0 0 0 0 2z"/></g></g>', "arrow-ios-back": '<g data-name="Layer 2"><g data-name="arrow-ios-back"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M13.83 19a1 1 0 0 1-.78-.37l-4.83-6a1 1 0 0 1 0-1.27l5-6a1 1 0 0 1 1.54 1.28L10.29 12l4.32 5.36a1 1 0 0 1-.78 1.64z"/></g></g>', "arrow-ios-downward": '<g data-name="Layer 2"><g data-name="arrow-ios-downward"><rect width="24" height="24" opacity="0"/><path d="M12 16a1 1 0 0 1-.64-.23l-6-5a1 1 0 1 1 1.28-1.54L12 13.71l5.36-4.32a1 1 0 0 1 1.41.15 1 1 0 0 1-.14 1.46l-6 4.83A1 1 0 0 1 12 16z"/></g></g>', "arrow-ios-forward": '<g data-name="Layer 2"><g data-name="arrow-ios-forward"><rect width="24" height="24" transform="rotate(-90 12 12)" opacity="0"/><path d="M10 19a1 1 0 0 1-.64-.23 1 1 0 0 1-.13-1.41L13.71 12 9.39 6.63a1 1 0 0 1 .15-1.41 1 1 0 0 1 1.46.15l4.83 6a1 1 0 0 1 0 1.27l-5 6A1 1 0 0 1 10 19z"/></g></g>', "arrow-ios-upward": '<g data-name="Layer 2"><g data-name="arrow-ios-upward"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M18 15a1 1 0 0 1-.64-.23L12 10.29l-5.37 4.32a1 1 0 0 1-1.41-.15 1 1 0 0 1 .15-1.41l6-4.83a1 1 0 0 1 1.27 0l6 5a1 1 0 0 1 .13 1.41A1 1 0 0 1 18 15z"/></g></g>', "arrow-left": '<g data-name="Layer 2"><g data-name="arrow-left"><rect width="24" height="24" opacity="0"/><path d="M13.54 18a2.06 2.06 0 0 1-1.3-.46l-5.1-4.21a1.7 1.7 0 0 1 0-2.66l5.1-4.21a2.1 2.1 0 0 1 2.21-.26 1.76 1.76 0 0 1 1.05 1.59v8.42a1.76 1.76 0 0 1-1.05 1.59 2.23 2.23 0 0 1-.91.2z"/></g></g>', "arrow-right": '<g data-name="Layer 2"><g data-name="arrow-right"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M10.46 18a2.23 2.23 0 0 1-.91-.2 1.76 1.76 0 0 1-1.05-1.59V7.79A1.76 1.76 0 0 1 9.55 6.2a2.1 2.1 0 0 1 2.21.26l5.1 4.21a1.7 1.7 0 0 1 0 2.66l-5.1 4.21a2.06 2.06 0 0 1-1.3.46z"/></g></g>', "arrow-up": '<g data-name="Layer 2"><g data-name="arrow-up"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M16.21 16H7.79a1.76 1.76 0 0 1-1.59-1 2.1 2.1 0 0 1 .26-2.21l4.21-5.1a1.76 1.76 0 0 1 2.66 0l4.21 5.1A2.1 2.1 0 0 1 17.8 15a1.76 1.76 0 0 1-1.59 1z"/></g></g>', "arrow-upward": '<g data-name="Layer 2"><g data-name="arrow-upward"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M5.23 10.64a1 1 0 0 0 1.41.13L11 7.14V19a1 1 0 0 0 2 0V7.14l4.36 3.63a1 1 0 1 0 1.28-1.54l-6-5-.15-.09-.13-.07a1 1 0 0 0-.72 0l-.13.07-.15.09-6 5a1 1 0 0 0-.13 1.41z"/></g></g>', "arrowhead-down": '<g data-name="Layer 2"><g data-name="arrowhead-down"><rect width="24" height="24" opacity="0"/><path d="M17.37 12.39L12 16.71l-5.36-4.48a1 1 0 1 0-1.28 1.54l6 5a1 1 0 0 0 1.27 0l6-4.83a1 1 0 0 0 .15-1.41 1 1 0 0 0-1.41-.14z"/><path d="M11.36 11.77a1 1 0 0 0 1.27 0l6-4.83a1 1 0 0 0 .15-1.41 1 1 0 0 0-1.41-.15L12 9.71 6.64 5.23a1 1 0 0 0-1.28 1.54z"/></g></g>', "arrowhead-left": '<g data-name="Layer 2"><g data-name="arrowhead-left"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M11.64 5.23a1 1 0 0 0-1.41.13l-5 6a1 1 0 0 0 0 1.27l4.83 6a1 1 0 0 0 .78.37 1 1 0 0 0 .78-1.63L7.29 12l4.48-5.37a1 1 0 0 0-.13-1.4z"/><path d="M14.29 12l4.48-5.37a1 1 0 0 0-1.54-1.28l-5 6a1 1 0 0 0 0 1.27l4.83 6a1 1 0 0 0 .78.37 1 1 0 0 0 .78-1.63z"/></g></g>', "arrowhead-right": '<g data-name="Layer 2"><g data-name="arrowhead-right"><rect width="24" height="24" transform="rotate(-90 12 12)" opacity="0"/><path d="M18.78 11.37l-4.78-6a1 1 0 0 0-1.41-.15 1 1 0 0 0-.15 1.41L16.71 12l-4.48 5.37a1 1 0 0 0 .13 1.41A1 1 0 0 0 13 19a1 1 0 0 0 .77-.36l5-6a1 1 0 0 0 .01-1.27z"/><path d="M7 5.37a1 1 0 0 0-1.61 1.26L9.71 12l-4.48 5.36a1 1 0 0 0 .13 1.41A1 1 0 0 0 6 19a1 1 0 0 0 .77-.36l5-6a1 1 0 0 0 0-1.27z"/></g></g>', "arrowhead-up": '<g data-name="Layer 2"><g data-name="arrowhead-up"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M6.63 11.61L12 7.29l5.37 4.48A1 1 0 0 0 18 12a1 1 0 0 0 .77-.36 1 1 0 0 0-.13-1.41l-6-5a1 1 0 0 0-1.27 0l-6 4.83a1 1 0 0 0-.15 1.41 1 1 0 0 0 1.41.14z"/><path d="M12.64 12.23a1 1 0 0 0-1.27 0l-6 4.83a1 1 0 0 0-.15 1.41 1 1 0 0 0 1.41.15L12 14.29l5.37 4.48A1 1 0 0 0 18 19a1 1 0 0 0 .77-.36 1 1 0 0 0-.13-1.41z"/></g></g>', "at": '<g data-name="Layer 2"><g data-name="at"><rect width="24" height="24" opacity="0"/><path d="M13 2a10 10 0 0 0-5 19.1 10.15 10.15 0 0 0 4 .9 10 10 0 0 0 6.08-2.06 1 1 0 0 0 .19-1.4 1 1 0 0 0-1.41-.19A8 8 0 1 1 12.77 4 8.17 8.17 0 0 1 20 12.22v.68a1.71 1.71 0 0 1-1.78 1.7 1.82 1.82 0 0 1-1.62-1.88V8.4a1 1 0 0 0-1-1 1 1 0 0 0-1 .87 5 5 0 0 0-3.44-1.36A5.09 5.09 0 1 0 15.31 15a3.6 3.6 0 0 0 5.55.61A3.67 3.67 0 0 0 22 12.9v-.68A10.2 10.2 0 0 0 13 2zm-1.82 13.09A3.09 3.09 0 1 1 14.27 12a3.1 3.1 0 0 1-3.09 3.09z"/></g></g>', "attach-2": '<g data-name="Layer 2"><g data-name="attach-2"><rect width="24" height="24" opacity="0"/><path d="M12 22a5.86 5.86 0 0 1-6-5.7V6.13A4.24 4.24 0 0 1 10.33 2a4.24 4.24 0 0 1 4.34 4.13v10.18a2.67 2.67 0 0 1-5.33 0V6.92a1 1 0 0 1 1-1 1 1 0 0 1 1 1v9.39a.67.67 0 0 0 1.33 0V6.13A2.25 2.25 0 0 0 10.33 4 2.25 2.25 0 0 0 8 6.13V16.3a3.86 3.86 0 0 0 4 3.7 3.86 3.86 0 0 0 4-3.7V6.13a1 1 0 1 1 2 0V16.3a5.86 5.86 0 0 1-6 5.7z"/></g></g>', "attach": '<g data-name="Layer 2"><g data-name="attach"><rect width="24" height="24" opacity="0"/><path d="M9.29 21a6.23 6.23 0 0 1-4.43-1.88 6 6 0 0 1-.22-8.49L12 3.2A4.11 4.11 0 0 1 15 2a4.48 4.48 0 0 1 3.19 1.35 4.36 4.36 0 0 1 .15 6.13l-7.4 7.43a2.54 2.54 0 0 1-1.81.75 2.72 2.72 0 0 1-1.95-.82 2.68 2.68 0 0 1-.08-3.77l6.83-6.86a1 1 0 0 1 1.37 1.41l-6.83 6.86a.68.68 0 0 0 .08.95.78.78 0 0 0 .53.23.56.56 0 0 0 .4-.16l7.39-7.43a2.36 2.36 0 0 0-.15-3.31 2.38 2.38 0 0 0-3.27-.15L6.06 12a4 4 0 0 0 .22 5.67 4.22 4.22 0 0 0 3 1.29 3.67 3.67 0 0 0 2.61-1.06l7.39-7.43a1 1 0 1 1 1.42 1.41l-7.39 7.43A5.65 5.65 0 0 1 9.29 21z"/></g></g>', "award": '<g data-name="Layer 2"><g data-name="award"><rect width="24" height="24" opacity="0"/><path d="M19 20.75l-2.31-9A5.94 5.94 0 0 0 18 8 6 6 0 0 0 6 8a5.94 5.94 0 0 0 1.34 3.77L5 20.75a1 1 0 0 0 1.48 1.11l5.33-3.13 5.68 3.14A.91.91 0 0 0 18 22a1 1 0 0 0 1-1.25zM12 4a4 4 0 1 1-4 4 4 4 0 0 1 4-4z"/></g></g>', "backspace": '<g data-name="Layer 2"><g data-name="backspace"><rect width="24" height="24" opacity="0"/><path d="M20.14 4h-9.77a3 3 0 0 0-2 .78l-.1.11-6 7.48a1 1 0 0 0 .11 1.37l6 5.48a3 3 0 0 0 2 .78h9.77A1.84 1.84 0 0 0 22 18.18V5.82A1.84 1.84 0 0 0 20.14 4zm-3.43 9.29a1 1 0 0 1 0 1.42 1 1 0 0 1-1.42 0L14 13.41l-1.29 1.3a1 1 0 0 1-1.42 0 1 1 0 0 1 0-1.42l1.3-1.29-1.3-1.29a1 1 0 0 1 1.42-1.42l1.29 1.3 1.29-1.3a1 1 0 0 1 1.42 1.42L15.41 12z"/></g></g>', "bar-chart-2": '<g data-name="Layer 2"><g data-name="bar-chart-2"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M12 8a1 1 0 0 0-1 1v11a1 1 0 0 0 2 0V9a1 1 0 0 0-1-1z"/><path d="M19 4a1 1 0 0 0-1 1v15a1 1 0 0 0 2 0V5a1 1 0 0 0-1-1z"/><path d="M5 12a1 1 0 0 0-1 1v7a1 1 0 0 0 2 0v-7a1 1 0 0 0-1-1z"/></g></g>', "bar-chart": '<g data-name="Layer 2"><g data-name="bar-chart"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M12 4a1 1 0 0 0-1 1v15a1 1 0 0 0 2 0V5a1 1 0 0 0-1-1z"/><path d="M19 12a1 1 0 0 0-1 1v7a1 1 0 0 0 2 0v-7a1 1 0 0 0-1-1z"/><path d="M5 8a1 1 0 0 0-1 1v11a1 1 0 0 0 2 0V9a1 1 0 0 0-1-1z"/></g></g>', "battery": '<g data-name="Layer 2"><g data-name="battery"><rect width="24" height="24" opacity="0"/><path d="M15.83 6H4.17A2.31 2.31 0 0 0 2 8.43v7.14A2.31 2.31 0 0 0 4.17 18h11.66A2.31 2.31 0 0 0 18 15.57V8.43A2.31 2.31 0 0 0 15.83 6z"/><path d="M21 9a1 1 0 0 0-1 1v4a1 1 0 0 0 2 0v-4a1 1 0 0 0-1-1z"/></g></g>', "behance": '<g data-name="Layer 2"><g data-name="behance"><rect width="24" height="24" opacity="0"/><path d="M14.76 11.19a1 1 0 0 0-1 1.09h2.06a1 1 0 0 0-1.06-1.09z"/><path d="M9.49 12.3H8.26v1.94h1c1 0 1.44-.33 1.44-1s-.46-.94-1.21-.94z"/><path d="M10.36 10.52c0-.53-.35-.85-.95-.85H8.26v1.74h.85c.89 0 1.25-.32 1.25-.89z"/><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zM9.7 15.2H7V8.7h2.7c1.17 0 1.94.61 1.94 1.6a1.4 1.4 0 0 1-1.12 1.43A1.52 1.52 0 0 1 12 13.37c0 1.16-1 1.83-2.3 1.83zm3.55-6h3v.5h-3zM17 13.05h-3.3v.14a1.07 1.07 0 0 0 1.09 1.19.9.9 0 0 0 1-.63H17a2 2 0 0 1-2.17 1.55 2.15 2.15 0 0 1-2.36-2.3v-.44a2.11 2.11 0 0 1 2.28-2.25A2.12 2.12 0 0 1 17 12.58z"/></g></g>', "bell-off": '<g data-name="Layer 2"><g data-name="bell-off"><rect width="24" height="24" opacity="0"/><path d="M15.88 18.71l-.59-.59L14 16.78l-.07-.07L6.58 9.4 5.31 8.14a5.68 5.68 0 0 0 0 .59v4.67l-1.8 1.81A1.64 1.64 0 0 0 4.64 18H8v.34A3.84 3.84 0 0 0 12 22a3.88 3.88 0 0 0 4-3.22zM14 18.34A1.88 1.88 0 0 1 12 20a1.88 1.88 0 0 1-2-1.66V18h4z"/><path d="M7.13 4.3l1.46 1.46 9.53 9.53 2 2 .31.3a1.58 1.58 0 0 0 .45-.6 1.62 1.62 0 0 0-.35-1.78l-1.8-1.81V8.94a6.86 6.86 0 0 0-5.83-6.88 6.71 6.71 0 0 0-5.32 1.61 6.88 6.88 0 0 0-.58.54z"/><path d="M20.71 19.29L19.41 18l-2-2-9.52-9.53L6.42 5 4.71 3.29a1 1 0 0 0-1.42 1.42L5.53 7l1.75 1.7 7.31 7.3.07.07L16 17.41l.59.59 2.7 2.71a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42z"/></g></g>', "bell": '<g data-name="Layer 2"><g data-name="bell"><rect width="24" height="24" opacity="0"/><path d="M20.52 15.21l-1.8-1.81V8.94a6.86 6.86 0 0 0-5.82-6.88 6.74 6.74 0 0 0-7.62 6.67v4.67l-1.8 1.81A1.64 1.64 0 0 0 4.64 18H8v.34A3.84 3.84 0 0 0 12 22a3.84 3.84 0 0 0 4-3.66V18h3.36a1.64 1.64 0 0 0 1.16-2.79zM14 18.34A1.88 1.88 0 0 1 12 20a1.88 1.88 0 0 1-2-1.66V18h4z"/></g></g>', "bluetooth": '<g data-name="Layer 2"><g data-name="bluetooth"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M13.63 12l4-3.79a1.14 1.14 0 0 0-.13-1.77l-4.67-3.23a1.17 1.17 0 0 0-1.21-.08 1.15 1.15 0 0 0-.62 1v6.2l-3.19-4a1 1 0 0 0-1.56 1.3L9.72 12l-3.5 4.43a1 1 0 0 0 .16 1.4A1 1 0 0 0 7 18a1 1 0 0 0 .78-.38L11 13.56v6.29A1.16 1.16 0 0 0 12.16 21a1.16 1.16 0 0 0 .67-.21l4.64-3.18a1.17 1.17 0 0 0 .49-.85 1.15 1.15 0 0 0-.34-.91zM13 5.76l2.5 1.73L13 9.85zm0 12.49v-4.07l2.47 2.38z"/></g></g>', "book-open": '<g data-name="Layer 2"><g data-name="book-open"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M21 4.34a1.24 1.24 0 0 0-1.08-.23L13 5.89v14.27l7.56-1.94A1.25 1.25 0 0 0 21.5 17V5.32a1.25 1.25 0 0 0-.5-.98z"/><path d="M11 5.89L4.06 4.11A1.27 1.27 0 0 0 3 4.34a1.25 1.25 0 0 0-.48 1V17a1.25 1.25 0 0 0 .94 1.21L11 20.16z"/></g></g>', "book": '<g data-name="Layer 2"><g data-name="book"><rect width="24" height="24" opacity="0"/><path d="M19 3H7a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h12a1 1 0 0 0 1-1V4a1 1 0 0 0-1-1zM7 19a1 1 0 0 1 0-2h11v2z"/></g></g>', "bookmark": '<g data-name="Layer 2"><g data-name="bookmark"><rect width="24" height="24" opacity="0"/><path d="M6 21a1 1 0 0 1-.49-.13A1 1 0 0 1 5 20V5.33A2.28 2.28 0 0 1 7.2 3h9.6A2.28 2.28 0 0 1 19 5.33V20a1 1 0 0 1-.5.86 1 1 0 0 1-1 0l-5.67-3.21-5.33 3.2A1 1 0 0 1 6 21z"/></g></g>', "briefcase": '<g data-name="Layer 2"><g data-name="briefcase"><rect width="24" height="24" opacity="0"/><path d="M7 21h10V7h-1V5.5A2.5 2.5 0 0 0 13.5 3h-3A2.5 2.5 0 0 0 8 5.5V7H7zm3-15.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5V7h-4z"/><path d="M19 7v14a3 3 0 0 0 3-3v-8a3 3 0 0 0-3-3z"/><path d="M5 7a3 3 0 0 0-3 3v8a3 3 0 0 0 3 3z"/></g></g>', "browser": '<g data-name="Layer 2"><g data-name="browser"><rect width="24" height="24" opacity="0"/><path d="M18 3H6a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3V6a3 3 0 0 0-3-3zm-6 3a1 1 0 1 1-1 1 1 1 0 0 1 1-1zM8 6a1 1 0 1 1-1 1 1 1 0 0 1 1-1zm11 12a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1v-7h14z"/></g></g>', "brush": '<g data-name="Layer 2"><g data-name="brush"><rect width="24" height="24" opacity="0"/><path d="M7.12 12.55a4 4 0 0 0-3.07 3.86v3.11a.47.47 0 0 0 .48.48l3.24-.06a3.78 3.78 0 0 0 3.44-2.2 3.65 3.65 0 0 0-4.09-5.19z"/><path d="M19.26 4.46a2.14 2.14 0 0 0-2.88.21L10 11.08a.47.47 0 0 0 0 .66L12.25 14a.47.47 0 0 0 .66 0l6.49-6.47a2.06 2.06 0 0 0 .6-1.47 2 2 0 0 0-.74-1.6z"/></g></g>', "bulb": '<g data-name="Layer 2"><g data-name="bulb"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M12 7a5 5 0 0 0-3 9v4a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2v-4a5 5 0 0 0-3-9z"/><path d="M12 6a1 1 0 0 0 1-1V3a1 1 0 0 0-2 0v2a1 1 0 0 0 1 1z"/><path d="M21 11h-2a1 1 0 0 0 0 2h2a1 1 0 0 0 0-2z"/><path d="M5 11H3a1 1 0 0 0 0 2h2a1 1 0 0 0 0-2z"/><path d="M7.66 6.42L6.22 5a1 1 0 0 0-1.39 1.47l1.44 1.39a1 1 0 0 0 .73.28 1 1 0 0 0 .72-.31 1 1 0 0 0-.06-1.41z"/><path d="M19.19 5.05a1 1 0 0 0-1.41 0l-1.44 1.37a1 1 0 0 0 0 1.41 1 1 0 0 0 .72.31 1 1 0 0 0 .69-.28l1.44-1.39a1 1 0 0 0 0-1.42z"/></g></g>', "calendar": '<g data-name="Layer 2"><g data-name="calendar"><rect width="24" height="24" opacity="0"/><path d="M18 4h-1V3a1 1 0 0 0-2 0v1H9V3a1 1 0 0 0-2 0v1H6a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3V7a3 3 0 0 0-3-3zM8 17a1 1 0 1 1 1-1 1 1 0 0 1-1 1zm8 0h-4a1 1 0 0 1 0-2h4a1 1 0 0 1 0 2zm3-6H5V7a1 1 0 0 1 1-1h1v1a1 1 0 0 0 2 0V6h6v1a1 1 0 0 0 2 0V6h1a1 1 0 0 1 1 1z"/></g></g>', "camera": '<g data-name="Layer 2"><g data-name="camera"><rect width="24" height="24" opacity="0"/><circle cx="12" cy="14" r="1.5"/><path d="M19 7h-3V5.5A2.5 2.5 0 0 0 13.5 3h-3A2.5 2.5 0 0 0 8 5.5V7H5a3 3 0 0 0-3 3v8a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3v-8a3 3 0 0 0-3-3zm-9-1.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5V7h-4zm2 12a3.5 3.5 0 1 1 3.5-3.5 3.5 3.5 0 0 1-3.5 3.5z"/></g></g>', "car": '<g data-name="Layer 2"><g data-name="car"><rect width="24" height="24" opacity="0"/><path d="M21.6 11.22L17 7.52V5a1.91 1.91 0 0 0-1.81-2H3.79A1.91 1.91 0 0 0 2 5v10a2 2 0 0 0 1.2 1.88 3 3 0 1 0 5.6.12h6.36a3 3 0 1 0 5.64 0h.2a1 1 0 0 0 1-1v-4a1 1 0 0 0-.4-.78zM20 12.48V15h-3v-4.92zM7 18a1 1 0 1 1-1-1 1 1 0 0 1 1 1zm12 0a1 1 0 1 1-1-1 1 1 0 0 1 1 1z"/></g></g>', "cast": '<g data-name="Layer 2"><g data-name="cast"><polyline points="24 24 0 24 0 0" opacity="0"/><path d="M18.4 3H5.6A2.7 2.7 0 0 0 3 5.78V7a1 1 0 0 0 2 0V5.78A.72.72 0 0 1 5.6 5h12.8a.72.72 0 0 1 .6.78v12.44a.72.72 0 0 1-.6.78H17a1 1 0 0 0 0 2h1.4a2.7 2.7 0 0 0 2.6-2.78V5.78A2.7 2.7 0 0 0 18.4 3z"/><path d="M3.86 14A1 1 0 0 0 3 15.17a1 1 0 0 0 1.14.83 2.49 2.49 0 0 1 2.12.72 2.52 2.52 0 0 1 .51 2.84 1 1 0 0 0 .48 1.33 1.06 1.06 0 0 0 .42.09 1 1 0 0 0 .91-.58A4.52 4.52 0 0 0 3.86 14z"/><path d="M3.86 10.08a1 1 0 0 0 .28 2 6 6 0 0 1 5.09 1.71 6 6 0 0 1 1.53 5.95 1 1 0 0 0 .68 1.26.9.9 0 0 0 .28 0 1 1 0 0 0 1-.72 8 8 0 0 0-8.82-10.2z"/><circle cx="4" cy="19" r="1"/></g></g>', "charging": '<g data-name="Layer 2"><g data-name="charging"><rect width="24" height="24" opacity="0"/><path d="M11.28 13H7a1 1 0 0 1-.86-.5 1 1 0 0 1 0-1L9.28 6H4.17A2.31 2.31 0 0 0 2 8.43v7.14A2.31 2.31 0 0 0 4.17 18h4.25z"/><path d="M15.83 6h-4.25l-2.86 5H13a1 1 0 0 1 .86.5 1 1 0 0 1 0 1L10.72 18h5.11A2.31 2.31 0 0 0 18 15.57V8.43A2.31 2.31 0 0 0 15.83 6z"/><path d="M21 9a1 1 0 0 0-1 1v4a1 1 0 0 0 2 0v-4a1 1 0 0 0-1-1z"/></g></g>', "checkmark-circle-2": '<g data-name="Layer 2"><g data-name="checkmark-circle-2"><rect width="24" height="24" opacity="0"/><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm4.3 7.61l-4.57 6a1 1 0 0 1-.79.39 1 1 0 0 1-.79-.38l-2.44-3.11a1 1 0 0 1 1.58-1.23l1.63 2.08 3.78-5a1 1 0 1 1 1.6 1.22z"/></g></g>', "checkmark-circle": '<g data-name="Layer 2"><g data-name="checkmark-circle"><rect width="24" height="24" opacity="0"/><path d="M9.71 11.29a1 1 0 0 0-1.42 1.42l3 3A1 1 0 0 0 12 16a1 1 0 0 0 .72-.34l7-8a1 1 0 0 0-1.5-1.32L12 13.54z"/><path d="M21 11a1 1 0 0 0-1 1 8 8 0 0 1-8 8A8 8 0 0 1 6.33 6.36 7.93 7.93 0 0 1 12 4a8.79 8.79 0 0 1 1.9.22 1 1 0 1 0 .47-1.94A10.54 10.54 0 0 0 12 2a10 10 0 0 0-7 17.09A9.93 9.93 0 0 0 12 22a10 10 0 0 0 10-10 1 1 0 0 0-1-1z"/></g></g>', "checkmark-square-2": '<g data-name="Layer 2"><g data-name="checkmark-square-2"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M18 3H6a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3V6a3 3 0 0 0-3-3zm-1.7 6.61l-4.57 6a1 1 0 0 1-.79.39 1 1 0 0 1-.79-.38l-2.44-3.11a1 1 0 0 1 1.58-1.23l1.63 2.08 3.78-5a1 1 0 1 1 1.6 1.22z"/></g></g>', "checkmark-square": '<g data-name="Layer 2"><g data-name="checkmark-square"><rect width="24" height="24" opacity="0"/><path d="M20 11.83a1 1 0 0 0-1 1v5.57a.6.6 0 0 1-.6.6H5.6a.6.6 0 0 1-.6-.6V5.6a.6.6 0 0 1 .6-.6h9.57a1 1 0 1 0 0-2H5.6A2.61 2.61 0 0 0 3 5.6v12.8A2.61 2.61 0 0 0 5.6 21h12.8a2.61 2.61 0 0 0 2.6-2.6v-5.57a1 1 0 0 0-1-1z"/><path d="M10.72 11a1 1 0 0 0-1.44 1.38l2.22 2.33a1 1 0 0 0 .72.31 1 1 0 0 0 .72-.3l6.78-7a1 1 0 1 0-1.44-1.4l-6.05 6.26z"/></g></g>', "checkmark": '<g data-name="Layer 2"><g data-name="checkmark"><rect width="24" height="24" opacity="0"/><path d="M9.86 18a1 1 0 0 1-.73-.32l-4.86-5.17a1 1 0 1 1 1.46-1.37l4.12 4.39 8.41-9.2a1 1 0 1 1 1.48 1.34l-9.14 10a1 1 0 0 1-.73.33z"/></g></g>', "chevron-down": '<g data-name="Layer 2"><g data-name="chevron-down"><rect width="24" height="24" opacity="0"/><path d="M12 15.5a1 1 0 0 1-.71-.29l-4-4a1 1 0 1 1 1.42-1.42L12 13.1l3.3-3.18a1 1 0 1 1 1.38 1.44l-4 3.86a1 1 0 0 1-.68.28z"/></g></g>', "chevron-left": '<g data-name="Layer 2"><g data-name="chevron-left"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M13.36 17a1 1 0 0 1-.72-.31l-3.86-4a1 1 0 0 1 0-1.4l4-4a1 1 0 1 1 1.42 1.42L10.9 12l3.18 3.3a1 1 0 0 1 0 1.41 1 1 0 0 1-.72.29z"/></g></g>', "chevron-right": '<g data-name="Layer 2"><g data-name="chevron-right"><rect width="24" height="24" transform="rotate(-90 12 12)" opacity="0"/><path d="M10.5 17a1 1 0 0 1-.71-.29 1 1 0 0 1 0-1.42L13.1 12 9.92 8.69a1 1 0 0 1 0-1.41 1 1 0 0 1 1.42 0l3.86 4a1 1 0 0 1 0 1.4l-4 4a1 1 0 0 1-.7.32z"/></g></g>', "chevron-up": '<g data-name="Layer 2"><g data-name="chevron-up"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M16 14.5a1 1 0 0 1-.71-.29L12 10.9l-3.3 3.18a1 1 0 0 1-1.41 0 1 1 0 0 1 0-1.42l4-3.86a1 1 0 0 1 1.4 0l4 4a1 1 0 0 1 0 1.42 1 1 0 0 1-.69.28z"/></g></g>', "clipboard": '<g data-name="Layer 2"><g data-name="clipboard"><rect width="24" height="24" opacity="0"/><path d="M18 4v3a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2V4a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3V7a3 3 0 0 0-3-3z"/><rect x="7" y="2" width="10" height="6" rx="1" ry="1"/></g></g>', "clock": '<g data-name="Layer 2"><g data-name="clock"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm4 11h-4a1 1 0 0 1-1-1V8a1 1 0 0 1 2 0v3h3a1 1 0 0 1 0 2z"/></g></g>', "close-circle": '<g data-name="Layer 2"><g data-name="close-circle"><rect width="24" height="24" opacity="0"/><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm2.71 11.29a1 1 0 0 1 0 1.42 1 1 0 0 1-1.42 0L12 13.41l-1.29 1.3a1 1 0 0 1-1.42 0 1 1 0 0 1 0-1.42l1.3-1.29-1.3-1.29a1 1 0 0 1 1.42-1.42l1.29 1.3 1.29-1.3a1 1 0 0 1 1.42 1.42L13.41 12z"/></g></g>', "close-square": '<g data-name="Layer 2"><g data-name="close-square"><rect width="24" height="24" opacity="0"/><path d="M18 3H6a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3V6a3 3 0 0 0-3-3zm-3.29 10.29a1 1 0 0 1 0 1.42 1 1 0 0 1-1.42 0L12 13.41l-1.29 1.3a1 1 0 0 1-1.42 0 1 1 0 0 1 0-1.42l1.3-1.29-1.3-1.29a1 1 0 0 1 1.42-1.42l1.29 1.3 1.29-1.3a1 1 0 0 1 1.42 1.42L13.41 12z"/></g></g>', "close": '<g data-name="Layer 2"><g data-name="close"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M13.41 12l4.3-4.29a1 1 0 1 0-1.42-1.42L12 10.59l-4.29-4.3a1 1 0 0 0-1.42 1.42l4.3 4.29-4.3 4.29a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0l4.29-4.3 4.29 4.3a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42z"/></g></g>', "cloud-download": '<g data-name="Layer 2"><g data-name="cloud-download"><rect width="24" height="24" opacity="0"/><path d="M21.9 11c0-.11-.06-.22-.09-.33a4.17 4.17 0 0 0-.18-.57c-.05-.12-.12-.24-.18-.37s-.15-.3-.24-.44S21 9.08 21 9s-.2-.25-.31-.37-.21-.2-.32-.3L20 8l-.36-.24a3.68 3.68 0 0 0-.44-.23l-.39-.18a4.13 4.13 0 0 0-.5-.15 3 3 0 0 0-.41-.09h-.18A6 6 0 0 0 6.33 7h-.18a3 3 0 0 0-.41.09 4.13 4.13 0 0 0-.5.15l-.39.18a3.68 3.68 0 0 0-.44.23L4.05 8l-.37.31c-.11.1-.22.19-.32.3s-.21.25-.31.37-.18.23-.26.36-.16.29-.24.44-.13.25-.18.37a4.17 4.17 0 0 0-.18.57c0 .11-.07.22-.09.33A5.23 5.23 0 0 0 2 12a5.5 5.5 0 0 0 .09.91c0 .1.05.19.07.29a5.58 5.58 0 0 0 .18.58l.12.29a5 5 0 0 0 .3.56l.14.22a.56.56 0 0 0 .05.08L3 15a5 5 0 0 0 4 2 2 2 0 0 1 .59-1.41A2 2 0 0 1 9 15a1.92 1.92 0 0 1 1 .27V12a2 2 0 0 1 4 0v3.37a2 2 0 0 1 1-.27 2.05 2.05 0 0 1 1.44.61A2 2 0 0 1 17 17a5 5 0 0 0 4-2l.05-.05a.56.56 0 0 0 .05-.08l.14-.22a5 5 0 0 0 .3-.56l.12-.29a5.58 5.58 0 0 0 .18-.58c0-.1.05-.19.07-.29A5.5 5.5 0 0 0 22 12a5.23 5.23 0 0 0-.1-1z"/><path d="M14.31 16.38L13 17.64V12a1 1 0 0 0-2 0v5.59l-1.29-1.3a1 1 0 0 0-1.42 1.42l3 3A1 1 0 0 0 12 21a1 1 0 0 0 .69-.28l3-2.9a1 1 0 1 0-1.38-1.44z"/><rect width="24" height="24" opacity="0"/><path d="M21.9 11c0-.11-.06-.22-.09-.33a4.17 4.17 0 0 0-.18-.57c-.05-.12-.12-.24-.18-.37s-.15-.3-.24-.44S21 9.08 21 9s-.2-.25-.31-.37-.21-.2-.32-.3L20 8l-.36-.24a3.68 3.68 0 0 0-.44-.23l-.39-.18a4.13 4.13 0 0 0-.5-.15 3 3 0 0 0-.41-.09h-.18A6 6 0 0 0 6.33 7h-.18a3 3 0 0 0-.41.09 4.13 4.13 0 0 0-.5.15l-.39.18a3.68 3.68 0 0 0-.44.23L4.05 8l-.37.31c-.11.1-.22.19-.32.3s-.21.25-.31.37-.18.23-.26.36-.16.29-.24.44-.13.25-.18.37a4.17 4.17 0 0 0-.18.57c0 .11-.07.22-.09.33A5.23 5.23 0 0 0 2 12a5.5 5.5 0 0 0 .09.91c0 .1.05.19.07.29a5.58 5.58 0 0 0 .18.58l.12.29a5 5 0 0 0 .3.56l.14.22a.56.56 0 0 0 .05.08L3 15a5 5 0 0 0 4 2 2 2 0 0 1 .59-1.41A2 2 0 0 1 9 15a1.92 1.92 0 0 1 1 .27V12a2 2 0 0 1 4 0v3.37a2 2 0 0 1 1-.27 2.05 2.05 0 0 1 1.44.61A2 2 0 0 1 17 17a5 5 0 0 0 4-2l.05-.05a.56.56 0 0 0 .05-.08l.14-.22a5 5 0 0 0 .3-.56l.12-.29a5.58 5.58 0 0 0 .18-.58c0-.1.05-.19.07-.29A5.5 5.5 0 0 0 22 12a5.23 5.23 0 0 0-.1-1z"/><path d="M14.31 16.38L13 17.64V12a1 1 0 0 0-2 0v5.59l-1.29-1.3a1 1 0 0 0-1.42 1.42l3 3A1 1 0 0 0 12 21a1 1 0 0 0 .69-.28l3-2.9a1 1 0 1 0-1.38-1.44z"/></g></g>', "cloud-upload": '<g data-name="Layer 2"><g data-name="cloud-upload"><rect width="24" height="24" opacity="0"/><path d="M21.9 12c0-.11-.06-.22-.09-.33a4.17 4.17 0 0 0-.18-.57c-.05-.12-.12-.24-.18-.37s-.15-.3-.24-.44S21 10.08 21 10s-.2-.25-.31-.37-.21-.2-.32-.3L20 9l-.36-.24a3.68 3.68 0 0 0-.44-.23l-.39-.18a4.13 4.13 0 0 0-.5-.15 3 3 0 0 0-.41-.09L17.67 8A6 6 0 0 0 6.33 8l-.18.05a3 3 0 0 0-.41.09 4.13 4.13 0 0 0-.5.15l-.39.18a3.68 3.68 0 0 0-.44.23l-.36.3-.37.31c-.11.1-.22.19-.32.3s-.21.25-.31.37-.18.23-.26.36-.16.29-.24.44-.13.25-.18.37a4.17 4.17 0 0 0-.18.57c0 .11-.07.22-.09.33A5.23 5.23 0 0 0 2 13a5.5 5.5 0 0 0 .09.91c0 .1.05.19.07.29a5.58 5.58 0 0 0 .18.58l.12.29a5 5 0 0 0 .3.56l.14.22a.56.56 0 0 0 .05.08L3 16a5 5 0 0 0 4 2h3v-1.37a2 2 0 0 1-1 .27 2.05 2.05 0 0 1-1.44-.61 2 2 0 0 1 .05-2.83l3-2.9A2 2 0 0 1 12 10a2 2 0 0 1 1.41.59l3 3a2 2 0 0 1 0 2.82A2 2 0 0 1 15 17a1.92 1.92 0 0 1-1-.27V18h3a5 5 0 0 0 4-2l.05-.05a.56.56 0 0 0 .05-.08l.14-.22a5 5 0 0 0 .3-.56l.12-.29a5.58 5.58 0 0 0 .18-.58c0-.1.05-.19.07-.29A5.5 5.5 0 0 0 22 13a5.23 5.23 0 0 0-.1-1z"/><path d="M12.71 11.29a1 1 0 0 0-1.4 0l-3 2.9a1 1 0 1 0 1.38 1.44L11 14.36V20a1 1 0 0 0 2 0v-5.59l1.29 1.3a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42z"/></g></g>', "code-download": '<g data-name="Layer 2"><g data-name="code-download"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M4.29 12l4.48-5.36a1 1 0 1 0-1.54-1.28l-5 6a1 1 0 0 0 0 1.27l4.83 6a1 1 0 0 0 .78.37 1 1 0 0 0 .78-1.63z"/><path d="M21.78 11.37l-4.78-6a1 1 0 0 0-1.56 1.26L19.71 12l-4.48 5.37a1 1 0 0 0 .13 1.41A1 1 0 0 0 16 19a1 1 0 0 0 .77-.36l5-6a1 1 0 0 0 .01-1.27z"/><path d="M15.72 11.41a1 1 0 0 0-1.41 0L13 12.64V8a1 1 0 0 0-2 0v4.59l-1.29-1.3a1 1 0 0 0-1.42 1.42l3 3A1 1 0 0 0 12 16a1 1 0 0 0 .69-.28l3-2.9a1 1 0 0 0 .03-1.41z"/></g></g>', "code": '<g data-name="Layer 2"><g data-name="code"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M8.64 5.23a1 1 0 0 0-1.41.13l-5 6a1 1 0 0 0 0 1.27l4.83 6a1 1 0 0 0 .78.37 1 1 0 0 0 .78-1.63L4.29 12l4.48-5.36a1 1 0 0 0-.13-1.41z"/><path d="M21.78 11.37l-4.78-6a1 1 0 0 0-1.41-.15 1 1 0 0 0-.15 1.41L19.71 12l-4.48 5.37a1 1 0 0 0 .13 1.41A1 1 0 0 0 16 19a1 1 0 0 0 .77-.36l5-6a1 1 0 0 0 .01-1.27z"/></g></g>', "collapse": '<g data-name="Layer 2"><g data-name="collapse"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M19 9h-2.58l3.29-3.29a1 1 0 1 0-1.42-1.42L15 7.57V5a1 1 0 0 0-1-1 1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h5a1 1 0 0 0 0-2z"/><path d="M10 13H5a1 1 0 0 0 0 2h2.57l-3.28 3.29a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0L9 16.42V19a1 1 0 0 0 1 1 1 1 0 0 0 1-1v-5a1 1 0 0 0-1-1z"/></g></g>', "color-palette": '<g data-name="Layer 2"><g data-name="color-palette"><rect width="24" height="24" opacity="0"/><path d="M19.54 5.08A10.61 10.61 0 0 0 11.91 2a10 10 0 0 0-.05 20 2.58 2.58 0 0 0 2.53-1.89 2.52 2.52 0 0 0-.57-2.28.5.5 0 0 1 .37-.83h1.65A6.15 6.15 0 0 0 22 11.33a8.48 8.48 0 0 0-2.46-6.25zm-12.7 9.66a1.5 1.5 0 1 1 .4-2.08 1.49 1.49 0 0 1-.4 2.08zM8.3 9.25a1.5 1.5 0 1 1-.55-2 1.5 1.5 0 0 1 .55 2zM11 7a1.5 1.5 0 1 1 1.5-1.5A1.5 1.5 0 0 1 11 7zm5.75.8a1.5 1.5 0 1 1 .55-2 1.5 1.5 0 0 1-.55 2z"/></g></g>', "color-picker": '<g data-name="Layer 2"><g data-name="color-picker"><rect width="24" height="24" opacity="0"/><path d="M19.4 7.34L16.66 4.6A1.92 1.92 0 0 0 14 4.53l-2 2-1.29-1.24a1 1 0 0 0-1.42 1.42L10.53 8 5 13.53a2 2 0 0 0-.57 1.21L4 18.91a1 1 0 0 0 .29.8A1 1 0 0 0 5 20h.09l4.17-.38a2 2 0 0 0 1.21-.57l5.58-5.58 1.24 1.24a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42l-1.24-1.24 2-2a1.92 1.92 0 0 0-.07-2.71zm-13 7.6L12 9.36l2.69 2.7-2.79 2.79"/></g></g>', "compass": '<g data-name="Layer 2"><g data-name="compass"><rect width="24" height="24" opacity="0"/><polygon points="10.8 13.21 12.49 12.53 13.2 10.79 11.51 11.47 10.8 13.21"/><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm3.93 7.42l-1.75 4.26a1 1 0 0 1-.55.55l-4.21 1.7A1 1 0 0 1 9 16a1 1 0 0 1-.71-.31h-.05a1 1 0 0 1-.18-1l1.75-4.26a1 1 0 0 1 .55-.55l4.21-1.7a1 1 0 0 1 1.1.25 1 1 0 0 1 .26.99z"/></g></g>', "copy": '<g data-name="Layer 2"><g data-name="copy"><rect width="24" height="24" opacity="0"/><path d="M18 9h-3V5.67A2.68 2.68 0 0 0 12.33 3H5.67A2.68 2.68 0 0 0 3 5.67v6.66A2.68 2.68 0 0 0 5.67 15H9v3a3 3 0 0 0 3 3h6a3 3 0 0 0 3-3v-6a3 3 0 0 0-3-3zm-9 3v1H5.67a.67.67 0 0 1-.67-.67V5.67A.67.67 0 0 1 5.67 5h6.66a.67.67 0 0 1 .67.67V9h-1a3 3 0 0 0-3 3z"/></g></g>', "corner-down-left": '<g data-name="Layer 2"><g data-name="corner-down-left"><rect x=".05" y=".05" width="24" height="24" transform="rotate(-89.76 12.05 12.05)" opacity="0"/><path d="M20 6a1 1 0 0 0-1-1 1 1 0 0 0-1 1v5a1 1 0 0 1-.29.71A1 1 0 0 1 17 12H8.08l2.69-3.39a1 1 0 0 0-1.52-1.17l-4 5a1 1 0 0 0 0 1.25l4 5a1 1 0 0 0 .78.37 1 1 0 0 0 .62-.22 1 1 0 0 0 .15-1.41l-2.66-3.36h8.92a3 3 0 0 0 3-3z"/></g></g>', "corner-down-right": '<g data-name="Layer 2"><g data-name="corner-down-right"><rect width="24" height="24" transform="rotate(-90 12 12)" opacity="0"/><path d="M19.78 12.38l-4-5a1 1 0 0 0-1.56 1.24l2.7 3.38H8a1 1 0 0 1-1-1V6a1 1 0 0 0-2 0v5a3 3 0 0 0 3 3h8.92l-2.7 3.38a1 1 0 0 0 .16 1.4A1 1 0 0 0 15 19a1 1 0 0 0 .78-.38l4-5a1 1 0 0 0 0-1.24z"/></g></g>', "corner-left-down": '<g data-name="Layer 2"><g data-name="corner-left-down"><rect width="24" height="24" opacity="0"/><path d="M18 5h-5a3 3 0 0 0-3 3v8.92l-3.38-2.7a1 1 0 0 0-1.24 1.56l5 4a1 1 0 0 0 1.24 0l5-4a1 1 0 1 0-1.24-1.56L12 16.92V8a1 1 0 0 1 1-1h5a1 1 0 0 0 0-2z"/></g></g>', "corner-left-up": '<g data-name="Layer 2"><g data-name="corner-left-up"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M18 17h-5a1 1 0 0 1-1-1V7.08l3.38 2.7A1 1 0 0 0 16 10a1 1 0 0 0 .78-.38 1 1 0 0 0-.16-1.4l-5-4a1 1 0 0 0-1.24 0l-5 4a1 1 0 0 0 1.24 1.56L10 7.08V16a3 3 0 0 0 3 3h5a1 1 0 0 0 0-2z"/></g></g>', "corner-right-down": '<g data-name="Layer 2"><g data-name="corner-right-down"><rect width="24" height="24" opacity="0"/><path d="M18.78 14.38a1 1 0 0 0-1.4-.16L14 16.92V8a3 3 0 0 0-3-3H6a1 1 0 0 0 0 2h5a1 1 0 0 1 1 1v8.92l-3.38-2.7a1 1 0 0 0-1.24 1.56l5 4a1 1 0 0 0 1.24 0l5-4a1 1 0 0 0 .16-1.4z"/></g></g>', "corner-right-up": '<g data-name="Layer 2"><g data-name="corner-right-up"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M18.62 8.22l-5-4a1 1 0 0 0-1.24 0l-5 4a1 1 0 0 0 1.24 1.56L12 7.08V16a1 1 0 0 1-1 1H6a1 1 0 0 0 0 2h5a3 3 0 0 0 3-3V7.08l3.38 2.7A1 1 0 0 0 18 10a1 1 0 0 0 .78-.38 1 1 0 0 0-.16-1.4z"/></g></g>', "corner-up-left": '<g data-name="Layer 2"><g data-name="corner-up-left"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M16 10H7.08l2.7-3.38a1 1 0 1 0-1.56-1.24l-4 5a1 1 0 0 0 0 1.24l4 5A1 1 0 0 0 9 17a1 1 0 0 0 .62-.22 1 1 0 0 0 .16-1.4L7.08 12H16a1 1 0 0 1 1 1v5a1 1 0 0 0 2 0v-5a3 3 0 0 0-3-3z"/></g></g>', "corner-up-right": '<g data-name="Layer 2"><g data-name="corner-up-right"><rect width="24" height="24" transform="rotate(-90 12 12)" opacity="0"/><path d="M19.78 10.38l-4-5a1 1 0 0 0-1.56 1.24l2.7 3.38H8a3 3 0 0 0-3 3v5a1 1 0 0 0 2 0v-5a1 1 0 0 1 1-1h8.92l-2.7 3.38a1 1 0 0 0 .16 1.4A1 1 0 0 0 15 17a1 1 0 0 0 .78-.38l4-5a1 1 0 0 0 0-1.24z"/></g></g>', "credit-card": '<g data-name="Layer 2"><g data-name="credit-card"><rect width="24" height="24" opacity="0"/><path d="M19 5H5a3 3 0 0 0-3 3v8a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3V8a3 3 0 0 0-3-3zm-8 10H7a1 1 0 0 1 0-2h4a1 1 0 0 1 0 2zm6 0h-2a1 1 0 0 1 0-2h2a1 1 0 0 1 0 2zm3-6H4V8a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1z"/></g></g>', "crop": '<g data-name="Layer 2"><g data-name="crop"><rect width="24" height="24" opacity="0"/><path d="M21 16h-3V8.56A2.56 2.56 0 0 0 15.44 6H8V3a1 1 0 0 0-2 0v3H3a1 1 0 0 0 0 2h3v7.44A2.56 2.56 0 0 0 8.56 18H16v3a1 1 0 0 0 2 0v-3h3a1 1 0 0 0 0-2zM8.56 16a.56.56 0 0 1-.56-.56V8h7.44a.56.56 0 0 1 .56.56V16z"/></g></g>', "cube": '<g data-name="Layer 2"><g data-name="cube"><rect width="24" height="24" opacity="0"/><path d="M11.25 11.83L3 8.36v7.73a1.69 1.69 0 0 0 1 1.52L11.19 21h.06z"/><path d="M12 10.5l8.51-3.57a1.62 1.62 0 0 0-.51-.38l-7.2-3.37a1.87 1.87 0 0 0-1.6 0L4 6.55a1.62 1.62 0 0 0-.51.38z"/><path d="M12.75 11.83V21h.05l7.2-3.39a1.69 1.69 0 0 0 1-1.51V8.36z"/></g></g>', "diagonal-arrow-left-down": '<g data-name="Layer 2"><g data-name="diagonal-arrow-left-down"><rect width="24" height="24" opacity="0"/><path d="M17.71 6.29a1 1 0 0 0-1.42 0L8 14.59V9a1 1 0 0 0-2 0v8a1 1 0 0 0 1 1h8a1 1 0 0 0 0-2H9.41l8.3-8.29a1 1 0 0 0 0-1.42z"/></g></g>', "diagonal-arrow-left-up": '<g data-name="Layer 2"><g data-name="diagonal-arrow-left-up"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M17.71 16.29L9.42 8H15a1 1 0 0 0 0-2H7.05a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1H7a1 1 0 0 0 1-1V9.45l8.26 8.26a1 1 0 0 0 1.42 0 1 1 0 0 0 .03-1.42z"/></g></g>', "diagonal-arrow-right-down": '<g data-name="Layer 2"><g data-name="diagonal-arrow-right-down"><rect width="24" height="24" transform="rotate(-90 12 12)" opacity="0"/><path d="M17 8a1 1 0 0 0-1 1v5.59l-8.29-8.3a1 1 0 0 0-1.42 1.42l8.3 8.29H9a1 1 0 0 0 0 2h8a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1z"/></g></g>', "diagonal-arrow-right-up": '<g data-name="Layer 2"><g data-name="diagonal-arrow-right-up"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M18 7.05a1 1 0 0 0-1-1L9 6a1 1 0 0 0 0 2h5.56l-8.27 8.29a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0L16 9.42V15a1 1 0 0 0 1 1 1 1 0 0 0 1-1z"/></g></g>', "done-all": '<g data-name="Layer 2"><g data-name="done-all"><rect width="24" height="24" opacity="0"/><path d="M16.62 6.21a1 1 0 0 0-1.41.17l-7 9-3.43-4.18a1 1 0 1 0-1.56 1.25l4.17 5.18a1 1 0 0 0 .78.37 1 1 0 0 0 .83-.38l7.83-10a1 1 0 0 0-.21-1.41z"/><path d="M21.62 6.21a1 1 0 0 0-1.41.17l-7 9-.61-.75-1.26 1.62 1.1 1.37a1 1 0 0 0 .78.37 1 1 0 0 0 .78-.38l7.83-10a1 1 0 0 0-.21-1.4z"/><path d="M8.71 13.06L10 11.44l-.2-.24a1 1 0 0 0-1.43-.2 1 1 0 0 0-.15 1.41z"/></g></g>', "download": '<g data-name="Layer 2"><g data-name="download"><rect width="24" height="24" opacity="0"/><rect x="4" y="18" width="16" height="2" rx="1" ry="1"/><rect x="3" y="17" width="4" height="2" rx="1" ry="1" transform="rotate(-90 5 18)"/><rect x="17" y="17" width="4" height="2" rx="1" ry="1" transform="rotate(-90 19 18)"/><path d="M12 15a1 1 0 0 1-.58-.18l-4-2.82a1 1 0 0 1-.24-1.39 1 1 0 0 1 1.4-.24L12 12.76l3.4-2.56a1 1 0 0 1 1.2 1.6l-4 3a1 1 0 0 1-.6.2z"/><path d="M12 13a1 1 0 0 1-1-1V4a1 1 0 0 1 2 0v8a1 1 0 0 1-1 1z"/></g></g>', "droplet-off": '<g data-name="Layer 2"><g data-name="droplet-off"><rect width="24" height="24" opacity="0"/><path d="M19 16.14A7.73 7.73 0 0 0 17.34 8l-4.56-4.69a1 1 0 0 0-.71-.31 1 1 0 0 0-.72.3L8.74 5.92z"/><path d="M6 8.82a7.73 7.73 0 0 0 .64 9.9A7.44 7.44 0 0 0 11.92 21a7.34 7.34 0 0 0 4.64-1.6z"/><path d="M20.71 19.29l-16-16a1 1 0 0 0-1.42 1.42l16 16a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42z"/></g></g>', "droplet": '<g data-name="Layer 2"><g data-name="droplet"><rect x=".1" y=".1" width="24" height="24" transform="rotate(.48 11.987 11.887)" opacity="0"/><path d="M12 21.1a7.4 7.4 0 0 1-5.28-2.28 7.73 7.73 0 0 1 .1-10.77l4.64-4.65a.94.94 0 0 1 .71-.3 1 1 0 0 1 .71.31l4.56 4.72a7.73 7.73 0 0 1-.09 10.77A7.33 7.33 0 0 1 12 21.1z"/></g></g>', "edit-2": '<g data-name="Layer 2"><g data-name="edit-2"><rect width="24" height="24" opacity="0"/><path d="M19 20H5a1 1 0 0 0 0 2h14a1 1 0 0 0 0-2z"/><path d="M5 18h.09l4.17-.38a2 2 0 0 0 1.21-.57l9-9a1.92 1.92 0 0 0-.07-2.71L16.66 2.6A2 2 0 0 0 14 2.53l-9 9a2 2 0 0 0-.57 1.21L4 16.91a1 1 0 0 0 .29.8A1 1 0 0 0 5 18zM15.27 4L18 6.73l-2 1.95L13.32 6z"/></g></g>', "edit": '<g data-name="Layer 2"><g data-name="edit"><rect width="24" height="24" opacity="0"/><path d="M19.4 7.34L16.66 4.6A2 2 0 0 0 14 4.53l-9 9a2 2 0 0 0-.57 1.21L4 18.91a1 1 0 0 0 .29.8A1 1 0 0 0 5 20h.09l4.17-.38a2 2 0 0 0 1.21-.57l9-9a1.92 1.92 0 0 0-.07-2.71zM16 10.68L13.32 8l1.95-2L18 8.73z"/></g></g>', "email": '<g data-name="Layer 2"><g data-name="email"><rect width="24" height="24" opacity="0"/><path d="M19 4H5a3 3 0 0 0-3 3v10a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3V7a3 3 0 0 0-3-3zm0 2l-6.5 4.47a1 1 0 0 1-1 0L5 6z"/></g></g>', "expand": '<g data-name="Layer 2"><g data-name="expand"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M20 5a1 1 0 0 0-1-1h-5a1 1 0 0 0 0 2h2.57l-3.28 3.29a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0L18 7.42V10a1 1 0 0 0 1 1 1 1 0 0 0 1-1z"/><path d="M10.71 13.29a1 1 0 0 0-1.42 0L6 16.57V14a1 1 0 0 0-1-1 1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h5a1 1 0 0 0 0-2H7.42l3.29-3.29a1 1 0 0 0 0-1.42z"/></g></g>', "external-link": '<g data-name="Layer 2"><g data-name="external-link"><rect width="24" height="24" opacity="0"/><path d="M20 11a1 1 0 0 0-1 1v6a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1h6a1 1 0 0 0 0-2H6a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3v-6a1 1 0 0 0-1-1z"/><path d="M16 5h1.58l-6.29 6.28a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0L19 6.42V8a1 1 0 0 0 1 1 1 1 0 0 0 1-1V4a1 1 0 0 0-1-1h-4a1 1 0 0 0 0 2z"/></g></g>', "eye-off-2": '<g data-name="Layer 2"><g data-name="eye-off-2"><rect width="24" height="24" opacity="0"/><path d="M17.81 13.39A8.93 8.93 0 0 0 21 7.62a1 1 0 1 0-2-.24 7.07 7.07 0 0 1-14 0 1 1 0 1 0-2 .24 8.93 8.93 0 0 0 3.18 5.77l-2.3 2.32a1 1 0 0 0 1.41 1.41l2.61-2.6a9.06 9.06 0 0 0 3.1.92V19a1 1 0 0 0 2 0v-3.56a9.06 9.06 0 0 0 3.1-.92l2.61 2.6a1 1 0 0 0 1.41-1.41z"/></g></g>', "eye-off": '<g data-name="Layer 2"><g data-name="eye-off"><rect width="24" height="24" opacity="0"/><circle cx="12" cy="12" r="1.5"/><path d="M15.29 18.12L14 16.78l-.07-.07-1.27-1.27a4.07 4.07 0 0 1-.61.06A3.5 3.5 0 0 1 8.5 12a4.07 4.07 0 0 1 .06-.61l-2-2L5 7.87a15.89 15.89 0 0 0-2.87 3.63 1 1 0 0 0 0 1c.63 1.09 4 6.5 9.89 6.5h.25a9.48 9.48 0 0 0 3.23-.67z"/><path d="M8.59 5.76l2.8 2.8A4.07 4.07 0 0 1 12 8.5a3.5 3.5 0 0 1 3.5 3.5 4.07 4.07 0 0 1-.06.61l2.68 2.68.84.84a15.89 15.89 0 0 0 2.91-3.63 1 1 0 0 0 0-1c-.64-1.11-4.16-6.68-10.14-6.5a9.48 9.48 0 0 0-3.23.67z"/><path d="M20.71 19.29L19.41 18l-2-2-9.52-9.53L6.42 5 4.71 3.29a1 1 0 0 0-1.42 1.42L5.53 7l1.75 1.7 7.31 7.3.07.07L16 17.41l.59.59 2.7 2.71a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42z"/></g></g>', "eye": '<g data-name="Layer 2"><g data-name="eye"><rect width="24" height="24" opacity="0"/><circle cx="12" cy="12" r="1.5"/><path d="M21.87 11.5c-.64-1.11-4.16-6.68-10.14-6.5-5.53.14-8.73 5-9.6 6.5a1 1 0 0 0 0 1c.63 1.09 4 6.5 9.89 6.5h.25c5.53-.14 8.74-5 9.6-6.5a1 1 0 0 0 0-1zm-9.87 4a3.5 3.5 0 1 1 3.5-3.5 3.5 3.5 0 0 1-3.5 3.5z"/></g></g>', "facebook": '<g data-name="Layer 2"><g data-name="facebook"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M17 3.5a.5.5 0 0 0-.5-.5H14a4.77 4.77 0 0 0-5 4.5v2.7H6.5a.5.5 0 0 0-.5.5v2.6a.5.5 0 0 0 .5.5H9v6.7a.5.5 0 0 0 .5.5h3a.5.5 0 0 0 .5-.5v-6.7h2.62a.5.5 0 0 0 .49-.37l.72-2.6a.5.5 0 0 0-.48-.63H13V7.5a1 1 0 0 1 1-.9h2.5a.5.5 0 0 0 .5-.5z"/></g></g>', "file-add": '<g data-name="Layer 2"><g data-name="file-add"><rect width="24" height="24" opacity="0"/><path d="M19.74 7.33l-4.44-5a1 1 0 0 0-.74-.33h-8A2.53 2.53 0 0 0 4 4.5v15A2.53 2.53 0 0 0 6.56 22h10.88A2.53 2.53 0 0 0 20 19.5V8a1 1 0 0 0-.26-.67zM14 15h-1v1a1 1 0 0 1-2 0v-1h-1a1 1 0 0 1 0-2h1v-1a1 1 0 0 1 2 0v1h1a1 1 0 0 1 0 2zm.71-7a.79.79 0 0 1-.71-.85V4l3.74 4z"/></g></g>', "file-remove": '<g data-name="Layer 2"><g data-name="file-remove"><rect width="24" height="24" opacity="0"/><path d="M19.74 7.33l-4.44-5a1 1 0 0 0-.74-.33h-8A2.53 2.53 0 0 0 4 4.5v15A2.53 2.53 0 0 0 6.56 22h10.88A2.53 2.53 0 0 0 20 19.5V8a1 1 0 0 0-.26-.67zM14 15h-4a1 1 0 0 1 0-2h4a1 1 0 0 1 0 2zm.71-7a.79.79 0 0 1-.71-.85V4l3.74 4z"/></g></g>', "file-text": '<g data-name="Layer 2"><g data-name="file-text"><rect width="24" height="24" opacity="0"/><path d="M19.74 7.33l-4.44-5a1 1 0 0 0-.74-.33h-8A2.53 2.53 0 0 0 4 4.5v15A2.53 2.53 0 0 0 6.56 22h10.88A2.53 2.53 0 0 0 20 19.5V8a1 1 0 0 0-.26-.67zM9 12h3a1 1 0 0 1 0 2H9a1 1 0 0 1 0-2zm6 6H9a1 1 0 0 1 0-2h6a1 1 0 0 1 0 2zm-.29-10a.79.79 0 0 1-.71-.85V4l3.74 4z"/></g></g>', "file": '<g data-name="Layer 2"><g data-name="file"><rect width="24" height="24" opacity="0"/><path d="M19.74 7.33l-4.44-5a1 1 0 0 0-.74-.33h-8A2.53 2.53 0 0 0 4 4.5v15A2.53 2.53 0 0 0 6.56 22h10.88A2.53 2.53 0 0 0 20 19.5V8a1 1 0 0 0-.26-.67zM14 4l3.74 4h-3a.79.79 0 0 1-.74-.85z"/></g></g>', "film": '<g data-name="Layer 2"><g data-name="film"><rect width="24" height="24" opacity="0"/><path d="M18.26 3H5.74A2.74 2.74 0 0 0 3 5.74v12.52A2.74 2.74 0 0 0 5.74 21h12.52A2.74 2.74 0 0 0 21 18.26V5.74A2.74 2.74 0 0 0 18.26 3zM7 11H5V9h2zm-2 2h2v2H5zm14-2h-2V9h2zm-2 2h2v2h-2zm2-7.26V7h-2V5h1.26a.74.74 0 0 1 .74.74zM5.74 5H7v2H5V5.74A.74.74 0 0 1 5.74 5zM5 18.26V17h2v2H5.74a.74.74 0 0 1-.74-.74zm14 0a.74.74 0 0 1-.74.74H17v-2h2z"/></g></g>', "flag": '<g data-name="Layer 2"><g data-name="flag"><polyline points="24 24 0 24 0 0" opacity="0"/><path d="M19.27 4.68a1.79 1.79 0 0 0-1.6-.25 7.53 7.53 0 0 1-2.17.28 8.54 8.54 0 0 1-3.13-.78A10.15 10.15 0 0 0 8.5 3c-2.89 0-4 1-4.2 1.14a1 1 0 0 0-.3.72V20a1 1 0 0 0 2 0v-4.3a6.28 6.28 0 0 1 2.5-.41 8.54 8.54 0 0 1 3.13.78 10.15 10.15 0 0 0 3.87.93 7.66 7.66 0 0 0 3.5-.7 1.74 1.74 0 0 0 1-1.55V6.11a1.77 1.77 0 0 0-.73-1.43z"/></g></g>', "flash-off": '<g data-name="Layer 2"><g data-name="flash-off"><rect width="24" height="24" opacity="0"/><path d="M17.33 14.5l2.5-3.74A1 1 0 0 0 19 9.2h-5.89l.77-7.09a1 1 0 0 0-.65-1 1 1 0 0 0-1.17.38L8.94 6.11z"/><path d="M6.67 9.5l-2.5 3.74A1 1 0 0 0 5 14.8h5.89l-.77 7.09a1 1 0 0 0 .65 1.05 1 1 0 0 0 .34.06 1 1 0 0 0 .83-.44l3.12-4.67z"/><path d="M20.71 19.29l-16-16a1 1 0 0 0-1.42 1.42l16 16a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42z"/></g></g>', "flash": '<g data-name="Layer 2"><g data-name="flash"><rect width="24" height="24" opacity="0"/><path d="M11.11 23a1 1 0 0 1-.34-.06 1 1 0 0 1-.65-1.05l.77-7.09H5a1 1 0 0 1-.83-1.56l7.89-11.8a1 1 0 0 1 1.17-.38 1 1 0 0 1 .65 1l-.77 7.14H19a1 1 0 0 1 .83 1.56l-7.89 11.8a1 1 0 0 1-.83.44z"/></g></g>', "flip-2": '<g data-name="Layer 2"><g data-name="flip-2"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M6.09 19h12l-1.3 1.29a1 1 0 0 0 1.42 1.42l3-3a1 1 0 0 0 0-1.42l-3-3a1 1 0 0 0-1.42 0 1 1 0 0 0 0 1.42l1.3 1.29h-12a1.56 1.56 0 0 1-1.59-1.53V13a1 1 0 0 0-2 0v2.47A3.56 3.56 0 0 0 6.09 19z"/><path d="M5.79 9.71a1 1 0 1 0 1.42-1.42L5.91 7h12a1.56 1.56 0 0 1 1.59 1.53V11a1 1 0 0 0 2 0V8.53A3.56 3.56 0 0 0 17.91 5h-12l1.3-1.29a1 1 0 0 0 0-1.42 1 1 0 0 0-1.42 0l-3 3a1 1 0 0 0 0 1.42z"/></g></g>', "flip": '<g data-name="Layer 2"><g data-name="flip-in"><rect width="24" height="24" transform="rotate(-90 12 12)" opacity="0"/><path d="M5 6.09v12l-1.29-1.3a1 1 0 0 0-1.42 1.42l3 3a1 1 0 0 0 1.42 0l3-3a1 1 0 0 0 0-1.42 1 1 0 0 0-1.42 0L7 18.09v-12A1.56 1.56 0 0 1 8.53 4.5H11a1 1 0 0 0 0-2H8.53A3.56 3.56 0 0 0 5 6.09z"/><path d="M14.29 5.79a1 1 0 0 0 1.42 1.42L17 5.91v12a1.56 1.56 0 0 1-1.53 1.59H13a1 1 0 0 0 0 2h2.47A3.56 3.56 0 0 0 19 17.91v-12l1.29 1.3a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42l-3-3a1 1 0 0 0-1.42 0z"/></g></g>', "folder-add": '<g data-name="Layer 2"><g data-name="folder-add"><rect width="24" height="24" opacity="0"/><path d="M19.5 7.05h-7L9.87 3.87a1 1 0 0 0-.77-.37H4.5A2.47 2.47 0 0 0 2 5.93v12.14a2.47 2.47 0 0 0 2.5 2.43h15a2.47 2.47 0 0 0 2.5-2.43V9.48a2.47 2.47 0 0 0-2.5-2.43zM14 15h-1v1a1 1 0 0 1-2 0v-1h-1a1 1 0 0 1 0-2h1v-1a1 1 0 0 1 2 0v1h1a1 1 0 0 1 0 2z"/></g></g>', "folder-remove": '<g data-name="Layer 2"><g data-name="folder-remove"><rect width="24" height="24" opacity="0"/><path d="M19.5 7.05h-7L9.87 3.87a1 1 0 0 0-.77-.37H4.5A2.47 2.47 0 0 0 2 5.93v12.14a2.47 2.47 0 0 0 2.5 2.43h15a2.47 2.47 0 0 0 2.5-2.43V9.48a2.47 2.47 0 0 0-2.5-2.43zM14 15h-4a1 1 0 0 1 0-2h4a1 1 0 0 1 0 2z"/></g></g>', "folder": '<g data-name="Layer 2"><g data-name="folder"><rect width="24" height="24" opacity="0"/><path d="M19.5 20.5h-15A2.47 2.47 0 0 1 2 18.07V5.93A2.47 2.47 0 0 1 4.5 3.5h4.6a1 1 0 0 1 .77.37l2.6 3.18h7A2.47 2.47 0 0 1 22 9.48v8.59a2.47 2.47 0 0 1-2.5 2.43z"/></g></g>', "funnel": '<g data-name="Layer 2"><g data-name="funnel"><rect width="24" height="24" opacity="0"/><path d="M13.9 22a1 1 0 0 1-.6-.2l-4-3.05a1 1 0 0 1-.39-.8v-3.27l-4.8-9.22A1 1 0 0 1 5 4h14a1 1 0 0 1 .86.49 1 1 0 0 1 0 1l-5 9.21V21a1 1 0 0 1-.55.9 1 1 0 0 1-.41.1z"/></g></g>', "gift": '<g data-name="Layer 2"><g data-name="gift"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M4.64 15.27v4.82a.92.92 0 0 0 .92.91h5.62v-5.73z"/><path d="M12.82 21h5.62a.92.92 0 0 0 .92-.91v-4.82h-6.54z"/><path d="M20.1 7.09h-1.84a2.82 2.82 0 0 0 .29-1.23A2.87 2.87 0 0 0 15.68 3 4.21 4.21 0 0 0 12 5.57 4.21 4.21 0 0 0 8.32 3a2.87 2.87 0 0 0-2.87 2.86 2.82 2.82 0 0 0 .29 1.23H3.9c-.5 0-.9.59-.9 1.31v3.93c0 .72.4 1.31.9 1.31h7.28V7.09h1.64v6.55h7.28c.5 0 .9-.59.9-1.31V8.4c0-.72-.4-1.31-.9-1.31zm-11.78 0a1.23 1.23 0 1 1 0-2.45c1.4 0 2.19 1.44 2.58 2.45zm7.36 0H13.1c.39-1 1.18-2.45 2.58-2.45a1.23 1.23 0 1 1 0 2.45z"/></g></g>', "github": '<g data-name="Layer 2"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M12 1A10.89 10.89 0 0 0 1 11.77 10.79 10.79 0 0 0 8.52 22c.55.1.75-.23.75-.52v-1.83c-3.06.65-3.71-1.44-3.71-1.44a2.86 2.86 0 0 0-1.22-1.58c-1-.66.08-.65.08-.65a2.31 2.31 0 0 1 1.68 1.11 2.37 2.37 0 0 0 3.2.89 2.33 2.33 0 0 1 .7-1.44c-2.44-.27-5-1.19-5-5.32a4.15 4.15 0 0 1 1.11-2.91 3.78 3.78 0 0 1 .11-2.84s.93-.29 3 1.1a10.68 10.68 0 0 1 5.5 0c2.1-1.39 3-1.1 3-1.1a3.78 3.78 0 0 1 .11 2.84A4.15 4.15 0 0 1 19 11.2c0 4.14-2.58 5.05-5 5.32a2.5 2.5 0 0 1 .75 2v2.95c0 .35.2.63.75.52A10.8 10.8 0 0 0 23 11.77 10.89 10.89 0 0 0 12 1" data-name="github"/></g>', "globe-2": '<g data-name="Layer 2"><g data-name="globe-2"><rect width="24" height="24" opacity="0"/><rect width="24" height="24" opacity="0"/><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 2a8.19 8.19 0 0 1 1.79.21 2.61 2.61 0 0 1-.78 1c-.22.17-.46.31-.7.46a4.56 4.56 0 0 0-1.85 1.67 6.49 6.49 0 0 0-.62 3.3c0 1.36 0 2.16-.95 2.87-1.37 1.07-3.46.47-4.76-.07A8.33 8.33 0 0 1 4 12a8 8 0 0 1 8-8zm4.89 14.32a6.79 6.79 0 0 0-.63-1.14c-.11-.16-.22-.32-.32-.49-.39-.68-.25-1 .38-2l.1-.17a4.77 4.77 0 0 0 .58-2.43 5.42 5.42 0 0 1 .09-1c.16-.73 1.71-.93 2.67-1a7.94 7.94 0 0 1-2.86 8.28z"/></g></g>', "globe-3": '<g data-name="Layer 2"><g data-name="globe-3"><rect width="24" height="24" opacity="0"/><rect width="24" height="24" opacity="0"/><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zM5 15.8a8.42 8.42 0 0 0 2 .27 5 5 0 0 0 3.14-1c1.71-1.34 1.71-3.06 1.71-4.44a4.76 4.76 0 0 1 .37-2.34 2.86 2.86 0 0 1 1.12-.91 9.75 9.75 0 0 0 .92-.61 4.55 4.55 0 0 0 1.4-1.87A8 8 0 0 1 19 8.12c-1.43.2-3.46.67-3.86 2.53A7 7 0 0 0 15 12a2.93 2.93 0 0 1-.29 1.47l-.1.17c-.65 1.08-1.38 2.31-.39 4 .12.21.25.41.38.61a2.29 2.29 0 0 1 .52 1.08A7.89 7.89 0 0 1 12 20a8 8 0 0 1-7-4.2z"/></g></g>', "globe": '<g data-name="Layer 2"><g data-name="globe"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M22 12A10 10 0 0 0 12 2a10 10 0 0 0 0 20 10 10 0 0 0 10-10zm-2.07-1H17a12.91 12.91 0 0 0-2.33-6.54A8 8 0 0 1 19.93 11zM9.08 13H15a11.44 11.44 0 0 1-3 6.61A11 11 0 0 1 9.08 13zm0-2A11.4 11.4 0 0 1 12 4.4a11.19 11.19 0 0 1 3 6.6zm.36-6.57A13.18 13.18 0 0 0 7.07 11h-3a8 8 0 0 1 5.37-6.57zM4.07 13h3a12.86 12.86 0 0 0 2.35 6.56A8 8 0 0 1 4.07 13zm10.55 6.55A13.14 13.14 0 0 0 17 13h2.95a8 8 0 0 1-5.33 6.55z"/></g></g>', "google": '<g data-name="Layer 2"><g data-name="google"><polyline points="0 0 24 0 24 24 0 24" opacity="0"/><path d="M17.5 14a5.51 5.51 0 0 1-4.5 3.93 6.15 6.15 0 0 1-7-5.45A6 6 0 0 1 12 6a6.12 6.12 0 0 1 2.27.44.5.5 0 0 0 .64-.21l1.44-2.65a.52.52 0 0 0-.23-.7A10 10 0 0 0 2 12.29 10.12 10.12 0 0 0 11.57 22 10 10 0 0 0 22 12.52v-2a.51.51 0 0 0-.5-.5h-9a.5.5 0 0 0-.5.5v3a.5.5 0 0 0 .5.5h5"/></g></g>', "grid": '<g data-name="Layer 2"><g data-name="grid"><rect width="24" height="24" opacity="0"/><path d="M9 3H5a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2z"/><path d="M19 3h-4a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2z"/><path d="M9 13H5a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2z"/><path d="M19 13h-4a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2z"/></g></g>', "hard-drive": '<g data-name="Layer 2"><g data-name="hard-drive"><rect width="24" height="24" opacity="0"/><path d="M20.79 11.34l-3.34-6.68A3 3 0 0 0 14.76 3H9.24a3 3 0 0 0-2.69 1.66l-3.34 6.68a2 2 0 0 0-.21.9V18a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3v-5.76a2 2 0 0 0-.21-.9zM8 17a1 1 0 1 1 1-1 1 1 0 0 1-1 1zm8 0h-4a1 1 0 0 1 0-2h4a1 1 0 0 1 0 2zM5.62 11l2.72-5.45a1 1 0 0 1 .9-.55h5.52a1 1 0 0 1 .9.55L18.38 11z"/></g></g>', "hash": '<g data-name="Layer 2"><g data-name="hash"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M20 14h-4.3l.73-4H20a1 1 0 0 0 0-2h-3.21l.69-3.81A1 1 0 0 0 16.64 3a1 1 0 0 0-1.22.82L14.67 8h-3.88l.69-3.81A1 1 0 0 0 10.64 3a1 1 0 0 0-1.22.82L8.67 8H4a1 1 0 0 0 0 2h4.3l-.73 4H4a1 1 0 0 0 0 2h3.21l-.69 3.81A1 1 0 0 0 7.36 21a1 1 0 0 0 1.22-.82L9.33 16h3.88l-.69 3.81a1 1 0 0 0 .84 1.19 1 1 0 0 0 1.22-.82l.75-4.18H20a1 1 0 0 0 0-2zM9.7 14l.73-4h3.87l-.73 4z"/></g></g>', "headphones": '<g data-name="Layer 2"><g data-name="headphones"><rect width="24" height="24" opacity="0"/><path d="M12 2A10.2 10.2 0 0 0 2 12.37V17a4 4 0 1 0 4-4 3.91 3.91 0 0 0-2 .56v-1.19A8.2 8.2 0 0 1 12 4a8.2 8.2 0 0 1 8 8.37v1.19a3.91 3.91 0 0 0-2-.56 4 4 0 1 0 4 4v-4.63A10.2 10.2 0 0 0 12 2z"/></g></g>', "heart": '<g data-name="Layer 2"><g data-name="heart"><rect width="24" height="24" opacity="0"/><path d="M12 21a1 1 0 0 1-.71-.29l-7.77-7.78a5.26 5.26 0 0 1 0-7.4 5.24 5.24 0 0 1 7.4 0L12 6.61l1.08-1.08a5.24 5.24 0 0 1 7.4 0 5.26 5.26 0 0 1 0 7.4l-7.77 7.78A1 1 0 0 1 12 21z"/></g></g>', "home": '<g data-name="Layer 2"><g data-name="home"><rect width="24" height="24" opacity="0"/><rect x="10" y="14" width="4" height="7"/><path d="M20.42 10.18L12.71 2.3a1 1 0 0 0-1.42 0l-7.71 7.89A2 2 0 0 0 3 11.62V20a2 2 0 0 0 1.89 2H8v-9a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1v9h3.11A2 2 0 0 0 21 20v-8.38a2.07 2.07 0 0 0-.58-1.44z"/></g></g>', "image-2": '<g data-name="Layer 2"><g data-name="image-2"><rect width="24" height="24" opacity="0"/><path d="M18 3H6a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3V6a3 3 0 0 0-3-3zM8 7a1.5 1.5 0 1 1-1.5 1.5A1.5 1.5 0 0 1 8 7zm11 10.83A1.09 1.09 0 0 1 18 19H6l7.57-6.82a.69.69 0 0 1 .93 0l4.5 4.48z"/></g></g>', "image": '<g data-name="Layer 2"><g data-name="image"><rect width="24" height="24" opacity="0"/><path d="M18 3H6a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3V6a3 3 0 0 0-3-3zM6 5h12a1 1 0 0 1 1 1v8.36l-3.2-2.73a2.77 2.77 0 0 0-3.52 0L5 17.7V6a1 1 0 0 1 1-1z"/><circle cx="8" cy="8.5" r="1.5"/></g></g>', "inbox": '<g data-name="Layer 2"><g data-name="inbox"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M20.79 11.34l-3.34-6.68A3 3 0 0 0 14.76 3H9.24a3 3 0 0 0-2.69 1.66l-3.34 6.68a2 2 0 0 0-.21.9V18a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3v-5.76a2 2 0 0 0-.21-.9zM8.34 5.55a1 1 0 0 1 .9-.55h5.52a1 1 0 0 1 .9.55L18.38 11H16a1 1 0 0 0-1 1v2a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1v-2a1 1 0 0 0-1-1H5.62z"/></g></g>', "info": '<g data-name="Layer 2"><g data-name="info"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm1 14a1 1 0 0 1-2 0v-5a1 1 0 0 1 2 0zm-1-7a1 1 0 1 1 1-1 1 1 0 0 1-1 1z"/></g></g>', "keypad": '<g data-name="Layer 2"><g data-name="keypad"><rect width="24" height="24" opacity="0"/><path d="M5 2a3 3 0 1 0 3 3 3 3 0 0 0-3-3z"/><path d="M12 2a3 3 0 1 0 3 3 3 3 0 0 0-3-3z"/><path d="M19 8a3 3 0 1 0-3-3 3 3 0 0 0 3 3z"/><path d="M5 9a3 3 0 1 0 3 3 3 3 0 0 0-3-3z"/><path d="M12 9a3 3 0 1 0 3 3 3 3 0 0 0-3-3z"/><path d="M19 9a3 3 0 1 0 3 3 3 3 0 0 0-3-3z"/><path d="M5 16a3 3 0 1 0 3 3 3 3 0 0 0-3-3z"/><path d="M12 16a3 3 0 1 0 3 3 3 3 0 0 0-3-3z"/><path d="M19 16a3 3 0 1 0 3 3 3 3 0 0 0-3-3z"/></g></g>', "layers": '<g data-name="Layer 2"><g data-name="layers"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M3.24 7.29l8.52 4.63a.51.51 0 0 0 .48 0l8.52-4.63a.44.44 0 0 0-.05-.81L12.19 3a.5.5 0 0 0-.38 0L3.29 6.48a.44.44 0 0 0-.05.81z"/><path d="M20.71 10.66l-1.83-.78-6.64 3.61a.51.51 0 0 1-.48 0L5.12 9.88l-1.83.78a.48.48 0 0 0 0 .85l8.52 4.9a.46.46 0 0 0 .48 0l8.52-4.9a.48.48 0 0 0-.1-.85z"/><path d="M20.71 15.1l-1.56-.68-6.91 3.76a.51.51 0 0 1-.48 0l-6.91-3.76-1.56.68a.49.49 0 0 0 0 .87l8.52 5a.51.51 0 0 0 .48 0l8.52-5a.49.49 0 0 0-.1-.87z"/></g></g>', "layout": '<g data-name="Layer 2"><g data-name="layout"><rect width="24" height="24" opacity="0"/><path d="M21 8V6a3 3 0 0 0-3-3H6a3 3 0 0 0-3 3v2z"/><path d="M3 10v8a3 3 0 0 0 3 3h5V10z"/><path d="M13 10v11h5a3 3 0 0 0 3-3v-8z"/></g></g>', "link-2": '<g data-name="Layer 2"><g data-name="link-2"><rect width="24" height="24" opacity="0"/><path d="M13.29 9.29l-4 4a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0l4-4a1 1 0 0 0-1.42-1.42z"/><path d="M12.28 17.4L11 18.67a4.2 4.2 0 0 1-5.58.4 4 4 0 0 1-.27-5.93l1.42-1.43a1 1 0 0 0 0-1.42 1 1 0 0 0-1.42 0l-1.27 1.28a6.15 6.15 0 0 0-.67 8.07 6.06 6.06 0 0 0 9.07.6l1.42-1.42a1 1 0 0 0-1.42-1.42z"/><path d="M19.66 3.22a6.18 6.18 0 0 0-8.13.68L10.45 5a1.09 1.09 0 0 0-.17 1.61 1 1 0 0 0 1.42 0L13 5.3a4.17 4.17 0 0 1 5.57-.4 4 4 0 0 1 .27 5.95l-1.42 1.43a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0l1.42-1.42a6.06 6.06 0 0 0-.6-9.06z"/></g></g>', "link": '<g data-name="Layer 2"><g data-name="link"><rect width="24" height="24" opacity="0"/><path d="M8 12a1 1 0 0 0 1 1h6a1 1 0 0 0 0-2H9a1 1 0 0 0-1 1z"/><path d="M9 16H7.21A4.13 4.13 0 0 1 3 12.37 4 4 0 0 1 7 8h2a1 1 0 0 0 0-2H7.21a6.15 6.15 0 0 0-6.16 5.21A6 6 0 0 0 7 18h2a1 1 0 0 0 0-2z"/><path d="M23 11.24A6.16 6.16 0 0 0 16.76 6h-1.51C14.44 6 14 6.45 14 7a1 1 0 0 0 1 1h1.79A4.13 4.13 0 0 1 21 11.63 4 4 0 0 1 17 16h-2a1 1 0 0 0 0 2h2a6 6 0 0 0 6-6.76z"/></g></g>', "linkedin": '<g data-name="Layer 2"><g data-name="linkedin"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M15.15 8.4a5.83 5.83 0 0 0-5.85 5.82v5.88a.9.9 0 0 0 .9.9h2.1a.9.9 0 0 0 .9-.9v-5.88a1.94 1.94 0 0 1 2.15-1.93 2 2 0 0 1 1.75 2v5.81a.9.9 0 0 0 .9.9h2.1a.9.9 0 0 0 .9-.9v-5.88a5.83 5.83 0 0 0-5.85-5.82z"/><rect x="3" y="9.3" width="4.5" height="11.7" rx=".9" ry=".9"/><circle cx="5.25" cy="5.25" r="2.25"/></g></g>', "list": '<g data-name="Layer 2"><g data-name="list"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><circle cx="4" cy="7" r="1"/><circle cx="4" cy="12" r="1"/><circle cx="4" cy="17" r="1"/><rect x="7" y="11" width="14" height="2" rx=".94" ry=".94"/><rect x="7" y="16" width="14" height="2" rx=".94" ry=".94"/><rect x="7" y="6" width="14" height="2" rx=".94" ry=".94"/></g></g>', "lock": '<g data-name="Layer 2"><g data-name="lock"><rect width="24" height="24" opacity="0"/><circle cx="12" cy="15" r="1"/><path d="M17 8h-1V6.11a4 4 0 1 0-8 0V8H7a3 3 0 0 0-3 3v8a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3v-8a3 3 0 0 0-3-3zm-7-1.89A2.06 2.06 0 0 1 12 4a2.06 2.06 0 0 1 2 2.11V8h-4zM12 18a3 3 0 1 1 3-3 3 3 0 0 1-3 3z"/></g></g>', "log-in": '<g data-name="Layer 2"><g data-name="log-in"><rect width="24" height="24" transform="rotate(-90 12 12)" opacity="0"/><path d="M19 4h-2a1 1 0 0 0 0 2h1v12h-1a1 1 0 0 0 0 2h2a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1z"/><path d="M11.8 7.4a1 1 0 0 0-1.6 1.2L12 11H4a1 1 0 0 0 0 2h8.09l-1.72 2.44a1 1 0 0 0 .24 1.4 1 1 0 0 0 .58.18 1 1 0 0 0 .81-.42l2.82-4a1 1 0 0 0 0-1.18z"/></g></g>', "log-out": '<g data-name="Layer 2"><g data-name="log-out"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M7 6a1 1 0 0 0 0-2H5a1 1 0 0 0-1 1v14a1 1 0 0 0 1 1h2a1 1 0 0 0 0-2H6V6z"/><path d="M20.82 11.42l-2.82-4a1 1 0 0 0-1.39-.24 1 1 0 0 0-.24 1.4L18.09 11H10a1 1 0 0 0 0 2h8l-1.8 2.4a1 1 0 0 0 .2 1.4 1 1 0 0 0 .6.2 1 1 0 0 0 .8-.4l3-4a1 1 0 0 0 .02-1.18z"/></g></g>', "map": '<g data-name="Layer 2"><g data-name="map"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M20.41 5.89l-4-1.8H15.59L12 5.7 8.41 4.09h-.05L8.24 4h-.6l-4 1.8a1 1 0 0 0-.64 1V19a1 1 0 0 0 .46.84A1 1 0 0 0 4 20a1 1 0 0 0 .41-.09L8 18.3l3.59 1.61h.05a.85.85 0 0 0 .72 0h.05L16 18.3l3.59 1.61A1 1 0 0 0 20 20a1 1 0 0 0 .54-.16A1 1 0 0 0 21 19V6.8a1 1 0 0 0-.59-.91zM9 6.55l2 .89v10l-2-.89zm10 10.9l-2-.89v-10l2 .89z"/></g></g>', "maximize": '<g data-name="Layer 2"><g data-name="maximize"><rect width="24" height="24" opacity="0"/><path d="M20.71 19.29l-3.4-3.39A7.92 7.92 0 0 0 19 11a8 8 0 1 0-8 8 7.92 7.92 0 0 0 4.9-1.69l3.39 3.4a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42zM13 12h-1v1a1 1 0 0 1-2 0v-1H9a1 1 0 0 1 0-2h1V9a1 1 0 0 1 2 0v1h1a1 1 0 0 1 0 2z"/></g></g>', "menu-2": '<g data-name="Layer 2"><g data-name="menu-2"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><circle cx="4" cy="12" r="1"/><rect x="7" y="11" width="14" height="2" rx=".94" ry=".94"/><rect x="3" y="16" width="18" height="2" rx=".94" ry=".94"/><rect x="3" y="6" width="18" height="2" rx=".94" ry=".94"/></g></g>', "menu-arrow": '<g data-name="Layer 2"><g data-name="menu-arrow"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M20.05 11H5.91l1.3-1.29a1 1 0 0 0-1.42-1.42l-3 3a1 1 0 0 0 0 1.42l3 3a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42L5.91 13h14.14a1 1 0 0 0 .95-.95V12a1 1 0 0 0-.95-1z"/><rect x="3" y="17" width="18" height="2" rx=".95" ry=".95"/><rect x="3" y="5" width="18" height="2" rx=".95" ry=".95"/></g></g>', "menu": '<g data-name="Layer 2"><g data-name="menu"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><rect x="3" y="11" width="18" height="2" rx=".95" ry=".95"/><rect x="3" y="16" width="18" height="2" rx=".95" ry=".95"/><rect x="3" y="6" width="18" height="2" rx=".95" ry=".95"/></g></g>', "message-circle": '<g data-name="Layer 2"><g data-name="message-circle"><rect width="24" height="24" opacity="0"/><path d="M19.07 4.93a10 10 0 0 0-16.28 11 1.06 1.06 0 0 1 .09.64L2 20.8a1 1 0 0 0 .27.91A1 1 0 0 0 3 22h.2l4.28-.86a1.26 1.26 0 0 1 .64.09 10 10 0 0 0 11-16.28zM8 13a1 1 0 1 1 1-1 1 1 0 0 1-1 1zm4 0a1 1 0 1 1 1-1 1 1 0 0 1-1 1zm4 0a1 1 0 1 1 1-1 1 1 0 0 1-1 1z"/></g></g>', "message-square": '<g data-name="Layer 2"><g data-name="message-square"><rect width="24" height="24" opacity="0"/><path d="M19 3H5a3 3 0 0 0-3 3v15a1 1 0 0 0 .51.87A1 1 0 0 0 3 22a1 1 0 0 0 .51-.14L8 19.14a1 1 0 0 1 .55-.14H19a3 3 0 0 0 3-3V6a3 3 0 0 0-3-3zM8 12a1 1 0 1 1 1-1 1 1 0 0 1-1 1zm4 0a1 1 0 1 1 1-1 1 1 0 0 1-1 1zm4 0a1 1 0 1 1 1-1 1 1 0 0 1-1 1z"/></g></g>', "mic-off": '<g data-name="Layer 2"><g data-name="mic-off"><rect width="24" height="24" opacity="0"/><path d="M15.58 12.75A4 4 0 0 0 16 11V6a4 4 0 0 0-7.92-.75"/><path d="M19 11a1 1 0 0 0-2 0 4.86 4.86 0 0 1-.69 2.48L17.78 15A7 7 0 0 0 19 11z"/><path d="M12 15h.16L8 10.83V11a4 4 0 0 0 4 4z"/><path d="M20.71 19.29l-16-16a1 1 0 0 0-1.42 1.42l16 16a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42z"/><path d="M15 20h-2v-2.08a7 7 0 0 0 1.65-.44l-1.6-1.6A4.57 4.57 0 0 1 12 16a5 5 0 0 1-5-5 1 1 0 0 0-2 0 7 7 0 0 0 6 6.92V20H9a1 1 0 0 0 0 2h6a1 1 0 0 0 0-2z"/></g></g>', "mic": '<g data-name="Layer 2"><g data-name="mic"><rect width="24" height="24" opacity="0"/><path d="M12 15a4 4 0 0 0 4-4V6a4 4 0 0 0-8 0v5a4 4 0 0 0 4 4z"/><path d="M19 11a1 1 0 0 0-2 0 5 5 0 0 1-10 0 1 1 0 0 0-2 0 7 7 0 0 0 6 6.92V20H8.89a.89.89 0 0 0-.89.89v.22a.89.89 0 0 0 .89.89h6.22a.89.89 0 0 0 .89-.89v-.22a.89.89 0 0 0-.89-.89H13v-2.08A7 7 0 0 0 19 11z"/></g></g>', "minimize": '<g data-name="Layer 2"><g data-name="minimize"><rect width="24" height="24" opacity="0"/><path d="M20.71 19.29l-3.4-3.39A7.92 7.92 0 0 0 19 11a8 8 0 1 0-8 8 7.92 7.92 0 0 0 4.9-1.69l3.39 3.4a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42zM13 12H9a1 1 0 0 1 0-2h4a1 1 0 0 1 0 2z"/></g></g>', "minus-circle": '<g data-name="Layer 2"><g data-name="minus-circle"><rect width="24" height="24" opacity="0"/><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm3 11H9a1 1 0 0 1 0-2h6a1 1 0 0 1 0 2z"/></g></g>', "minus-square": '<g data-name="Layer 2"><g data-name="minus-square"><rect width="24" height="24" opacity="0"/><path d="M18 3H6a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3V6a3 3 0 0 0-3-3zm-3 10H9a1 1 0 0 1 0-2h6a1 1 0 0 1 0 2z"/></g></g>', "minus": '<g data-name="Layer 2"><g data-name="minus"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M19 13H5a1 1 0 0 1 0-2h14a1 1 0 0 1 0 2z"/></g></g>', "monitor": '<g data-name="Layer 2"><g data-name="monitor"><rect width="24" height="24" opacity="0"/><path d="M19 3H5a3 3 0 0 0-3 3v5h20V6a3 3 0 0 0-3-3z"/><path d="M2 14a3 3 0 0 0 3 3h6v2H7a1 1 0 0 0 0 2h10a1 1 0 0 0 0-2h-4v-2h6a3 3 0 0 0 3-3v-1H2z"/></g></g>', "moon": '<g data-name="Layer 2"><g data-name="moon"><rect width="24" height="24" opacity="0"/><path d="M12.3 22h-.1a10.31 10.31 0 0 1-7.34-3.15 10.46 10.46 0 0 1-.26-14 10.13 10.13 0 0 1 4-2.74 1 1 0 0 1 1.06.22 1 1 0 0 1 .24 1 8.4 8.4 0 0 0 1.94 8.81 8.47 8.47 0 0 0 8.83 1.94 1 1 0 0 1 1.27 1.29A10.16 10.16 0 0 1 19.6 19a10.28 10.28 0 0 1-7.3 3z"/></g></g>', "more-horizontal": '<g data-name="Layer 2"><g data-name="more-horizotnal"><rect width="24" height="24" opacity="0"/><circle cx="12" cy="12" r="2"/><circle cx="19" cy="12" r="2"/><circle cx="5" cy="12" r="2"/></g></g>', "more-vertical": '<g data-name="Layer 2"><g data-name="more-vertical"><rect width="24" height="24" transform="rotate(-90 12 12)" opacity="0"/><circle cx="12" cy="12" r="2"/><circle cx="12" cy="5" r="2"/><circle cx="12" cy="19" r="2"/></g></g>', "move": '<g data-name="Layer 2"><g data-name="move"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M21.71 11.31l-3-3a1 1 0 0 0-1.42 1.42L18.58 11H13V5.41l1.29 1.3A1 1 0 0 0 15 7a1 1 0 0 0 .71-.29 1 1 0 0 0 0-1.42l-3-3A1 1 0 0 0 12 2a1 1 0 0 0-.7.29l-3 3a1 1 0 0 0 1.41 1.42L11 5.42V11H5.41l1.3-1.29a1 1 0 0 0-1.42-1.42l-3 3A1 1 0 0 0 2 12a1 1 0 0 0 .29.71l3 3A1 1 0 0 0 6 16a1 1 0 0 0 .71-.29 1 1 0 0 0 0-1.42L5.42 13H11v5.59l-1.29-1.3a1 1 0 0 0-1.42 1.42l3 3A1 1 0 0 0 12 22a1 1 0 0 0 .7-.29l3-3a1 1 0 0 0-1.42-1.42L13 18.58V13h5.59l-1.3 1.29a1 1 0 0 0 0 1.42A1 1 0 0 0 18 16a1 1 0 0 0 .71-.29l3-3A1 1 0 0 0 22 12a1 1 0 0 0-.29-.69z"/></g></g>', "music": '<g data-name="Layer 2"><g data-name="music"><rect width="24" height="24" opacity="0"/><path d="M19 15V4a1 1 0 0 0-.38-.78 1 1 0 0 0-.84-.2l-9 2A1 1 0 0 0 8 6v8.34a3.49 3.49 0 1 0 2 3.18 4.36 4.36 0 0 0 0-.52V6.8l7-1.55v7.09a3.49 3.49 0 1 0 2 3.17 4.57 4.57 0 0 0 0-.51z"/></g></g>', "navigation-2": '<g data-name="Layer 2"><g data-name="navigation-2"><rect width="24" height="24" opacity="0"/><path d="M13.67 22h-.06a1 1 0 0 1-.92-.8l-1.54-7.57a1 1 0 0 0-.78-.78L2.8 11.31a1 1 0 0 1-.12-1.93l16-5.33A1 1 0 0 1 20 5.32l-5.33 16a1 1 0 0 1-1 .68z"/></g></g>', "navigation": '<g data-name="Layer 2"><g data-name="navigation"><rect width="24" height="24" opacity="0"/><path d="M20 20a.94.94 0 0 1-.55-.17l-6.9-4.56a1 1 0 0 0-1.1 0l-6.9 4.56a1 1 0 0 1-1.44-1.28l8-16a1 1 0 0 1 1.78 0l8 16a1 1 0 0 1-.23 1.2A1 1 0 0 1 20 20z"/></g></g>', "npm": '<g data-name="Layer 2"><g data-name="npm"><rect width="24" height="24" opacity="0"/><path d="M18 3H6a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h7V11h4v10h1a3 3 0 0 0 3-3V6a3 3 0 0 0-3-3z"/></g></g>', "options-2": '<g data-name="Layer 2"><g data-name="options-2"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M19 9a3 3 0 0 0-2.82 2H3a1 1 0 0 0 0 2h13.18A3 3 0 1 0 19 9z"/><path d="M3 7h1.18a3 3 0 0 0 5.64 0H21a1 1 0 0 0 0-2H9.82a3 3 0 0 0-5.64 0H3a1 1 0 0 0 0 2z"/><path d="M21 17h-7.18a3 3 0 0 0-5.64 0H3a1 1 0 0 0 0 2h5.18a3 3 0 0 0 5.64 0H21a1 1 0 0 0 0-2z"/></g></g>', "options": '<g data-name="Layer 2"><g data-name="options"><rect width="24" height="24" opacity="0"/><path d="M7 14.18V3a1 1 0 0 0-2 0v11.18a3 3 0 0 0 0 5.64V21a1 1 0 0 0 2 0v-1.18a3 3 0 0 0 0-5.64z"/><path d="M21 13a3 3 0 0 0-2-2.82V3a1 1 0 0 0-2 0v7.18a3 3 0 0 0 0 5.64V21a1 1 0 0 0 2 0v-5.18A3 3 0 0 0 21 13z"/><path d="M15 5a3 3 0 1 0-4 2.82V21a1 1 0 0 0 2 0V7.82A3 3 0 0 0 15 5z"/></g></g>', "pantone": '<g data-name="Layer 2"><g data-name="pantone"><rect width="24" height="24" opacity="0"/><path d="M20 13.18h-2.7l-1.86 2L11.88 19l-1.41 1.52L10 21h10a1 1 0 0 0 1-1v-5.82a1 1 0 0 0-1-1z"/><path d="M18.19 9.3l-4.14-3.86a.89.89 0 0 0-.71-.26 1 1 0 0 0-.7.31l-.82.89v10.71a5.23 5.23 0 0 1-.06.57l6.48-6.95a1 1 0 0 0-.05-1.41z"/><path d="M10.82 4a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1v13.09a3.91 3.91 0 0 0 7.82 0zm-2 13.09a1.91 1.91 0 0 1-3.82 0V15h3.82zm0-4.09H5v-3h3.82zm0-5H5V5h3.82z"/></g></g>', "paper-plane": '<g data-name="Layer 2"><g data-name="paper-plane"><rect width="24" height="24" opacity="0"/><path d="M21 4a1.31 1.31 0 0 0-.06-.27v-.09a1 1 0 0 0-.2-.3 1 1 0 0 0-.29-.19h-.09a.86.86 0 0 0-.31-.15H20a1 1 0 0 0-.3 0l-18 6a1 1 0 0 0 0 1.9l8.53 2.84 2.84 8.53a1 1 0 0 0 1.9 0l6-18A1 1 0 0 0 21 4zm-4.7 2.29l-5.57 5.57L5.16 10zM14 18.84l-1.86-5.57 5.57-5.57z"/></g></g>', "pause-circle": '<g data-name="Layer 2"><g data-name="pause-circle"><rect width="24" height="24" opacity="0"/><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm-2 13a1 1 0 0 1-2 0V9a1 1 0 0 1 2 0zm6 0a1 1 0 0 1-2 0V9a1 1 0 0 1 2 0z"/></g></g>', "people": '<g data-name="Layer 2"><g data-name="people"><rect width="24" height="24" opacity="0"/><path d="M9 11a4 4 0 1 0-4-4 4 4 0 0 0 4 4z"/><path d="M17 13a3 3 0 1 0-3-3 3 3 0 0 0 3 3z"/><path d="M21 20a1 1 0 0 0 1-1 5 5 0 0 0-8.06-3.95A7 7 0 0 0 2 20a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1"/></g></g>', "percent": '<g data-name="Layer 2"><g data-name="percent"><rect width="24" height="24" opacity="0"/><path d="M8 11a3.5 3.5 0 1 0-3.5-3.5A3.5 3.5 0 0 0 8 11zm0-5a1.5 1.5 0 1 1-1.5 1.5A1.5 1.5 0 0 1 8 6z"/><path d="M16 14a3.5 3.5 0 1 0 3.5 3.5A3.5 3.5 0 0 0 16 14zm0 5a1.5 1.5 0 1 1 1.5-1.5A1.5 1.5 0 0 1 16 19z"/><path d="M19.74 4.26a.89.89 0 0 0-1.26 0L4.26 18.48a.91.91 0 0 0-.26.63.89.89 0 0 0 1.52.63L19.74 5.52a.89.89 0 0 0 0-1.26z"/></g></g>', "person-add": '<g data-name="Layer 2"><g data-name="person-add"><rect width="24" height="24" opacity="0"/><path d="M21 6h-1V5a1 1 0 0 0-2 0v1h-1a1 1 0 0 0 0 2h1v1a1 1 0 0 0 2 0V8h1a1 1 0 0 0 0-2z"/><path d="M10 11a4 4 0 1 0-4-4 4 4 0 0 0 4 4z"/><path d="M16 21a1 1 0 0 0 1-1 7 7 0 0 0-14 0 1 1 0 0 0 1 1"/></g></g>', "person-delete": '<g data-name="Layer 2"><g data-name="person-delete"><rect width="24" height="24" opacity="0"/><path d="M20.47 7.5l.73-.73a1 1 0 0 0-1.47-1.47L19 6l-.73-.73a1 1 0 0 0-1.47 1.5l.73.73-.73.73a1 1 0 0 0 1.47 1.47L19 9l.73.73a1 1 0 0 0 1.47-1.5z"/><path d="M10 11a4 4 0 1 0-4-4 4 4 0 0 0 4 4z"/><path d="M16 21a1 1 0 0 0 1-1 7 7 0 0 0-14 0 1 1 0 0 0 1 1z"/></g></g>', "person-done": '<g data-name="Layer 2"><g data-name="person-done"><rect width="24" height="24" opacity="0"/><path d="M21.66 4.25a1 1 0 0 0-1.41.09l-1.87 2.15-.63-.71a1 1 0 0 0-1.5 1.33l1.39 1.56a1 1 0 0 0 .75.33 1 1 0 0 0 .74-.34l2.61-3a1 1 0 0 0-.08-1.41z"/><path d="M10 11a4 4 0 1 0-4-4 4 4 0 0 0 4 4z"/><path d="M16 21a1 1 0 0 0 1-1 7 7 0 0 0-14 0 1 1 0 0 0 1 1"/></g></g>', "person-remove": '<g data-name="Layer 2"><g data-name="person-remove"><rect width="24" height="24" opacity="0"/><path d="M21 6h-4a1 1 0 0 0 0 2h4a1 1 0 0 0 0-2z"/><path d="M10 11a4 4 0 1 0-4-4 4 4 0 0 0 4 4z"/><path d="M16 21a1 1 0 0 0 1-1 7 7 0 0 0-14 0 1 1 0 0 0 1 1"/></g></g>', "person": '<g data-name="Layer 2"><g data-name="person"><rect width="24" height="24" opacity="0"/><path d="M12 11a4 4 0 1 0-4-4 4 4 0 0 0 4 4z"/><path d="M18 21a1 1 0 0 0 1-1 7 7 0 0 0-14 0 1 1 0 0 0 1 1z"/></g></g>', "phone-call": '<g data-name="Layer 2"><g data-name="phone-call"><rect width="24" height="24" opacity="0"/><path d="M13 8a3 3 0 0 1 3 3 1 1 0 0 0 2 0 5 5 0 0 0-5-5 1 1 0 0 0 0 2z"/><path d="M13 4a7 7 0 0 1 7 7 1 1 0 0 0 2 0 9 9 0 0 0-9-9 1 1 0 0 0 0 2z"/><path d="M21.75 15.91a1 1 0 0 0-.72-.65l-6-1.37a1 1 0 0 0-.92.26c-.14.13-.15.14-.8 1.38a9.91 9.91 0 0 1-4.87-4.89C9.71 10 9.72 10 9.85 9.85a1 1 0 0 0 .26-.92L8.74 3a1 1 0 0 0-.65-.72 3.79 3.79 0 0 0-.72-.18A3.94 3.94 0 0 0 6.6 2 4.6 4.6 0 0 0 2 6.6 15.42 15.42 0 0 0 17.4 22a4.6 4.6 0 0 0 4.6-4.6 4.77 4.77 0 0 0-.06-.76 4.34 4.34 0 0 0-.19-.73z"/></g></g>', "phone-missed": '<g data-name="Layer 2"><g data-name="phone-missed"><rect width="24" height="24" opacity="0"/><path d="M21.94 16.64a4.34 4.34 0 0 0-.19-.73 1 1 0 0 0-.72-.65l-6-1.37a1 1 0 0 0-.92.26c-.14.13-.15.14-.8 1.38a10 10 0 0 1-4.88-4.89C9.71 10 9.72 10 9.85 9.85a1 1 0 0 0 .26-.92L8.74 3a1 1 0 0 0-.65-.72 3.79 3.79 0 0 0-.72-.18A3.94 3.94 0 0 0 6.6 2 4.6 4.6 0 0 0 2 6.6 15.42 15.42 0 0 0 17.4 22a4.6 4.6 0 0 0 4.6-4.6 4.77 4.77 0 0 0-.06-.76z"/><path d="M15.8 8.7a1.05 1.05 0 0 0 1.47 0L18 8l.73.73a1 1 0 0 0 1.47-1.5l-.73-.73.73-.73a1 1 0 0 0-1.47-1.47L18 5l-.73-.73a1 1 0 0 0-1.47 1.5l.73.73-.73.73a1.05 1.05 0 0 0 0 1.47z"/></g></g>', "phone-off": '<g data-name="Layer 2"><g data-name="phone-off"><rect width="24" height="24" opacity="0"/><path d="M9.27 12.06a10.37 10.37 0 0 1-.8-1.42C9.71 10 9.72 10 9.85 9.85a1 1 0 0 0 .26-.92L8.74 3a1 1 0 0 0-.65-.72 3.79 3.79 0 0 0-.72-.18A3.94 3.94 0 0 0 6.6 2 4.6 4.6 0 0 0 2 6.6a15.33 15.33 0 0 0 3.27 9.46z"/><path d="M21.94 16.64a4.34 4.34 0 0 0-.19-.73 1 1 0 0 0-.72-.65l-6-1.37a1 1 0 0 0-.92.26c-.14.13-.15.14-.8 1.38a10.88 10.88 0 0 1-1.41-.8l-4 4A15.33 15.33 0 0 0 17.4 22a4.6 4.6 0 0 0 4.6-4.6 4.77 4.77 0 0 0-.06-.76z"/><path d="M19.74 4.26a.89.89 0 0 0-1.26 0L4.26 18.48a.91.91 0 0 0-.26.63.89.89 0 0 0 1.52.63L19.74 5.52a.89.89 0 0 0 0-1.26z"/></g></g>', "phone": '<g data-name="Layer 2"><g data-name="phone"><rect width="24" height="24" opacity="0"/><path d="M17.4 22A15.42 15.42 0 0 1 2 6.6 4.6 4.6 0 0 1 6.6 2a3.94 3.94 0 0 1 .77.07 3.79 3.79 0 0 1 .72.18 1 1 0 0 1 .65.75l1.37 6a1 1 0 0 1-.26.92c-.13.14-.14.15-1.37.79a9.91 9.91 0 0 0 4.87 4.89c.65-1.24.66-1.25.8-1.38a1 1 0 0 1 .92-.26l6 1.37a1 1 0 0 1 .72.65 4.34 4.34 0 0 1 .19.73 4.77 4.77 0 0 1 .06.76A4.6 4.6 0 0 1 17.4 22z"/></g></g>', "pie-chart-2": '<g data-name="Layer 2"><g data-name="pie-chart-2"><rect width="24" height="24" opacity="0"/><path d="M14.5 10.33h6.67A.83.83 0 0 0 22 9.5 7.5 7.5 0 0 0 14.5 2a.83.83 0 0 0-.83.83V9.5a.83.83 0 0 0 .83.83zm.83-6.6a5.83 5.83 0 0 1 4.94 4.94h-4.94z"/><path d="M21.08 12h-8.15a.91.91 0 0 1-.91-.91V2.92A.92.92 0 0 0 11 2a10 10 0 1 0 11 11 .92.92 0 0 0-.92-1z"/></g></g>', "pie-chart": '<g data-name="Layer 2"><g data-name="pie-chart"><rect width="24" height="24" opacity="0"/><path d="M14.5 10.33h6.67A.83.83 0 0 0 22 9.5 7.5 7.5 0 0 0 14.5 2a.83.83 0 0 0-.83.83V9.5a.83.83 0 0 0 .83.83z"/><path d="M21.08 12h-8.15a.91.91 0 0 1-.91-.91V2.92A.92.92 0 0 0 11 2a10 10 0 1 0 11 11 .92.92 0 0 0-.92-1z"/></g></g>', "pin": '<g data-name="Layer 2"><g data-name="pin"><rect width="24" height="24" opacity="0"/><circle cx="12" cy="9.5" r="1.5"/><path d="M12 2a8 8 0 0 0-8 7.92c0 5.48 7.05 11.58 7.35 11.84a1 1 0 0 0 1.3 0C13 21.5 20 15.4 20 9.92A8 8 0 0 0 12 2zm0 11a3.5 3.5 0 1 1 3.5-3.5A3.5 3.5 0 0 1 12 13z"/></g></g>', "play-circle": '<g data-name="Layer 2"><g data-name="play-circle"><rect width="24" height="24" opacity="0"/><polygon points="11.5 14.6 14.31 12 11.5 9.4 11.5 14.6"/><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm4 11.18l-3.64 3.37a1.74 1.74 0 0 1-1.16.45 1.68 1.68 0 0 1-.69-.15 1.6 1.6 0 0 1-1-1.48V8.63a1.6 1.6 0 0 1 1-1.48 1.7 1.7 0 0 1 1.85.3L16 10.82a1.6 1.6 0 0 1 0 2.36z"/></g></g>', "plus-circle": '<g data-name="Layer 2"><g data-name="plus-circle"><rect width="24" height="24" opacity="0"/><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm3 11h-2v2a1 1 0 0 1-2 0v-2H9a1 1 0 0 1 0-2h2V9a1 1 0 0 1 2 0v2h2a1 1 0 0 1 0 2z"/></g></g>', "plus-square": '<g data-name="Layer 2"><g data-name="plus-square"><rect width="24" height="24" opacity="0"/><path d="M18 3H6a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3V6a3 3 0 0 0-3-3zm-3 10h-2v2a1 1 0 0 1-2 0v-2H9a1 1 0 0 1 0-2h2V9a1 1 0 0 1 2 0v2h2a1 1 0 0 1 0 2z"/></g></g>', "plus": '<g data-name="Layer 2"><g data-name="plus"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M19 11h-6V5a1 1 0 0 0-2 0v6H5a1 1 0 0 0 0 2h6v6a1 1 0 0 0 2 0v-6h6a1 1 0 0 0 0-2z"/></g></g>', "power": '<g data-name="Layer 2"><g data-name="power"><rect width="24" height="24" opacity="0"/><path d="M12 13a1 1 0 0 0 1-1V2a1 1 0 0 0-2 0v10a1 1 0 0 0 1 1z"/><path d="M16.59 3.11a1 1 0 0 0-.92 1.78 8 8 0 1 1-7.34 0 1 1 0 1 0-.92-1.78 10 10 0 1 0 9.18 0z"/></g></g>', "pricetags": '<g data-name="Layer 2"><g data-name="pricetags"><rect width="24" height="24" opacity="0"/><path d="M21.47 11.58l-6.42-6.41a1 1 0 0 0-.61-.29L5.09 4a1 1 0 0 0-.8.29 1 1 0 0 0-.29.8l.88 9.35a1 1 0 0 0 .29.61l6.41 6.42a1.84 1.84 0 0 0 1.29.53 1.82 1.82 0 0 0 1.28-.53l7.32-7.32a1.82 1.82 0 0 0 0-2.57zm-9.91 0a1.5 1.5 0 1 1 0-2.12 1.49 1.49 0 0 1 0 2.1z"/></g></g>', "printer": '<g data-name="Layer 2"><g data-name="printer"><rect width="24" height="24" opacity="0"/><path d="M19.36 7H18V5a1.92 1.92 0 0 0-1.83-2H7.83A1.92 1.92 0 0 0 6 5v2H4.64A2.66 2.66 0 0 0 2 9.67v6.66A2.66 2.66 0 0 0 4.64 19h.86a2 2 0 0 0 2 2h9a2 2 0 0 0 2-2h.86A2.66 2.66 0 0 0 22 16.33V9.67A2.66 2.66 0 0 0 19.36 7zM8 5h8v2H8zm-.5 14v-4h9v4z"/></g></g>', "question-mark-circle": '<g data-name="Layer 2"><g data-name="menu-arrow-circle"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 16a1 1 0 1 1 1-1 1 1 0 0 1-1 1zm1-5.16V14a1 1 0 0 1-2 0v-2a1 1 0 0 1 1-1 1.5 1.5 0 1 0-1.5-1.5 1 1 0 0 1-2 0 3.5 3.5 0 1 1 4.5 3.34z"/></g></g>', "question-mark": '<g data-name="Layer 2"><g data-name="menu-arrow"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M17 9A5 5 0 0 0 7 9a1 1 0 0 0 2 0 3 3 0 1 1 3 3 1 1 0 0 0-1 1v2a1 1 0 0 0 2 0v-1.1A5 5 0 0 0 17 9z"/><circle cx="12" cy="19" r="1"/></g></g>', "radio-button-off": '<g data-name="Layer 2"><g data-name="radio-button-off"><rect width="24" height="24" opacity="0"/><path d="M12 22a10 10 0 1 1 10-10 10 10 0 0 1-10 10zm0-18a8 8 0 1 0 8 8 8 8 0 0 0-8-8z"/></g></g>', "radio-button-on": '<g data-name="Layer 2"><g data-name="radio-button-on"><rect width="24" height="24" opacity="0"/><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 18a8 8 0 1 1 8-8 8 8 0 0 1-8 8z"/><path d="M12 7a5 5 0 1 0 5 5 5 5 0 0 0-5-5z"/></g></g>', "radio": '<g data-name="Layer 2"><g data-name="radio"><rect width="24" height="24" opacity="0"/><path d="M12 8a3 3 0 0 0-1 5.83 1 1 0 0 0 0 .17v6a1 1 0 0 0 2 0v-6a1 1 0 0 0 0-.17A3 3 0 0 0 12 8z"/><path d="M3.5 11a6.87 6.87 0 0 1 2.64-5.23 1 1 0 1 0-1.28-1.54A8.84 8.84 0 0 0 1.5 11a8.84 8.84 0 0 0 3.36 6.77 1 1 0 1 0 1.28-1.54A6.87 6.87 0 0 1 3.5 11z"/><path d="M16.64 6.24a1 1 0 0 0-1.28 1.52A4.28 4.28 0 0 1 17 11a4.28 4.28 0 0 1-1.64 3.24A1 1 0 0 0 16 16a1 1 0 0 0 .64-.24A6.2 6.2 0 0 0 19 11a6.2 6.2 0 0 0-2.36-4.76z"/><path d="M8.76 6.36a1 1 0 0 0-1.4-.12A6.2 6.2 0 0 0 5 11a6.2 6.2 0 0 0 2.36 4.76 1 1 0 0 0 1.4-.12 1 1 0 0 0-.12-1.4A4.28 4.28 0 0 1 7 11a4.28 4.28 0 0 1 1.64-3.24 1 1 0 0 0 .12-1.4z"/><path d="M19.14 4.23a1 1 0 1 0-1.28 1.54A6.87 6.87 0 0 1 20.5 11a6.87 6.87 0 0 1-2.64 5.23 1 1 0 0 0 1.28 1.54A8.84 8.84 0 0 0 22.5 11a8.84 8.84 0 0 0-3.36-6.77z"/></g></g>', "recording": '<g data-name="Layer 2"><g data-name="recording"><rect width="24" height="24" opacity="0"/><path d="M18 8a4 4 0 0 0-4 4 3.91 3.91 0 0 0 .56 2H9.44a3.91 3.91 0 0 0 .56-2 4 4 0 1 0-4 4h12a4 4 0 0 0 0-8z"/></g></g>', "refresh": '<g data-name="Layer 2"><g data-name="refresh"><rect width="24" height="24" opacity="0"/><path d="M20.3 13.43a1 1 0 0 0-1.25.65A7.14 7.14 0 0 1 12.18 19 7.1 7.1 0 0 1 5 12a7.1 7.1 0 0 1 7.18-7 7.26 7.26 0 0 1 4.65 1.67l-2.17-.36a1 1 0 0 0-1.15.83 1 1 0 0 0 .83 1.15l4.24.7h.17a1 1 0 0 0 .34-.06.33.33 0 0 0 .1-.06.78.78 0 0 0 .2-.11l.09-.11c0-.05.09-.09.13-.15s0-.1.05-.14a1.34 1.34 0 0 0 .07-.18l.75-4a1 1 0 0 0-2-.38l-.27 1.45A9.21 9.21 0 0 0 12.18 3 9.1 9.1 0 0 0 3 12a9.1 9.1 0 0 0 9.18 9A9.12 9.12 0 0 0 21 14.68a1 1 0 0 0-.7-1.25z"/></g></g>', "repeat": '<g data-name="Layer 2"><g data-name="repeat"><rect width="24" height="24" opacity="0"/><path d="M17.91 5h-12l1.3-1.29a1 1 0 0 0-1.42-1.42l-3 3a1 1 0 0 0 0 1.42l3 3a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42L5.91 7h12a1.56 1.56 0 0 1 1.59 1.53V11a1 1 0 0 0 2 0V8.53A3.56 3.56 0 0 0 17.91 5z"/><path d="M18.21 14.29a1 1 0 0 0-1.42 1.42l1.3 1.29h-12a1.56 1.56 0 0 1-1.59-1.53V13a1 1 0 0 0-2 0v2.47A3.56 3.56 0 0 0 6.09 19h12l-1.3 1.29a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0l3-3a1 1 0 0 0 0-1.42z"/></g></g>', "rewind-left": '<g data-name="Layer 2"><g data-name="rewind-left"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M18.45 6.2a2.1 2.1 0 0 0-2.21.26l-4.74 3.92V7.79a1.76 1.76 0 0 0-1.05-1.59 2.1 2.1 0 0 0-2.21.26l-5.1 4.21a1.7 1.7 0 0 0 0 2.66l5.1 4.21a2.06 2.06 0 0 0 1.3.46 2.23 2.23 0 0 0 .91-.2 1.76 1.76 0 0 0 1.05-1.59v-2.59l4.74 3.92a2.06 2.06 0 0 0 1.3.46 2.23 2.23 0 0 0 .91-.2 1.76 1.76 0 0 0 1.05-1.59V7.79a1.76 1.76 0 0 0-1.05-1.59z"/></g></g>', "rewind-right": '<g data-name="Layer 2"><g data-name="rewind-right"><rect width="24" height="24" opacity="0"/><path d="M20.86 10.67l-5.1-4.21a2.1 2.1 0 0 0-2.21-.26 1.76 1.76 0 0 0-1.05 1.59v2.59L7.76 6.46a2.1 2.1 0 0 0-2.21-.26 1.76 1.76 0 0 0-1 1.59v8.42a1.76 1.76 0 0 0 1 1.59 2.23 2.23 0 0 0 .91.2 2.06 2.06 0 0 0 1.3-.46l4.74-3.92v2.59a1.76 1.76 0 0 0 1.05 1.59 2.23 2.23 0 0 0 .91.2 2.06 2.06 0 0 0 1.3-.46l5.1-4.21a1.7 1.7 0 0 0 0-2.66z"/></g></g>', "save": '<g data-name="Layer 2"><g data-name="save"><rect width="24" height="24" opacity="0"/><rect x="10" y="17" width="4" height="4"/><path d="M20.12 8.71l-4.83-4.83A3 3 0 0 0 13.17 3H10v6h5a1 1 0 0 1 0 2H9a1 1 0 0 1-1-1V3H6a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h2v-4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v4h2a3 3 0 0 0 3-3v-7.17a3 3 0 0 0-.88-2.12z"/></g></g>', "scissors": '<g data-name="Layer 2"><g data-name="scissors"><rect width="24" height="24" opacity="0"/><path d="M20.21 5.71a1 1 0 1 0-1.42-1.42l-6.28 6.31-3.3-3.31A3 3 0 0 0 9.5 6a3 3 0 1 0-3 3 3 3 0 0 0 1.29-.3L11.1 12l-3.29 3.3A3 3 0 0 0 6.5 15a3 3 0 1 0 3 3 3 3 0 0 0-.29-1.26zM6.5 7a1 1 0 1 1 1-1 1 1 0 0 1-1 1zm0 12a1 1 0 1 1 1-1 1 1 0 0 1-1 1z"/><path d="M15.21 13.29a1 1 0 0 0-1.42 1.42l5 5a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42z"/></g></g>', "search": '<g data-name="Layer 2"><g data-name="search"><rect width="24" height="24" opacity="0"/><path d="M20.71 19.29l-3.4-3.39A7.92 7.92 0 0 0 19 11a8 8 0 1 0-8 8 7.92 7.92 0 0 0 4.9-1.69l3.39 3.4a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42zM5 11a6 6 0 1 1 6 6 6 6 0 0 1-6-6z"/></g></g>', "settings-2": '<g data-name="Layer 2"><g data-name="settings-2"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><circle cx="12" cy="12" r="1.5"/><path d="M20.32 9.37h-1.09c-.14 0-.24-.11-.3-.26a.34.34 0 0 1 0-.37l.81-.74a1.63 1.63 0 0 0 .5-1.18 1.67 1.67 0 0 0-.5-1.19L18.4 4.26a1.67 1.67 0 0 0-2.37 0l-.77.74a.38.38 0 0 1-.41 0 .34.34 0 0 1-.22-.29V3.68A1.68 1.68 0 0 0 13 2h-1.94a1.69 1.69 0 0 0-1.69 1.68v1.09c0 .14-.11.24-.26.3a.34.34 0 0 1-.37 0L8 4.26a1.72 1.72 0 0 0-1.19-.5 1.65 1.65 0 0 0-1.18.5L4.26 5.6a1.67 1.67 0 0 0 0 2.4l.74.74a.38.38 0 0 1 0 .41.34.34 0 0 1-.29.22H3.68A1.68 1.68 0 0 0 2 11.05v1.89a1.69 1.69 0 0 0 1.68 1.69h1.09c.14 0 .24.11.3.26a.34.34 0 0 1 0 .37l-.81.74a1.72 1.72 0 0 0-.5 1.19 1.66 1.66 0 0 0 .5 1.19l1.34 1.36a1.67 1.67 0 0 0 2.37 0l.77-.74a.38.38 0 0 1 .41 0 .34.34 0 0 1 .22.29v1.09A1.68 1.68 0 0 0 11.05 22h1.89a1.69 1.69 0 0 0 1.69-1.68v-1.09c0-.14.11-.24.26-.3a.34.34 0 0 1 .37 0l.76.77a1.72 1.72 0 0 0 1.19.5 1.65 1.65 0 0 0 1.18-.5l1.34-1.34a1.67 1.67 0 0 0 0-2.37l-.73-.73a.34.34 0 0 1 0-.37.34.34 0 0 1 .29-.22h1.09A1.68 1.68 0 0 0 22 13v-1.94a1.69 1.69 0 0 0-1.68-1.69zM12 15.5a3.5 3.5 0 1 1 3.5-3.5 3.5 3.5 0 0 1-3.5 3.5z"/></g></g>', "settings": '<g data-name="Layer 2"><g data-name="settings"><rect width="24" height="24" opacity="0"/><circle cx="12" cy="12" r="1.5"/><path d="M21.89 10.32L21.1 7.8a2.26 2.26 0 0 0-2.88-1.51l-.34.11a1.74 1.74 0 0 1-1.59-.26l-.11-.08a1.76 1.76 0 0 1-.69-1.43v-.28a2.37 2.37 0 0 0-.68-1.68 2.26 2.26 0 0 0-1.6-.67h-2.55a2.32 2.32 0 0 0-2.29 2.33v.24a1.94 1.94 0 0 1-.73 1.51l-.13.1a1.93 1.93 0 0 1-1.78.29 2.14 2.14 0 0 0-1.68.12 2.18 2.18 0 0 0-1.12 1.33l-.82 2.6a2.34 2.34 0 0 0 1.48 2.94h.16a1.83 1.83 0 0 1 1.12 1.22l.06.16a2.06 2.06 0 0 1-.23 1.86 2.37 2.37 0 0 0 .49 3.3l2.07 1.57a2.25 2.25 0 0 0 1.35.43A2 2 0 0 0 9 22a2.25 2.25 0 0 0 1.47-1l.23-.33a1.8 1.8 0 0 1 1.43-.77 1.75 1.75 0 0 1 1.5.78l.12.17a2.24 2.24 0 0 0 3.22.53L19 19.86a2.38 2.38 0 0 0 .5-3.23l-.26-.38A2 2 0 0 1 19 14.6a1.89 1.89 0 0 1 1.21-1.28l.2-.07a2.36 2.36 0 0 0 1.48-2.93zM12 15.5a3.5 3.5 0 1 1 3.5-3.5 3.5 3.5 0 0 1-3.5 3.5z"/></g></g>', "shake": '<g data-name="Layer 2"><g data-name="shake"><rect width="24" height="24" opacity="0"/><path d="M5.5 18a1 1 0 0 1-.64-.24A8.81 8.81 0 0 1 1.5 11a8.81 8.81 0 0 1 3.36-6.76 1 1 0 1 1 1.28 1.52A6.9 6.9 0 0 0 3.5 11a6.9 6.9 0 0 0 2.64 5.24 1 1 0 0 1 .13 1.4 1 1 0 0 1-.77.36z"/><path d="M12 7a4.09 4.09 0 0 1 1 .14V3a1 1 0 0 0-2 0v4.14A4.09 4.09 0 0 1 12 7z"/><path d="M12 15a4.09 4.09 0 0 1-1-.14V20a1 1 0 0 0 2 0v-5.14a4.09 4.09 0 0 1-1 .14z"/><path d="M16 16a1 1 0 0 1-.77-.36 1 1 0 0 1 .13-1.4A4.28 4.28 0 0 0 17 11a4.28 4.28 0 0 0-1.64-3.24 1 1 0 1 1 1.28-1.52A6.2 6.2 0 0 1 19 11a6.2 6.2 0 0 1-2.36 4.76A1 1 0 0 1 16 16z"/><path d="M8 16a1 1 0 0 1-.64-.24A6.2 6.2 0 0 1 5 11a6.2 6.2 0 0 1 2.36-4.76 1 1 0 1 1 1.28 1.52A4.28 4.28 0 0 0 7 11a4.28 4.28 0 0 0 1.64 3.24 1 1 0 0 1 .13 1.4A1 1 0 0 1 8 16z"/><path d="M18.5 18a1 1 0 0 1-.77-.36 1 1 0 0 1 .13-1.4A6.9 6.9 0 0 0 20.5 11a6.9 6.9 0 0 0-2.64-5.24 1 1 0 1 1 1.28-1.52A8.81 8.81 0 0 1 22.5 11a8.81 8.81 0 0 1-3.36 6.76 1 1 0 0 1-.64.24z"/><path d="M12 12a1 1 0 1 1 1-1 1 1 0 0 1-1 1zm0-1zm0 0zm0 0zm0 0zm0 0zm0 0zm0 0z"/></g></g>', "share": '<g data-name="Layer 2"><g data-name="share"><rect width="24" height="24" opacity="0"/><path d="M18 15a3 3 0 0 0-2.1.86L8 12.34V12v-.33l7.9-3.53A3 3 0 1 0 15 6v.34L7.1 9.86a3 3 0 1 0 0 4.28l7.9 3.53V18a3 3 0 1 0 3-3z"/></g></g>', "shield-off": '<g data-name="Layer 2"><g data-name="shield-off"><rect width="24" height="24" opacity="0"/><path d="M3.73 6.56A2 2 0 0 0 3 8.09v.14a15.17 15.17 0 0 0 7.72 13.2l.3.17a2 2 0 0 0 2 0l.3-.17a15.22 15.22 0 0 0 3-2.27z"/><path d="M18.84 16A15.08 15.08 0 0 0 21 8.23v-.14a2 2 0 0 0-1-1.75L13 2.4a2 2 0 0 0-2 0L7.32 4.49z"/><path d="M4.71 3.29a1 1 0 0 0-1.42 1.42l16 16a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42z"/></g></g>', "shield": '<g data-name="Layer 2"><g data-name="shield"><rect width="24" height="24" opacity="0"/><path d="M12 21.85a2 2 0 0 1-1-.25l-.3-.17A15.17 15.17 0 0 1 3 8.23v-.14a2 2 0 0 1 1-1.75l7-3.94a2 2 0 0 1 2 0l7 3.94a2 2 0 0 1 1 1.75v.14a15.17 15.17 0 0 1-7.72 13.2l-.3.17a2 2 0 0 1-.98.25z"/></g></g>', "shopping-bag": '<g data-name="Layer 2"><g data-name="shopping-bag"><rect width="24" height="24" opacity="0"/><path d="M20.12 6.71l-2.83-2.83A3 3 0 0 0 15.17 3H8.83a3 3 0 0 0-2.12.88L3.88 6.71A3 3 0 0 0 3 8.83V18a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3V8.83a3 3 0 0 0-.88-2.12zM12 16a4 4 0 0 1-4-4 1 1 0 0 1 2 0 2 2 0 0 0 4 0 1 1 0 0 1 2 0 4 4 0 0 1-4 4zM6.41 7l1.71-1.71A1.05 1.05 0 0 1 8.83 5h6.34a1.05 1.05 0 0 1 .71.29L17.59 7z"/></g></g>', "shopping-cart": '<g data-name="Layer 2"><g data-name="shopping-cart"><rect width="24" height="24" opacity="0"/><path d="M21.08 7a2 2 0 0 0-1.7-1H6.58L6 3.74A1 1 0 0 0 5 3H3a1 1 0 0 0 0 2h1.24L7 15.26A1 1 0 0 0 8 16h9a1 1 0 0 0 .89-.55l3.28-6.56A2 2 0 0 0 21.08 7z"/><circle cx="7.5" cy="19.5" r="1.5"/><circle cx="17.5" cy="19.5" r="1.5"/></g></g>', "shuffle-2": '<g data-name="Layer 2"><g data-name="shuffle-2"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M18.71 14.29a1 1 0 0 0-1.42 1.42l.29.29H16a4 4 0 0 1 0-8h1.59l-.3.29a1 1 0 0 0 0 1.42A1 1 0 0 0 18 10a1 1 0 0 0 .71-.29l2-2A1 1 0 0 0 21 7a1 1 0 0 0-.29-.71l-2-2a1 1 0 0 0-1.42 1.42l.29.29H16a6 6 0 0 0-5 2.69A6 6 0 0 0 6 6H4a1 1 0 0 0 0 2h2a4 4 0 0 1 0 8H4a1 1 0 0 0 0 2h2a6 6 0 0 0 5-2.69A6 6 0 0 0 16 18h1.59l-.3.29a1 1 0 0 0 0 1.42A1 1 0 0 0 18 20a1 1 0 0 0 .71-.29l2-2A1 1 0 0 0 21 17a1 1 0 0 0-.29-.71z"/></g></g>', "shuffle": '<g data-name="Layer 2"><g data-name="shuffle"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M18 9.31a1 1 0 0 0 1 1 1 1 0 0 0 1-1V5a1 1 0 0 0-1-1h-4.3a1 1 0 0 0-1 1 1 1 0 0 0 1 1h1.89L12 10.59 6.16 4.76a1 1 0 0 0-1.41 1.41L10.58 12l-6.29 6.29a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0L18 7.42z"/><path d="M19 13.68a1 1 0 0 0-1 1v1.91l-2.78-2.79a1 1 0 0 0-1.42 1.42L16.57 18h-1.88a1 1 0 0 0 0 2H19a1 1 0 0 0 1-1.11v-4.21a1 1 0 0 0-1-1z"/></g></g>', "skip-back": '<g data-name="Layer 2"><g data-name="skip-back"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M16.45 6.2a2.1 2.1 0 0 0-2.21.26l-5.1 4.21-.14.15V7a1 1 0 0 0-2 0v10a1 1 0 0 0 2 0v-3.82l.14.15 5.1 4.21a2.06 2.06 0 0 0 1.3.46 2.23 2.23 0 0 0 .91-.2 1.76 1.76 0 0 0 1.05-1.59V7.79a1.76 1.76 0 0 0-1.05-1.59z"/></g></g>', "skip-forward": '<g data-name="Layer 2"><g data-name="skip-forward"><rect width="24" height="24" opacity="0"/><path d="M16 6a1 1 0 0 0-1 1v3.82l-.14-.15-5.1-4.21a2.1 2.1 0 0 0-2.21-.26 1.76 1.76 0 0 0-1 1.59v8.42a1.76 1.76 0 0 0 1 1.59 2.23 2.23 0 0 0 .91.2 2.06 2.06 0 0 0 1.3-.46l5.1-4.21.14-.15V17a1 1 0 0 0 2 0V7a1 1 0 0 0-1-1z"/></g></g>', "slash": '<g data-name="Layer 2"><g data-name="slash"><rect width="24" height="24" opacity="0"/><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm8 10a7.92 7.92 0 0 1-1.69 4.9L7.1 5.69A7.92 7.92 0 0 1 12 4a8 8 0 0 1 8 8zM4 12a7.92 7.92 0 0 1 1.69-4.9L16.9 18.31A7.92 7.92 0 0 1 12 20a8 8 0 0 1-8-8z"/></g></g>', "smartphone": '<g data-name="Layer 2"><g data-name="smartphone"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M17 2H7a3 3 0 0 0-3 3v14a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3V5a3 3 0 0 0-3-3zm-5 16a1.5 1.5 0 1 1 1.5-1.5A1.5 1.5 0 0 1 12 18zm2.5-10h-5a1 1 0 0 1 0-2h5a1 1 0 0 1 0 2z"/></g></g>', "smiling-face": '<defs><style/></defs><g id="Layer_2" data-name="Layer 2"><g id="smiling-face"><g id="smiling-face" data-name="smiling-face"><rect width="24" height="24" opacity="0"/><path d="M12 2c5.523 0 10 4.477 10 10s-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2zm0 2a8 8 0 1 0 0 16 8 8 0 0 0 0-16zm5 9a5 5 0 0 1-10 0z" id="&#x1F3A8;-Icon-&#x421;olor"/></g></g></g>', "speaker": '<g data-name="Layer 2"><g data-name="speaker"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><circle cx="12" cy="15.5" r="1.5"/><circle cx="12" cy="8" r="1"/><path d="M17 2H7a3 3 0 0 0-3 3v14a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3V5a3 3 0 0 0-3-3zm-5 3a3 3 0 1 1-3 3 3 3 0 0 1 3-3zm0 14a3.5 3.5 0 1 1 3.5-3.5A3.5 3.5 0 0 1 12 19z"/></g></g>', "square": '<g data-name="Layer 2"><g data-name="square"><rect width="24" height="24" opacity="0"/><path d="M18 21H6a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3h12a3 3 0 0 1 3 3v12a3 3 0 0 1-3 3zM6 5a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1z"/></g></g>', "star": '<g data-name="Layer 2"><g data-name="star"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M17.56 21a1 1 0 0 1-.46-.11L12 18.22l-5.1 2.67a1 1 0 0 1-1.45-1.06l1-5.63-4.12-4a1 1 0 0 1-.25-1 1 1 0 0 1 .81-.68l5.7-.83 2.51-5.13a1 1 0 0 1 1.8 0l2.54 5.12 5.7.83a1 1 0 0 1 .81.68 1 1 0 0 1-.25 1l-4.12 4 1 5.63a1 1 0 0 1-.4 1 1 1 0 0 1-.62.18z"/></g></g>', "stop-circle": '<g data-name="Layer 2"><g data-name="stop-circle"><rect width="24" height="24" opacity="0"/><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm4 12.75A1.25 1.25 0 0 1 14.75 16h-5.5A1.25 1.25 0 0 1 8 14.75v-5.5A1.25 1.25 0 0 1 9.25 8h5.5A1.25 1.25 0 0 1 16 9.25z"/><rect x="10" y="10" width="4" height="4"/></g></g>', "sun": '<g data-name="Layer 2"><g data-name="sun"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M12 6a1 1 0 0 0 1-1V3a1 1 0 0 0-2 0v2a1 1 0 0 0 1 1z"/><path d="M21 11h-2a1 1 0 0 0 0 2h2a1 1 0 0 0 0-2z"/><path d="M6 12a1 1 0 0 0-1-1H3a1 1 0 0 0 0 2h2a1 1 0 0 0 1-1z"/><path d="M6.22 5a1 1 0 0 0-1.39 1.47l1.44 1.39a1 1 0 0 0 .73.28 1 1 0 0 0 .72-.31 1 1 0 0 0 0-1.41z"/><path d="M17 8.14a1 1 0 0 0 .69-.28l1.44-1.39A1 1 0 0 0 17.78 5l-1.44 1.42a1 1 0 0 0 0 1.41 1 1 0 0 0 .66.31z"/><path d="M12 18a1 1 0 0 0-1 1v2a1 1 0 0 0 2 0v-2a1 1 0 0 0-1-1z"/><path d="M17.73 16.14a1 1 0 0 0-1.39 1.44L17.78 19a1 1 0 0 0 .69.28 1 1 0 0 0 .72-.3 1 1 0 0 0 0-1.42z"/><path d="M6.27 16.14l-1.44 1.39a1 1 0 0 0 0 1.42 1 1 0 0 0 .72.3 1 1 0 0 0 .67-.25l1.44-1.39a1 1 0 0 0-1.39-1.44z"/><path d="M12 8a4 4 0 1 0 4 4 4 4 0 0 0-4-4z"/></g></g>', "swap": '<g data-name="Layer 2"><g data-name="swap"><rect width="24" height="24" transform="rotate(-90 12 12)" opacity="0"/><path d="M4 9h13l-1.6 1.2a1 1 0 0 0-.2 1.4 1 1 0 0 0 .8.4 1 1 0 0 0 .6-.2l4-3a1 1 0 0 0 0-1.59l-3.86-3a1 1 0 0 0-1.23 1.58L17.08 7H4a1 1 0 0 0 0 2z"/><path d="M20 16H7l1.6-1.2a1 1 0 0 0-1.2-1.6l-4 3a1 1 0 0 0 0 1.59l3.86 3a1 1 0 0 0 .61.21 1 1 0 0 0 .79-.39 1 1 0 0 0-.17-1.4L6.92 18H20a1 1 0 0 0 0-2z"/></g></g>', "sync": '<g data-name="Layer 2"><g data-name="sync"><rect width="24" height="24" opacity="0"/><path d="M21.66 10.37a.62.62 0 0 0 .07-.19l.75-4a1 1 0 0 0-2-.36l-.37 2a9.22 9.22 0 0 0-16.58.84 1 1 0 0 0 .55 1.3 1 1 0 0 0 1.31-.55A7.08 7.08 0 0 1 12.07 5a7.17 7.17 0 0 1 6.24 3.58l-1.65-.27a1 1 0 1 0-.32 2l4.25.71h.16a.93.93 0 0 0 .34-.06.33.33 0 0 0 .1-.06.78.78 0 0 0 .2-.11l.08-.1a1.07 1.07 0 0 0 .14-.16.58.58 0 0 0 .05-.16z"/><path d="M19.88 14.07a1 1 0 0 0-1.31.56A7.08 7.08 0 0 1 11.93 19a7.17 7.17 0 0 1-6.24-3.58l1.65.27h.16a1 1 0 0 0 .16-2L3.41 13a.91.91 0 0 0-.33 0H3a1.15 1.15 0 0 0-.32.14 1 1 0 0 0-.18.18l-.09.1a.84.84 0 0 0-.07.19.44.44 0 0 0-.07.17l-.75 4a1 1 0 0 0 .8 1.22h.18a1 1 0 0 0 1-.82l.37-2a9.22 9.22 0 0 0 16.58-.83 1 1 0 0 0-.57-1.28z"/></g></g>', "text": '<g data-name="Layer 2"><g data-name="text"><rect width="24" height="24" opacity="0"/><path d="M20 4H4a1 1 0 0 0-1 1v3a1 1 0 0 0 2 0V6h6v13H9a1 1 0 0 0 0 2h6a1 1 0 0 0 0-2h-2V6h6v2a1 1 0 0 0 2 0V5a1 1 0 0 0-1-1z"/></g></g>', "thermometer-minus": '<g data-name="Layer 2"><g data-name="thermometer-minus"><rect width="24" height="24" opacity="0"/><rect x="2" y="5" width="6" height="2" rx="1" ry="1"/><path d="M14 22a5 5 0 0 1-3-9V5a3 3 0 0 1 3-3 3 3 0 0 1 3 3v8a5 5 0 0 1-3 9zm1-12.46V5a.93.93 0 0 0-.29-.69A1 1 0 0 0 14 4a1 1 0 0 0-1 1v4.54z"/></g></g>', "thermometer-plus": '<g data-name="Layer 2"><g data-name="thermometer-plus"><rect width="24" height="24" opacity="0"/><rect x="2" y="5" width="6" height="2" rx="1" ry="1"/><rect x="2" y="5" width="6" height="2" rx="1" ry="1" transform="rotate(-90 5 6)"/><path d="M14 22a5 5 0 0 1-3-9V5a3 3 0 0 1 3-3 3 3 0 0 1 3 3v8a5 5 0 0 1-3 9zm1-12.46V5a.93.93 0 0 0-.29-.69A1 1 0 0 0 14 4a1 1 0 0 0-1 1v4.54z"/></g></g>', "thermometer": '<g data-name="Layer 2"><g data-name="thermometer"><rect width="24" height="24" opacity="0"/><path d="M12 22a5 5 0 0 1-3-9V5a3 3 0 0 1 3-3 3 3 0 0 1 3 3v8a5 5 0 0 1-3 9zm1-12.46V5a.93.93 0 0 0-.29-.69A1 1 0 0 0 12 4a1 1 0 0 0-1 1v4.54z"/></g></g>', "toggle-left": '<g data-name="Layer 2"><g data-name="toggle-left"><rect x=".02" y=".02" width="23.97" height="23.97" transform="rotate(179.92 12.002 11.998)" opacity="0"/><path d="M15 5H9a7 7 0 0 0 0 14h6a7 7 0 0 0 0-14zM9 15a3 3 0 1 1 3-3 3 3 0 0 1-3 3z"/><path d="M9 11a1 1 0 1 0 0 2 1 1 0 0 0 0-2z"/></g></g>', "toggle-right": '<g data-name="Layer 2"><g data-name="toggle-right"><rect width="24" height="24" opacity="0"/><circle cx="15" cy="12" r="1"/><path d="M15 5H9a7 7 0 0 0 0 14h6a7 7 0 0 0 0-14zm0 10a3 3 0 1 1 3-3 3 3 0 0 1-3 3z"/></g></g>', "trash-2": '<g data-name="Layer 2"><g data-name="trash-2"><rect width="24" height="24" opacity="0"/><path d="M21 6h-5V4.33A2.42 2.42 0 0 0 13.5 2h-3A2.42 2.42 0 0 0 8 4.33V6H3a1 1 0 0 0 0 2h1v11a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3V8h1a1 1 0 0 0 0-2zM10 16a1 1 0 0 1-2 0v-4a1 1 0 0 1 2 0zm0-11.67c0-.16.21-.33.5-.33h3c.29 0 .5.17.5.33V6h-4zM16 16a1 1 0 0 1-2 0v-4a1 1 0 0 1 2 0z"/></g></g>', "trash": '<g data-name="Layer 2"><g data-name="trash"><rect width="24" height="24" opacity="0"/><path d="M21 6h-5V4.33A2.42 2.42 0 0 0 13.5 2h-3A2.42 2.42 0 0 0 8 4.33V6H3a1 1 0 0 0 0 2h1v11a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3V8h1a1 1 0 0 0 0-2zM10 4.33c0-.16.21-.33.5-.33h3c.29 0 .5.17.5.33V6h-4z"/></g></g>', "trending-down": '<g data-name="Layer 2"><g data-name="trending-down"><rect width="24" height="24" transform="rotate(-90 12 12)" opacity="0"/><path d="M21 12a1 1 0 0 0-2 0v2.3l-4.24-5a1 1 0 0 0-1.27-.21L9.22 11.7 4.77 6.36a1 1 0 1 0-1.54 1.28l5 6a1 1 0 0 0 1.28.22l4.28-2.57 4 4.71H15a1 1 0 0 0 0 2h5a1.1 1.1 0 0 0 .36-.07l.14-.08a1.19 1.19 0 0 0 .15-.09.75.75 0 0 0 .14-.17 1.1 1.1 0 0 0 .09-.14.64.64 0 0 0 .05-.17A.78.78 0 0 0 21 17z"/></g></g>', "trending-up": '<g data-name="Layer 2"><g data-name="trending-up"><rect width="24" height="24" transform="rotate(-90 12 12)" opacity="0"/><path d="M21 7a.78.78 0 0 0 0-.21.64.64 0 0 0-.05-.17 1.1 1.1 0 0 0-.09-.14.75.75 0 0 0-.14-.17l-.12-.07a.69.69 0 0 0-.19-.1h-.2A.7.7 0 0 0 20 6h-5a1 1 0 0 0 0 2h2.83l-4 4.71-4.32-2.57a1 1 0 0 0-1.28.22l-5 6a1 1 0 0 0 .13 1.41A1 1 0 0 0 4 18a1 1 0 0 0 .77-.36l4.45-5.34 4.27 2.56a1 1 0 0 0 1.27-.21L19 9.7V12a1 1 0 0 0 2 0V7z"/></g></g>', "tv": '<g data-name="Layer 2"><g data-name="tv"><rect width="24" height="24" opacity="0"/><path d="M18 6h-3.59l2.3-2.29a1 1 0 1 0-1.42-1.42L12 5.59l-3.29-3.3a1 1 0 1 0-1.42 1.42L9.59 6H6a3 3 0 0 0-3 3v10a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3V9a3 3 0 0 0-3-3zm1 13a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1v-7a1 1 0 0 1 1-1h12a1 1 0 0 1 1 1z"/></g></g>', "twitter": '<g data-name="Layer 2"><g data-name="twitter"><polyline points="0 0 24 0 24 24 0 24" opacity="0"/><path d="M8.08 20A11.07 11.07 0 0 0 19.52 9 8.09 8.09 0 0 0 21 6.16a.44.44 0 0 0-.62-.51 1.88 1.88 0 0 1-2.16-.38 3.89 3.89 0 0 0-5.58-.17A4.13 4.13 0 0 0 11.49 9C8.14 9.2 5.84 7.61 4 5.43a.43.43 0 0 0-.75.24 9.68 9.68 0 0 0 4.6 10.05A6.73 6.73 0 0 1 3.38 18a.45.45 0 0 0-.14.84A11 11 0 0 0 8.08 20"/></g></g>', "umbrella": '<g data-name="Layer 2"><g data-name="umbrella"><rect width="24" height="24" opacity="0"/><path d="M12 2A10 10 0 0 0 2 12a1 1 0 0 0 1 1h8v6a3 3 0 0 0 6 0 1 1 0 0 0-2 0 1 1 0 0 1-2 0v-6h8a1 1 0 0 0 1-1A10 10 0 0 0 12 2z"/></g></g>', "undo": '<g data-name="Layer 2"><g data-name="undo"><rect width="24" height="24" transform="rotate(-90 12 12)" opacity="0"/><path d="M20.22 21a1 1 0 0 1-1-.76 8.91 8.91 0 0 0-7.8-6.69v1.12a1.78 1.78 0 0 1-1.09 1.64A2 2 0 0 1 8.18 16l-5.06-4.41a1.76 1.76 0 0 1 0-2.68l5.06-4.42a2 2 0 0 1 2.18-.3 1.78 1.78 0 0 1 1.09 1.64V7A10.89 10.89 0 0 1 21.5 17.75a10.29 10.29 0 0 1-.31 2.49 1 1 0 0 1-1 .76z"/></g></g>', "unlock": '<g data-name="Layer 2"><g data-name="unlock"><rect width="24" height="24" opacity="0"/><circle cx="12" cy="15" r="1"/><path d="M17 8h-7V6a2 2 0 0 1 4 0 1 1 0 0 0 2 0 4 4 0 0 0-8 0v2H7a3 3 0 0 0-3 3v8a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3v-8a3 3 0 0 0-3-3zm-5 10a3 3 0 1 1 3-3 3 3 0 0 1-3 3z"/></g></g>', "upload": '<g data-name="Layer 2"><g data-name="upload"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><rect x="4" y="4" width="16" height="2" rx="1" ry="1" transform="rotate(180 12 5)"/><rect x="17" y="5" width="4" height="2" rx="1" ry="1" transform="rotate(90 19 6)"/><rect x="3" y="5" width="4" height="2" rx="1" ry="1" transform="rotate(90 5 6)"/><path d="M8 14a1 1 0 0 1-.8-.4 1 1 0 0 1 .2-1.4l4-3a1 1 0 0 1 1.18 0l4 2.82a1 1 0 0 1 .24 1.39 1 1 0 0 1-1.4.24L12 11.24 8.6 13.8a1 1 0 0 1-.6.2z"/><path d="M12 21a1 1 0 0 1-1-1v-8a1 1 0 0 1 2 0v8a1 1 0 0 1-1 1z"/></g></g>', "video-off": '<g data-name="Layer 2"><g data-name="video-off"><rect width="24" height="24" opacity="0"/><path d="M14.22 17.05L4.88 7.71 3.12 6 3 5.8A3 3 0 0 0 2 8v8a3 3 0 0 0 3 3h9a2.94 2.94 0 0 0 1.66-.51z"/><path d="M21 7.15a1.7 1.7 0 0 0-1.85.3l-2.15 2V8a3 3 0 0 0-3-3H7.83l1.29 1.29 6.59 6.59 2 2 2 2a1.73 1.73 0 0 0 .6.11 1.68 1.68 0 0 0 .69-.15 1.6 1.6 0 0 0 1-1.48V8.63a1.6 1.6 0 0 0-1-1.48z"/><path d="M17 15.59l-2-2L8.41 7l-2-2-1.7-1.71a1 1 0 0 0-1.42 1.42l.54.53L5.59 7l9.34 9.34 1.46 1.46 2.9 2.91a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42z"/></g></g>', "video": '<g data-name="Layer 2"><g data-name="video"><rect width="24" height="24" opacity="0"/><path d="M21 7.15a1.7 1.7 0 0 0-1.85.3l-2.15 2V8a3 3 0 0 0-3-3H5a3 3 0 0 0-3 3v8a3 3 0 0 0 3 3h9a3 3 0 0 0 3-3v-1.45l2.16 2a1.74 1.74 0 0 0 1.16.45 1.68 1.68 0 0 0 .69-.15 1.6 1.6 0 0 0 1-1.48V8.63A1.6 1.6 0 0 0 21 7.15z"/></g></g>', "volume-down": '<g data-name="Layer 2"><g data-name="volume-down"><rect width="24" height="24" opacity="0"/><path d="M20.78 8.37a1 1 0 1 0-1.56 1.26 4 4 0 0 1 0 4.74A1 1 0 0 0 20 16a1 1 0 0 0 .78-.37 6 6 0 0 0 0-7.26z"/><path d="M16.47 3.12a1 1 0 0 0-1 0L9 7.57H4a1 1 0 0 0-1 1v6.86a1 1 0 0 0 1 1h5l6.41 4.4A1.06 1.06 0 0 0 16 21a1 1 0 0 0 1-1V4a1 1 0 0 0-.53-.88z"/></g></g>', "volume-mute": '<g data-name="Layer 2"><g data-name="volume-mute"><rect width="24" height="24" opacity="0"/><path d="M17 21a1.06 1.06 0 0 1-.57-.17L10 16.43H5a1 1 0 0 1-1-1V8.57a1 1 0 0 1 1-1h5l6.41-4.4A1 1 0 0 1 18 4v16a1 1 0 0 1-1 1z"/></g></g>', "volume-off": '<g data-name="Layer 2"><g data-name="volume-off"><rect width="24" height="24" opacity="0"/><path d="M16.91 14.08l1.44 1.44a6 6 0 0 0-.07-7.15 1 1 0 1 0-1.56 1.26 4 4 0 0 1 .19 4.45z"/><path d="M21 12a6.51 6.51 0 0 1-1.78 4.39l1.42 1.42A8.53 8.53 0 0 0 23 12a8.75 8.75 0 0 0-3.36-6.77 1 1 0 1 0-1.28 1.54A6.8 6.8 0 0 1 21 12z"/><path d="M15 12.17V4a1 1 0 0 0-1.57-.83L9 6.2z"/><path d="M4.74 7.57H2a1 1 0 0 0-1 1v6.86a1 1 0 0 0 1 1h5l6.41 4.4A1.06 1.06 0 0 0 14 21a1 1 0 0 0 1-1v-2.17z"/><path d="M4.71 3.29a1 1 0 0 0-1.42 1.42l16 16a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42z"/></g></g>', "volume-up": '<g data-name="Layer 2"><g data-name="volume-up"><rect width="24" height="24" opacity="0"/><path d="M18.28 8.37a1 1 0 1 0-1.56 1.26 4 4 0 0 1 0 4.74A1 1 0 0 0 17.5 16a1 1 0 0 0 .78-.37 6 6 0 0 0 0-7.26z"/><path d="M19.64 5.23a1 1 0 1 0-1.28 1.54A6.8 6.8 0 0 1 21 12a6.8 6.8 0 0 1-2.64 5.23 1 1 0 0 0-.13 1.41A1 1 0 0 0 19 19a1 1 0 0 0 .64-.23A8.75 8.75 0 0 0 23 12a8.75 8.75 0 0 0-3.36-6.77z"/><path d="M14.47 3.12a1 1 0 0 0-1 0L7 7.57H2a1 1 0 0 0-1 1v6.86a1 1 0 0 0 1 1h5l6.41 4.4A1.06 1.06 0 0 0 14 21a1 1 0 0 0 1-1V4a1 1 0 0 0-.53-.88z"/></g></g>', "wifi-off": '<g data-name="Layer 2"><g data-name="wifi-off"><rect width="24" height="24" opacity="0"/><circle cx="12" cy="19" r="1"/><path d="M12.44 11l-1.9-1.89-2.46-2.44-1.55-1.55-1.82-1.83a1 1 0 0 0-1.42 1.42l1.38 1.37 1.46 1.46 2.23 2.24 1.55 1.54 2.74 2.74 2.79 2.8 3.85 3.85a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42z"/><path d="M21.72 7.93A13.93 13.93 0 0 0 12 4a14.1 14.1 0 0 0-4.44.73l1.62 1.62a11.89 11.89 0 0 1 11.16 3 1 1 0 0 0 .69.28 1 1 0 0 0 .72-.31 1 1 0 0 0-.03-1.39z"/><path d="M3.82 6.65a14.32 14.32 0 0 0-1.54 1.28 1 1 0 0 0 1.38 1.44 13.09 13.09 0 0 1 1.6-1.29z"/><path d="M17 13.14a1 1 0 0 0 .71.3 1 1 0 0 0 .72-1.69A9 9 0 0 0 12 9h-.16l2.35 2.35A7 7 0 0 1 17 13.14z"/><path d="M7.43 10.26a8.8 8.8 0 0 0-1.9 1.49A1 1 0 0 0 7 13.14a7.3 7.3 0 0 1 2-1.41z"/><path d="M8.53 15.4a1 1 0 1 0 1.39 1.44 3.06 3.06 0 0 1 3.84-.25l-2.52-2.52a5 5 0 0 0-2.71 1.33z"/></g></g>', "wifi": '<g data-name="Layer 2"><g data-name="wifi"><rect width="24" height="24" opacity="0"/><circle cx="12" cy="19" r="1"/><path d="M12 14a5 5 0 0 0-3.47 1.4 1 1 0 1 0 1.39 1.44 3.08 3.08 0 0 1 4.16 0 1 1 0 1 0 1.39-1.44A5 5 0 0 0 12 14z"/><path d="M12 9a9 9 0 0 0-6.47 2.75A1 1 0 0 0 7 13.14a7 7 0 0 1 10.08 0 1 1 0 0 0 .71.3 1 1 0 0 0 .72-1.69A9 9 0 0 0 12 9z"/><path d="M21.72 7.93a14 14 0 0 0-19.44 0 1 1 0 0 0 1.38 1.44 12 12 0 0 1 16.68 0 1 1 0 0 0 .69.28 1 1 0 0 0 .72-.31 1 1 0 0 0-.03-1.41z"/></g></g>', "activity-outline": '<g data-name="Layer 2"><g data-name="activity"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M14.33 20h-.21a2 2 0 0 1-1.76-1.58L9.68 6l-2.76 6.4A1 1 0 0 1 6 13H3a1 1 0 0 1 0-2h2.34l2.51-5.79a2 2 0 0 1 3.79.38L14.32 18l2.76-6.38A1 1 0 0 1 18 11h3a1 1 0 0 1 0 2h-2.34l-2.51 5.79A2 2 0 0 1 14.33 20z"/></g></g>', "alert-circle-outline": '<g data-name="Layer 2"><g data-name="alert-circle"><rect width="24" height="24" opacity="0"/><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 18a8 8 0 1 1 8-8 8 8 0 0 1-8 8z"/><circle cx="12" cy="16" r="1"/><path d="M12 7a1 1 0 0 0-1 1v5a1 1 0 0 0 2 0V8a1 1 0 0 0-1-1z"/></g></g>', "alert-triangle-outline": '<g data-name="Layer 2"><g data-name="alert-triangle"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M22.56 16.3L14.89 3.58a3.43 3.43 0 0 0-5.78 0L1.44 16.3a3 3 0 0 0-.05 3A3.37 3.37 0 0 0 4.33 21h15.34a3.37 3.37 0 0 0 2.94-1.66 3 3 0 0 0-.05-3.04zm-1.7 2.05a1.31 1.31 0 0 1-1.19.65H4.33a1.31 1.31 0 0 1-1.19-.65 1 1 0 0 1 0-1l7.68-12.73a1.48 1.48 0 0 1 2.36 0l7.67 12.72a1 1 0 0 1 .01 1.01z"/><circle cx="12" cy="16" r="1"/><path d="M12 8a1 1 0 0 0-1 1v4a1 1 0 0 0 2 0V9a1 1 0 0 0-1-1z"/></g></g>', "archive-outline": '<g data-name="Layer 2"><g data-name="archive"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M21 6a3 3 0 0 0-3-3H6a3 3 0 0 0-2 5.22V18a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3V8.22A3 3 0 0 0 21 6zM6 5h12a1 1 0 0 1 0 2H6a1 1 0 0 1 0-2zm12 13a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V9h12z"/><rect x="9" y="12" width="6" height="2" rx=".87" ry=".87"/></g></g>', "arrow-back-outline": '<g data-name="Layer 2"><g data-name="arrow-back"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M19 11H7.14l3.63-4.36a1 1 0 1 0-1.54-1.28l-5 6a1.19 1.19 0 0 0-.09.15c0 .05 0 .08-.07.13A1 1 0 0 0 4 12a1 1 0 0 0 .07.36c0 .05 0 .08.07.13a1.19 1.19 0 0 0 .09.15l5 6A1 1 0 0 0 10 19a1 1 0 0 0 .64-.23 1 1 0 0 0 .13-1.41L7.14 13H19a1 1 0 0 0 0-2z"/></g></g>', "arrow-circle-down-outline": '<g data-name="Layer 2"><g data-name="arrow-circle-down"><rect width="24" height="24" opacity="0"/><path d="M14.31 12.41L13 13.66V8a1 1 0 0 0-2 0v5.59l-1.29-1.3a1 1 0 0 0-1.42 1.42l3 3a1 1 0 0 0 .33.21.94.94 0 0 0 .76 0 .54.54 0 0 0 .16-.1.49.49 0 0 0 .15-.1l3-2.86a1 1 0 0 0-1.38-1.45z"/><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 18a8 8 0 1 1 8-8 8 8 0 0 1-8 8z"/></g></g>', "arrow-circle-left-outline": '<g data-name="Layer 2"><g data-name="arrow-circle-left"><rect width="24" height="24" opacity="0"/><path d="M16 11h-5.66l1.25-1.31a1 1 0 0 0-1.45-1.38l-2.86 3a1 1 0 0 0-.09.13.72.72 0 0 0-.11.19.88.88 0 0 0-.06.28L7 12a1 1 0 0 0 .08.38 1 1 0 0 0 .21.32l3 3a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42L10.41 13H16a1 1 0 0 0 0-2z"/><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 18a8 8 0 1 1 8-8 8 8 0 0 1-8 8z"/></g></g>', "arrow-circle-right-outline": '<g data-name="Layer 2"><g data-name="arrow-circle-right"><rect width="24" height="24" transform="rotate(-90 12 12)" opacity="0"/><path d="M17 12v-.09a.88.88 0 0 0-.06-.28.72.72 0 0 0-.11-.19 1 1 0 0 0-.09-.13l-2.86-3a1 1 0 0 0-1.45 1.38L13.66 11H8a1 1 0 0 0 0 2h5.59l-1.3 1.29a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0l3-3a1 1 0 0 0 .21-.32A1 1 0 0 0 17 12z"/><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 18a8 8 0 1 1 8-8 8 8 0 0 1-8 8z"/></g></g>', "arrow-circle-up-outline": '<g data-name="Layer 2"><g data-name="arrow-circle-up"><rect width="24" height="24" opacity="0"/><path d="M12.71 7.29a1 1 0 0 0-.32-.21A1 1 0 0 0 12 7h-.1a.82.82 0 0 0-.27.06.72.72 0 0 0-.19.11 1 1 0 0 0-.13.09l-3 2.86a1 1 0 0 0 1.38 1.45L11 10.34V16a1 1 0 0 0 2 0v-5.59l1.29 1.3a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42z"/><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 18a8 8 0 1 1 8-8 8 8 0 0 1-8 8z"/></g></g>', "arrow-down-outline": '<g data-name="Layer 2"><g data-name="arrow-down"><rect width="24" height="24" transform="rotate(-90 12 12)" opacity="0"/><path d="M12 17a1.72 1.72 0 0 1-1.33-.64l-4.21-5.1a2.1 2.1 0 0 1-.26-2.21A1.76 1.76 0 0 1 7.79 8h8.42a1.76 1.76 0 0 1 1.59 1.05 2.1 2.1 0 0 1-.26 2.21l-4.21 5.1A1.72 1.72 0 0 1 12 17zm-3.91-7L12 14.82 16 10z"/></g></g>', "arrow-downward-outline": '<g data-name="Layer 2"><g data-name="arrow-downward"><rect width="24" height="24" opacity="0"/><path d="M18.77 13.36a1 1 0 0 0-1.41-.13L13 16.86V5a1 1 0 0 0-2 0v11.86l-4.36-3.63a1 1 0 1 0-1.28 1.54l6 5 .15.09.13.07a1 1 0 0 0 .72 0l.13-.07.15-.09 6-5a1 1 0 0 0 .13-1.41z"/></g></g>', "arrow-forward-outline": '<g data-name="Layer 2"><g data-name="arrow-forward"><rect width="24" height="24" transform="rotate(-90 12 12)" opacity="0"/><path d="M5 13h11.86l-3.63 4.36a1 1 0 0 0 1.54 1.28l5-6a1.19 1.19 0 0 0 .09-.15c0-.05.05-.08.07-.13A1 1 0 0 0 20 12a1 1 0 0 0-.07-.36c0-.05-.05-.08-.07-.13a1.19 1.19 0 0 0-.09-.15l-5-6A1 1 0 0 0 14 5a1 1 0 0 0-.64.23 1 1 0 0 0-.13 1.41L16.86 11H5a1 1 0 0 0 0 2z"/></g></g>', "arrow-ios-back-outline": '<g data-name="Layer 2"><g data-name="arrow-ios-back"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M13.83 19a1 1 0 0 1-.78-.37l-4.83-6a1 1 0 0 1 0-1.27l5-6a1 1 0 0 1 1.54 1.28L10.29 12l4.32 5.36a1 1 0 0 1-.78 1.64z"/></g></g>', "arrow-ios-downward-outline": '<g data-name="Layer 2"><g data-name="arrow-ios-downward"><rect width="24" height="24" opacity="0"/><path d="M12 16a1 1 0 0 1-.64-.23l-6-5a1 1 0 1 1 1.28-1.54L12 13.71l5.36-4.32a1 1 0 0 1 1.41.15 1 1 0 0 1-.14 1.46l-6 4.83A1 1 0 0 1 12 16z"/></g></g>', "arrow-ios-forward-outline": '<g data-name="Layer 2"><g data-name="arrow-ios-forward"><rect width="24" height="24" transform="rotate(-90 12 12)" opacity="0"/><path d="M10 19a1 1 0 0 1-.64-.23 1 1 0 0 1-.13-1.41L13.71 12 9.39 6.63a1 1 0 0 1 .15-1.41 1 1 0 0 1 1.46.15l4.83 6a1 1 0 0 1 0 1.27l-5 6A1 1 0 0 1 10 19z"/></g></g>', "arrow-ios-upward-outline": '<g data-name="Layer 2"><g data-name="arrow-ios-upward"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M18 15a1 1 0 0 1-.64-.23L12 10.29l-5.37 4.32a1 1 0 0 1-1.41-.15 1 1 0 0 1 .15-1.41l6-4.83a1 1 0 0 1 1.27 0l6 5a1 1 0 0 1 .13 1.41A1 1 0 0 1 18 15z"/></g></g>', "arrow-left-outline": '<g data-name="Layer 2"><g data-name="arrow-left"><rect width="24" height="24" opacity="0"/><path d="M13.54 18a2.06 2.06 0 0 1-1.3-.46l-5.1-4.21a1.7 1.7 0 0 1 0-2.66l5.1-4.21a2.1 2.1 0 0 1 2.21-.26 1.76 1.76 0 0 1 1.05 1.59v8.42a1.76 1.76 0 0 1-1.05 1.59 2.23 2.23 0 0 1-.91.2zm-4.86-6l4.82 4V8.09z"/></g></g>', "arrow-right-outline": '<g data-name="Layer 2"><g data-name="arrow-right"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M10.46 18a2.23 2.23 0 0 1-.91-.2 1.76 1.76 0 0 1-1.05-1.59V7.79A1.76 1.76 0 0 1 9.55 6.2a2.1 2.1 0 0 1 2.21.26l5.1 4.21a1.7 1.7 0 0 1 0 2.66l-5.1 4.21a2.06 2.06 0 0 1-1.3.46zm0-10v7.9l4.86-3.9z"/></g></g>', "arrow-up-outline": '<g data-name="Layer 2"><g data-name="arrow-up"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M16.21 16H7.79a1.76 1.76 0 0 1-1.59-1 2.1 2.1 0 0 1 .26-2.21l4.21-5.1a1.76 1.76 0 0 1 2.66 0l4.21 5.1A2.1 2.1 0 0 1 17.8 15a1.76 1.76 0 0 1-1.59 1zM8 14h7.9L12 9.18z"/></g></g>', "arrow-upward-outline": '<g data-name="Layer 2"><g data-name="arrow-upward"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M5.23 10.64a1 1 0 0 0 1.41.13L11 7.14V19a1 1 0 0 0 2 0V7.14l4.36 3.63a1 1 0 1 0 1.28-1.54l-6-5-.15-.09-.13-.07a1 1 0 0 0-.72 0l-.13.07-.15.09-6 5a1 1 0 0 0-.13 1.41z"/></g></g>', "arrowhead-down-outline": '<g data-name="Layer 2"><g data-name="arrowhead-down"><rect width="24" height="24" opacity="0"/><path d="M17.37 12.39L12 16.71l-5.36-4.48a1 1 0 1 0-1.28 1.54l6 5a1 1 0 0 0 1.27 0l6-4.83a1 1 0 0 0 .15-1.41 1 1 0 0 0-1.41-.14z"/><path d="M11.36 11.77a1 1 0 0 0 1.27 0l6-4.83a1 1 0 0 0 .15-1.41 1 1 0 0 0-1.41-.15L12 9.71 6.64 5.23a1 1 0 0 0-1.28 1.54z"/></g></g>', "arrowhead-left-outline": '<g data-name="Layer 2"><g data-name="arrowhead-left"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M11.64 5.23a1 1 0 0 0-1.41.13l-5 6a1 1 0 0 0 0 1.27l4.83 6a1 1 0 0 0 .78.37 1 1 0 0 0 .78-1.63L7.29 12l4.48-5.37a1 1 0 0 0-.13-1.4z"/><path d="M14.29 12l4.48-5.37a1 1 0 0 0-1.54-1.28l-5 6a1 1 0 0 0 0 1.27l4.83 6a1 1 0 0 0 .78.37 1 1 0 0 0 .78-1.63z"/></g></g>', "arrowhead-right-outline": '<g data-name="Layer 2"><g data-name="arrowhead-right"><rect width="24" height="24" transform="rotate(-90 12 12)" opacity="0"/><path d="M18.78 11.37l-4.78-6a1 1 0 0 0-1.41-.15 1 1 0 0 0-.15 1.41L16.71 12l-4.48 5.37a1 1 0 0 0 .13 1.41A1 1 0 0 0 13 19a1 1 0 0 0 .77-.36l5-6a1 1 0 0 0 .01-1.27z"/><path d="M7 5.37a1 1 0 0 0-1.61 1.26L9.71 12l-4.48 5.36a1 1 0 0 0 .13 1.41A1 1 0 0 0 6 19a1 1 0 0 0 .77-.36l5-6a1 1 0 0 0 0-1.27z"/></g></g>', "arrowhead-up-outline": '<g data-name="Layer 2"><g data-name="arrowhead-up"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M6.63 11.61L12 7.29l5.37 4.48A1 1 0 0 0 18 12a1 1 0 0 0 .77-.36 1 1 0 0 0-.13-1.41l-6-5a1 1 0 0 0-1.27 0l-6 4.83a1 1 0 0 0-.15 1.41 1 1 0 0 0 1.41.14z"/><path d="M12.64 12.23a1 1 0 0 0-1.27 0l-6 4.83a1 1 0 0 0-.15 1.41 1 1 0 0 0 1.41.15L12 14.29l5.37 4.48A1 1 0 0 0 18 19a1 1 0 0 0 .77-.36 1 1 0 0 0-.13-1.41z"/></g></g>', "at-outline": '<g data-name="Layer 2"><g data-name="at"><rect width="24" height="24" opacity="0"/><path d="M13 2a10 10 0 0 0-5 19.1 10.15 10.15 0 0 0 4 .9 10 10 0 0 0 6.08-2.06 1 1 0 0 0 .19-1.4 1 1 0 0 0-1.41-.19A8 8 0 1 1 12.77 4 8.17 8.17 0 0 1 20 12.22v.68a1.71 1.71 0 0 1-1.78 1.7 1.82 1.82 0 0 1-1.62-1.88V8.4a1 1 0 0 0-1-1 1 1 0 0 0-1 .87 5 5 0 0 0-3.44-1.36A5.09 5.09 0 1 0 15.31 15a3.6 3.6 0 0 0 5.55.61A3.67 3.67 0 0 0 22 12.9v-.68A10.2 10.2 0 0 0 13 2zm-1.82 13.09A3.09 3.09 0 1 1 14.27 12a3.1 3.1 0 0 1-3.09 3.09z"/></g></g>', "attach-2-outline": '<g data-name="Layer 2"><g data-name="attach-2"><rect width="24" height="24" opacity="0"/><path d="M12 22a5.86 5.86 0 0 1-6-5.7V6.13A4.24 4.24 0 0 1 10.33 2a4.24 4.24 0 0 1 4.34 4.13v10.18a2.67 2.67 0 0 1-5.33 0V6.92a1 1 0 0 1 1-1 1 1 0 0 1 1 1v9.39a.67.67 0 0 0 1.33 0V6.13A2.25 2.25 0 0 0 10.33 4 2.25 2.25 0 0 0 8 6.13V16.3a3.86 3.86 0 0 0 4 3.7 3.86 3.86 0 0 0 4-3.7V6.13a1 1 0 1 1 2 0V16.3a5.86 5.86 0 0 1-6 5.7z"/></g></g>', "attach-outline": '<g data-name="Layer 2"><g data-name="attach"><rect width="24" height="24" opacity="0"/><path d="M9.29 21a6.23 6.23 0 0 1-4.43-1.88 6 6 0 0 1-.22-8.49L12 3.2A4.11 4.11 0 0 1 15 2a4.48 4.48 0 0 1 3.19 1.35 4.36 4.36 0 0 1 .15 6.13l-7.4 7.43a2.54 2.54 0 0 1-1.81.75 2.72 2.72 0 0 1-1.95-.82 2.68 2.68 0 0 1-.08-3.77l6.83-6.86a1 1 0 0 1 1.37 1.41l-6.83 6.86a.68.68 0 0 0 .08.95.78.78 0 0 0 .53.23.56.56 0 0 0 .4-.16l7.39-7.43a2.36 2.36 0 0 0-.15-3.31 2.38 2.38 0 0 0-3.27-.15L6.06 12a4 4 0 0 0 .22 5.67 4.22 4.22 0 0 0 3 1.29 3.67 3.67 0 0 0 2.61-1.06l7.39-7.43a1 1 0 1 1 1.42 1.41l-7.39 7.43A5.65 5.65 0 0 1 9.29 21z"/></g></g>', "award-outline": '<g data-name="Layer 2"><g data-name="award"><rect width="24" height="24" opacity="0"/><path d="M19 20.75l-2.31-9A5.94 5.94 0 0 0 18 8 6 6 0 0 0 6 8a5.94 5.94 0 0 0 1.34 3.77L5 20.75a1 1 0 0 0 1.48 1.11l5.33-3.13 5.68 3.14A.91.91 0 0 0 18 22a1 1 0 0 0 1-1.25zM12 4a4 4 0 1 1-4 4 4 4 0 0 1 4-4zm.31 12.71a1 1 0 0 0-1 0l-3.75 2.2L9 13.21a5.94 5.94 0 0 0 5.92 0L16.45 19z"/></g></g>', "backspace-outline": '<g data-name="Layer 2"><g data-name="backspace"><rect width="24" height="24" opacity="0"/><path d="M20.14 4h-9.77a3 3 0 0 0-2 .78l-.1.11-6 7.48a1 1 0 0 0 .11 1.37l6 5.48a3 3 0 0 0 2 .78h9.77A1.84 1.84 0 0 0 22 18.18V5.82A1.84 1.84 0 0 0 20.14 4zM20 18h-9.63a1 1 0 0 1-.67-.26l-5.33-4.85 5.38-6.67a1 1 0 0 1 .62-.22H20z"/><path d="M11.29 14.71a1 1 0 0 0 1.42 0l1.29-1.3 1.29 1.3a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42L15.41 12l1.3-1.29a1 1 0 0 0-1.42-1.42L14 10.59l-1.29-1.3a1 1 0 0 0-1.42 1.42l1.3 1.29-1.3 1.29a1 1 0 0 0 0 1.42z"/></g></g>', "bar-chart-2-outline": '<g data-name="Layer 2"><g data-name="bar-chart-2"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M12 8a1 1 0 0 0-1 1v11a1 1 0 0 0 2 0V9a1 1 0 0 0-1-1z"/><path d="M19 4a1 1 0 0 0-1 1v15a1 1 0 0 0 2 0V5a1 1 0 0 0-1-1z"/><path d="M5 12a1 1 0 0 0-1 1v7a1 1 0 0 0 2 0v-7a1 1 0 0 0-1-1z"/></g></g>', "bar-chart-outline": '<g data-name="Layer 2"><g data-name="bar-chart"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M12 4a1 1 0 0 0-1 1v15a1 1 0 0 0 2 0V5a1 1 0 0 0-1-1z"/><path d="M19 12a1 1 0 0 0-1 1v7a1 1 0 0 0 2 0v-7a1 1 0 0 0-1-1z"/><path d="M5 8a1 1 0 0 0-1 1v11a1 1 0 0 0 2 0V9a1 1 0 0 0-1-1z"/></g></g>', "battery-outline": '<g data-name="Layer 2"><g data-name="battery"><rect width="24" height="24" opacity="0"/><path d="M15.83 6H4.17A2.31 2.31 0 0 0 2 8.43v7.14A2.31 2.31 0 0 0 4.17 18h11.66A2.31 2.31 0 0 0 18 15.57V8.43A2.31 2.31 0 0 0 15.83 6zm.17 9.57a.52.52 0 0 1-.17.43H4.18a.5.5 0 0 1-.18-.43V8.43A.53.53 0 0 1 4.17 8h11.65a.5.5 0 0 1 .18.43z"/><path d="M21 9a1 1 0 0 0-1 1v4a1 1 0 0 0 2 0v-4a1 1 0 0 0-1-1z"/></g></g>', "behance-outline": '<g data-name="Layer 2"><g data-name="behance"><rect width="24" height="24" opacity="0"/><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 18a8 8 0 1 1 8-8 8 8 0 0 1-8 8z"/><path d="M10.52 11.78a1.4 1.4 0 0 0 1.12-1.43c0-1-.77-1.6-1.94-1.6H7v6.5h2.7c1.3-.05 2.3-.72 2.3-1.88a1.52 1.52 0 0 0-1.48-1.59zM8.26 9.67h1.15c.6 0 .95.32.95.85s-.38.89-1.25.89h-.85zm1 4.57h-1V12.3h1.23c.75 0 1.17.38 1.17 1s-.42.94-1.44.94z"/><path d="M14.75 10.3a2.11 2.11 0 0 0-2.28 2.25V13a2.15 2.15 0 0 0 2.34 2.31A2 2 0 0 0 17 13.75h-1.21a.9.9 0 0 1-1 .63 1.07 1.07 0 0 1-1.09-1.19v-.14H17v-.47a2.12 2.12 0 0 0-2.25-2.28zm1 2h-2.02a1 1 0 0 1 1-1.09 1 1 0 0 1 1 1.09z"/><rect x="13.25" y="9.2" width="3" height=".5"/></g></g>', "bell-off-outline": '<g data-name="Layer 2"><g data-name="bell-off"><rect width="24" height="24" opacity="0"/><path d="M8.9 5.17A4.67 4.67 0 0 1 12.64 4a4.86 4.86 0 0 1 4.08 4.9v4.5a1.92 1.92 0 0 0 .1.59l3.6 3.6a1.58 1.58 0 0 0 .45-.6 1.62 1.62 0 0 0-.35-1.78l-1.8-1.81V8.94a6.86 6.86 0 0 0-5.82-6.88 6.71 6.71 0 0 0-5.32 1.61 6.88 6.88 0 0 0-.58.54l1.47 1.43a4.79 4.79 0 0 1 .43-.47z"/><path d="M14 16.86l-.83-.86H5.51l1.18-1.18a2 2 0 0 0 .59-1.42v-3.29l-2-2a5.68 5.68 0 0 0 0 .59v4.7l-1.8 1.81A1.63 1.63 0 0 0 4.64 18H8v.34A3.84 3.84 0 0 0 12 22a3.88 3.88 0 0 0 4-3.22l-.83-.78zM12 20a1.88 1.88 0 0 1-2-1.66V18h4v.34A1.88 1.88 0 0 1 12 20z"/><path d="M20.71 19.29L19.41 18l-2-2-9.52-9.53L6.42 5 4.71 3.29a1 1 0 0 0-1.42 1.42L5.53 7l1.75 1.7 7.31 7.3.07.07L16 17.41l.59.59 2.7 2.71a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42z"/></g></g>', "bell-outline": '<g data-name="Layer 2"><g data-name="bell"><rect width="24" height="24" opacity="0"/><path d="M20.52 15.21l-1.8-1.81V8.94a6.86 6.86 0 0 0-5.82-6.88 6.74 6.74 0 0 0-7.62 6.67v4.67l-1.8 1.81A1.64 1.64 0 0 0 4.64 18H8v.34A3.84 3.84 0 0 0 12 22a3.84 3.84 0 0 0 4-3.66V18h3.36a1.64 1.64 0 0 0 1.16-2.79zM14 18.34A1.88 1.88 0 0 1 12 20a1.88 1.88 0 0 1-2-1.66V18h4zM5.51 16l1.18-1.18a2 2 0 0 0 .59-1.42V8.73A4.73 4.73 0 0 1 8.9 5.17 4.67 4.67 0 0 1 12.64 4a4.86 4.86 0 0 1 4.08 4.9v4.5a2 2 0 0 0 .58 1.42L18.49 16z"/></g></g>', "bluetooth-outline": '<g data-name="Layer 2"><g data-name="bluetooth"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M13.63 12l4-3.79a1.14 1.14 0 0 0-.13-1.77l-4.67-3.23a1.17 1.17 0 0 0-1.21-.08 1.15 1.15 0 0 0-.62 1v6.2l-3.19-4a1 1 0 0 0-1.56 1.3L9.72 12l-3.5 4.43a1 1 0 0 0 .16 1.4A1 1 0 0 0 7 18a1 1 0 0 0 .78-.38L11 13.56v6.29A1.16 1.16 0 0 0 12.16 21a1.16 1.16 0 0 0 .67-.21l4.64-3.18a1.17 1.17 0 0 0 .49-.85 1.15 1.15 0 0 0-.34-.91zM13 5.76l2.5 1.73L13 9.85zm0 12.49v-4.07l2.47 2.38z"/></g></g>', "book-open-outline": '<g data-name="Layer 2"><g data-name="book-open"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M20.62 4.22a1 1 0 0 0-.84-.2L12 5.77 4.22 4A1 1 0 0 0 3 5v12.2a1 1 0 0 0 .78 1l8 1.8h.44l8-1.8a1 1 0 0 0 .78-1V5a1 1 0 0 0-.38-.78zM5 6.25l6 1.35v10.15L5 16.4zM19 16.4l-6 1.35V7.6l6-1.35z"/></g></g>', "book-outline": '<g data-name="Layer 2"><g data-name="book"><rect width="24" height="24" opacity="0"/><path d="M19 3H7a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h12a1 1 0 0 0 1-1V4a1 1 0 0 0-1-1zM7 5h11v10H7a3 3 0 0 0-1 .18V6a1 1 0 0 1 1-1zm0 14a1 1 0 0 1 0-2h11v2z"/></g></g>', "bookmark-outline": '<g data-name="Layer 2"><g data-name="bookmark"><rect width="24" height="24" opacity="0"/><path d="M6.09 21.06a1 1 0 0 1-1-1L4.94 5.4a2.26 2.26 0 0 1 2.18-2.35L16.71 3a2.27 2.27 0 0 1 2.23 2.31l.14 14.66a1 1 0 0 1-.49.87 1 1 0 0 1-1 0l-5.7-3.16-5.29 3.23a1.2 1.2 0 0 1-.51.15zm5.76-5.55a1.11 1.11 0 0 1 .5.12l4.71 2.61-.12-12.95c0-.2-.13-.34-.21-.33l-9.6.09c-.08 0-.19.13-.19.33l.12 12.9 4.28-2.63a1.06 1.06 0 0 1 .51-.14z"/></g></g>', "briefcase-outline": '<g data-name="Layer 2"><g data-name="briefcase"><rect width="24" height="24" opacity="0"/><path d="M19 7h-3V5.5A2.5 2.5 0 0 0 13.5 3h-3A2.5 2.5 0 0 0 8 5.5V7H5a3 3 0 0 0-3 3v8a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3v-8a3 3 0 0 0-3-3zm-4 2v10H9V9zm-5-3.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5V7h-4zM4 18v-8a1 1 0 0 1 1-1h2v10H5a1 1 0 0 1-1-1zm16 0a1 1 0 0 1-1 1h-2V9h2a1 1 0 0 1 1 1z"/></g></g>', "browser-outline": '<g data-name="Layer 2"><g data-name="browser"><rect width="24" height="24" opacity="0"/><path d="M18 3H6a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3V6a3 3 0 0 0-3-3zm1 15a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1v-7h14zM5 9V6a1 1 0 0 1 1-1h12a1 1 0 0 1 1 1v3z"/><circle cx="8" cy="7.03" r="1"/><circle cx="12" cy="7.03" r="1"/></g></g>', "brush-outline": '<g data-name="Layer 2"><g data-name="brush"><rect width="24" height="24" opacity="0"/><path d="M20 6.83a2.76 2.76 0 0 0-.82-2 2.89 2.89 0 0 0-4 0l-6.6 6.6h-.22a4.42 4.42 0 0 0-4.3 4.31L4 19a1 1 0 0 0 .29.73A1.05 1.05 0 0 0 5 20l3.26-.06a4.42 4.42 0 0 0 4.31-4.3v-.23l6.61-6.6A2.74 2.74 0 0 0 20 6.83zM8.25 17.94L6 18v-2.23a2.4 2.4 0 0 1 2.4-2.36 2.15 2.15 0 0 1 2.15 2.19 2.4 2.4 0 0 1-2.3 2.34zm9.52-10.55l-5.87 5.87a4.55 4.55 0 0 0-.52-.64 3.94 3.94 0 0 0-.64-.52l5.87-5.86a.84.84 0 0 1 1.16 0 .81.81 0 0 1 .23.59.79.79 0 0 1-.23.56z"/></g></g>', "bulb-outline": '<g data-name="Layer 2"><g data-name="bulb"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M12 7a5 5 0 0 0-3 9v4a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2v-4a5 5 0 0 0-3-9zm1.5 7.59a1 1 0 0 0-.5.87V20h-2v-4.54a1 1 0 0 0-.5-.87A3 3 0 0 1 9 12a3 3 0 0 1 6 0 3 3 0 0 1-1.5 2.59z"/><path d="M12 6a1 1 0 0 0 1-1V3a1 1 0 0 0-2 0v2a1 1 0 0 0 1 1z"/><path d="M21 11h-2a1 1 0 0 0 0 2h2a1 1 0 0 0 0-2z"/><path d="M5 11H3a1 1 0 0 0 0 2h2a1 1 0 0 0 0-2z"/><path d="M7.66 6.42L6.22 5a1 1 0 0 0-1.39 1.47l1.44 1.39a1 1 0 0 0 .73.28 1 1 0 0 0 .72-.31 1 1 0 0 0-.06-1.41z"/><path d="M19.19 5.05a1 1 0 0 0-1.41 0l-1.44 1.37a1 1 0 0 0 0 1.41 1 1 0 0 0 .72.31 1 1 0 0 0 .69-.28l1.44-1.39a1 1 0 0 0 0-1.42z"/></g></g>', "calendar-outline": '<g data-name="Layer 2"><g data-name="calendar"><rect width="24" height="24" opacity="0"/><path d="M18 4h-1V3a1 1 0 0 0-2 0v1H9V3a1 1 0 0 0-2 0v1H6a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3V7a3 3 0 0 0-3-3zM6 6h1v1a1 1 0 0 0 2 0V6h6v1a1 1 0 0 0 2 0V6h1a1 1 0 0 1 1 1v4H5V7a1 1 0 0 1 1-1zm12 14H6a1 1 0 0 1-1-1v-6h14v6a1 1 0 0 1-1 1z"/><circle cx="8" cy="16" r="1"/><path d="M16 15h-4a1 1 0 0 0 0 2h4a1 1 0 0 0 0-2z"/></g></g>', "camera-outline": '<g data-name="Layer 2"><g data-name="camera"><rect width="24" height="24" opacity="0"/><path d="M19 7h-3V5.5A2.5 2.5 0 0 0 13.5 3h-3A2.5 2.5 0 0 0 8 5.5V7H5a3 3 0 0 0-3 3v8a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3v-8a3 3 0 0 0-3-3zm-9-1.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5V7h-4zM20 18a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1v-8a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1z"/><path d="M12 10.5a3.5 3.5 0 1 0 3.5 3.5 3.5 3.5 0 0 0-3.5-3.5zm0 5a1.5 1.5 0 1 1 1.5-1.5 1.5 1.5 0 0 1-1.5 1.5z"/></g></g>', "car-outline": '<g data-name="Layer 2"><g data-name="car"><rect width="24" height="24" opacity="0"/><path d="M21.6 11.22L17 7.52V5a1.91 1.91 0 0 0-1.81-2H3.79A1.91 1.91 0 0 0 2 5v10a2 2 0 0 0 1.2 1.88 3 3 0 1 0 5.6.12h6.36a3 3 0 1 0 5.64 0h.2a1 1 0 0 0 1-1v-4a1 1 0 0 0-.4-.78zM20 12.48V15h-3v-4.92zM7 18a1 1 0 1 1-1-1 1 1 0 0 1 1 1zm5-3H4V5h11v10zm7 3a1 1 0 1 1-1-1 1 1 0 0 1 1 1z"/></g></g>', "cast-outline": '<g data-name="Layer 2"><g data-name="cast"><polyline points="24 24 0 24 0 0" opacity="0"/><path d="M18.4 3H5.6A2.7 2.7 0 0 0 3 5.78V7a1 1 0 0 0 2 0V5.78A.72.72 0 0 1 5.6 5h12.8a.72.72 0 0 1 .6.78v12.44a.72.72 0 0 1-.6.78H17a1 1 0 0 0 0 2h1.4a2.7 2.7 0 0 0 2.6-2.78V5.78A2.7 2.7 0 0 0 18.4 3z"/><path d="M3.86 14A1 1 0 0 0 3 15.17a1 1 0 0 0 1.14.83 2.49 2.49 0 0 1 2.12.72 2.52 2.52 0 0 1 .51 2.84 1 1 0 0 0 .48 1.33 1.06 1.06 0 0 0 .42.09 1 1 0 0 0 .91-.58A4.52 4.52 0 0 0 3.86 14z"/><path d="M3.86 10.08a1 1 0 0 0 .28 2 6 6 0 0 1 5.09 1.71 6 6 0 0 1 1.53 5.95 1 1 0 0 0 .68 1.26.9.9 0 0 0 .28 0 1 1 0 0 0 1-.72 8 8 0 0 0-8.82-10.2z"/><circle cx="4" cy="19" r="1"/></g></g>', "charging-outline": '<g data-name="Layer 2"><g data-name="charging"><rect width="24" height="24" opacity="0"/><path d="M21 9a1 1 0 0 0-1 1v4a1 1 0 0 0 2 0v-4a1 1 0 0 0-1-1z"/><path d="M15.83 6h-3.1l-1.14 2h4.23a.5.5 0 0 1 .18.43v7.14a.52.52 0 0 1-.17.43H13l-1.15 2h4A2.31 2.31 0 0 0 18 15.57V8.43A2.31 2.31 0 0 0 15.83 6z"/><path d="M4 15.57V8.43A.53.53 0 0 1 4.17 8H7l1.13-2h-4A2.31 2.31 0 0 0 2 8.43v7.14A2.31 2.31 0 0 0 4.17 18h3.1l1.14-2H4.18a.5.5 0 0 1-.18-.43z"/><path d="M9 20a1 1 0 0 1-.87-1.5l3.15-5.5H7a1 1 0 0 1-.86-.5 1 1 0 0 1 0-1l4-7a1 1 0 0 1 1.74 1L8.72 11H13a1 1 0 0 1 .86.5 1 1 0 0 1 0 1l-4 7A1 1 0 0 1 9 20z"/></g></g>', "checkmark-circle-2-outline": '<g data-name="Layer 2"><g data-name="checkmark-circle-2"><rect width="24" height="24" opacity="0"/><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 18a8 8 0 1 1 8-8 8 8 0 0 1-8 8z"/><path d="M14.7 8.39l-3.78 5-1.63-2.11a1 1 0 0 0-1.58 1.23l2.43 3.11a1 1 0 0 0 .79.38 1 1 0 0 0 .79-.39l4.57-6a1 1 0 1 0-1.6-1.22z"/></g></g>', "checkmark-circle-outline": '<g data-name="Layer 2"><g data-name="checkmark-circle"><rect width="24" height="24" opacity="0"/><path d="M9.71 11.29a1 1 0 0 0-1.42 1.42l3 3A1 1 0 0 0 12 16a1 1 0 0 0 .72-.34l7-8a1 1 0 0 0-1.5-1.32L12 13.54z"/><path d="M21 11a1 1 0 0 0-1 1 8 8 0 0 1-8 8A8 8 0 0 1 6.33 6.36 7.93 7.93 0 0 1 12 4a8.79 8.79 0 0 1 1.9.22 1 1 0 1 0 .47-1.94A10.54 10.54 0 0 0 12 2a10 10 0 0 0-7 17.09A9.93 9.93 0 0 0 12 22a10 10 0 0 0 10-10 1 1 0 0 0-1-1z"/></g></g>', "checkmark-outline": '<g data-name="Layer 2"><g data-name="checkmark"><rect width="24" height="24" opacity="0"/><path d="M9.86 18a1 1 0 0 1-.73-.32l-4.86-5.17a1 1 0 1 1 1.46-1.37l4.12 4.39 8.41-9.2a1 1 0 1 1 1.48 1.34l-9.14 10a1 1 0 0 1-.73.33z"/></g></g>', "checkmark-square-2-outline": '<g data-name="Layer 2"><g data-name="checkmark-square-2"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M18 3H6a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3V6a3 3 0 0 0-3-3zm1 15a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1h12a1 1 0 0 1 1 1z"/><path d="M14.7 8.39l-3.78 5-1.63-2.11a1 1 0 0 0-1.58 1.23l2.43 3.11a1 1 0 0 0 .79.38 1 1 0 0 0 .79-.39l4.57-6a1 1 0 1 0-1.6-1.22z"/></g></g>', "checkmark-square-outline": '<g data-name="Layer 2"><g data-name="checkmark-square"><rect width="24" height="24" opacity="0"/><path d="M20 11.83a1 1 0 0 0-1 1v5.57a.6.6 0 0 1-.6.6H5.6a.6.6 0 0 1-.6-.6V5.6a.6.6 0 0 1 .6-.6h9.57a1 1 0 1 0 0-2H5.6A2.61 2.61 0 0 0 3 5.6v12.8A2.61 2.61 0 0 0 5.6 21h12.8a2.61 2.61 0 0 0 2.6-2.6v-5.57a1 1 0 0 0-1-1z"/><path d="M10.72 11a1 1 0 0 0-1.44 1.38l2.22 2.33a1 1 0 0 0 .72.31 1 1 0 0 0 .72-.3l6.78-7a1 1 0 1 0-1.44-1.4l-6.05 6.26z"/></g></g>', "chevron-down-outline": '<g data-name="Layer 2"><g data-name="chevron-down"><rect width="24" height="24" opacity="0"/><path d="M12 15.5a1 1 0 0 1-.71-.29l-4-4a1 1 0 1 1 1.42-1.42L12 13.1l3.3-3.18a1 1 0 1 1 1.38 1.44l-4 3.86a1 1 0 0 1-.68.28z"/></g></g>', "chevron-left-outline": '<g data-name="Layer 2"><g data-name="chevron-left"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M13.36 17a1 1 0 0 1-.72-.31l-3.86-4a1 1 0 0 1 0-1.4l4-4a1 1 0 1 1 1.42 1.42L10.9 12l3.18 3.3a1 1 0 0 1 0 1.41 1 1 0 0 1-.72.29z"/></g></g>', "chevron-right-outline": '<g data-name="Layer 2"><g data-name="chevron-right"><rect width="24" height="24" transform="rotate(-90 12 12)" opacity="0"/><path d="M10.5 17a1 1 0 0 1-.71-.29 1 1 0 0 1 0-1.42L13.1 12 9.92 8.69a1 1 0 0 1 0-1.41 1 1 0 0 1 1.42 0l3.86 4a1 1 0 0 1 0 1.4l-4 4a1 1 0 0 1-.7.32z"/></g></g>', "chevron-up-outline": '<g data-name="Layer 2"><g data-name="chevron-up"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M16 14.5a1 1 0 0 1-.71-.29L12 10.9l-3.3 3.18a1 1 0 0 1-1.41 0 1 1 0 0 1 0-1.42l4-3.86a1 1 0 0 1 1.4 0l4 4a1 1 0 0 1 0 1.42 1 1 0 0 1-.69.28z"/></g></g>', "clipboard-outline": '<g data-name="Layer 2"><g data-name="clipboard"><rect width="24" height="24" opacity="0"/><path d="M18 5V4a2 2 0 0 0-2-2H8a2 2 0 0 0-2 2v1a3 3 0 0 0-3 3v11a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3V8a3 3 0 0 0-3-3zM8 4h8v4H8V4zm11 15a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1v1a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V7a1 1 0 0 1 1 1z"/></g></g>', "clock-outline": '<g data-name="Layer 2"><g data-name="clock"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 18a8 8 0 1 1 8-8 8 8 0 0 1-8 8z"/><path d="M16 11h-3V8a1 1 0 0 0-2 0v4a1 1 0 0 0 1 1h4a1 1 0 0 0 0-2z"/></g></g>', "close-circle-outline": '<g data-name="Layer 2"><g data-name="close-circle"><rect width="24" height="24" opacity="0"/><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 18a8 8 0 1 1 8-8 8 8 0 0 1-8 8z"/><path d="M14.71 9.29a1 1 0 0 0-1.42 0L12 10.59l-1.29-1.3a1 1 0 0 0-1.42 1.42l1.3 1.29-1.3 1.29a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0l1.29-1.3 1.29 1.3a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42L13.41 12l1.3-1.29a1 1 0 0 0 0-1.42z"/></g></g>', "close-outline": '<g data-name="Layer 2"><g data-name="close"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M13.41 12l4.3-4.29a1 1 0 1 0-1.42-1.42L12 10.59l-4.29-4.3a1 1 0 0 0-1.42 1.42l4.3 4.29-4.3 4.29a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0l4.29-4.3 4.29 4.3a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42z"/></g></g>', "close-square-outline": '<g data-name="Layer 2"><g data-name="close-square"><rect width="24" height="24" opacity="0"/><path d="M18 3H6a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3V6a3 3 0 0 0-3-3zm1 15a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1h12a1 1 0 0 1 1 1z"/><path d="M14.71 9.29a1 1 0 0 0-1.42 0L12 10.59l-1.29-1.3a1 1 0 0 0-1.42 1.42l1.3 1.29-1.3 1.29a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0l1.29-1.3 1.29 1.3a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42L13.41 12l1.3-1.29a1 1 0 0 0 0-1.42z"/></g></g>', "cloud-download-outline": '<g data-name="Layer 2"><g data-name="cloud-download"><rect width="24" height="24" opacity="0"/><path d="M14.31 16.38L13 17.64V12a1 1 0 0 0-2 0v5.59l-1.29-1.3a1 1 0 0 0-1.42 1.42l3 3A1 1 0 0 0 12 21a1 1 0 0 0 .69-.28l3-2.9a1 1 0 1 0-1.38-1.44z"/><path d="M17.67 7A6 6 0 0 0 6.33 7a5 5 0 0 0-3.08 8.27A1 1 0 1 0 4.75 14 3 3 0 0 1 7 9h.1a1 1 0 0 0 1-.8 4 4 0 0 1 7.84 0 1 1 0 0 0 1 .8H17a3 3 0 0 1 2.25 5 1 1 0 0 0 .09 1.42 1 1 0 0 0 .66.25 1 1 0 0 0 .75-.34A5 5 0 0 0 17.67 7z"/></g></g>', "cloud-upload-outline": '<g data-name="Layer 2"><g data-name="cloud-upload"><rect width="24" height="24" opacity="0"/><path d="M12.71 11.29a1 1 0 0 0-1.4 0l-3 2.9a1 1 0 1 0 1.38 1.44L11 14.36V20a1 1 0 0 0 2 0v-5.59l1.29 1.3a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42z"/><path d="M17.67 7A6 6 0 0 0 6.33 7a5 5 0 0 0-3.08 8.27A1 1 0 1 0 4.75 14 3 3 0 0 1 7 9h.1a1 1 0 0 0 1-.8 4 4 0 0 1 7.84 0 1 1 0 0 0 1 .8H17a3 3 0 0 1 2.25 5 1 1 0 0 0 .09 1.42 1 1 0 0 0 .66.25 1 1 0 0 0 .75-.34A5 5 0 0 0 17.67 7z"/></g></g>', "code-download-outline": '<g data-name="Layer 2"><g data-name="code-download"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M4.29 12l4.48-5.36a1 1 0 1 0-1.54-1.28l-5 6a1 1 0 0 0 0 1.27l4.83 6a1 1 0 0 0 .78.37 1 1 0 0 0 .78-1.63z"/><path d="M21.78 11.37l-4.78-6a1 1 0 0 0-1.56 1.26L19.71 12l-4.48 5.37a1 1 0 0 0 .13 1.41A1 1 0 0 0 16 19a1 1 0 0 0 .77-.36l5-6a1 1 0 0 0 .01-1.27z"/><path d="M15.72 11.41a1 1 0 0 0-1.41 0L13 12.64V8a1 1 0 0 0-2 0v4.59l-1.29-1.3a1 1 0 0 0-1.42 1.42l3 3A1 1 0 0 0 12 16a1 1 0 0 0 .69-.28l3-2.9a1 1 0 0 0 .03-1.41z"/></g></g>', "code-outline": '<g data-name="Layer 2"><g data-name="code"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M8.64 5.23a1 1 0 0 0-1.41.13l-5 6a1 1 0 0 0 0 1.27l4.83 6a1 1 0 0 0 .78.37 1 1 0 0 0 .78-1.63L4.29 12l4.48-5.36a1 1 0 0 0-.13-1.41z"/><path d="M21.78 11.37l-4.78-6a1 1 0 0 0-1.41-.15 1 1 0 0 0-.15 1.41L19.71 12l-4.48 5.37a1 1 0 0 0 .13 1.41A1 1 0 0 0 16 19a1 1 0 0 0 .77-.36l5-6a1 1 0 0 0 .01-1.27z"/></g></g>', "collapse-outline": '<g data-name="Layer 2"><g data-name="collapse"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M19 9h-2.58l3.29-3.29a1 1 0 1 0-1.42-1.42L15 7.57V5a1 1 0 0 0-1-1 1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h5a1 1 0 0 0 0-2z"/><path d="M10 13H5a1 1 0 0 0 0 2h2.57l-3.28 3.29a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0L9 16.42V19a1 1 0 0 0 1 1 1 1 0 0 0 1-1v-5a1 1 0 0 0-1-1z"/></g></g>', "color-palette-outline": '<g data-name="Layer 2"><g data-name="color-palette"><rect width="24" height="24" opacity="0"/><path d="M19.54 5.08A10.61 10.61 0 0 0 11.91 2a10 10 0 0 0-.05 20 2.58 2.58 0 0 0 2.53-1.89 2.52 2.52 0 0 0-.57-2.28.5.5 0 0 1 .37-.83h1.65A6.15 6.15 0 0 0 22 11.33a8.48 8.48 0 0 0-2.46-6.25zM15.88 15h-1.65a2.49 2.49 0 0 0-1.87 4.15.49.49 0 0 1 .12.49c-.05.21-.28.34-.59.36a8 8 0 0 1-7.82-9.11A8.1 8.1 0 0 1 11.92 4H12a8.47 8.47 0 0 1 6.1 2.48 6.5 6.5 0 0 1 1.9 4.77A4.17 4.17 0 0 1 15.88 15z"/><circle cx="12" cy="6.5" r="1.5"/><path d="M15.25 7.2a1.5 1.5 0 1 0 2.05.55 1.5 1.5 0 0 0-2.05-.55z"/><path d="M8.75 7.2a1.5 1.5 0 1 0 .55 2.05 1.5 1.5 0 0 0-.55-2.05z"/><path d="M6.16 11.26a1.5 1.5 0 1 0 2.08.4 1.49 1.49 0 0 0-2.08-.4z"/></g></g>', "color-picker-outline": '<g data-name="Layer 2"><g data-name="color-picker"><rect width="24" height="24" opacity="0"/><path d="M19.4 7.34L16.66 4.6A1.92 1.92 0 0 0 14 4.53l-2 2-1.29-1.24a1 1 0 0 0-1.42 1.42L10.53 8 5 13.53a2 2 0 0 0-.57 1.21L4 18.91a1 1 0 0 0 .29.8A1 1 0 0 0 5 20h.09l4.17-.38a2 2 0 0 0 1.21-.57l5.58-5.58 1.24 1.24a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42l-1.24-1.24 2-2a1.92 1.92 0 0 0-.07-2.71zM9.08 17.62l-3 .28.27-3L12 9.36l2.69 2.7zm7-7L13.36 8l1.91-2L18 8.73z"/></g></g>', "compass-outline": '<g data-name="Layer 2"><g data-name="compass"><rect width="24" height="24" opacity="0"/><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 18a8 8 0 1 1 8-8 8 8 0 0 1-8 8z"/><path d="M15.68 8.32a1 1 0 0 0-1.1-.25l-4.21 1.7a1 1 0 0 0-.55.55l-1.75 4.26a1 1 0 0 0 .18 1h.05A1 1 0 0 0 9 16a1 1 0 0 0 .38-.07l4.21-1.7a1 1 0 0 0 .55-.55l1.75-4.26a1 1 0 0 0-.21-1.1zm-4.88 4.89l.71-1.74 1.69-.68-.71 1.74z"/></g></g>', "copy-outline": '<g data-name="Layer 2"><g data-name="copy"><rect width="24" height="24" opacity="0"/><path d="M18 21h-6a3 3 0 0 1-3-3v-6a3 3 0 0 1 3-3h6a3 3 0 0 1 3 3v6a3 3 0 0 1-3 3zm-6-10a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1v-6a1 1 0 0 0-1-1z"/><path d="M9.73 15H5.67A2.68 2.68 0 0 1 3 12.33V5.67A2.68 2.68 0 0 1 5.67 3h6.66A2.68 2.68 0 0 1 15 5.67V9.4h-2V5.67a.67.67 0 0 0-.67-.67H5.67a.67.67 0 0 0-.67.67v6.66a.67.67 0 0 0 .67.67h4.06z"/></g></g>', "corner-down-left-outline": '<g data-name="Layer 2"><g data-name="corner-down-left"><rect x=".05" y=".05" width="24" height="24" transform="rotate(-89.76 12.05 12.05)" opacity="0"/><path d="M20 6a1 1 0 0 0-1-1 1 1 0 0 0-1 1v5a1 1 0 0 1-.29.71A1 1 0 0 1 17 12H8.08l2.69-3.39a1 1 0 0 0-1.52-1.17l-4 5a1 1 0 0 0 0 1.25l4 5a1 1 0 0 0 .78.37 1 1 0 0 0 .62-.22 1 1 0 0 0 .15-1.41l-2.66-3.36h8.92a3 3 0 0 0 3-3z"/></g></g>', "corner-down-right-outline": '<g data-name="Layer 2"><g data-name="corner-down-right"><rect width="24" height="24" transform="rotate(-90 12 12)" opacity="0"/><path d="M19.78 12.38l-4-5a1 1 0 0 0-1.56 1.24l2.7 3.38H8a1 1 0 0 1-1-1V6a1 1 0 0 0-2 0v5a3 3 0 0 0 3 3h8.92l-2.7 3.38a1 1 0 0 0 .16 1.4A1 1 0 0 0 15 19a1 1 0 0 0 .78-.38l4-5a1 1 0 0 0 0-1.24z"/></g></g>', "corner-left-down-outline": '<g data-name="Layer 2"><g data-name="corner-left-down"><rect width="24" height="24" opacity="0"/><path d="M18 5h-5a3 3 0 0 0-3 3v8.92l-3.38-2.7a1 1 0 0 0-1.24 1.56l5 4a1 1 0 0 0 1.24 0l5-4a1 1 0 1 0-1.24-1.56L12 16.92V8a1 1 0 0 1 1-1h5a1 1 0 0 0 0-2z"/></g></g>', "corner-left-up-outline": '<g data-name="Layer 2"><g data-name="corner-left-up"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M18 17h-5a1 1 0 0 1-1-1V7.08l3.38 2.7A1 1 0 0 0 16 10a1 1 0 0 0 .78-.38 1 1 0 0 0-.16-1.4l-5-4a1 1 0 0 0-1.24 0l-5 4a1 1 0 0 0 1.24 1.56L10 7.08V16a3 3 0 0 0 3 3h5a1 1 0 0 0 0-2z"/></g></g>', "corner-right-down-outline": '<g data-name="Layer 2"><g data-name="corner-right-down"><rect width="24" height="24" opacity="0"/><path d="M18.78 14.38a1 1 0 0 0-1.4-.16L14 16.92V8a3 3 0 0 0-3-3H6a1 1 0 0 0 0 2h5a1 1 0 0 1 1 1v8.92l-3.38-2.7a1 1 0 0 0-1.24 1.56l5 4a1 1 0 0 0 1.24 0l5-4a1 1 0 0 0 .16-1.4z"/></g></g>', "corner-right-up-outline": '<g data-name="Layer 2"><g data-name="corner-right-up"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M18.62 8.22l-5-4a1 1 0 0 0-1.24 0l-5 4a1 1 0 0 0 1.24 1.56L12 7.08V16a1 1 0 0 1-1 1H6a1 1 0 0 0 0 2h5a3 3 0 0 0 3-3V7.08l3.38 2.7A1 1 0 0 0 18 10a1 1 0 0 0 .78-.38 1 1 0 0 0-.16-1.4z"/></g></g>', "corner-up-left-outline": '<g data-name="Layer 2"><g data-name="corner-up-left"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M16 10H7.08l2.7-3.38a1 1 0 1 0-1.56-1.24l-4 5a1 1 0 0 0 0 1.24l4 5A1 1 0 0 0 9 17a1 1 0 0 0 .62-.22 1 1 0 0 0 .16-1.4L7.08 12H16a1 1 0 0 1 1 1v5a1 1 0 0 0 2 0v-5a3 3 0 0 0-3-3z"/></g></g>', "corner-up-right-outline": '<g data-name="Layer 2"><g data-name="corner-up-right"><rect width="24" height="24" transform="rotate(-90 12 12)" opacity="0"/><path d="M19.78 10.38l-4-5a1 1 0 0 0-1.56 1.24l2.7 3.38H8a3 3 0 0 0-3 3v5a1 1 0 0 0 2 0v-5a1 1 0 0 1 1-1h8.92l-2.7 3.38a1 1 0 0 0 .16 1.4A1 1 0 0 0 15 17a1 1 0 0 0 .78-.38l4-5a1 1 0 0 0 0-1.24z"/></g></g>', "credit-card-outline": '<g data-name="Layer 2"><g data-name="credit-card"><rect width="24" height="24" opacity="0"/><path d="M19 5H5a3 3 0 0 0-3 3v8a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3V8a3 3 0 0 0-3-3zM4 8a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1v1H4zm16 8a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1v-5h16z"/><path d="M7 15h4a1 1 0 0 0 0-2H7a1 1 0 0 0 0 2z"/><path d="M15 15h2a1 1 0 0 0 0-2h-2a1 1 0 0 0 0 2z"/></g></g>', "crop-outline": '<g data-name="Layer 2"><g data-name="crop"><rect width="24" height="24" opacity="0"/><path d="M21 16h-3V8.56A2.56 2.56 0 0 0 15.44 6H8V3a1 1 0 0 0-2 0v3H3a1 1 0 0 0 0 2h3v7.44A2.56 2.56 0 0 0 8.56 18H16v3a1 1 0 0 0 2 0v-3h3a1 1 0 0 0 0-2zM8.56 16a.56.56 0 0 1-.56-.56V8h7.44a.56.56 0 0 1 .56.56V16z"/></g></g>', "cube-outline": '<g data-name="Layer 2"><g data-name="cube"><rect width="24" height="24" opacity="0"/><path d="M20.66 7.26c0-.07-.1-.14-.15-.21l-.09-.1a2.5 2.5 0 0 0-.86-.68l-6.4-3a2.7 2.7 0 0 0-2.26 0l-6.4 3a2.6 2.6 0 0 0-.86.68L3.52 7a1 1 0 0 0-.15.2A2.39 2.39 0 0 0 3 8.46v7.06a2.49 2.49 0 0 0 1.46 2.26l6.4 3a2.7 2.7 0 0 0 2.27 0l6.4-3A2.49 2.49 0 0 0 21 15.54V8.46a2.39 2.39 0 0 0-.34-1.2zm-8.95-2.2a.73.73 0 0 1 .58 0l5.33 2.48L12 10.15 6.38 7.54zM5.3 16a.47.47 0 0 1-.3-.43V9.1l6 2.79v6.72zm13.39 0L13 18.61v-6.72l6-2.79v6.44a.48.48 0 0 1-.31.46z"/></g></g>', "diagonal-arrow-left-down-outline": '<g data-name="Layer 2"><g data-name="diagonal-arrow-left-down"><rect width="24" height="24" opacity="0"/><path d="M17.71 6.29a1 1 0 0 0-1.42 0L8 14.59V9a1 1 0 0 0-2 0v8a1 1 0 0 0 1 1h8a1 1 0 0 0 0-2H9.41l8.3-8.29a1 1 0 0 0 0-1.42z"/></g></g>', "diagonal-arrow-left-up-outline": '<g data-name="Layer 2"><g data-name="diagonal-arrow-left-up"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M17.71 16.29L9.42 8H15a1 1 0 0 0 0-2H7.05a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1H7a1 1 0 0 0 1-1V9.45l8.26 8.26a1 1 0 0 0 1.42 0 1 1 0 0 0 .03-1.42z"/></g></g>', "diagonal-arrow-right-down-outline": '<g data-name="Layer 2"><g data-name="diagonal-arrow-right-down"><rect width="24" height="24" transform="rotate(-90 12 12)" opacity="0"/><path d="M17 8a1 1 0 0 0-1 1v5.59l-8.29-8.3a1 1 0 0 0-1.42 1.42l8.3 8.29H9a1 1 0 0 0 0 2h8a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1z"/></g></g>', "diagonal-arrow-right-up-outline": '<g data-name="Layer 2"><g data-name="diagonal-arrow-right-up"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M18 7.05a1 1 0 0 0-1-1L9 6a1 1 0 0 0 0 2h5.56l-8.27 8.29a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0L16 9.42V15a1 1 0 0 0 1 1 1 1 0 0 0 1-1z"/></g></g>', "done-all-outline": '<g data-name="Layer 2"><g data-name="done-all"><rect width="24" height="24" opacity="0"/><path d="M16.62 6.21a1 1 0 0 0-1.41.17l-7 9-3.43-4.18a1 1 0 1 0-1.56 1.25l4.17 5.18a1 1 0 0 0 .78.37 1 1 0 0 0 .83-.38l7.83-10a1 1 0 0 0-.21-1.41z"/><path d="M21.62 6.21a1 1 0 0 0-1.41.17l-7 9-.61-.75-1.26 1.62 1.1 1.37a1 1 0 0 0 .78.37 1 1 0 0 0 .78-.38l7.83-10a1 1 0 0 0-.21-1.4z"/><path d="M8.71 13.06L10 11.44l-.2-.24a1 1 0 0 0-1.43-.2 1 1 0 0 0-.15 1.41z"/></g></g>', "download-outline": '<g data-name="Layer 2"><g data-name="download"><rect width="24" height="24" opacity="0"/><rect x="4" y="18" width="16" height="2" rx="1" ry="1"/><rect x="3" y="17" width="4" height="2" rx="1" ry="1" transform="rotate(-90 5 18)"/><rect x="17" y="17" width="4" height="2" rx="1" ry="1" transform="rotate(-90 19 18)"/><path d="M12 15a1 1 0 0 1-.58-.18l-4-2.82a1 1 0 0 1-.24-1.39 1 1 0 0 1 1.4-.24L12 12.76l3.4-2.56a1 1 0 0 1 1.2 1.6l-4 3a1 1 0 0 1-.6.2z"/><path d="M12 13a1 1 0 0 1-1-1V4a1 1 0 0 1 2 0v8a1 1 0 0 1-1 1z"/></g></g>', "droplet-off-outline": '<g data-name="Layer 2"><g data-name="droplet-off-outline"><rect width="24" height="24" opacity="0"/><path d="M12 19a5.4 5.4 0 0 1-3.88-1.64 5.73 5.73 0 0 1-.69-7.11L6 8.82a7.74 7.74 0 0 0 .7 9.94A7.37 7.37 0 0 0 12 21a7.36 7.36 0 0 0 4.58-1.59L15.15 18A5.43 5.43 0 0 1 12 19z"/><path d="M12 5.43l3.88 4a5.71 5.71 0 0 1 1.49 5.15L19 16.15A7.72 7.72 0 0 0 17.31 8l-4.6-4.7A1 1 0 0 0 12 3a1 1 0 0 0-.72.3L8.73 5.9l1.42 1.42z"/><path d="M20.71 19.29l-16-16a1 1 0 0 0-1.42 1.42l16 16a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42z"/></g></g>', "droplet-outline": '<g data-name="Layer 2"><g data-name="droplet-outline"><rect x=".1" y=".1" width="24" height="24" transform="rotate(.48 11.987 11.887)" opacity="0"/><path d="M12 21.1a7.4 7.4 0 0 1-5.28-2.28 7.73 7.73 0 0 1 .1-10.77l4.64-4.65a.94.94 0 0 1 .71-.3 1 1 0 0 1 .71.31l4.56 4.72a7.73 7.73 0 0 1-.09 10.77A7.33 7.33 0 0 1 12 21.1zm.13-15.57L8.24 9.45a5.74 5.74 0 0 0-.07 8A5.43 5.43 0 0 0 12 19.1a5.42 5.42 0 0 0 3.9-1.61 5.72 5.72 0 0 0 .06-8z"/></g></g>', "edit-2-outline": '<g data-name="Layer 2"><g data-name="edit-2"><rect width="24" height="24" opacity="0"/><path d="M19 20H5a1 1 0 0 0 0 2h14a1 1 0 0 0 0-2z"/><path d="M5 18h.09l4.17-.38a2 2 0 0 0 1.21-.57l9-9a1.92 1.92 0 0 0-.07-2.71L16.66 2.6A2 2 0 0 0 14 2.53l-9 9a2 2 0 0 0-.57 1.21L4 16.91a1 1 0 0 0 .29.8A1 1 0 0 0 5 18zM15.27 4L18 6.73l-2 1.95L13.32 6zm-8.9 8.91L12 7.32l2.7 2.7-5.6 5.6-3 .28z"/></g></g>', "edit-outline": '<g data-name="Layer 2"><g data-name="edit"><rect width="24" height="24" opacity="0"/><path d="M19.4 7.34L16.66 4.6A2 2 0 0 0 14 4.53l-9 9a2 2 0 0 0-.57 1.21L4 18.91a1 1 0 0 0 .29.8A1 1 0 0 0 5 20h.09l4.17-.38a2 2 0 0 0 1.21-.57l9-9a1.92 1.92 0 0 0-.07-2.71zM9.08 17.62l-3 .28.27-3L12 9.32l2.7 2.7zM16 10.68L13.32 8l1.95-2L18 8.73z"/></g></g>', "email-outline": '<g data-name="Layer 2"><g data-name="email"><rect width="24" height="24" opacity="0"/><path d="M19 4H5a3 3 0 0 0-3 3v10a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3V7a3 3 0 0 0-3-3zm-.67 2L12 10.75 5.67 6zM19 18H5a1 1 0 0 1-1-1V7.25l7.4 5.55a1 1 0 0 0 .6.2 1 1 0 0 0 .6-.2L20 7.25V17a1 1 0 0 1-1 1z"/></g></g>', "expand-outline": '<g data-name="Layer 2"><g data-name="expand"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M20 5a1 1 0 0 0-1-1h-5a1 1 0 0 0 0 2h2.57l-3.28 3.29a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0L18 7.42V10a1 1 0 0 0 1 1 1 1 0 0 0 1-1z"/><path d="M10.71 13.29a1 1 0 0 0-1.42 0L6 16.57V14a1 1 0 0 0-1-1 1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h5a1 1 0 0 0 0-2H7.42l3.29-3.29a1 1 0 0 0 0-1.42z"/></g></g>', "external-link-outline": '<g data-name="Layer 2"><g data-name="external-link"><rect width="24" height="24" opacity="0"/><path d="M20 11a1 1 0 0 0-1 1v6a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1h6a1 1 0 0 0 0-2H6a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3v-6a1 1 0 0 0-1-1z"/><path d="M16 5h1.58l-6.29 6.28a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0L19 6.42V8a1 1 0 0 0 1 1 1 1 0 0 0 1-1V4a1 1 0 0 0-1-1h-4a1 1 0 0 0 0 2z"/></g></g>', "eye-off-2-outline": '<g data-name="Layer 2"><g data-name="eye-off-2"><rect width="24" height="24" opacity="0"/><path d="M17.81 13.39A8.93 8.93 0 0 0 21 7.62a1 1 0 1 0-2-.24 7.07 7.07 0 0 1-14 0 1 1 0 1 0-2 .24 8.93 8.93 0 0 0 3.18 5.77l-2.3 2.32a1 1 0 0 0 1.41 1.41l2.61-2.6a9.06 9.06 0 0 0 3.1.92V19a1 1 0 0 0 2 0v-3.56a9.06 9.06 0 0 0 3.1-.92l2.61 2.6a1 1 0 0 0 1.41-1.41z"/></g></g>', "eye-off-outline": '<g data-name="Layer 2"><g data-name="eye-off"><rect width="24" height="24" opacity="0"/><path d="M4.71 3.29a1 1 0 0 0-1.42 1.42l5.63 5.63a3.5 3.5 0 0 0 4.74 4.74l5.63 5.63a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42zM12 13.5a1.5 1.5 0 0 1-1.5-1.5v-.07l1.56 1.56z"/><path d="M12.22 17c-4.3.1-7.12-3.59-8-5a13.7 13.7 0 0 1 2.24-2.72L5 7.87a15.89 15.89 0 0 0-2.87 3.63 1 1 0 0 0 0 1c.63 1.09 4 6.5 9.89 6.5h.25a9.48 9.48 0 0 0 3.23-.67l-1.58-1.58a7.74 7.74 0 0 1-1.7.25z"/><path d="M21.87 11.5c-.64-1.11-4.17-6.68-10.14-6.5a9.48 9.48 0 0 0-3.23.67l1.58 1.58a7.74 7.74 0 0 1 1.7-.25c4.29-.11 7.11 3.59 8 5a13.7 13.7 0 0 1-2.29 2.72L19 16.13a15.89 15.89 0 0 0 2.91-3.63 1 1 0 0 0-.04-1z"/></g></g>', "eye-outline": '<g data-name="Layer 2"><g data-name="eye"><rect width="24" height="24" opacity="0"/><path d="M21.87 11.5c-.64-1.11-4.16-6.68-10.14-6.5-5.53.14-8.73 5-9.6 6.5a1 1 0 0 0 0 1c.63 1.09 4 6.5 9.89 6.5h.25c5.53-.14 8.74-5 9.6-6.5a1 1 0 0 0 0-1zM12.22 17c-4.31.1-7.12-3.59-8-5 1-1.61 3.61-4.9 7.61-5 4.29-.11 7.11 3.59 8 5-1.03 1.61-3.61 4.9-7.61 5z"/><path d="M12 8.5a3.5 3.5 0 1 0 3.5 3.5A3.5 3.5 0 0 0 12 8.5zm0 5a1.5 1.5 0 1 1 1.5-1.5 1.5 1.5 0 0 1-1.5 1.5z"/></g></g>', "facebook-outline": '<g data-name="Layer 2"><g data-name="facebook"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M13 22H9a1 1 0 0 1-1-1v-6.2H6a1 1 0 0 1-1-1v-3.6a1 1 0 0 1 1-1h2V7.5A5.77 5.77 0 0 1 14 2h3a1 1 0 0 1 1 1v3.6a1 1 0 0 1-1 1h-3v1.6h3a1 1 0 0 1 .8.39 1 1 0 0 1 .16.88l-1 3.6a1 1 0 0 1-1 .73H14V21a1 1 0 0 1-1 1zm-3-2h2v-6.2a1 1 0 0 1 1-1h2.24l.44-1.6H13a1 1 0 0 1-1-1V7.5a2 2 0 0 1 2-1.9h2V4h-2a3.78 3.78 0 0 0-4 3.5v2.7a1 1 0 0 1-1 1H7v1.6h2a1 1 0 0 1 1 1z"/></g></g>', "file-add-outline": '<g data-name="Layer 2"><g data-name="file-add"><rect width="24" height="24" opacity="0"/><path d="M19.74 8.33l-5.44-6a1 1 0 0 0-.74-.33h-7A2.53 2.53 0 0 0 4 4.5v15A2.53 2.53 0 0 0 6.56 22h10.88A2.53 2.53 0 0 0 20 19.5V9a1 1 0 0 0-.26-.67zM14 5l2.74 3h-2a.79.79 0 0 1-.74-.85zm3.44 15H6.56a.53.53 0 0 1-.56-.5v-15a.53.53 0 0 1 .56-.5H12v3.15A2.79 2.79 0 0 0 14.71 10H18v9.5a.53.53 0 0 1-.56.5z"/><path d="M14 13h-1v-1a1 1 0 0 0-2 0v1h-1a1 1 0 0 0 0 2h1v1a1 1 0 0 0 2 0v-1h1a1 1 0 0 0 0-2z"/></g></g>', "file-outline": '<g data-name="Layer 2"><g data-name="file"><rect width="24" height="24" opacity="0"/><path d="M19.74 8.33l-5.44-6a1 1 0 0 0-.74-.33h-7A2.53 2.53 0 0 0 4 4.5v15A2.53 2.53 0 0 0 6.56 22h10.88A2.53 2.53 0 0 0 20 19.5V9a1 1 0 0 0-.26-.67zM17.65 9h-3.94a.79.79 0 0 1-.71-.85V4h.11zm-.21 11H6.56a.53.53 0 0 1-.56-.5v-15a.53.53 0 0 1 .56-.5H11v4.15A2.79 2.79 0 0 0 13.71 11H18v8.5a.53.53 0 0 1-.56.5z"/></g></g>', "file-remove-outline": '<g data-name="Layer 2"><g data-name="file-remove"><rect width="24" height="24" opacity="0"/><path d="M19.74 8.33l-5.44-6a1 1 0 0 0-.74-.33h-7A2.53 2.53 0 0 0 4 4.5v15A2.53 2.53 0 0 0 6.56 22h10.88A2.53 2.53 0 0 0 20 19.5V9a1 1 0 0 0-.26-.67zM14 5l2.74 3h-2a.79.79 0 0 1-.74-.85zm3.44 15H6.56a.53.53 0 0 1-.56-.5v-15a.53.53 0 0 1 .56-.5H12v3.15A2.79 2.79 0 0 0 14.71 10H18v9.5a.53.53 0 0 1-.56.5z"/><path d="M14 13h-4a1 1 0 0 0 0 2h4a1 1 0 0 0 0-2z"/></g></g>', "file-text-outline": '<g data-name="Layer 2"><g data-name="file-text"><rect width="24" height="24" opacity="0"/><path d="M15 16H9a1 1 0 0 0 0 2h6a1 1 0 0 0 0-2z"/><path d="M9 14h3a1 1 0 0 0 0-2H9a1 1 0 0 0 0 2z"/><path d="M19.74 8.33l-5.44-6a1 1 0 0 0-.74-.33h-7A2.53 2.53 0 0 0 4 4.5v15A2.53 2.53 0 0 0 6.56 22h10.88A2.53 2.53 0 0 0 20 19.5V9a1 1 0 0 0-.26-.67zM14 5l2.74 3h-2a.79.79 0 0 1-.74-.85zm3.44 15H6.56a.53.53 0 0 1-.56-.5v-15a.53.53 0 0 1 .56-.5H12v3.15A2.79 2.79 0 0 0 14.71 10H18v9.5a.53.53 0 0 1-.56.5z"/></g></g>', "film-outline": '<g data-name="Layer 2"><g data-name="film"><rect width="24" height="24" opacity="0"/><path d="M18.26 3H5.74A2.74 2.74 0 0 0 3 5.74v12.52A2.74 2.74 0 0 0 5.74 21h12.52A2.74 2.74 0 0 0 21 18.26V5.74A2.74 2.74 0 0 0 18.26 3zM7 11H5V9h2zm-2 2h2v2H5zm4-8h6v14H9zm10 6h-2V9h2zm-2 2h2v2h-2zm2-7.26V7h-2V5h1.26a.74.74 0 0 1 .74.74zM5.74 5H7v2H5V5.74A.74.74 0 0 1 5.74 5zM5 18.26V17h2v2H5.74a.74.74 0 0 1-.74-.74zm14 0a.74.74 0 0 1-.74.74H17v-2h2z"/></g></g>', "flag-outline": '<g data-name="Layer 2"><g data-name="flag"><polyline points="24 24 0 24 0 0" opacity="0"/><path d="M19.27 4.68a1.79 1.79 0 0 0-1.6-.25 7.53 7.53 0 0 1-2.17.28 8.54 8.54 0 0 1-3.13-.78A10.15 10.15 0 0 0 8.5 3c-2.89 0-4 1-4.2 1.14a1 1 0 0 0-.3.72V20a1 1 0 0 0 2 0v-4.3a6.28 6.28 0 0 1 2.5-.41 8.54 8.54 0 0 1 3.13.78 10.15 10.15 0 0 0 3.87.93 7.66 7.66 0 0 0 3.5-.7 1.74 1.74 0 0 0 1-1.55V6.11a1.77 1.77 0 0 0-.73-1.43zM18 14.59a6.32 6.32 0 0 1-2.5.41 8.36 8.36 0 0 1-3.13-.79 10.34 10.34 0 0 0-3.87-.92 9.51 9.51 0 0 0-2.5.29V5.42A6.13 6.13 0 0 1 8.5 5a8.36 8.36 0 0 1 3.13.79 10.34 10.34 0 0 0 3.87.92 9.41 9.41 0 0 0 2.5-.3z"/></g></g>', "flash-off-outline": '<g data-name="Layer 2"><g data-name="flash-off"><rect width="24" height="24" opacity="0"/><path d="M20.71 19.29l-16-16a1 1 0 0 0-1.42 1.42l16 16a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42z"/><path d="M12.54 18.06l.27-2.42L10 12.8H6.87l1.24-1.86L6.67 9.5l-2.5 3.74A1 1 0 0 0 5 14.8h5.89l-.77 7.09a1 1 0 0 0 .65 1.05 1 1 0 0 0 .34.06 1 1 0 0 0 .83-.44l3.12-4.67-1.44-1.44z"/><path d="M11.46 5.94l-.27 2.42L14 11.2h3.1l-1.24 1.86 1.44 1.44 2.5-3.74A1 1 0 0 0 19 9.2h-5.89l.77-7.09a1 1 0 0 0-.65-1 1 1 0 0 0-1.17.38L8.94 6.11l1.44 1.44z"/></g></g>', "flash-outline": '<g data-name="Layer 2"><g data-name="flash"><rect width="24" height="24" opacity="0"/><path d="M11.11 23a1 1 0 0 1-.34-.06 1 1 0 0 1-.65-1.05l.77-7.09H5a1 1 0 0 1-.83-1.56l7.89-11.8a1 1 0 0 1 1.17-.38 1 1 0 0 1 .65 1l-.77 7.14H19a1 1 0 0 1 .83 1.56l-7.89 11.8a1 1 0 0 1-.83.44zM6.87 12.8H12a1 1 0 0 1 .74.33 1 1 0 0 1 .25.78l-.45 4.15 4.59-6.86H12a1 1 0 0 1-1-1.11l.45-4.15z"/></g></g>', "flip-2-outline": '<g data-name="Layer 2"><g data-name="flip-2"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M6.09 19h12l-1.3 1.29a1 1 0 0 0 1.42 1.42l3-3a1 1 0 0 0 0-1.42l-3-3a1 1 0 0 0-1.42 0 1 1 0 0 0 0 1.42l1.3 1.29h-12a1.56 1.56 0 0 1-1.59-1.53V13a1 1 0 0 0-2 0v2.47A3.56 3.56 0 0 0 6.09 19z"/><path d="M5.79 9.71a1 1 0 1 0 1.42-1.42L5.91 7h12a1.56 1.56 0 0 1 1.59 1.53V11a1 1 0 0 0 2 0V8.53A3.56 3.56 0 0 0 17.91 5h-12l1.3-1.29a1 1 0 0 0 0-1.42 1 1 0 0 0-1.42 0l-3 3a1 1 0 0 0 0 1.42z"/></g></g>', "flip-outline": '<g data-name="Layer 2"><g data-name="flip-in"><rect width="24" height="24" transform="rotate(-90 12 12)" opacity="0"/><path d="M5 6.09v12l-1.29-1.3a1 1 0 0 0-1.42 1.42l3 3a1 1 0 0 0 1.42 0l3-3a1 1 0 0 0 0-1.42 1 1 0 0 0-1.42 0L7 18.09v-12A1.56 1.56 0 0 1 8.53 4.5H11a1 1 0 0 0 0-2H8.53A3.56 3.56 0 0 0 5 6.09z"/><path d="M14.29 5.79a1 1 0 0 0 1.42 1.42L17 5.91v12a1.56 1.56 0 0 1-1.53 1.59H13a1 1 0 0 0 0 2h2.47A3.56 3.56 0 0 0 19 17.91v-12l1.29 1.3a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42l-3-3a1 1 0 0 0-1.42 0z"/></g></g>', "folder-add-outline": '<g data-name="Layer 2"><g data-name="folder-add"><rect width="24" height="24" opacity="0"/><path d="M14 13h-1v-1a1 1 0 0 0-2 0v1h-1a1 1 0 0 0 0 2h1v1a1 1 0 0 0 2 0v-1h1a1 1 0 0 0 0-2z"/><path d="M19.5 7.05h-7L9.87 3.87a1 1 0 0 0-.77-.37H4.5A2.47 2.47 0 0 0 2 5.93v12.14a2.47 2.47 0 0 0 2.5 2.43h15a2.47 2.47 0 0 0 2.5-2.43V9.48a2.47 2.47 0 0 0-2.5-2.43zm.5 11a.46.46 0 0 1-.5.43h-15a.46.46 0 0 1-.5-.43V5.93a.46.46 0 0 1 .5-.43h4.13l2.6 3.18a1 1 0 0 0 .77.37h7.5a.46.46 0 0 1 .5.43z"/></g></g>', "folder-outline": '<g data-name="Layer 2"><g data-name="folder"><rect width="24" height="24" opacity="0"/><path d="M19.5 20.5h-15A2.47 2.47 0 0 1 2 18.07V5.93A2.47 2.47 0 0 1 4.5 3.5h4.6a1 1 0 0 1 .77.37l2.6 3.18h7A2.47 2.47 0 0 1 22 9.48v8.59a2.47 2.47 0 0 1-2.5 2.43zM4 13.76v4.31a.46.46 0 0 0 .5.43h15a.46.46 0 0 0 .5-.43V9.48a.46.46 0 0 0-.5-.43H12a1 1 0 0 1-.77-.37L8.63 5.5H4.5a.46.46 0 0 0-.5.43z"/></g></g>', "folder-remove-outline": '<g data-name="Layer 2"><g data-name="folder-remove"><rect width="24" height="24" opacity="0"/><path d="M14 13h-4a1 1 0 0 0 0 2h4a1 1 0 0 0 0-2z"/><path d="M19.5 7.05h-7L9.87 3.87a1 1 0 0 0-.77-.37H4.5A2.47 2.47 0 0 0 2 5.93v12.14a2.47 2.47 0 0 0 2.5 2.43h15a2.47 2.47 0 0 0 2.5-2.43V9.48a2.47 2.47 0 0 0-2.5-2.43zm.5 11a.46.46 0 0 1-.5.43h-15a.46.46 0 0 1-.5-.43V5.93a.46.46 0 0 1 .5-.43h4.13l2.6 3.18a1 1 0 0 0 .77.37h7.5a.46.46 0 0 1 .5.43z"/></g></g>', "funnel-outline": '<g data-name="Layer 2"><g data-name="funnel"><rect width="24" height="24" opacity="0"/><path d="M13.9 22a1 1 0 0 1-.6-.2l-4-3.05a1 1 0 0 1-.39-.8v-3.27l-4.8-9.22A1 1 0 0 1 5 4h14a1 1 0 0 1 .86.49 1 1 0 0 1 0 1l-5 9.21V21a1 1 0 0 1-.55.9 1 1 0 0 1-.41.1zm-3-4.54l2 1.53v-4.55A1 1 0 0 1 13 14l4.3-8H6.64l4.13 8a1 1 0 0 1 .11.46z"/></g></g>', "gift-outline": '<g data-name="Layer 2"><g data-name="gift"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M19.2 7h-.39A3 3 0 0 0 19 6a3.08 3.08 0 0 0-3.14-3A4.46 4.46 0 0 0 12 5.4 4.46 4.46 0 0 0 8.14 3 3.08 3.08 0 0 0 5 6a3 3 0 0 0 .19 1H4.8A2 2 0 0 0 3 9.2v3.6A2.08 2.08 0 0 0 4.5 15v4.37A1.75 1.75 0 0 0 6.31 21h11.38a1.75 1.75 0 0 0 1.81-1.67V15a2.08 2.08 0 0 0 1.5-2.2V9.2A2 2 0 0 0 19.2 7zM19 9.2v3.6a.56.56 0 0 1 0 .2h-6V9h6a.56.56 0 0 1 0 .2zM15.86 5A1.08 1.08 0 0 1 17 6a1.08 1.08 0 0 1-1.14 1H13.4a2.93 2.93 0 0 1 2.46-2zM7 6a1.08 1.08 0 0 1 1.14-1 2.93 2.93 0 0 1 2.45 2H8.14A1.08 1.08 0 0 1 7 6zM5 9.2A.56.56 0 0 1 5 9h6v4H5a.56.56 0 0 1 0-.2zM6.5 15H11v4H6.5zm6.5 4v-4h4.5v4z"/></g></g>', "github-outline": '<g data-name="Layer 2"><rect width="24" height="24" opacity="0"/><path d="M16.24 22a1 1 0 0 1-1-1v-2.6a2.15 2.15 0 0 0-.54-1.66 1 1 0 0 1 .61-1.67C17.75 14.78 20 14 20 9.77a4 4 0 0 0-.67-2.22 2.75 2.75 0 0 1-.41-2.06 3.71 3.71 0 0 0 0-1.41 7.65 7.65 0 0 0-2.09 1.09 1 1 0 0 1-.84.15 10.15 10.15 0 0 0-5.52 0 1 1 0 0 1-.84-.15 7.4 7.4 0 0 0-2.11-1.09 3.52 3.52 0 0 0 0 1.41 2.84 2.84 0 0 1-.43 2.08 4.07 4.07 0 0 0-.67 2.23c0 3.89 1.88 4.93 4.7 5.29a1 1 0 0 1 .82.66 1 1 0 0 1-.21 1 2.06 2.06 0 0 0-.55 1.56V21a1 1 0 0 1-2 0v-.57a6 6 0 0 1-5.27-2.09 3.9 3.9 0 0 0-1.16-.88 1 1 0 1 1 .5-1.94 4.93 4.93 0 0 1 2 1.36c1 1 2 1.88 3.9 1.52a3.89 3.89 0 0 1 .23-1.58c-2.06-.52-5-2-5-7a6 6 0 0 1 1-3.33.85.85 0 0 0 .13-.62 5.69 5.69 0 0 1 .33-3.21 1 1 0 0 1 .63-.57c.34-.1 1.56-.3 3.87 1.2a12.16 12.16 0 0 1 5.69 0c2.31-1.5 3.53-1.31 3.86-1.2a1 1 0 0 1 .63.57 5.71 5.71 0 0 1 .33 3.22.75.75 0 0 0 .11.57 6 6 0 0 1 1 3.34c0 5.07-2.92 6.54-5 7a4.28 4.28 0 0 1 .22 1.67V21a1 1 0 0 1-.94 1z"/></g>', "globe-2-outline": '<g data-name="Layer 2"><g data-name="globe-2"><rect width="24" height="24" opacity="0"/><rect width="24" height="24" opacity="0"/><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 2a8.19 8.19 0 0 1 1.79.21 2.61 2.61 0 0 1-.78 1c-.22.17-.46.31-.7.46a4.56 4.56 0 0 0-1.85 1.67 6.49 6.49 0 0 0-.62 3.3c0 1.36 0 2.16-.95 2.87-1.37 1.07-3.46.47-4.76-.07A8.33 8.33 0 0 1 4 12a8 8 0 0 1 8-8zM5 15.8a8.42 8.42 0 0 0 2 .27 5 5 0 0 0 3.14-1c1.71-1.34 1.71-3.06 1.71-4.44a4.76 4.76 0 0 1 .37-2.34 2.86 2.86 0 0 1 1.12-.91 9.75 9.75 0 0 0 .92-.61 4.55 4.55 0 0 0 1.4-1.87A8 8 0 0 1 19 8.12c-1.43.2-3.46.67-3.86 2.53A7 7 0 0 0 15 12a2.93 2.93 0 0 1-.29 1.47l-.1.17c-.65 1.08-1.38 2.31-.39 4 .12.21.25.41.38.61a2.29 2.29 0 0 1 .52 1.08A7.89 7.89 0 0 1 12 20a8 8 0 0 1-7-4.2zm11.93 2.52a6.79 6.79 0 0 0-.63-1.14c-.11-.16-.22-.32-.32-.49-.39-.68-.25-1 .38-2l.1-.17a4.77 4.77 0 0 0 .54-2.43 5.42 5.42 0 0 1 .09-1c.16-.73 1.71-.93 2.67-1a7.94 7.94 0 0 1-2.86 8.28z"/></g></g>', "globe-outline": '<g data-name="Layer 2"><g data-name="globe"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M22 12A10 10 0 0 0 12 2a10 10 0 0 0 0 20 10 10 0 0 0 10-10zm-2.07-1H17a12.91 12.91 0 0 0-2.33-6.54A8 8 0 0 1 19.93 11zM9.08 13H15a11.44 11.44 0 0 1-3 6.61A11 11 0 0 1 9.08 13zm0-2A11.4 11.4 0 0 1 12 4.4a11.19 11.19 0 0 1 3 6.6zm.36-6.57A13.18 13.18 0 0 0 7.07 11h-3a8 8 0 0 1 5.37-6.57zM4.07 13h3a12.86 12.86 0 0 0 2.35 6.56A8 8 0 0 1 4.07 13zm10.55 6.55A13.14 13.14 0 0 0 17 13h2.95a8 8 0 0 1-5.33 6.55z"/></g></g>', "google-outline": '<g data-name="Layer 2"><g data-name="google"><polyline points="0 0 24 0 24 24 0 24" opacity="0"/><path d="M12 22h-.43A10.16 10.16 0 0 1 2 12.29a10 10 0 0 1 14.12-9.41 1.48 1.48 0 0 1 .77.86 1.47 1.47 0 0 1-.1 1.16L15.5 7.28a1.44 1.44 0 0 1-1.83.64A4.5 4.5 0 0 0 8.77 9a4.41 4.41 0 0 0-1.16 3.34 4.36 4.36 0 0 0 1.66 3 4.52 4.52 0 0 0 3.45 1 3.89 3.89 0 0 0 2.63-1.57h-2.9A1.45 1.45 0 0 1 11 13.33v-2.68a1.45 1.45 0 0 1 1.45-1.45h8.1A1.46 1.46 0 0 1 22 10.64v1.88A10 10 0 0 1 12 22zm0-18a8 8 0 0 0-8 8.24A8.12 8.12 0 0 0 11.65 20 8 8 0 0 0 20 12.42V11.2h-7v1.58h5.31l-.41 1.3a6 6 0 0 1-4.9 4.25A6.58 6.58 0 0 1 8 17a6.33 6.33 0 0 1-.72-9.3A6.52 6.52 0 0 1 14 5.91l.77-1.43A7.9 7.9 0 0 0 12 4z"/></g></g>', "grid-outline": '<g data-name="Layer 2"><g data-name="grid"><rect width="24" height="24" opacity="0"/><path d="M9 3H5a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2zM5 9V5h4v4z"/><path d="M19 3h-4a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2zm-4 6V5h4v4z"/><path d="M9 13H5a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2zm-4 6v-4h4v4z"/><path d="M19 13h-4a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2zm-4 6v-4h4v4z"/></g></g>', "hard-drive-outline": '<g data-name="Layer 2"><g data-name="hard-drive"><rect width="24" height="24" opacity="0"/><path d="M20.79 11.34l-3.34-6.68A3 3 0 0 0 14.76 3H9.24a3 3 0 0 0-2.69 1.66l-3.34 6.68a2 2 0 0 0-.21.9V18a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3v-5.76a2 2 0 0 0-.21-.9zM8.34 5.55a1 1 0 0 1 .9-.55h5.52a1 1 0 0 1 .9.55L18.38 11H5.62zM18 19H6a1 1 0 0 1-1-1v-5h14v5a1 1 0 0 1-1 1z"/><path d="M16 15h-4a1 1 0 0 0 0 2h4a1 1 0 0 0 0-2z"/><circle cx="8" cy="16" r="1"/></g></g>', "hash-outline": '<g data-name="Layer 2"><g data-name="hash"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M20 14h-4.3l.73-4H20a1 1 0 0 0 0-2h-3.21l.69-3.81A1 1 0 0 0 16.64 3a1 1 0 0 0-1.22.82L14.67 8h-3.88l.69-3.81A1 1 0 0 0 10.64 3a1 1 0 0 0-1.22.82L8.67 8H4a1 1 0 0 0 0 2h4.3l-.73 4H4a1 1 0 0 0 0 2h3.21l-.69 3.81A1 1 0 0 0 7.36 21a1 1 0 0 0 1.22-.82L9.33 16h3.88l-.69 3.81a1 1 0 0 0 .84 1.19 1 1 0 0 0 1.22-.82l.75-4.18H20a1 1 0 0 0 0-2zM9.7 14l.73-4h3.87l-.73 4z"/></g></g>', "headphones-outline": '<g data-name="Layer 2"><g data-name="headphones"><rect width="24" height="24" opacity="0"/><path d="M12 2A10.2 10.2 0 0 0 2 12.37V17a4 4 0 1 0 4-4 3.91 3.91 0 0 0-2 .56v-1.19A8.2 8.2 0 0 1 12 4a8.2 8.2 0 0 1 8 8.37v1.19a3.91 3.91 0 0 0-2-.56 4 4 0 1 0 4 4v-4.63A10.2 10.2 0 0 0 12 2zM6 15a2 2 0 1 1-2 2 2 2 0 0 1 2-2zm12 4a2 2 0 1 1 2-2 2 2 0 0 1-2 2z"/></g></g>', "heart-outline": '<g data-name="Layer 2"><g data-name="heart"><rect width="24" height="24" opacity="0"/><path d="M12 21a1 1 0 0 1-.71-.29l-7.77-7.78a5.26 5.26 0 0 1 0-7.4 5.24 5.24 0 0 1 7.4 0L12 6.61l1.08-1.08a5.24 5.24 0 0 1 7.4 0 5.26 5.26 0 0 1 0 7.4l-7.77 7.78A1 1 0 0 1 12 21zM7.22 6a3.2 3.2 0 0 0-2.28.94 3.24 3.24 0 0 0 0 4.57L12 18.58l7.06-7.07a3.24 3.24 0 0 0 0-4.57 3.32 3.32 0 0 0-4.56 0l-1.79 1.8a1 1 0 0 1-1.42 0L9.5 6.94A3.2 3.2 0 0 0 7.22 6z"/></g></g>', "home-outline": '<g data-name="Layer 2"><g data-name="home"><rect width="24" height="24" opacity="0"/><path d="M20.42 10.18L12.71 2.3a1 1 0 0 0-1.42 0l-7.71 7.89A2 2 0 0 0 3 11.62V20a2 2 0 0 0 1.89 2h14.22A2 2 0 0 0 21 20v-8.38a2.07 2.07 0 0 0-.58-1.44zM10 20v-6h4v6zm9 0h-3v-7a1 1 0 0 0-1-1H9a1 1 0 0 0-1 1v7H5v-8.42l7-7.15 7 7.19z"/></g></g>', "image-outline": '<g data-name="Layer 2"><g data-name="image"><rect width="24" height="24" opacity="0"/><path d="M18 3H6a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3V6a3 3 0 0 0-3-3zM6 5h12a1 1 0 0 1 1 1v8.36l-3.2-2.73a2.77 2.77 0 0 0-3.52 0L5 17.7V6a1 1 0 0 1 1-1zm12 14H6.56l7-5.84a.78.78 0 0 1 .93 0L19 17v1a1 1 0 0 1-1 1z"/><circle cx="8" cy="8.5" r="1.5"/></g></g>', "inbox-outline": '<g data-name="Layer 2"><g data-name="inbox"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M20.79 11.34l-3.34-6.68A3 3 0 0 0 14.76 3H9.24a3 3 0 0 0-2.69 1.66l-3.34 6.68a2 2 0 0 0-.21.9V18a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3v-5.76a2 2 0 0 0-.21-.9zM8.34 5.55a1 1 0 0 1 .9-.55h5.52a1 1 0 0 1 .9.55L18.38 11H16a1 1 0 0 0-1 1v3H9v-3a1 1 0 0 0-1-1H5.62zM18 19H6a1 1 0 0 1-1-1v-5h2v3a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-3h2v5a1 1 0 0 1-1 1z"/></g></g>', "info-outline": '<g data-name="Layer 2"><g data-name="info"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 18a8 8 0 1 1 8-8 8 8 0 0 1-8 8z"/><circle cx="12" cy="8" r="1"/><path d="M12 10a1 1 0 0 0-1 1v5a1 1 0 0 0 2 0v-5a1 1 0 0 0-1-1z"/></g></g>', "keypad-outline": '<g data-name="Layer 2"><g data-name="keypad"><rect width="24" height="24" opacity="0"/><path d="M5 2a3 3 0 1 0 3 3 3 3 0 0 0-3-3zm0 4a1 1 0 1 1 1-1 1 1 0 0 1-1 1z"/><path d="M12 2a3 3 0 1 0 3 3 3 3 0 0 0-3-3zm0 4a1 1 0 1 1 1-1 1 1 0 0 1-1 1z"/><path d="M19 8a3 3 0 1 0-3-3 3 3 0 0 0 3 3zm0-4a1 1 0 1 1-1 1 1 1 0 0 1 1-1z"/><path d="M5 9a3 3 0 1 0 3 3 3 3 0 0 0-3-3zm0 4a1 1 0 1 1 1-1 1 1 0 0 1-1 1z"/><path d="M12 9a3 3 0 1 0 3 3 3 3 0 0 0-3-3zm0 4a1 1 0 1 1 1-1 1 1 0 0 1-1 1z"/><path d="M19 9a3 3 0 1 0 3 3 3 3 0 0 0-3-3zm0 4a1 1 0 1 1 1-1 1 1 0 0 1-1 1z"/><path d="M5 16a3 3 0 1 0 3 3 3 3 0 0 0-3-3zm0 4a1 1 0 1 1 1-1 1 1 0 0 1-1 1z"/><path d="M12 16a3 3 0 1 0 3 3 3 3 0 0 0-3-3zm0 4a1 1 0 1 1 1-1 1 1 0 0 1-1 1z"/><path d="M19 16a3 3 0 1 0 3 3 3 3 0 0 0-3-3zm0 4a1 1 0 1 1 1-1 1 1 0 0 1-1 1z"/></g></g>', "layers-outline": '<g data-name="Layer 2"><g data-name="layers"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M21 11.35a1 1 0 0 0-.61-.86l-2.15-.92 2.26-1.3a1 1 0 0 0 .5-.92 1 1 0 0 0-.61-.86l-8-3.41a1 1 0 0 0-.78 0l-8 3.41a1 1 0 0 0-.61.86 1 1 0 0 0 .5.92l2.26 1.3-2.15.92a1 1 0 0 0-.61.86 1 1 0 0 0 .5.92l2.26 1.3-2.15.92a1 1 0 0 0-.61.86 1 1 0 0 0 .5.92l8 4.6a1 1 0 0 0 1 0l8-4.6a1 1 0 0 0 .5-.92 1 1 0 0 0-.61-.86l-2.15-.92 2.26-1.3a1 1 0 0 0 .5-.92zm-9-6.26l5.76 2.45L12 10.85 6.24 7.54zm-.5 7.78a1 1 0 0 0 1 0l3.57-2 1.69.72L12 14.85l-5.76-3.31 1.69-.72zm6.26 2.67L12 18.85l-5.76-3.31 1.69-.72 3.57 2.05a1 1 0 0 0 1 0l3.57-2.05z"/></g></g>', "layout-outline": '<g data-name="Layer 2"><g data-name="layout"><rect width="24" height="24" opacity="0"/><path d="M18 3H6a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3V6a3 3 0 0 0-3-3zM6 5h12a1 1 0 0 1 1 1v2H5V6a1 1 0 0 1 1-1zM5 18v-8h6v9H6a1 1 0 0 1-1-1zm13 1h-5v-9h6v8a1 1 0 0 1-1 1z"/></g></g>', "link-2-outline": '<g data-name="Layer 2"><g data-name="link-2"><rect width="24" height="24" opacity="0"/><path d="M13.29 9.29l-4 4a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0l4-4a1 1 0 0 0-1.42-1.42z"/><path d="M12.28 17.4L11 18.67a4.2 4.2 0 0 1-5.58.4 4 4 0 0 1-.27-5.93l1.42-1.43a1 1 0 0 0 0-1.42 1 1 0 0 0-1.42 0l-1.27 1.28a6.15 6.15 0 0 0-.67 8.07 6.06 6.06 0 0 0 9.07.6l1.42-1.42a1 1 0 0 0-1.42-1.42z"/><path d="M19.66 3.22a6.18 6.18 0 0 0-8.13.68L10.45 5a1.09 1.09 0 0 0-.17 1.61 1 1 0 0 0 1.42 0L13 5.3a4.17 4.17 0 0 1 5.57-.4 4 4 0 0 1 .27 5.95l-1.42 1.43a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0l1.42-1.42a6.06 6.06 0 0 0-.6-9.06z"/></g></g>', "link-outline": '<g data-name="Layer 2"><g data-name="link"><rect width="24" height="24" opacity="0"/><path d="M8 12a1 1 0 0 0 1 1h6a1 1 0 0 0 0-2H9a1 1 0 0 0-1 1z"/><path d="M9 16H7.21A4.13 4.13 0 0 1 3 12.37 4 4 0 0 1 7 8h2a1 1 0 0 0 0-2H7.21a6.15 6.15 0 0 0-6.16 5.21A6 6 0 0 0 7 18h2a1 1 0 0 0 0-2z"/><path d="M23 11.24A6.16 6.16 0 0 0 16.76 6h-1.51C14.44 6 14 6.45 14 7a1 1 0 0 0 1 1h1.79A4.13 4.13 0 0 1 21 11.63 4 4 0 0 1 17 16h-2a1 1 0 0 0 0 2h2a6 6 0 0 0 6-6.76z"/></g></g>', "linkedin-outline": '<g data-name="Layer 2"><g data-name="linkedin"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M20 22h-1.67a2 2 0 0 1-2-2v-5.37a.92.92 0 0 0-.69-.93.84.84 0 0 0-.67.19.85.85 0 0 0-.3.65V20a2 2 0 0 1-2 2H11a2 2 0 0 1-2-2v-5.46a6.5 6.5 0 1 1 13 0V20a2 2 0 0 1-2 2zm-4.5-10.31a3.73 3.73 0 0 1 .47 0 2.91 2.91 0 0 1 2.36 2.9V20H20v-5.46a4.5 4.5 0 1 0-9 0V20h1.67v-5.46a2.85 2.85 0 0 1 2.83-2.85z"/><path d="M6 22H4a2 2 0 0 1-2-2V10a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2zM4 10v10h2V10z"/><path d="M5 7a3 3 0 1 1 3-3 3 3 0 0 1-3 3zm0-4a1 1 0 1 0 1 1 1 1 0 0 0-1-1z"/></g></g>', "list-outline": '<g data-name="Layer 2"><g data-name="list"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><circle cx="4" cy="7" r="1"/><circle cx="4" cy="12" r="1"/><circle cx="4" cy="17" r="1"/><rect x="7" y="11" width="14" height="2" rx=".94" ry=".94"/><rect x="7" y="16" width="14" height="2" rx=".94" ry=".94"/><rect x="7" y="6" width="14" height="2" rx=".94" ry=".94"/></g></g>', "loader-outline": '<g data-name="Layer 2"><g data-name="loader"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M12 2a1 1 0 0 0-1 1v2a1 1 0 0 0 2 0V3a1 1 0 0 0-1-1z"/><path d="M21 11h-2a1 1 0 0 0 0 2h2a1 1 0 0 0 0-2z"/><path d="M6 12a1 1 0 0 0-1-1H3a1 1 0 0 0 0 2h2a1 1 0 0 0 1-1z"/><path d="M6.22 5a1 1 0 0 0-1.39 1.47l1.44 1.39a1 1 0 0 0 .73.28 1 1 0 0 0 .72-.31 1 1 0 0 0 0-1.41z"/><path d="M17 8.14a1 1 0 0 0 .69-.28l1.44-1.39A1 1 0 0 0 17.78 5l-1.44 1.42a1 1 0 0 0 0 1.41 1 1 0 0 0 .66.31z"/><path d="M12 18a1 1 0 0 0-1 1v2a1 1 0 0 0 2 0v-2a1 1 0 0 0-1-1z"/><path d="M17.73 16.14a1 1 0 0 0-1.39 1.44L17.78 19a1 1 0 0 0 .69.28 1 1 0 0 0 .72-.3 1 1 0 0 0 0-1.42z"/><path d="M6.27 16.14l-1.44 1.39a1 1 0 0 0 0 1.42 1 1 0 0 0 .72.3 1 1 0 0 0 .67-.25l1.44-1.39a1 1 0 0 0-1.39-1.44z"/></g></g>', "lock-outline": '<g data-name="Layer 2"><g data-name="lock"><rect width="24" height="24" opacity="0"/><path d="M17 8h-1V6.11a4 4 0 1 0-8 0V8H7a3 3 0 0 0-3 3v8a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3v-8a3 3 0 0 0-3-3zm-7-1.89A2.06 2.06 0 0 1 12 4a2.06 2.06 0 0 1 2 2.11V8h-4zM18 19a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1v-8a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1z"/><path d="M12 12a3 3 0 1 0 3 3 3 3 0 0 0-3-3zm0 4a1 1 0 1 1 1-1 1 1 0 0 1-1 1z"/></g></g>', "log-in-outline": '<g data-name="Layer 2"><g data-name="log-in"><rect width="24" height="24" transform="rotate(-90 12 12)" opacity="0"/><path d="M19 4h-2a1 1 0 0 0 0 2h1v12h-1a1 1 0 0 0 0 2h2a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1z"/><path d="M11.8 7.4a1 1 0 0 0-1.6 1.2L12 11H4a1 1 0 0 0 0 2h8.09l-1.72 2.44a1 1 0 0 0 .24 1.4 1 1 0 0 0 .58.18 1 1 0 0 0 .81-.42l2.82-4a1 1 0 0 0 0-1.18z"/></g></g>', "log-out-outline": '<g data-name="Layer 2"><g data-name="log-out"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M7 6a1 1 0 0 0 0-2H5a1 1 0 0 0-1 1v14a1 1 0 0 0 1 1h2a1 1 0 0 0 0-2H6V6z"/><path d="M20.82 11.42l-2.82-4a1 1 0 0 0-1.39-.24 1 1 0 0 0-.24 1.4L18.09 11H10a1 1 0 0 0 0 2h8l-1.8 2.4a1 1 0 0 0 .2 1.4 1 1 0 0 0 .6.2 1 1 0 0 0 .8-.4l3-4a1 1 0 0 0 .02-1.18z"/></g></g>', "map-outline": '<g data-name="Layer 2"><g data-name="map"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M20.41 5.89l-4-1.8H15.59L12 5.7 8.41 4.09h-.05L8.24 4h-.6l-4 1.8a1 1 0 0 0-.64 1V19a1 1 0 0 0 .46.84A1 1 0 0 0 4 20a1 1 0 0 0 .41-.09L8 18.3l3.59 1.61h.05a.85.85 0 0 0 .72 0h.05L16 18.3l3.59 1.61A1 1 0 0 0 20 20a1 1 0 0 0 .54-.16A1 1 0 0 0 21 19V6.8a1 1 0 0 0-.59-.91zM5 7.44l2-.89v10l-2 .89zm4-.89l2 .89v10l-2-.89zm4 .89l2-.89v10l-2 .89zm6 10l-2-.89v-10l2 .89z"/></g></g>', "maximize-outline": '<g data-name="Layer 2"><g data-name="maximize"><rect width="24" height="24" opacity="0"/><path d="M20.71 19.29l-3.4-3.39A7.92 7.92 0 0 0 19 11a8 8 0 1 0-8 8 7.92 7.92 0 0 0 4.9-1.69l3.39 3.4a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42zM5 11a6 6 0 1 1 6 6 6 6 0 0 1-6-6z"/><path d="M13 10h-1V9a1 1 0 0 0-2 0v1H9a1 1 0 0 0 0 2h1v1a1 1 0 0 0 2 0v-1h1a1 1 0 0 0 0-2z"/></g></g>', "menu-2-outline": '<g data-name="Layer 2"><g data-name="menu-2"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><circle cx="4" cy="12" r="1"/><rect x="7" y="11" width="14" height="2" rx=".94" ry=".94"/><rect x="3" y="16" width="18" height="2" rx=".94" ry=".94"/><rect x="3" y="6" width="18" height="2" rx=".94" ry=".94"/></g></g>', "menu-arrow-outline": '<g data-name="Layer 2"><g data-name="menu-arrow"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M20.05 11H5.91l1.3-1.29a1 1 0 0 0-1.42-1.42l-3 3a1 1 0 0 0 0 1.42l3 3a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42L5.91 13h14.14a1 1 0 0 0 .95-.95V12a1 1 0 0 0-.95-1z"/><rect x="3" y="17" width="18" height="2" rx=".95" ry=".95"/><rect x="3" y="5" width="18" height="2" rx=".95" ry=".95"/></g></g>', "menu-outline": '<g data-name="Layer 2"><g data-name="menu"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><rect x="3" y="11" width="18" height="2" rx=".95" ry=".95"/><rect x="3" y="16" width="18" height="2" rx=".95" ry=".95"/><rect x="3" y="6" width="18" height="2" rx=".95" ry=".95"/></g></g>', "message-circle-outline": '<g data-name="Layer 2"><g data-name="message-circle"><circle cx="12" cy="12" r="1"/><circle cx="16" cy="12" r="1"/><circle cx="8" cy="12" r="1"/><path d="M19.07 4.93a10 10 0 0 0-16.28 11 1.06 1.06 0 0 1 .09.64L2 20.8a1 1 0 0 0 .27.91A1 1 0 0 0 3 22h.2l4.28-.86a1.26 1.26 0 0 1 .64.09 10 10 0 0 0 11-16.28zm.83 8.36a8 8 0 0 1-11 6.08 3.26 3.26 0 0 0-1.25-.26 3.43 3.43 0 0 0-.56.05l-2.82.57.57-2.82a3.09 3.09 0 0 0-.21-1.81 8 8 0 0 1 6.08-11 8 8 0 0 1 9.19 9.19z"/><rect width="24" height="24" opacity="0"/></g></g>', "message-square-outline": '<g data-name="Layer 2"><g data-name="message-square"><rect width="24" height="24" opacity="0"/><circle cx="12" cy="11" r="1"/><circle cx="16" cy="11" r="1"/><circle cx="8" cy="11" r="1"/><path d="M19 3H5a3 3 0 0 0-3 3v15a1 1 0 0 0 .51.87A1 1 0 0 0 3 22a1 1 0 0 0 .51-.14L8 19.14a1 1 0 0 1 .55-.14H19a3 3 0 0 0 3-3V6a3 3 0 0 0-3-3zm1 13a1 1 0 0 1-1 1H8.55a3 3 0 0 0-1.55.43l-3 1.8V6a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1z"/></g></g>', "mic-off-outline": '<g data-name="Layer 2"><g data-name="mic-off"><rect width="24" height="24" opacity="0"/><path d="M10 6a2 2 0 0 1 4 0v5a1 1 0 0 1 0 .16l1.6 1.59A4 4 0 0 0 16 11V6a4 4 0 0 0-7.92-.75L10 7.17z"/><path d="M19 11a1 1 0 0 0-2 0 4.86 4.86 0 0 1-.69 2.48L17.78 15A7 7 0 0 0 19 11z"/><path d="M12 15h.16L8 10.83V11a4 4 0 0 0 4 4z"/><path d="M20.71 19.29l-16-16a1 1 0 0 0-1.42 1.42l16 16a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42z"/><path d="M15 20h-2v-2.08a7 7 0 0 0 1.65-.44l-1.6-1.6A4.57 4.57 0 0 1 12 16a5 5 0 0 1-5-5 1 1 0 0 0-2 0 7 7 0 0 0 6 6.92V20H9a1 1 0 0 0 0 2h6a1 1 0 0 0 0-2z"/></g></g>', "mic-outline": '<g data-name="Layer 2"><g data-name="mic"><rect width="24" height="24" opacity="0"/><path d="M12 15a4 4 0 0 0 4-4V6a4 4 0 0 0-8 0v5a4 4 0 0 0 4 4zm-2-9a2 2 0 0 1 4 0v5a2 2 0 0 1-4 0z"/><path d="M19 11a1 1 0 0 0-2 0 5 5 0 0 1-10 0 1 1 0 0 0-2 0 7 7 0 0 0 6 6.92V20H8.89a.89.89 0 0 0-.89.89v.22a.89.89 0 0 0 .89.89h6.22a.89.89 0 0 0 .89-.89v-.22a.89.89 0 0 0-.89-.89H13v-2.08A7 7 0 0 0 19 11z"/></g></g>', "minimize-outline": '<g data-name="Layer 2"><g data-name="minimize"><rect width="24" height="24" opacity="0"/><path d="M20.71 19.29l-3.4-3.39A7.92 7.92 0 0 0 19 11a8 8 0 1 0-8 8 7.92 7.92 0 0 0 4.9-1.69l3.39 3.4a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42zM5 11a6 6 0 1 1 6 6 6 6 0 0 1-6-6z"/><path d="M13 10H9a1 1 0 0 0 0 2h4a1 1 0 0 0 0-2z"/></g></g>', "minus-circle-outline": '<g data-name="Layer 2"><g data-name="minus-circle"><rect width="24" height="24" opacity="0"/><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 18a8 8 0 1 1 8-8 8 8 0 0 1-8 8z"/><path d="M15 11H9a1 1 0 0 0 0 2h6a1 1 0 0 0 0-2z"/></g></g>', "minus-outline": '<g data-name="Layer 2"><g data-name="minus"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M19 13H5a1 1 0 0 1 0-2h14a1 1 0 0 1 0 2z"/></g></g>', "minus-square-outline": '<g data-name="Layer 2"><g data-name="minus-square"><rect width="24" height="24" opacity="0"/><path d="M18 3H6a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3V6a3 3 0 0 0-3-3zm1 15a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1h12a1 1 0 0 1 1 1z"/><path d="M15 11H9a1 1 0 0 0 0 2h6a1 1 0 0 0 0-2z"/></g></g>', "monitor-outline": '<g data-name="Layer 2"><g data-name="monitor"><rect width="24" height="24" opacity="0"/><path d="M19 3H5a3 3 0 0 0-3 3v8a3 3 0 0 0 3 3h6v2H7a1 1 0 0 0 0 2h10a1 1 0 0 0 0-2h-4v-2h6a3 3 0 0 0 3-3V6a3 3 0 0 0-3-3zm1 11a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1z"/></g></g>', "moon-outline": '<g data-name="Layer 2"><g data-name="moon"><rect width="24" height="24" opacity="0"/><path d="M12.3 22h-.1a10.31 10.31 0 0 1-7.34-3.15 10.46 10.46 0 0 1-.26-14 10.13 10.13 0 0 1 4-2.74 1 1 0 0 1 1.06.22 1 1 0 0 1 .24 1 8.4 8.4 0 0 0 1.94 8.81 8.47 8.47 0 0 0 8.83 1.94 1 1 0 0 1 1.27 1.29A10.16 10.16 0 0 1 19.6 19a10.28 10.28 0 0 1-7.3 3zM7.46 4.92a7.93 7.93 0 0 0-1.37 1.22 8.44 8.44 0 0 0 .2 11.32A8.29 8.29 0 0 0 12.22 20h.08a8.34 8.34 0 0 0 6.78-3.49A10.37 10.37 0 0 1 7.46 4.92z"/></g></g>', "more-horizontal-outline": '<g data-name="Layer 2"><g data-name="more-horizotnal"><rect width="24" height="24" opacity="0"/><circle cx="12" cy="12" r="2"/><circle cx="19" cy="12" r="2"/><circle cx="5" cy="12" r="2"/></g></g>', "more-vertical-outline": '<g data-name="Layer 2"><g data-name="more-vertical"><rect width="24" height="24" transform="rotate(-90 12 12)" opacity="0"/><circle cx="12" cy="12" r="2"/><circle cx="12" cy="5" r="2"/><circle cx="12" cy="19" r="2"/></g></g>', "move-outline": '<g data-name="Layer 2"><g data-name="move"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M21.71 11.31l-3-3a1 1 0 0 0-1.42 1.42L18.58 11H13V5.41l1.29 1.3A1 1 0 0 0 15 7a1 1 0 0 0 .71-.29 1 1 0 0 0 0-1.42l-3-3A1 1 0 0 0 12 2a1 1 0 0 0-.7.29l-3 3a1 1 0 0 0 1.41 1.42L11 5.42V11H5.41l1.3-1.29a1 1 0 0 0-1.42-1.42l-3 3A1 1 0 0 0 2 12a1 1 0 0 0 .29.71l3 3A1 1 0 0 0 6 16a1 1 0 0 0 .71-.29 1 1 0 0 0 0-1.42L5.42 13H11v5.59l-1.29-1.3a1 1 0 0 0-1.42 1.42l3 3A1 1 0 0 0 12 22a1 1 0 0 0 .7-.29l3-3a1 1 0 0 0-1.42-1.42L13 18.58V13h5.59l-1.3 1.29a1 1 0 0 0 0 1.42A1 1 0 0 0 18 16a1 1 0 0 0 .71-.29l3-3A1 1 0 0 0 22 12a1 1 0 0 0-.29-.69z"/></g></g>', "music-outline": '<g data-name="Layer 2"><g data-name="music"><rect width="24" height="24" opacity="0"/><path d="M19 15V4a1 1 0 0 0-.38-.78 1 1 0 0 0-.84-.2l-9 2A1 1 0 0 0 8 6v8.34a3.49 3.49 0 1 0 2 3.18 4.36 4.36 0 0 0 0-.52V6.8l7-1.55v7.09a3.49 3.49 0 1 0 2 3.17 4.57 4.57 0 0 0 0-.51zM6.54 19A1.49 1.49 0 1 1 8 17.21a1.53 1.53 0 0 1 0 .3A1.49 1.49 0 0 1 6.54 19zm9-2A1.5 1.5 0 1 1 17 15.21a1.53 1.53 0 0 1 0 .3A1.5 1.5 0 0 1 15.51 17z"/></g></g>', "navigation-2-outline": '<g data-name="Layer 2"><g data-name="navigation-2"><rect width="24" height="24" opacity="0"/><path d="M13.67 22h-.06a1 1 0 0 1-.92-.8L11 13l-8.2-1.69a1 1 0 0 1-.12-1.93l16-5.33A1 1 0 0 1 20 5.32l-5.33 16a1 1 0 0 1-1 .68zm-6.8-11.9l5.19 1.06a1 1 0 0 1 .79.78l1.05 5.19 3.52-10.55z"/></g></g>', "navigation-outline": '<g data-name="Layer 2"><g data-name="navigation"><rect width="24" height="24" opacity="0"/><path d="M20 20a.94.94 0 0 1-.55-.17L12 14.9l-7.45 4.93a1 1 0 0 1-1.44-1.28l8-16a1 1 0 0 1 1.78 0l8 16a1 1 0 0 1-.23 1.2A1 1 0 0 1 20 20zm-8-7.3a1 1 0 0 1 .55.17l4.88 3.23L12 5.24 6.57 16.1l4.88-3.23a1 1 0 0 1 .55-.17z"/></g></g>', "npm-outline": '<g data-name="Layer 2"><g data-name="npm"><rect width="24" height="24" opacity="0"/><path d="M18 21H6a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3h12a3 3 0 0 1 3 3v12a3 3 0 0 1-3 3zM6 5a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1z"/><rect x="12" y="9" width="4" height="10"/></g></g>', "options-2-outline": '<g data-name="Layer 2"><g data-name="options-2"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M19 9a3 3 0 0 0-2.82 2H3a1 1 0 0 0 0 2h13.18A3 3 0 1 0 19 9zm0 4a1 1 0 1 1 1-1 1 1 0 0 1-1 1z"/><path d="M3 7h1.18a3 3 0 0 0 5.64 0H21a1 1 0 0 0 0-2H9.82a3 3 0 0 0-5.64 0H3a1 1 0 0 0 0 2zm4-2a1 1 0 1 1-1 1 1 1 0 0 1 1-1z"/><path d="M21 17h-7.18a3 3 0 0 0-5.64 0H3a1 1 0 0 0 0 2h5.18a3 3 0 0 0 5.64 0H21a1 1 0 0 0 0-2zm-10 2a1 1 0 1 1 1-1 1 1 0 0 1-1 1z"/></g></g>', "options-outline": '<g data-name="Layer 2"><g data-name="options"><rect width="24" height="24" opacity="0"/><path d="M7 14.18V3a1 1 0 0 0-2 0v11.18a3 3 0 0 0 0 5.64V21a1 1 0 0 0 2 0v-1.18a3 3 0 0 0 0-5.64zM6 18a1 1 0 1 1 1-1 1 1 0 0 1-1 1z"/><path d="M21 13a3 3 0 0 0-2-2.82V3a1 1 0 0 0-2 0v7.18a3 3 0 0 0 0 5.64V21a1 1 0 0 0 2 0v-5.18A3 3 0 0 0 21 13zm-3 1a1 1 0 1 1 1-1 1 1 0 0 1-1 1z"/><path d="M15 5a3 3 0 1 0-4 2.82V21a1 1 0 0 0 2 0V7.82A3 3 0 0 0 15 5zm-3 1a1 1 0 1 1 1-1 1 1 0 0 1-1 1z"/></g></g>', "pantone-outline": '<g data-name="Layer 2"><g data-name="pantone"><rect width="24" height="24" opacity="0"/><path d="M20 13.18h-4.06l2.3-2.47a1 1 0 0 0 0-1.41l-4.19-3.86a.93.93 0 0 0-.71-.26 1 1 0 0 0-.7.31l-1.82 2V4a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1v13.09A3.91 3.91 0 0 0 6.91 21H20a1 1 0 0 0 1-1v-5.82a1 1 0 0 0-1-1zm-6.58-5.59l2.67 2.49-5.27 5.66v-5.36zM8.82 10v3H5v-3zm0-5v3H5V5zM5 17.09V15h3.82v2.09a1.91 1.91 0 0 1-3.82 0zM19 19h-8.49l3.56-3.82H19z"/></g></g>', "paper-plane-outline": '<g data-name="Layer 2"><g data-name="paper-plane"><rect width="24" height="24" opacity="0"/><path d="M21 4a1.31 1.31 0 0 0-.06-.27v-.09a1 1 0 0 0-.2-.3 1 1 0 0 0-.29-.19h-.09a.86.86 0 0 0-.31-.15H20a1 1 0 0 0-.3 0l-18 6a1 1 0 0 0 0 1.9l8.53 2.84 2.84 8.53a1 1 0 0 0 1.9 0l6-18A1 1 0 0 0 21 4zm-4.7 2.29l-5.57 5.57L5.16 10zM14 18.84l-1.86-5.57 5.57-5.57z"/></g></g>', "pause-circle-outline": '<g data-name="Layer 2"><g data-name="pause-circle"><rect width="24" height="24" opacity="0"/><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 18a8 8 0 1 1 8-8 8 8 0 0 1-8 8z"/><path d="M15 8a1 1 0 0 0-1 1v6a1 1 0 0 0 2 0V9a1 1 0 0 0-1-1z"/><path d="M9 8a1 1 0 0 0-1 1v6a1 1 0 0 0 2 0V9a1 1 0 0 0-1-1z"/></g></g>', "people-outline": '<g data-name="Layer 2"><g data-name="people"><rect width="24" height="24" opacity="0"/><path d="M9 11a4 4 0 1 0-4-4 4 4 0 0 0 4 4zm0-6a2 2 0 1 1-2 2 2 2 0 0 1 2-2z"/><path d="M17 13a3 3 0 1 0-3-3 3 3 0 0 0 3 3zm0-4a1 1 0 1 1-1 1 1 1 0 0 1 1-1z"/><path d="M17 14a5 5 0 0 0-3.06 1.05A7 7 0 0 0 2 20a1 1 0 0 0 2 0 5 5 0 0 1 10 0 1 1 0 0 0 2 0 6.9 6.9 0 0 0-.86-3.35A3 3 0 0 1 20 19a1 1 0 0 0 2 0 5 5 0 0 0-5-5z"/></g></g>', "percent-outline": '<g data-name="Layer 2"><g data-name="percent"><rect width="24" height="24" opacity="0"/><path d="M8 11a3.5 3.5 0 1 0-3.5-3.5A3.5 3.5 0 0 0 8 11zm0-5a1.5 1.5 0 1 1-1.5 1.5A1.5 1.5 0 0 1 8 6z"/><path d="M16 14a3.5 3.5 0 1 0 3.5 3.5A3.5 3.5 0 0 0 16 14zm0 5a1.5 1.5 0 1 1 1.5-1.5A1.5 1.5 0 0 1 16 19z"/><path d="M19.74 4.26a.89.89 0 0 0-1.26 0L4.26 18.48a.91.91 0 0 0-.26.63.89.89 0 0 0 1.52.63L19.74 5.52a.89.89 0 0 0 0-1.26z"/></g></g>', "person-add-outline": '<g data-name="Layer 2"><g data-name="person-add"><rect width="24" height="24" opacity="0"/><path d="M21 6h-1V5a1 1 0 0 0-2 0v1h-1a1 1 0 0 0 0 2h1v1a1 1 0 0 0 2 0V8h1a1 1 0 0 0 0-2z"/><path d="M10 11a4 4 0 1 0-4-4 4 4 0 0 0 4 4zm0-6a2 2 0 1 1-2 2 2 2 0 0 1 2-2z"/><path d="M10 13a7 7 0 0 0-7 7 1 1 0 0 0 2 0 5 5 0 0 1 10 0 1 1 0 0 0 2 0 7 7 0 0 0-7-7z"/></g></g>', "person-delete-outline": '<g data-name="Layer 2"><g data-name="person-delete"><rect width="24" height="24" opacity="0"/><path d="M20.47 7.5l.73-.73a1 1 0 0 0-1.47-1.47L19 6l-.73-.73a1 1 0 0 0-1.47 1.5l.73.73-.73.73a1 1 0 0 0 1.47 1.47L19 9l.73.73a1 1 0 0 0 1.47-1.5z"/><path d="M10 11a4 4 0 1 0-4-4 4 4 0 0 0 4 4zm0-6a2 2 0 1 1-2 2 2 2 0 0 1 2-2z"/><path d="M10 13a7 7 0 0 0-7 7 1 1 0 0 0 2 0 5 5 0 0 1 10 0 1 1 0 0 0 2 0 7 7 0 0 0-7-7z"/></g></g>', "person-done-outline": '<g data-name="Layer 2"><g data-name="person-done"><rect width="24" height="24" opacity="0"/><path d="M21.66 4.25a1 1 0 0 0-1.41.09l-1.87 2.15-.63-.71a1 1 0 0 0-1.5 1.33l1.39 1.56a1 1 0 0 0 .75.33 1 1 0 0 0 .74-.34l2.61-3a1 1 0 0 0-.08-1.41z"/><path d="M10 11a4 4 0 1 0-4-4 4 4 0 0 0 4 4zm0-6a2 2 0 1 1-2 2 2 2 0 0 1 2-2z"/><path d="M10 13a7 7 0 0 0-7 7 1 1 0 0 0 2 0 5 5 0 0 1 10 0 1 1 0 0 0 2 0 7 7 0 0 0-7-7z"/></g></g>', "person-outline": '<g data-name="Layer 2"><g data-name="person"><rect width="24" height="24" opacity="0"/><path d="M12 11a4 4 0 1 0-4-4 4 4 0 0 0 4 4zm0-6a2 2 0 1 1-2 2 2 2 0 0 1 2-2z"/><path d="M12 13a7 7 0 0 0-7 7 1 1 0 0 0 2 0 5 5 0 0 1 10 0 1 1 0 0 0 2 0 7 7 0 0 0-7-7z"/></g></g>', "person-remove-outline": '<g data-name="Layer 2"><g data-name="person-remove"><rect width="24" height="24" opacity="0"/><path d="M21 6h-4a1 1 0 0 0 0 2h4a1 1 0 0 0 0-2z"/><path d="M10 11a4 4 0 1 0-4-4 4 4 0 0 0 4 4zm0-6a2 2 0 1 1-2 2 2 2 0 0 1 2-2z"/><path d="M10 13a7 7 0 0 0-7 7 1 1 0 0 0 2 0 5 5 0 0 1 10 0 1 1 0 0 0 2 0 7 7 0 0 0-7-7z"/></g></g>', "phone-call-outline": '<g data-name="Layer 2"><g data-name="phone-call"><rect width="24" height="24" opacity="0"/><path d="M13 8a3 3 0 0 1 3 3 1 1 0 0 0 2 0 5 5 0 0 0-5-5 1 1 0 0 0 0 2z"/><path d="M13 4a7 7 0 0 1 7 7 1 1 0 0 0 2 0 9 9 0 0 0-9-9 1 1 0 0 0 0 2z"/><path d="M21.75 15.91a1 1 0 0 0-.72-.65l-6-1.37a1 1 0 0 0-.92.26c-.14.13-.15.14-.8 1.38a9.91 9.91 0 0 1-4.87-4.89C9.71 10 9.72 10 9.85 9.85a1 1 0 0 0 .26-.92L8.74 3a1 1 0 0 0-.65-.72 3.79 3.79 0 0 0-.72-.18A3.94 3.94 0 0 0 6.6 2 4.6 4.6 0 0 0 2 6.6 15.42 15.42 0 0 0 17.4 22a4.6 4.6 0 0 0 4.6-4.6 4.77 4.77 0 0 0-.06-.76 4.34 4.34 0 0 0-.19-.73zM17.4 20A13.41 13.41 0 0 1 4 6.6 2.61 2.61 0 0 1 6.6 4h.33L8 8.64l-.54.28c-.86.45-1.54.81-1.18 1.59a11.85 11.85 0 0 0 7.18 7.21c.84.34 1.17-.29 1.62-1.16l.29-.55L20 17.07v.33a2.61 2.61 0 0 1-2.6 2.6z"/></g></g>', "phone-missed-outline": '<g data-name="Layer 2"><g data-name="phone-missed"><rect width="24" height="24" opacity="0"/><path d="M21.94 16.64a4.34 4.34 0 0 0-.19-.73 1 1 0 0 0-.72-.65l-6-1.37a1 1 0 0 0-.92.26c-.14.13-.15.14-.8 1.38a10 10 0 0 1-4.88-4.89C9.71 10 9.72 10 9.85 9.85a1 1 0 0 0 .26-.92L8.74 3a1 1 0 0 0-.65-.72 3.79 3.79 0 0 0-.72-.18A3.94 3.94 0 0 0 6.6 2 4.6 4.6 0 0 0 2 6.6 15.42 15.42 0 0 0 17.4 22a4.6 4.6 0 0 0 4.6-4.6 4.77 4.77 0 0 0-.06-.76zM17.4 20A13.41 13.41 0 0 1 4 6.6 2.61 2.61 0 0 1 6.6 4h.33L8 8.64l-.55.29c-.87.45-1.5.78-1.17 1.58a11.85 11.85 0 0 0 7.18 7.21c.84.34 1.17-.29 1.62-1.16l.29-.55L20 17.07v.33a2.61 2.61 0 0 1-2.6 2.6z"/><path d="M15.8 8.7a1.05 1.05 0 0 0 1.47 0L18 8l.73.73a1 1 0 0 0 1.47-1.5l-.73-.73.73-.73a1 1 0 0 0-1.47-1.47L18 5l-.73-.73a1 1 0 0 0-1.47 1.5l.73.73-.73.73a1.05 1.05 0 0 0 0 1.47z"/></g></g>', "phone-off-outline": '<g data-name="Layer 2"><g data-name="phone-off"><rect width="24" height="24" opacity="0"/><path d="M19.74 4.26a.89.89 0 0 0-1.26 0L4.26 18.48a.91.91 0 0 0-.26.63.89.89 0 0 0 1.52.63L19.74 5.52a.89.89 0 0 0 0-1.26z"/><path d="M6.7 14.63A13.29 13.29 0 0 1 4 6.6 2.61 2.61 0 0 1 6.6 4h.33L8 8.64l-.55.29c-.87.45-1.5.78-1.17 1.58a11.57 11.57 0 0 0 1.57 3l1.43-1.42a10.37 10.37 0 0 1-.8-1.42C9.71 10 9.72 10 9.85 9.85a1 1 0 0 0 .26-.92L8.74 3a1 1 0 0 0-.65-.72 3.79 3.79 0 0 0-.72-.18A3.94 3.94 0 0 0 6.6 2 4.6 4.6 0 0 0 2 6.6a15.33 15.33 0 0 0 3.27 9.46z"/><path d="M21.94 16.64a4.34 4.34 0 0 0-.19-.73 1 1 0 0 0-.72-.65l-6-1.37a1 1 0 0 0-.92.26c-.14.13-.15.14-.8 1.38a10.88 10.88 0 0 1-1.41-.8l-1.43 1.43a11.52 11.52 0 0 0 2.94 1.56c.84.34 1.17-.29 1.62-1.16l.29-.55L20 17.07v.33a2.61 2.61 0 0 1-2.6 2.6 13.29 13.29 0 0 1-8-2.7l-1.46 1.43A15.33 15.33 0 0 0 17.4 22a4.6 4.6 0 0 0 4.6-4.6 4.77 4.77 0 0 0-.06-.76z"/></g></g>', "phone-outline": '<g data-name="Layer 2"><g data-name="phone"><rect width="24" height="24" opacity="0"/><path d="M17.4 22A15.42 15.42 0 0 1 2 6.6 4.6 4.6 0 0 1 6.6 2a3.94 3.94 0 0 1 .77.07 3.79 3.79 0 0 1 .72.18 1 1 0 0 1 .65.75l1.37 6a1 1 0 0 1-.26.92c-.13.14-.14.15-1.37.79a9.91 9.91 0 0 0 4.87 4.89c.65-1.24.66-1.25.8-1.38a1 1 0 0 1 .92-.26l6 1.37a1 1 0 0 1 .72.65 4.34 4.34 0 0 1 .19.73 4.77 4.77 0 0 1 .06.76A4.6 4.6 0 0 1 17.4 22zM6.6 4A2.61 2.61 0 0 0 4 6.6 13.41 13.41 0 0 0 17.4 20a2.61 2.61 0 0 0 2.6-2.6v-.33L15.36 16l-.29.55c-.45.87-.78 1.5-1.62 1.16a11.85 11.85 0 0 1-7.18-7.21c-.36-.78.32-1.14 1.18-1.59L8 8.64 6.93 4z"/></g></g>', "pie-chart-outline": '<g data-name="Layer 2"><g data-name="pie-chart"><rect width="24" height="24" opacity="0"/><path d="M13 2a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1 9 9 0 0 0-9-9zm1 8V4.07A7 7 0 0 1 19.93 10z"/><path d="M20.82 14.06a1 1 0 0 0-1.28.61A8 8 0 1 1 9.33 4.46a1 1 0 0 0-.66-1.89 10 10 0 1 0 12.76 12.76 1 1 0 0 0-.61-1.27z"/></g></g>', "pin-outline": '<g data-name="Layer 2"><g data-name="pin"><rect width="24" height="24" opacity="0"/><path d="M12 2a8 8 0 0 0-8 7.92c0 5.48 7.05 11.58 7.35 11.84a1 1 0 0 0 1.3 0C13 21.5 20 15.4 20 9.92A8 8 0 0 0 12 2zm0 17.65c-1.67-1.59-6-6-6-9.73a6 6 0 0 1 12 0c0 3.7-4.33 8.14-6 9.73z"/><path d="M12 6a3.5 3.5 0 1 0 3.5 3.5A3.5 3.5 0 0 0 12 6zm0 5a1.5 1.5 0 1 1 1.5-1.5A1.5 1.5 0 0 1 12 11z"/></g></g>', "play-circle-outline": '<g data-name="Layer 2"><g data-name="play-circle"><rect width="24" height="24" opacity="0"/><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 18a8 8 0 1 1 8-8 8 8 0 0 1-8 8z"/><path d="M12.34 7.45a1.7 1.7 0 0 0-1.85-.3 1.6 1.6 0 0 0-1 1.48v6.74a1.6 1.6 0 0 0 1 1.48 1.68 1.68 0 0 0 .69.15 1.74 1.74 0 0 0 1.16-.45L16 13.18a1.6 1.6 0 0 0 0-2.36zm-.84 7.15V9.4l2.81 2.6z"/></g></g>', "plus-circle-outline": '<g data-name="Layer 2"><g data-name="plus-circle"><rect width="24" height="24" opacity="0"/><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 18a8 8 0 1 1 8-8 8 8 0 0 1-8 8z"/><path d="M15 11h-2V9a1 1 0 0 0-2 0v2H9a1 1 0 0 0 0 2h2v2a1 1 0 0 0 2 0v-2h2a1 1 0 0 0 0-2z"/></g></g>', "plus-outline": '<g data-name="Layer 2"><g data-name="plus"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M19 11h-6V5a1 1 0 0 0-2 0v6H5a1 1 0 0 0 0 2h6v6a1 1 0 0 0 2 0v-6h6a1 1 0 0 0 0-2z"/></g></g>', "plus-square-outline": '<g data-name="Layer 2"><g data-name="plus-square"><rect width="24" height="24" opacity="0"/><path d="M18 3H6a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3V6a3 3 0 0 0-3-3zm1 15a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1h12a1 1 0 0 1 1 1z"/><path d="M15 11h-2V9a1 1 0 0 0-2 0v2H9a1 1 0 0 0 0 2h2v2a1 1 0 0 0 2 0v-2h2a1 1 0 0 0 0-2z"/></g></g>', "power-outline": '<g data-name="Layer 2"><g data-name="power"><rect width="24" height="24" opacity="0"/><path d="M12 13a1 1 0 0 0 1-1V2a1 1 0 0 0-2 0v10a1 1 0 0 0 1 1z"/><path d="M16.59 3.11a1 1 0 0 0-.92 1.78 8 8 0 1 1-7.34 0 1 1 0 1 0-.92-1.78 10 10 0 1 0 9.18 0z"/></g></g>', "pricetags-outline": '<g data-name="Layer 2"><g data-name="pricetags"><rect width="24" height="24" opacity="0"/><path d="M12.87 22a1.84 1.84 0 0 1-1.29-.53l-6.41-6.42a1 1 0 0 1-.29-.61L4 5.09a1 1 0 0 1 .29-.8 1 1 0 0 1 .8-.29l9.35.88a1 1 0 0 1 .61.29l6.42 6.41a1.82 1.82 0 0 1 0 2.57l-7.32 7.32a1.82 1.82 0 0 1-1.28.53zm-6-8.11l6 6 7.05-7.05-6-6-7.81-.73z"/><circle cx="10.5" cy="10.5" r="1.5"/></g></g>', "printer-outline": '<g data-name="Layer 2"><g data-name="printer"><rect width="24" height="24" opacity="0"/><path d="M19.36 7H18V5a1.92 1.92 0 0 0-1.83-2H7.83A1.92 1.92 0 0 0 6 5v2H4.64A2.66 2.66 0 0 0 2 9.67v6.66A2.66 2.66 0 0 0 4.64 19h.86a2 2 0 0 0 2 2h9a2 2 0 0 0 2-2h.86A2.66 2.66 0 0 0 22 16.33V9.67A2.66 2.66 0 0 0 19.36 7zM8 5h8v2H8zm-.5 14v-4h9v4zM20 16.33a.66.66 0 0 1-.64.67h-.86v-2a2 2 0 0 0-2-2h-9a2 2 0 0 0-2 2v2h-.86a.66.66 0 0 1-.64-.67V9.67A.66.66 0 0 1 4.64 9h14.72a.66.66 0 0 1 .64.67z"/></g></g>', "question-mark-circle-outline": '<g data-name="Layer 2"><g data-name="menu-arrow-circle"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 18a8 8 0 1 1 8-8 8 8 0 0 1-8 8z"/><path d="M12 6a3.5 3.5 0 0 0-3.5 3.5 1 1 0 0 0 2 0A1.5 1.5 0 1 1 12 11a1 1 0 0 0-1 1v2a1 1 0 0 0 2 0v-1.16A3.49 3.49 0 0 0 12 6z"/><circle cx="12" cy="17" r="1"/></g></g>', "question-mark-outline": '<g data-name="Layer 2"><g data-name="question-mark"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M17 9A5 5 0 0 0 7 9a1 1 0 0 0 2 0 3 3 0 1 1 3 3 1 1 0 0 0-1 1v2a1 1 0 0 0 2 0v-1.1A5 5 0 0 0 17 9z"/><circle cx="12" cy="19" r="1"/></g></g>', "radio-button-off-outline": '<g data-name="Layer 2"><g data-name="radio-button-off"><rect width="24" height="24" opacity="0"/><path d="M12 22a10 10 0 1 1 10-10 10 10 0 0 1-10 10zm0-18a8 8 0 1 0 8 8 8 8 0 0 0-8-8z"/></g></g>', "radio-button-on-outline": '<g data-name="Layer 2"><g data-name="radio-button-on"><rect width="24" height="24" opacity="0"/><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 18a8 8 0 1 1 8-8 8 8 0 0 1-8 8z"/><path d="M12 7a5 5 0 1 0 5 5 5 5 0 0 0-5-5zm0 8a3 3 0 1 1 3-3 3 3 0 0 1-3 3z"/></g></g>', "radio-outline": '<g data-name="Layer 2"><g data-name="radio"><rect width="24" height="24" opacity="0"/><path d="M12 8a3 3 0 0 0-1 5.83 1 1 0 0 0 0 .17v6a1 1 0 0 0 2 0v-6a1 1 0 0 0 0-.17A3 3 0 0 0 12 8zm0 4a1 1 0 1 1 1-1 1 1 0 0 1-1 1z"/><path d="M3.5 11a6.87 6.87 0 0 1 2.64-5.23 1 1 0 1 0-1.28-1.54A8.84 8.84 0 0 0 1.5 11a8.84 8.84 0 0 0 3.36 6.77 1 1 0 1 0 1.28-1.54A6.87 6.87 0 0 1 3.5 11z"/><path d="M16.64 6.24a1 1 0 0 0-1.28 1.52A4.28 4.28 0 0 1 17 11a4.28 4.28 0 0 1-1.64 3.24A1 1 0 0 0 16 16a1 1 0 0 0 .64-.24A6.2 6.2 0 0 0 19 11a6.2 6.2 0 0 0-2.36-4.76z"/><path d="M8.76 6.36a1 1 0 0 0-1.4-.12A6.2 6.2 0 0 0 5 11a6.2 6.2 0 0 0 2.36 4.76 1 1 0 0 0 1.4-.12 1 1 0 0 0-.12-1.4A4.28 4.28 0 0 1 7 11a4.28 4.28 0 0 1 1.64-3.24 1 1 0 0 0 .12-1.4z"/><path d="M19.14 4.23a1 1 0 1 0-1.28 1.54A6.87 6.87 0 0 1 20.5 11a6.87 6.87 0 0 1-2.64 5.23 1 1 0 0 0 1.28 1.54A8.84 8.84 0 0 0 22.5 11a8.84 8.84 0 0 0-3.36-6.77z"/></g></g>', "recording-outline": '<g data-name="Layer 2"><g data-name="recording"><rect width="24" height="24" opacity="0"/><path d="M18 8a4 4 0 0 0-4 4 3.91 3.91 0 0 0 .56 2H9.44a3.91 3.91 0 0 0 .56-2 4 4 0 1 0-4 4h12a4 4 0 0 0 0-8zM4 12a2 2 0 1 1 2 2 2 2 0 0 1-2-2zm14 2a2 2 0 1 1 2-2 2 2 0 0 1-2 2z"/></g></g>', "refresh-outline": '<g data-name="Layer 2"><g data-name="refresh"><rect width="24" height="24" opacity="0"/><path d="M20.3 13.43a1 1 0 0 0-1.25.65A7.14 7.14 0 0 1 12.18 19 7.1 7.1 0 0 1 5 12a7.1 7.1 0 0 1 7.18-7 7.26 7.26 0 0 1 4.65 1.67l-2.17-.36a1 1 0 0 0-1.15.83 1 1 0 0 0 .83 1.15l4.24.7h.17a1 1 0 0 0 .34-.06.33.33 0 0 0 .1-.06.78.78 0 0 0 .2-.11l.09-.11c0-.05.09-.09.13-.15s0-.1.05-.14a1.34 1.34 0 0 0 .07-.18l.75-4a1 1 0 0 0-2-.38l-.27 1.45A9.21 9.21 0 0 0 12.18 3 9.1 9.1 0 0 0 3 12a9.1 9.1 0 0 0 9.18 9A9.12 9.12 0 0 0 21 14.68a1 1 0 0 0-.7-1.25z"/></g></g>', "repeat-outline": '<g data-name="Layer 2"><g data-name="repeat"><rect width="24" height="24" opacity="0"/><path d="M17.91 5h-12l1.3-1.29a1 1 0 0 0-1.42-1.42l-3 3a1 1 0 0 0 0 1.42l3 3a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42L5.91 7h12a1.56 1.56 0 0 1 1.59 1.53V11a1 1 0 0 0 2 0V8.53A3.56 3.56 0 0 0 17.91 5z"/><path d="M18.21 14.29a1 1 0 0 0-1.42 1.42l1.3 1.29h-12a1.56 1.56 0 0 1-1.59-1.53V13a1 1 0 0 0-2 0v2.47A3.56 3.56 0 0 0 6.09 19h12l-1.3 1.29a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0l3-3a1 1 0 0 0 0-1.42z"/></g></g>', "rewind-left-outline": '<g data-name="Layer 2"><g data-name="rewind-left"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M18.45 6.2a2.1 2.1 0 0 0-2.21.26l-4.74 3.92V7.79a1.76 1.76 0 0 0-1.05-1.59 2.1 2.1 0 0 0-2.21.26l-5.1 4.21a1.7 1.7 0 0 0 0 2.66l5.1 4.21a2.06 2.06 0 0 0 1.3.46 2.23 2.23 0 0 0 .91-.2 1.76 1.76 0 0 0 1.05-1.59v-2.59l4.74 3.92a2.06 2.06 0 0 0 1.3.46 2.23 2.23 0 0 0 .91-.2 1.76 1.76 0 0 0 1.05-1.59V7.79a1.76 1.76 0 0 0-1.05-1.59zM9.5 16l-4.82-4L9.5 8.09zm8 0l-4.82-4 4.82-3.91z"/></g></g>', "rewind-right-outline": '<g data-name="Layer 2"><g data-name="rewind-right"><rect width="24" height="24" opacity="0"/><path d="M20.86 10.67l-5.1-4.21a2.1 2.1 0 0 0-2.21-.26 1.76 1.76 0 0 0-1.05 1.59v2.59L7.76 6.46a2.1 2.1 0 0 0-2.21-.26 1.76 1.76 0 0 0-1 1.59v8.42a1.76 1.76 0 0 0 1 1.59 2.23 2.23 0 0 0 .91.2 2.06 2.06 0 0 0 1.3-.46l4.74-3.92v2.59a1.76 1.76 0 0 0 1.05 1.59 2.23 2.23 0 0 0 .91.2 2.06 2.06 0 0 0 1.3-.46l5.1-4.21a1.7 1.7 0 0 0 0-2.66zM6.5 15.91V8l4.82 4zm8 0V8l4.82 4z"/></g></g>', "save-outline": '<g data-name="Layer 2"><g data-name="save"><rect width="24" height="24" opacity="0"/><path d="M20.12 8.71l-4.83-4.83A3 3 0 0 0 13.17 3H6a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3v-7.17a3 3 0 0 0-.88-2.12zM10 19v-2h4v2zm9-1a1 1 0 0 1-1 1h-2v-3a1 1 0 0 0-1-1H9a1 1 0 0 0-1 1v3H6a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1h2v5a1 1 0 0 0 1 1h4a1 1 0 0 0 0-2h-3V5h3.17a1.05 1.05 0 0 1 .71.29l4.83 4.83a1 1 0 0 1 .29.71z"/></g></g>', "scissors-outline": '<g data-name="Layer 2"><g data-name="scissors"><rect width="24" height="24" opacity="0"/><path d="M20.21 5.71a1 1 0 1 0-1.42-1.42l-6.28 6.31-3.3-3.31A3 3 0 0 0 9.5 6a3 3 0 1 0-3 3 3 3 0 0 0 1.29-.3L11.1 12l-3.29 3.3A3 3 0 0 0 6.5 15a3 3 0 1 0 3 3 3 3 0 0 0-.29-1.26zM6.5 7a1 1 0 1 1 1-1 1 1 0 0 1-1 1zm0 12a1 1 0 1 1 1-1 1 1 0 0 1-1 1z"/><path d="M15.21 13.29a1 1 0 0 0-1.42 1.42l5 5a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42z"/></g></g>', "search-outline": '<g data-name="Layer 2"><g data-name="search"><rect width="24" height="24" opacity="0"/><path d="M20.71 19.29l-3.4-3.39A7.92 7.92 0 0 0 19 11a8 8 0 1 0-8 8 7.92 7.92 0 0 0 4.9-1.69l3.39 3.4a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42zM5 11a6 6 0 1 1 6 6 6 6 0 0 1-6-6z"/></g></g>', "settings-2-outline": '<g data-name="Layer 2"><g data-name="settings-2"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M12.94 22h-1.89a1.68 1.68 0 0 1-1.68-1.68v-1.09a.34.34 0 0 0-.22-.29.38.38 0 0 0-.41 0l-.74.8a1.67 1.67 0 0 1-2.37 0L4.26 18.4a1.66 1.66 0 0 1-.5-1.19 1.72 1.72 0 0 1 .5-1.21l.74-.74a.34.34 0 0 0 0-.37c-.06-.15-.16-.26-.3-.26H3.68A1.69 1.69 0 0 1 2 12.94v-1.89a1.68 1.68 0 0 1 1.68-1.68h1.09a.34.34 0 0 0 .29-.22.38.38 0 0 0 0-.41L4.26 8a1.67 1.67 0 0 1 0-2.37L5.6 4.26a1.65 1.65 0 0 1 1.18-.5 1.72 1.72 0 0 1 1.22.5l.74.74a.34.34 0 0 0 .37 0c.15-.06.26-.16.26-.3V3.68A1.69 1.69 0 0 1 11.06 2H13a1.68 1.68 0 0 1 1.68 1.68v1.09a.34.34 0 0 0 .22.29.38.38 0 0 0 .41 0l.69-.8a1.67 1.67 0 0 1 2.37 0l1.37 1.34a1.67 1.67 0 0 1 .5 1.19 1.63 1.63 0 0 1-.5 1.21l-.74.74a.34.34 0 0 0 0 .37c.06.15.16.26.3.26h1.09A1.69 1.69 0 0 1 22 11.06V13a1.68 1.68 0 0 1-1.68 1.68h-1.09a.34.34 0 0 0-.29.22.34.34 0 0 0 0 .37l.77.77a1.67 1.67 0 0 1 0 2.37l-1.31 1.33a1.65 1.65 0 0 1-1.18.5 1.72 1.72 0 0 1-1.19-.5l-.77-.74a.34.34 0 0 0-.37 0c-.15.06-.26.16-.26.3v1.09A1.69 1.69 0 0 1 12.94 22zm-1.57-2h1.26v-.77a2.33 2.33 0 0 1 1.46-2.14 2.36 2.36 0 0 1 2.59.47l.54.54.88-.88-.54-.55a2.34 2.34 0 0 1-.48-2.56 2.33 2.33 0 0 1 2.14-1.45H20v-1.29h-.77a2.33 2.33 0 0 1-2.14-1.46 2.36 2.36 0 0 1 .47-2.59l.54-.54-.88-.88-.55.54a2.39 2.39 0 0 1-4-1.67V4h-1.3v.77a2.33 2.33 0 0 1-1.46 2.14 2.36 2.36 0 0 1-2.59-.47l-.54-.54-.88.88.54.55a2.39 2.39 0 0 1-1.67 4H4v1.26h.77a2.33 2.33 0 0 1 2.14 1.46 2.36 2.36 0 0 1-.47 2.59l-.54.54.88.88.55-.54a2.39 2.39 0 0 1 4 1.67z" data-name="&lt;Group&gt;"/><path d="M12 15.5a3.5 3.5 0 1 1 3.5-3.5 3.5 3.5 0 0 1-3.5 3.5zm0-5a1.5 1.5 0 1 0 1.5 1.5 1.5 1.5 0 0 0-1.5-1.5z"/></g></g>', "settings-outline": '<g data-name="Layer 2"><g data-name="settings"><rect width="24" height="24" opacity="0"/><path d="M8.61 22a2.25 2.25 0 0 1-1.35-.46L5.19 20a2.37 2.37 0 0 1-.49-3.22 2.06 2.06 0 0 0 .23-1.86l-.06-.16a1.83 1.83 0 0 0-1.12-1.22h-.16a2.34 2.34 0 0 1-1.48-2.94L2.93 8a2.18 2.18 0 0 1 1.12-1.41 2.14 2.14 0 0 1 1.68-.12 1.93 1.93 0 0 0 1.78-.29l.13-.1a1.94 1.94 0 0 0 .73-1.51v-.24A2.32 2.32 0 0 1 10.66 2h2.55a2.26 2.26 0 0 1 1.6.67 2.37 2.37 0 0 1 .68 1.68v.28a1.76 1.76 0 0 0 .69 1.43l.11.08a1.74 1.74 0 0 0 1.59.26l.34-.11A2.26 2.26 0 0 1 21.1 7.8l.79 2.52a2.36 2.36 0 0 1-1.46 2.93l-.2.07A1.89 1.89 0 0 0 19 14.6a2 2 0 0 0 .25 1.65l.26.38a2.38 2.38 0 0 1-.5 3.23L17 21.41a2.24 2.24 0 0 1-3.22-.53l-.12-.17a1.75 1.75 0 0 0-1.5-.78 1.8 1.8 0 0 0-1.43.77l-.23.33A2.25 2.25 0 0 1 9 22a2 2 0 0 1-.39 0zM4.4 11.62a3.83 3.83 0 0 1 2.38 2.5v.12a4 4 0 0 1-.46 3.62.38.38 0 0 0 0 .51L8.47 20a.25.25 0 0 0 .37-.07l.23-.33a3.77 3.77 0 0 1 6.2 0l.12.18a.3.3 0 0 0 .18.12.25.25 0 0 0 .19-.05l2.06-1.56a.36.36 0 0 0 .07-.49l-.26-.38A4 4 0 0 1 17.1 14a3.92 3.92 0 0 1 2.49-2.61l.2-.07a.34.34 0 0 0 .19-.44l-.78-2.49a.35.35 0 0 0-.2-.19.21.21 0 0 0-.19 0l-.34.11a3.74 3.74 0 0 1-3.43-.57L15 7.65a3.76 3.76 0 0 1-1.49-3v-.31a.37.37 0 0 0-.1-.26.31.31 0 0 0-.21-.08h-2.54a.31.31 0 0 0-.29.33v.25a3.9 3.9 0 0 1-1.52 3.09l-.13.1a3.91 3.91 0 0 1-3.63.59.22.22 0 0 0-.14 0 .28.28 0 0 0-.12.15L4 11.12a.36.36 0 0 0 .22.45z" data-name="&lt;Group&gt;"/><path d="M12 15.5a3.5 3.5 0 1 1 3.5-3.5 3.5 3.5 0 0 1-3.5 3.5zm0-5a1.5 1.5 0 1 0 1.5 1.5 1.5 1.5 0 0 0-1.5-1.5z"/></g></g>', "shake-outline": '<g data-name="Layer 2"><g data-name="shake"><rect width="24" height="24" opacity="0"/><path d="M5.5 18a1 1 0 0 1-.64-.24A8.81 8.81 0 0 1 1.5 11a8.81 8.81 0 0 1 3.36-6.76 1 1 0 1 1 1.28 1.52A6.9 6.9 0 0 0 3.5 11a6.9 6.9 0 0 0 2.64 5.24 1 1 0 0 1 .13 1.4 1 1 0 0 1-.77.36z"/><path d="M12 7a4.09 4.09 0 0 1 1 .14V3a1 1 0 0 0-2 0v4.14A4.09 4.09 0 0 1 12 7z"/><path d="M12 15a4.09 4.09 0 0 1-1-.14V20a1 1 0 0 0 2 0v-5.14a4.09 4.09 0 0 1-1 .14z"/><path d="M16 16a1 1 0 0 1-.77-.36 1 1 0 0 1 .13-1.4A4.28 4.28 0 0 0 17 11a4.28 4.28 0 0 0-1.64-3.24 1 1 0 1 1 1.28-1.52A6.2 6.2 0 0 1 19 11a6.2 6.2 0 0 1-2.36 4.76A1 1 0 0 1 16 16z"/><path d="M8 16a1 1 0 0 1-.64-.24A6.2 6.2 0 0 1 5 11a6.2 6.2 0 0 1 2.36-4.76 1 1 0 1 1 1.28 1.52A4.28 4.28 0 0 0 7 11a4.28 4.28 0 0 0 1.64 3.24 1 1 0 0 1 .13 1.4A1 1 0 0 1 8 16z"/><path d="M18.5 18a1 1 0 0 1-.77-.36 1 1 0 0 1 .13-1.4A6.9 6.9 0 0 0 20.5 11a6.9 6.9 0 0 0-2.64-5.24 1 1 0 1 1 1.28-1.52A8.81 8.81 0 0 1 22.5 11a8.81 8.81 0 0 1-3.36 6.76 1 1 0 0 1-.64.24z"/><path d="M12 12a1 1 0 1 1 1-1 1 1 0 0 1-1 1zm0-1zm0 0zm0 0zm0 0zm0 0zm0 0zm0 0z"/></g></g>', "share-outline": '<g data-name="Layer 2"><g data-name="share"><rect width="24" height="24" opacity="0"/><path d="M18 15a3 3 0 0 0-2.1.86L8 12.34V12v-.33l7.9-3.53A3 3 0 1 0 15 6v.34L7.1 9.86a3 3 0 1 0 0 4.28l7.9 3.53V18a3 3 0 1 0 3-3zm0-10a1 1 0 1 1-1 1 1 1 0 0 1 1-1zM5 13a1 1 0 1 1 1-1 1 1 0 0 1-1 1zm13 6a1 1 0 1 1 1-1 1 1 0 0 1-1 1z"/></g></g>', "shield-off-outline": '<g data-name="Layer 2"><g data-name="shield-off"><rect width="24" height="24" opacity="0"/><path d="M4.71 3.29a1 1 0 0 0-1.42 1.42l16 16a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42z"/><path d="M12.3 19.68l-.3.17-.3-.17A13.15 13.15 0 0 1 5 8.23v-.14L5.16 8 3.73 6.56A2 2 0 0 0 3 8.09v.14a15.17 15.17 0 0 0 7.72 13.2l.3.17a2 2 0 0 0 2 0l.3-.17a15.22 15.22 0 0 0 3-2.27l-1.42-1.42a12.56 12.56 0 0 1-2.6 1.94z"/><path d="M20 6.34L13 2.4a2 2 0 0 0-2 0L7.32 4.49 8.78 6 12 4.15l7 3.94v.14a13 13 0 0 1-1.63 6.31L18.84 16A15.08 15.08 0 0 0 21 8.23v-.14a2 2 0 0 0-1-1.75z"/></g></g>', "shield-outline": '<g data-name="Layer 2"><g data-name="shield"><rect width="24" height="24" opacity="0"/><path d="M12 21.85a2 2 0 0 1-1-.25l-.3-.17A15.17 15.17 0 0 1 3 8.23v-.14a2 2 0 0 1 1-1.75l7-3.94a2 2 0 0 1 2 0l7 3.94a2 2 0 0 1 1 1.75v.14a15.17 15.17 0 0 1-7.72 13.2l-.3.17a2 2 0 0 1-.98.25zm0-17.7L5 8.09v.14a13.15 13.15 0 0 0 6.7 11.45l.3.17.3-.17A13.15 13.15 0 0 0 19 8.23v-.14z"/></g></g>', "shopping-bag-outline": '<g data-name="Layer 2"><g data-name="shopping-bag"><rect width="24" height="24" opacity="0"/><path d="M20.12 6.71l-2.83-2.83A3 3 0 0 0 15.17 3H8.83a3 3 0 0 0-2.12.88L3.88 6.71A3 3 0 0 0 3 8.83V18a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3V8.83a3 3 0 0 0-.88-2.12zm-12-1.42A1.05 1.05 0 0 1 8.83 5h6.34a1.05 1.05 0 0 1 .71.29L17.59 7H6.41zM18 19H6a1 1 0 0 1-1-1V9h14v9a1 1 0 0 1-1 1z"/><path d="M15 11a1 1 0 0 0-1 1 2 2 0 0 1-4 0 1 1 0 0 0-2 0 4 4 0 0 0 8 0 1 1 0 0 0-1-1z"/></g></g>', "shopping-cart-outline": '<g data-name="Layer 2"><g data-name="shopping-cart"><rect width="24" height="24" opacity="0"/><path d="M21.08 7a2 2 0 0 0-1.7-1H6.58L6 3.74A1 1 0 0 0 5 3H3a1 1 0 0 0 0 2h1.24L7 15.26A1 1 0 0 0 8 16h9a1 1 0 0 0 .89-.55l3.28-6.56A2 2 0 0 0 21.08 7zm-4.7 7H8.76L7.13 8h12.25z"/><circle cx="7.5" cy="19.5" r="1.5"/><circle cx="17.5" cy="19.5" r="1.5"/></g></g>', "shuffle-2-outline": '<g data-name="Layer 2"><g data-name="shuffle-2"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M18.71 14.29a1 1 0 0 0-1.42 1.42l.29.29H16a4 4 0 0 1 0-8h1.59l-.3.29a1 1 0 0 0 0 1.42A1 1 0 0 0 18 10a1 1 0 0 0 .71-.29l2-2A1 1 0 0 0 21 7a1 1 0 0 0-.29-.71l-2-2a1 1 0 0 0-1.42 1.42l.29.29H16a6 6 0 0 0-5 2.69A6 6 0 0 0 6 6H4a1 1 0 0 0 0 2h2a4 4 0 0 1 0 8H4a1 1 0 0 0 0 2h2a6 6 0 0 0 5-2.69A6 6 0 0 0 16 18h1.59l-.3.29a1 1 0 0 0 0 1.42A1 1 0 0 0 18 20a1 1 0 0 0 .71-.29l2-2A1 1 0 0 0 21 17a1 1 0 0 0-.29-.71z"/></g></g>', "shuffle-outline": '<g data-name="Layer 2"><g data-name="shuffle"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M18 9.31a1 1 0 0 0 1 1 1 1 0 0 0 1-1V5a1 1 0 0 0-1-1h-4.3a1 1 0 0 0-1 1 1 1 0 0 0 1 1h1.89L12 10.59 6.16 4.76a1 1 0 0 0-1.41 1.41L10.58 12l-6.29 6.29a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0L18 7.42z"/><path d="M19 13.68a1 1 0 0 0-1 1v1.91l-2.78-2.79a1 1 0 0 0-1.42 1.42L16.57 18h-1.88a1 1 0 0 0 0 2H19a1 1 0 0 0 1-1.11v-4.21a1 1 0 0 0-1-1z"/></g></g>', "skip-back-outline": '<g data-name="Layer 2"><g data-name="skip-back"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M16.45 6.2a2.1 2.1 0 0 0-2.21.26l-5.1 4.21-.14.15V7a1 1 0 0 0-2 0v10a1 1 0 0 0 2 0v-3.82l.14.15 5.1 4.21a2.06 2.06 0 0 0 1.3.46 2.23 2.23 0 0 0 .91-.2 1.76 1.76 0 0 0 1.05-1.59V7.79a1.76 1.76 0 0 0-1.05-1.59zM15.5 16l-4.82-4 4.82-3.91z"/></g></g>', "skip-forward-outline": '<g data-name="Layer 2"><g data-name="skip-forward"><rect width="24" height="24" opacity="0"/><path d="M16 6a1 1 0 0 0-1 1v3.82l-.14-.15-5.1-4.21a2.1 2.1 0 0 0-2.21-.26 1.76 1.76 0 0 0-1 1.59v8.42a1.76 1.76 0 0 0 1 1.59 2.23 2.23 0 0 0 .91.2 2.06 2.06 0 0 0 1.3-.46l5.1-4.21.14-.15V17a1 1 0 0 0 2 0V7a1 1 0 0 0-1-1zm-7.5 9.91V8l4.82 4z"/></g></g>', "slash-outline": '<g data-name="Layer 2"><g data-name="slash"><rect width="24" height="24" opacity="0"/><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm8 10a7.92 7.92 0 0 1-1.69 4.9L7.1 5.69A7.92 7.92 0 0 1 12 4a8 8 0 0 1 8 8zM4 12a7.92 7.92 0 0 1 1.69-4.9L16.9 18.31A7.92 7.92 0 0 1 12 20a8 8 0 0 1-8-8z"/></g></g>', "smartphone-outline": '<g data-name="Layer 2"><g data-name="smartphone"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M17 2H7a3 3 0 0 0-3 3v14a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3V5a3 3 0 0 0-3-3zm1 17a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V5a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1z"/><circle cx="12" cy="16.5" r="1.5"/><path d="M14.5 6h-5a1 1 0 0 0 0 2h5a1 1 0 0 0 0-2z"/></g></g>', "smiling-face-outline": '<defs><style/></defs><g id="Layer_2" data-name="Layer 2"><g id="smiling-face"><g id="smiling-face" data-name="smiling-face"><rect width="24" height="24" opacity="0"/><path d="M12 2c5.523 0 10 4.477 10 10s-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2zm0 2a8 8 0 1 0 0 16 8 8 0 0 0 0-16zm5 9a5 5 0 0 1-10 0z" id="&#x1F3A8;-Icon-&#x421;olor"/></g></g></g>', "speaker-outline": '<g data-name="Layer 2"><g data-name="speaker"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M12 11a3 3 0 1 0-3-3 3 3 0 0 0 3 3zm0-4a1 1 0 1 1-1 1 1 1 0 0 1 1-1z"/><path d="M12 12a3.5 3.5 0 1 0 3.5 3.5A3.5 3.5 0 0 0 12 12zm0 5a1.5 1.5 0 1 1 1.5-1.5A1.5 1.5 0 0 1 12 17z"/><path d="M17 2H7a3 3 0 0 0-3 3v14a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3V5a3 3 0 0 0-3-3zm1 17a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V5a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1z"/></g></g>', "square-outline": '<g data-name="Layer 2"><g data-name="square"><rect width="24" height="24" opacity="0"/><path d="M18 21H6a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3h12a3 3 0 0 1 3 3v12a3 3 0 0 1-3 3zM6 5a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1z"/></g></g>', "star-outline": '<g data-name="Layer 2"><g data-name="star"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M17.56 21a1 1 0 0 1-.46-.11L12 18.22l-5.1 2.67a1 1 0 0 1-1.45-1.06l1-5.63-4.12-4a1 1 0 0 1-.25-1 1 1 0 0 1 .81-.68l5.7-.83 2.51-5.13a1 1 0 0 1 1.8 0l2.54 5.12 5.7.83a1 1 0 0 1 .81.68 1 1 0 0 1-.25 1l-4.12 4 1 5.63a1 1 0 0 1-.4 1 1 1 0 0 1-.62.18zM12 16.1a.92.92 0 0 1 .46.11l3.77 2-.72-4.21a1 1 0 0 1 .29-.89l3-2.93-4.2-.62a1 1 0 0 1-.71-.56L12 5.25 10.11 9a1 1 0 0 1-.75.54l-4.2.62 3 2.93a1 1 0 0 1 .29.89l-.72 4.16 3.77-2a.92.92 0 0 1 .5-.04z"/></g></g>', "stop-circle-outline": '<g data-name="Layer 2"><g data-name="stop-circle"><rect width="24" height="24" opacity="0"/><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 18a8 8 0 1 1 8-8 8 8 0 0 1-8 8z"/><path d="M14.75 8h-5.5A1.25 1.25 0 0 0 8 9.25v5.5A1.25 1.25 0 0 0 9.25 16h5.5A1.25 1.25 0 0 0 16 14.75v-5.5A1.25 1.25 0 0 0 14.75 8zM14 14h-4v-4h4z"/></g></g>', "sun-outline": '<g data-name="Layer 2"><g data-name="sun"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M12 6a1 1 0 0 0 1-1V3a1 1 0 0 0-2 0v2a1 1 0 0 0 1 1z"/><path d="M21 11h-2a1 1 0 0 0 0 2h2a1 1 0 0 0 0-2z"/><path d="M6 12a1 1 0 0 0-1-1H3a1 1 0 0 0 0 2h2a1 1 0 0 0 1-1z"/><path d="M6.22 5a1 1 0 0 0-1.39 1.47l1.44 1.39a1 1 0 0 0 .73.28 1 1 0 0 0 .72-.31 1 1 0 0 0 0-1.41z"/><path d="M17 8.14a1 1 0 0 0 .69-.28l1.44-1.39A1 1 0 0 0 17.78 5l-1.44 1.42a1 1 0 0 0 0 1.41 1 1 0 0 0 .66.31z"/><path d="M12 18a1 1 0 0 0-1 1v2a1 1 0 0 0 2 0v-2a1 1 0 0 0-1-1z"/><path d="M17.73 16.14a1 1 0 0 0-1.39 1.44L17.78 19a1 1 0 0 0 .69.28 1 1 0 0 0 .72-.3 1 1 0 0 0 0-1.42z"/><path d="M6.27 16.14l-1.44 1.39a1 1 0 0 0 0 1.42 1 1 0 0 0 .72.3 1 1 0 0 0 .67-.25l1.44-1.39a1 1 0 0 0-1.39-1.44z"/><path d="M12 8a4 4 0 1 0 4 4 4 4 0 0 0-4-4zm0 6a2 2 0 1 1 2-2 2 2 0 0 1-2 2z"/></g></g>', "swap-outline": '<g data-name="Layer 2"><g data-name="swap"><rect width="24" height="24" transform="rotate(-90 12 12)" opacity="0"/><path d="M4 9h13l-1.6 1.2a1 1 0 0 0-.2 1.4 1 1 0 0 0 .8.4 1 1 0 0 0 .6-.2l4-3a1 1 0 0 0 0-1.59l-3.86-3a1 1 0 0 0-1.23 1.58L17.08 7H4a1 1 0 0 0 0 2z"/><path d="M20 16H7l1.6-1.2a1 1 0 0 0-1.2-1.6l-4 3a1 1 0 0 0 0 1.59l3.86 3a1 1 0 0 0 .61.21 1 1 0 0 0 .79-.39 1 1 0 0 0-.17-1.4L6.92 18H20a1 1 0 0 0 0-2z"/></g></g>', "sync-outline": '<g data-name="Layer 2"><g data-name="sync"><rect width="24" height="24" opacity="0"/><path d="M21.66 10.37a.62.62 0 0 0 .07-.19l.75-4a1 1 0 0 0-2-.36l-.37 2a9.22 9.22 0 0 0-16.58.84 1 1 0 0 0 .55 1.3 1 1 0 0 0 1.31-.55A7.08 7.08 0 0 1 12.07 5a7.17 7.17 0 0 1 6.24 3.58l-1.65-.27a1 1 0 1 0-.32 2l4.25.71h.16a.93.93 0 0 0 .34-.06.33.33 0 0 0 .1-.06.78.78 0 0 0 .2-.11l.08-.1a1.07 1.07 0 0 0 .14-.16.58.58 0 0 0 .05-.16z"/><path d="M19.88 14.07a1 1 0 0 0-1.31.56A7.08 7.08 0 0 1 11.93 19a7.17 7.17 0 0 1-6.24-3.58l1.65.27h.16a1 1 0 0 0 .16-2L3.41 13a.91.91 0 0 0-.33 0H3a1.15 1.15 0 0 0-.32.14 1 1 0 0 0-.18.18l-.09.1a.84.84 0 0 0-.07.19.44.44 0 0 0-.07.17l-.75 4a1 1 0 0 0 .8 1.22h.18a1 1 0 0 0 1-.82l.37-2a9.22 9.22 0 0 0 16.58-.83 1 1 0 0 0-.57-1.28z"/></g></g>', "text-outline": '<g data-name="Layer 2"><g data-name="text"><rect width="24" height="24" opacity="0"/><path d="M20 4H4a1 1 0 0 0-1 1v3a1 1 0 0 0 2 0V6h6v13H9a1 1 0 0 0 0 2h6a1 1 0 0 0 0-2h-2V6h6v2a1 1 0 0 0 2 0V5a1 1 0 0 0-1-1z"/></g></g>', "thermometer-minus-outline": '<g data-name="Layer 2"><g data-name="thermometer-minus"><rect width="24" height="24" opacity="0"/><rect x="2" y="5" width="6" height="2" rx="1" ry="1"/><path d="M14 22a5 5 0 0 1-3-9V5a3 3 0 0 1 3-3 3 3 0 0 1 3 3v8a5 5 0 0 1-3 9zm0-18a1 1 0 0 0-1 1v8.54a1 1 0 0 1-.5.87A3 3 0 0 0 11 17a3 3 0 0 0 6 0 3 3 0 0 0-1.5-2.59 1 1 0 0 1-.5-.87V5a.93.93 0 0 0-.29-.69A1 1 0 0 0 14 4z"/></g></g>', "thermometer-outline": '<g data-name="Layer 2"><g data-name="thermometer"><rect width="24" height="24" opacity="0"/><path d="M12 22a5 5 0 0 1-3-9V5a3 3 0 0 1 3-3 3 3 0 0 1 3 3v8a5 5 0 0 1-3 9zm0-18a1 1 0 0 0-1 1v8.54a1 1 0 0 1-.5.87A3 3 0 0 0 9 17a3 3 0 0 0 6 0 3 3 0 0 0-1.5-2.59 1 1 0 0 1-.5-.87V5a.93.93 0 0 0-.29-.69A1 1 0 0 0 12 4z"/></g></g>', "thermometer-plus-outline": '<g data-name="Layer 2"><g data-name="thermometer-plus"><rect width="24" height="24" opacity="0"/><rect x="2" y="5" width="6" height="2" rx="1" ry="1"/><rect x="2" y="5" width="6" height="2" rx="1" ry="1" transform="rotate(-90 5 6)"/><path d="M14 22a5 5 0 0 1-3-9V5a3 3 0 0 1 3-3 3 3 0 0 1 3 3v8a5 5 0 0 1-3 9zm0-18a1 1 0 0 0-1 1v8.54a1 1 0 0 1-.5.87A3 3 0 0 0 11 17a3 3 0 0 0 6 0 3 3 0 0 0-1.5-2.59 1 1 0 0 1-.5-.87V5a.93.93 0 0 0-.29-.69A1 1 0 0 0 14 4z"/></g></g>', "toggle-left-outline": '<g data-name="Layer 2"><g data-name="toggle-left"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M15 5H9a7 7 0 0 0 0 14h6a7 7 0 0 0 0-14zm0 12H9A5 5 0 0 1 9 7h6a5 5 0 0 1 0 10z"/><path d="M9 9a3 3 0 1 0 3 3 3 3 0 0 0-3-3zm0 4a1 1 0 1 1 1-1 1 1 0 0 1-1 1z"/></g></g>', "toggle-right-outline": '<g data-name="Layer 2"><g data-name="toggle-right"><rect width="24" height="24" opacity="0"/><path d="M15 5H9a7 7 0 0 0 0 14h6a7 7 0 0 0 0-14zm0 12H9A5 5 0 0 1 9 7h6a5 5 0 0 1 0 10z"/><path d="M15 9a3 3 0 1 0 3 3 3 3 0 0 0-3-3zm0 4a1 1 0 1 1 1-1 1 1 0 0 1-1 1z"/></g></g>', "trash-2-outline": '<g data-name="Layer 2"><g data-name="trash-2"><rect width="24" height="24" opacity="0"/><path d="M21 6h-5V4.33A2.42 2.42 0 0 0 13.5 2h-3A2.42 2.42 0 0 0 8 4.33V6H3a1 1 0 0 0 0 2h1v11a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3V8h1a1 1 0 0 0 0-2zM10 4.33c0-.16.21-.33.5-.33h3c.29 0 .5.17.5.33V6h-4zM18 19a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V8h12z"/><path d="M9 17a1 1 0 0 0 1-1v-4a1 1 0 0 0-2 0v4a1 1 0 0 0 1 1z"/><path d="M15 17a1 1 0 0 0 1-1v-4a1 1 0 0 0-2 0v4a1 1 0 0 0 1 1z"/></g></g>', "trash-outline": '<g data-name="Layer 2"><g data-name="trash"><rect width="24" height="24" opacity="0"/><path d="M21 6h-5V4.33A2.42 2.42 0 0 0 13.5 2h-3A2.42 2.42 0 0 0 8 4.33V6H3a1 1 0 0 0 0 2h1v11a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3V8h1a1 1 0 0 0 0-2zM10 4.33c0-.16.21-.33.5-.33h3c.29 0 .5.17.5.33V6h-4zM18 19a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V8h12z"/></g></g>', "trending-down-outline": '<g data-name="Layer 2"><g data-name="trending-down"><rect width="24" height="24" transform="rotate(-90 12 12)" opacity="0"/><path d="M21 12a1 1 0 0 0-2 0v2.3l-4.24-5a1 1 0 0 0-1.27-.21L9.22 11.7 4.77 6.36a1 1 0 1 0-1.54 1.28l5 6a1 1 0 0 0 1.28.22l4.28-2.57 4 4.71H15a1 1 0 0 0 0 2h5a1.1 1.1 0 0 0 .36-.07l.14-.08a1.19 1.19 0 0 0 .15-.09.75.75 0 0 0 .14-.17 1.1 1.1 0 0 0 .09-.14.64.64 0 0 0 .05-.17A.78.78 0 0 0 21 17z"/></g></g>', "trending-up-outline": '<g data-name="Layer 2"><g data-name="trending-up"><rect width="24" height="24" transform="rotate(-90 12 12)" opacity="0"/><path d="M21 7a.78.78 0 0 0 0-.21.64.64 0 0 0-.05-.17 1.1 1.1 0 0 0-.09-.14.75.75 0 0 0-.14-.17l-.12-.07a.69.69 0 0 0-.19-.1h-.2A.7.7 0 0 0 20 6h-5a1 1 0 0 0 0 2h2.83l-4 4.71-4.32-2.57a1 1 0 0 0-1.28.22l-5 6a1 1 0 0 0 .13 1.41A1 1 0 0 0 4 18a1 1 0 0 0 .77-.36l4.45-5.34 4.27 2.56a1 1 0 0 0 1.27-.21L19 9.7V12a1 1 0 0 0 2 0V7z"/></g></g>', "tv-outline": '<g data-name="Layer 2"><g data-name="tv"><rect width="24" height="24" opacity="0"/><path d="M18 6h-3.59l2.3-2.29a1 1 0 1 0-1.42-1.42L12 5.59l-3.29-3.3a1 1 0 1 0-1.42 1.42L9.59 6H6a3 3 0 0 0-3 3v10a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3V9a3 3 0 0 0-3-3zm1 13a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V9a1 1 0 0 1 1-1h12a1 1 0 0 1 1 1z"/></g></g>', "twitter-outline": '<g data-name="Layer 2"><g data-name="twitter"><polyline points="0 0 24 0 24 24 0 24" opacity="0"/><path d="M8.51 20h-.08a10.87 10.87 0 0 1-4.65-1.09A1.38 1.38 0 0 1 3 17.47a1.41 1.41 0 0 1 1.16-1.18 6.63 6.63 0 0 0 2.54-.89 9.49 9.49 0 0 1-3.51-9.07 1.41 1.41 0 0 1 1-1.15 1.35 1.35 0 0 1 1.43.41 7.09 7.09 0 0 0 4.88 2.75 4.5 4.5 0 0 1 1.41-3.1 4.47 4.47 0 0 1 6.37.19.7.7 0 0 0 .78.1A1.39 1.39 0 0 1 21 7.13a6.66 6.66 0 0 1-1.28 2.6A10.79 10.79 0 0 1 8.51 20zm0-2h.08a8.79 8.79 0 0 0 9.09-8.59 1.32 1.32 0 0 1 .37-.85 5.19 5.19 0 0 0 .62-1 2.56 2.56 0 0 1-1.91-.85A2.45 2.45 0 0 0 15 6a2.5 2.5 0 0 0-1.79.69 2.53 2.53 0 0 0-.72 2.42l.26 1.14-1.17.08a8.3 8.3 0 0 1-6.54-2.4 7.12 7.12 0 0 0 3.73 6.46l.95.54-.63.9a5.62 5.62 0 0 1-2.68 1.92A8.34 8.34 0 0 0 8.5 18zM19 6.65z"/></g></g>', "umbrella-outline": '<g data-name="Layer 2"><g data-name="umbrella"><rect width="24" height="24" opacity="0"/><path d="M12 2A10 10 0 0 0 2 12a1 1 0 0 0 1 1h8v6a3 3 0 0 0 6 0 1 1 0 0 0-2 0 1 1 0 0 1-2 0v-6h8a1 1 0 0 0 1-1A10 10 0 0 0 12 2zm-7.94 9a8 8 0 0 1 15.88 0z"/></g></g>', "undo-outline": '<g data-name="Layer 2"><g data-name="undo"><rect width="24" height="24" transform="rotate(-90 12 12)" opacity="0"/><path d="M20.22 21a1 1 0 0 1-1-.76 8.91 8.91 0 0 0-7.8-6.69v1.12a1.78 1.78 0 0 1-1.09 1.64A2 2 0 0 1 8.18 16l-5.06-4.41a1.76 1.76 0 0 1 0-2.68l5.06-4.42a2 2 0 0 1 2.18-.3 1.78 1.78 0 0 1 1.09 1.64V7A10.89 10.89 0 0 1 21.5 17.75a10.29 10.29 0 0 1-.31 2.49 1 1 0 0 1-1 .76zm-9.77-9.5a11.07 11.07 0 0 1 8.81 4.26A9 9 0 0 0 10.45 9a1 1 0 0 1-1-1V6.08l-4.82 4.17 4.82 4.21v-2a1 1 0 0 1 1-.96z"/></g></g>', "unlock-outline": '<g data-name="Layer 2"><g data-name="unlock"><rect width="24" height="24" opacity="0"/><path d="M17 8h-7V6a2 2 0 0 1 4 0 1 1 0 0 0 2 0 4 4 0 0 0-8 0v2H7a3 3 0 0 0-3 3v8a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3v-8a3 3 0 0 0-3-3zm1 11a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1v-8a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1z"/><path d="M12 12a3 3 0 1 0 3 3 3 3 0 0 0-3-3zm0 4a1 1 0 1 1 1-1 1 1 0 0 1-1 1z"/></g></g>', "upload-outline": '<g data-name="Layer 2"><g data-name="upload"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><rect x="4" y="4" width="16" height="2" rx="1" ry="1" transform="rotate(180 12 5)"/><rect x="17" y="5" width="4" height="2" rx="1" ry="1" transform="rotate(90 19 6)"/><rect x="3" y="5" width="4" height="2" rx="1" ry="1" transform="rotate(90 5 6)"/><path d="M8 14a1 1 0 0 1-.8-.4 1 1 0 0 1 .2-1.4l4-3a1 1 0 0 1 1.18 0l4 2.82a1 1 0 0 1 .24 1.39 1 1 0 0 1-1.4.24L12 11.24 8.6 13.8a1 1 0 0 1-.6.2z"/><path d="M12 21a1 1 0 0 1-1-1v-8a1 1 0 0 1 2 0v8a1 1 0 0 1-1 1z"/></g></g>', "video-off-outline": '<g data-name="Layer 2"><g data-name="video-off"><rect width="24" height="24" opacity="0"/><path d="M17 15.59l-2-2L8.41 7l-2-2-1.7-1.71a1 1 0 0 0-1.42 1.42l.54.53L5.59 7l9.34 9.34 1.46 1.46 2.9 2.91a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42z"/><path d="M14 17H5a1 1 0 0 1-1-1V8a1 1 0 0 1 .4-.78L3 5.8A3 3 0 0 0 2 8v8a3 3 0 0 0 3 3h9a2.94 2.94 0 0 0 1.66-.51L14.14 17a.7.7 0 0 1-.14 0z"/><path d="M21 7.15a1.7 1.7 0 0 0-1.85.3l-2.15 2V8a3 3 0 0 0-3-3H7.83l2 2H14a1 1 0 0 1 1 1v4.17l4.72 4.72a1.73 1.73 0 0 0 .6.11 1.68 1.68 0 0 0 .69-.15 1.6 1.6 0 0 0 1-1.48V8.63A1.6 1.6 0 0 0 21 7.15zm-1 7.45L17.19 12 20 9.4z"/></g></g>', "video-outline": '<g data-name="Layer 2"><g data-name="video"><rect width="24" height="24" opacity="0"/><path d="M21 7.15a1.7 1.7 0 0 0-1.85.3l-2.15 2V8a3 3 0 0 0-3-3H5a3 3 0 0 0-3 3v8a3 3 0 0 0 3 3h9a3 3 0 0 0 3-3v-1.45l2.16 2a1.74 1.74 0 0 0 1.16.45 1.68 1.68 0 0 0 .69-.15 1.6 1.6 0 0 0 1-1.48V8.63A1.6 1.6 0 0 0 21 7.15zM15 16a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1h9a1 1 0 0 1 1 1zm5-1.4L17.19 12 20 9.4z"/></g></g>', "volume-down-outline": '<g data-name="Layer 2"><g data-name="volume-down"><rect width="24" height="24" opacity="0"/><path d="M20.78 8.37a1 1 0 1 0-1.56 1.26 4 4 0 0 1 0 4.74A1 1 0 0 0 20 16a1 1 0 0 0 .78-.37 6 6 0 0 0 0-7.26z"/><path d="M16.47 3.12a1 1 0 0 0-1 0L9 7.57H4a1 1 0 0 0-1 1v6.86a1 1 0 0 0 1 1h5l6.41 4.4A1.06 1.06 0 0 0 16 21a1 1 0 0 0 1-1V4a1 1 0 0 0-.53-.88zM15 18.1l-5.1-3.5a1 1 0 0 0-.57-.17H5V9.57h4.33a1 1 0 0 0 .57-.17L15 5.9z"/></g></g>', "volume-mute-outline": '<g data-name="Layer 2"><g data-name="volume-mute"><rect width="24" height="24" opacity="0"/><path d="M17 21a1.06 1.06 0 0 1-.57-.17L10 16.43H5a1 1 0 0 1-1-1V8.57a1 1 0 0 1 1-1h5l6.41-4.4A1 1 0 0 1 18 4v16a1 1 0 0 1-1 1zM6 14.43h4.33a1 1 0 0 1 .57.17l5.1 3.5V5.9l-5.1 3.5a1 1 0 0 1-.57.17H6z"/></g></g>', "volume-off-outline": '<g data-name="Layer 2"><g data-name="volume-off"><rect width="24" height="24" opacity="0"/><path d="M4.71 3.29a1 1 0 0 0-1.42 1.42l16 16a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42z"/><path d="M16.91 14.08l1.44 1.44a6 6 0 0 0-.07-7.15 1 1 0 1 0-1.56 1.26 4 4 0 0 1 .19 4.45z"/><path d="M21 12a6.51 6.51 0 0 1-1.78 4.39l1.42 1.42A8.53 8.53 0 0 0 23 12a8.75 8.75 0 0 0-3.36-6.77 1 1 0 1 0-1.28 1.54A6.8 6.8 0 0 1 21 12z"/><path d="M13.5 18.1l-5.1-3.5a1 1 0 0 0-.57-.17H3.5V9.57h3.24l-2-2H2.5a1 1 0 0 0-1 1v6.86a1 1 0 0 0 1 1h5l6.41 4.4a1.06 1.06 0 0 0 .57.17 1 1 0 0 0 1-1v-1.67l-2-2z"/><path d="M13.5 5.9v4.77l2 2V4a1 1 0 0 0-1.57-.83L9.23 6.4l1.44 1.44z"/></g></g>', "volume-up-outline": '<g data-name="Layer 2"><g data-name="volume-up"><rect width="24" height="24" opacity="0"/><path d="M18.28 8.37a1 1 0 1 0-1.56 1.26 4 4 0 0 1 0 4.74A1 1 0 0 0 17.5 16a1 1 0 0 0 .78-.37 6 6 0 0 0 0-7.26z"/><path d="M19.64 5.23a1 1 0 1 0-1.28 1.54A6.8 6.8 0 0 1 21 12a6.8 6.8 0 0 1-2.64 5.23 1 1 0 0 0-.13 1.41A1 1 0 0 0 19 19a1 1 0 0 0 .64-.23A8.75 8.75 0 0 0 23 12a8.75 8.75 0 0 0-3.36-6.77z"/><path d="M15 3.12a1 1 0 0 0-1 0L7.52 7.57h-5a1 1 0 0 0-1 1v6.86a1 1 0 0 0 1 1h5l6.41 4.4a1.06 1.06 0 0 0 .57.17 1 1 0 0 0 1-1V4a1 1 0 0 0-.5-.88zm-1.47 15L8.4 14.6a1 1 0 0 0-.57-.17H3.5V9.57h4.33a1 1 0 0 0 .57-.17l5.1-3.5z"/></g></g>', "wifi-off-outline": '<g data-name="Layer 2"><g data-name="wifi-off"><rect width="24" height="24" opacity="0"/><circle cx="12" cy="19" r="1"/><path d="M12.44 11l-1.9-1.89-2.46-2.44-1.55-1.55-1.82-1.83a1 1 0 0 0-1.42 1.42l1.38 1.37 1.46 1.46 2.23 2.24 1.55 1.54 2.74 2.74 2.79 2.8 3.85 3.85a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42z"/><path d="M21.72 7.93A13.93 13.93 0 0 0 12 4a14.1 14.1 0 0 0-4.44.73l1.62 1.62a11.89 11.89 0 0 1 11.16 3 1 1 0 0 0 .69.28 1 1 0 0 0 .72-.31 1 1 0 0 0-.03-1.39z"/><path d="M3.82 6.65a14.32 14.32 0 0 0-1.54 1.28 1 1 0 0 0 1.38 1.44 13.09 13.09 0 0 1 1.6-1.29z"/><path d="M17 13.14a1 1 0 0 0 .71.3 1 1 0 0 0 .72-1.69A9 9 0 0 0 12 9h-.16l2.35 2.35A7 7 0 0 1 17 13.14z"/><path d="M7.43 10.26a8.8 8.8 0 0 0-1.9 1.49A1 1 0 0 0 7 13.14a7.3 7.3 0 0 1 2-1.41z"/><path d="M8.53 15.4a1 1 0 1 0 1.39 1.44 3.06 3.06 0 0 1 3.84-.25l-2.52-2.52a5 5 0 0 0-2.71 1.33z"/></g></g>', "wifi-outline": '<g data-name="Layer 2"><g data-name="wifi"><rect width="24" height="24" opacity="0"/><circle cx="12" cy="19" r="1"/><path d="M12 14a5 5 0 0 0-3.47 1.4 1 1 0 1 0 1.39 1.44 3.08 3.08 0 0 1 4.16 0 1 1 0 1 0 1.39-1.44A5 5 0 0 0 12 14z"/><path d="M12 9a9 9 0 0 0-6.47 2.75A1 1 0 0 0 7 13.14a7 7 0 0 1 10.08 0 1 1 0 0 0 .71.3 1 1 0 0 0 .72-1.69A9 9 0 0 0 12 9z"/><path d="M21.72 7.93a14 14 0 0 0-19.44 0 1 1 0 0 0 1.38 1.44 12 12 0 0 1 16.68 0 1 1 0 0 0 .69.28 1 1 0 0 0 .72-.31 1 1 0 0 0-.03-1.41z"/></g></g>' };
            })
          ),
          /***/
          "./package/src/animation.scss": (
            /*!************************************!*\
              !*** ./package/src/animation.scss ***!
              \************************************/
            /*! no static exports found */
            /***/
            (function(module2, exports2, __webpack_require__) {
              var refs = 0;
              var css = __webpack_require__(
                /*! !../../node_modules/css-loader!../../node_modules/sass-loader/lib/loader.js!./animation.scss */
                "./node_modules/css-loader/index.js!./node_modules/sass-loader/lib/loader.js!./package/src/animation.scss"
              );
              var insertCss = __webpack_require__(
                /*! ../../node_modules/isomorphic-style-loader/insertCss.js */
                "./node_modules/isomorphic-style-loader/insertCss.js"
              );
              var content = typeof css === "string" ? [[module2.i, css, ""]] : css;
              exports2 = module2.exports = css.locals || {};
              exports2._getContent = function() {
                return content;
              };
              exports2._getCss = function() {
                return "" + css;
              };
              exports2._insertCss = function(options) {
                return insertCss(content, options);
              };
              if (false) {
                var removeCss;
              }
            })
          ),
          /***/
          "./package/src/default-attrs.json": (
            /*!****************************************!*\
              !*** ./package/src/default-attrs.json ***!
              \****************************************/
            /*! exports provided: xmlns, width, height, viewBox, default */
            /***/
            (function(module2) {
              module2.exports = { "xmlns": "http://www.w3.org/2000/svg", "width": 24, "height": 24, "viewBox": "0 0 24 24" };
            })
          ),
          /***/
          "./package/src/icon.js": (
            /*!*****************************!*\
              !*** ./package/src/icon.js ***!
              \*****************************/
            /*! exports provided: default */
            /***/
            (function(module2, __webpack_exports__, __webpack_require__) {
              "use strict";
              __webpack_require__.r(__webpack_exports__);
              var classnames_dedupe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
                /*! classnames/dedupe */
                "./node_modules/classnames/dedupe.js"
              );
              var classnames_dedupe__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__.n(classnames_dedupe__WEBPACK_IMPORTED_MODULE_0__);
              var _default_attrs_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
                /*! ./default-attrs.json */
                "./package/src/default-attrs.json"
              );
              var _default_attrs_json__WEBPACK_IMPORTED_MODULE_1___namespace = /* @__PURE__ */ __webpack_require__.t(
                /*! ./default-attrs.json */
                "./package/src/default-attrs.json",
                1
              );
              function _objectWithoutProperties(source, excluded) {
                if (source == null) return {};
                var target = _objectWithoutPropertiesLoose(source, excluded);
                var key, i;
                if (Object.getOwnPropertySymbols) {
                  var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
                  for (i = 0; i < sourceSymbolKeys.length; i++) {
                    key = sourceSymbolKeys[i];
                    if (excluded.indexOf(key) >= 0) continue;
                    if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
                    target[key] = source[key];
                  }
                }
                return target;
              }
              function _objectWithoutPropertiesLoose(source, excluded) {
                if (source == null) return {};
                var target = {};
                var sourceKeys = Object.keys(source);
                var key, i;
                for (i = 0; i < sourceKeys.length; i++) {
                  key = sourceKeys[i];
                  if (excluded.indexOf(key) >= 0) continue;
                  target[key] = source[key];
                }
                return target;
              }
              function _objectSpread(target) {
                for (var i = 1; i < arguments.length; i++) {
                  var source = arguments[i] != null ? arguments[i] : {};
                  var ownKeys = Object.keys(source);
                  if (typeof Object.getOwnPropertySymbols === "function") {
                    ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                      return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                    }));
                  }
                  ownKeys.forEach(function(key) {
                    _defineProperty(target, key, source[key]);
                  });
                }
                return target;
              }
              function _defineProperty(obj, key, value) {
                if (key in obj) {
                  Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
                } else {
                  obj[key] = value;
                }
                return obj;
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor) descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function _createClass(Constructor, protoProps, staticProps) {
                if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                if (staticProps) _defineProperties(Constructor, staticProps);
                return Constructor;
              }
              var defaultAnimationOptions = {
                hover: true
              };
              var isString = function isString2(value) {
                return typeof value === "string" || value instanceof String;
              };
              var Icon = /* @__PURE__ */ (function() {
                function Icon2(name, contents) {
                  _classCallCheck(this, Icon2);
                  this.name = name;
                  this.contents = contents;
                  this.attrs = _objectSpread({}, _default_attrs_json__WEBPACK_IMPORTED_MODULE_1__, {
                    class: "eva eva-".concat(name)
                  });
                }
                _createClass(Icon2, [{
                  key: "toSvg",
                  value: function toSvg() {
                    var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                    var animation2 = attrs.animation, remAttrs = _objectWithoutProperties(attrs, ["animation"]);
                    var animationOptions = getAnimationOptions(animation2);
                    var animationClasses = animationOptions ? animationOptions.class : "";
                    var combinedAttrs = _objectSpread({}, this.attrs, remAttrs, {
                      class: classnames_dedupe__WEBPACK_IMPORTED_MODULE_0___default()(this.attrs.class, attrs.class, animationClasses)
                    });
                    var svg = "<svg ".concat(attrsToString(combinedAttrs), ">").concat(this.contents, "</svg>");
                    return !!animationOptions ? animationOptions.hover ? '<i class="eva-hover">'.concat(svg, "</i>") : svg : svg;
                  }
                }, {
                  key: "toString",
                  value: function toString() {
                    return this.contents;
                  }
                }]);
                return Icon2;
              })();
              function getAnimationOptions(animation2) {
                if (!animation2) {
                  return null;
                }
                if (animation2.hover) {
                  animation2.hover = isString(animation2.hover) ? JSON.parse(animation2.hover) : animation2.hover;
                }
                var mergedAnimationOptions = _objectSpread({}, defaultAnimationOptions, animation2);
                var animationType = mergedAnimationOptions.hover ? "eva-icon-hover-".concat(mergedAnimationOptions.type) : "eva-icon-".concat(mergedAnimationOptions.type);
                mergedAnimationOptions.class = classnames_dedupe__WEBPACK_IMPORTED_MODULE_0___default()({
                  "eva-animation": true,
                  "eva-infinite": isString(animation2.infinite) ? JSON.parse(animation2.infinite) : animation2.infinite
                }, animationType);
                return mergedAnimationOptions;
              }
              function attrsToString(attrs) {
                return Object.keys(attrs).map(function(key) {
                  return "".concat(key, '="').concat(attrs[key], '"');
                }).join(" ");
              }
              __webpack_exports__["default"] = Icon;
            })
          ),
          /***/
          "./package/src/icons.js": (
            /*!******************************!*\
              !*** ./package/src/icons.js ***!
              \******************************/
            /*! exports provided: default */
            /***/
            (function(module2, __webpack_exports__, __webpack_require__) {
              "use strict";
              __webpack_require__.r(__webpack_exports__);
              var _icon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
                /*! ./icon */
                "./package/src/icon.js"
              );
              var _package_build_eva_icons_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
                /*! ../../package-build/eva-icons.json */
                "./package-build/eva-icons.json"
              );
              var _package_build_eva_icons_json__WEBPACK_IMPORTED_MODULE_1___namespace = /* @__PURE__ */ __webpack_require__.t(
                /*! ../../package-build/eva-icons.json */
                "./package-build/eva-icons.json",
                1
              );
              __webpack_exports__["default"] = Object.keys(_package_build_eva_icons_json__WEBPACK_IMPORTED_MODULE_1__).map(function(key) {
                return new _icon__WEBPACK_IMPORTED_MODULE_0__["default"](key, _package_build_eva_icons_json__WEBPACK_IMPORTED_MODULE_1__[key]);
              }).reduce(function(object, icon) {
                object[icon.name] = icon;
                return object;
              }, {});
            })
          ),
          /***/
          "./package/src/index.js": (
            /*!******************************!*\
              !*** ./package/src/index.js ***!
              \******************************/
            /*! exports provided: icons, replace */
            /***/
            (function(module2, __webpack_exports__, __webpack_require__) {
              "use strict";
              __webpack_require__.r(__webpack_exports__);
              var _icons__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
                /*! ./icons */
                "./package/src/icons.js"
              );
              __webpack_require__.d(__webpack_exports__, "icons", function() {
                return _icons__WEBPACK_IMPORTED_MODULE_0__["default"];
              });
              var _replace__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
                /*! ./replace */
                "./package/src/replace.js"
              );
              __webpack_require__.d(__webpack_exports__, "replace", function() {
                return _replace__WEBPACK_IMPORTED_MODULE_1__["default"];
              });
              var _animation_scss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
                /*! ./animation.scss */
                "./package/src/animation.scss"
              );
              var _animation_scss__WEBPACK_IMPORTED_MODULE_2___default = /* @__PURE__ */ __webpack_require__.n(_animation_scss__WEBPACK_IMPORTED_MODULE_2__);
              if (typeof window !== "undefined") {
                _animation_scss__WEBPACK_IMPORTED_MODULE_2___default.a._insertCss();
              }
            })
          ),
          /***/
          "./package/src/replace.js": (
            /*!********************************!*\
              !*** ./package/src/replace.js ***!
              \********************************/
            /*! exports provided: default */
            /***/
            (function(module2, __webpack_exports__, __webpack_require__) {
              "use strict";
              __webpack_require__.r(__webpack_exports__);
              var classnames_dedupe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
                /*! classnames/dedupe */
                "./node_modules/classnames/dedupe.js"
              );
              var classnames_dedupe__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__.n(classnames_dedupe__WEBPACK_IMPORTED_MODULE_0__);
              var _icons__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
                /*! ./icons */
                "./package/src/icons.js"
              );
              function _objectSpread(target) {
                for (var i = 1; i < arguments.length; i++) {
                  var source = arguments[i] != null ? arguments[i] : {};
                  var ownKeys = Object.keys(source);
                  if (typeof Object.getOwnPropertySymbols === "function") {
                    ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                      return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                    }));
                  }
                  ownKeys.forEach(function(key) {
                    _defineProperty(target, key, source[key]);
                  });
                }
                return target;
              }
              function _defineProperty(obj, key, value) {
                if (key in obj) {
                  Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
                } else {
                  obj[key] = value;
                }
                return obj;
              }
              function _objectWithoutProperties(source, excluded) {
                if (source == null) return {};
                var target = _objectWithoutPropertiesLoose(source, excluded);
                var key, i;
                if (Object.getOwnPropertySymbols) {
                  var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
                  for (i = 0; i < sourceSymbolKeys.length; i++) {
                    key = sourceSymbolKeys[i];
                    if (excluded.indexOf(key) >= 0) continue;
                    if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
                    target[key] = source[key];
                  }
                }
                return target;
              }
              function _objectWithoutPropertiesLoose(source, excluded) {
                if (source == null) return {};
                var target = {};
                var sourceKeys = Object.keys(source);
                var key, i;
                for (i = 0; i < sourceKeys.length; i++) {
                  key = sourceKeys[i];
                  if (excluded.indexOf(key) >= 0) continue;
                  target[key] = source[key];
                }
                return target;
              }
              var animationKeys = {
                "data-eva-animation": "type",
                "data-eva-hover": "hover",
                "data-eva-infinite": "infinite"
              };
              var dataAttributesKeys = {
                "data-eva": "name",
                "data-eva-width": "width",
                "data-eva-height": "height",
                "data-eva-fill": "fill"
              };
              function replace() {
                var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                if (typeof document === "undefined") {
                  throw new Error("`eva.replace()` only works in a browser environment.");
                }
                var elementsToReplace = document.querySelectorAll("[data-eva]");
                Array.from(elementsToReplace).forEach(function(element) {
                  return replaceElement(element, options);
                });
              }
              function replaceElement(element) {
                var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                var _getAttrs = getAttrs(element), name = _getAttrs.name, elementAttrs = _objectWithoutProperties(_getAttrs, ["name"]);
                var svgString = _icons__WEBPACK_IMPORTED_MODULE_1__["default"][name].toSvg(_objectSpread({}, options, elementAttrs, {
                  animation: getAnimationObject(options.animation, elementAttrs.animation)
                }, {
                  class: classnames_dedupe__WEBPACK_IMPORTED_MODULE_0___default()(options.class, elementAttrs.class)
                }));
                var svgDocument = new DOMParser().parseFromString(svgString, "text/html");
                var svgElement = svgDocument.querySelector(".eva-hover") || svgDocument.querySelector("svg");
                element.parentNode.replaceChild(svgElement, element);
              }
              function getAttrs(element) {
                return Array.from(element.attributes).reduce(function(attrs, attr) {
                  if (!!animationKeys[attr.name]) {
                    attrs["animation"] = _objectSpread({}, attrs["animation"], _defineProperty({}, animationKeys[attr.name], attr.value));
                  } else {
                    attrs = _objectSpread({}, attrs, getAttr(attr));
                  }
                  return attrs;
                }, {});
              }
              function getAttr(attr) {
                if (!!dataAttributesKeys[attr.name]) {
                  return _defineProperty({}, dataAttributesKeys[attr.name], attr.value);
                }
                return _defineProperty({}, attr.name, attr.value);
              }
              function getAnimationObject(optionsAnimation, elementAttrsAnimation) {
                if (optionsAnimation || elementAttrsAnimation) {
                  return _objectSpread({}, optionsAnimation, elementAttrsAnimation);
                }
                return null;
              }
              __webpack_exports__["default"] = replace;
            })
          )
          /******/
        })
      );
    });
  }
});

// node_modules/@angular/platform-browser/fesm2022/dom_renderer.mjs
var EventManagerPlugin = class {
  _doc;
  // TODO: remove (has some usage in G3)
  constructor(_doc) {
    this._doc = _doc;
  }
  // Using non-null assertion because it's set by EventManager's constructor
  manager;
};
var DomEventsPlugin = class _DomEventsPlugin extends EventManagerPlugin {
  constructor(doc) {
    super(doc);
  }
  // This plugin should come last in the list of plugins, because it accepts all
  // events.
  supports(eventName) {
    return true;
  }
  addEventListener(element, eventName, handler, options) {
    element.addEventListener(eventName, handler, options);
    return () => this.removeEventListener(element, eventName, handler, options);
  }
  removeEventListener(target, eventName, callback, options) {
    return target.removeEventListener(eventName, callback, options);
  }
  static \u0275fac = function DomEventsPlugin_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DomEventsPlugin)(\u0275\u0275inject(DOCUMENT));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _DomEventsPlugin,
    factory: _DomEventsPlugin.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DomEventsPlugin, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();
var EVENT_MANAGER_PLUGINS = new InjectionToken(ngDevMode ? "EventManagerPlugins" : "");
var EventManager = class _EventManager {
  _zone;
  _plugins;
  _eventNameToPlugin = /* @__PURE__ */ new Map();
  /**
   * Initializes an instance of the event-manager service.
   */
  constructor(plugins, _zone) {
    this._zone = _zone;
    plugins.forEach((plugin) => {
      plugin.manager = this;
    });
    const otherPlugins = plugins.filter((p) => !(p instanceof DomEventsPlugin));
    this._plugins = otherPlugins.slice().reverse();
    const domEventPlugin = plugins.find((p) => p instanceof DomEventsPlugin);
    if (domEventPlugin) {
      this._plugins.push(domEventPlugin);
    }
  }
  /**
   * Registers a handler for a specific element and event.
   *
   * @param element The HTML element to receive event notifications.
   * @param eventName The name of the event to listen for.
   * @param handler A function to call when the notification occurs. Receives the
   * event object as an argument.
   * @param options Options that configure how the event listener is bound.
   * @returns  A callback function that can be used to remove the handler.
   */
  addEventListener(element, eventName, handler, options) {
    const plugin = this._findPluginFor(eventName);
    return plugin.addEventListener(element, eventName, handler, options);
  }
  /**
   * Retrieves the compilation zone in which event listeners are registered.
   */
  getZone() {
    return this._zone;
  }
  /** @internal */
  _findPluginFor(eventName) {
    let plugin = this._eventNameToPlugin.get(eventName);
    if (plugin) {
      return plugin;
    }
    const plugins = this._plugins;
    plugin = plugins.find((plugin2) => plugin2.supports(eventName));
    if (!plugin) {
      throw new RuntimeError(5101, (typeof ngDevMode === "undefined" || ngDevMode) && `No event manager plugin found for event ${eventName}`);
    }
    this._eventNameToPlugin.set(eventName, plugin);
    return plugin;
  }
  static \u0275fac = function EventManager_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _EventManager)(\u0275\u0275inject(EVENT_MANAGER_PLUGINS), \u0275\u0275inject(NgZone));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _EventManager,
    factory: _EventManager.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EventManager, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [EVENT_MANAGER_PLUGINS]
    }]
  }, {
    type: NgZone
  }], null);
})();
var APP_ID_ATTRIBUTE_NAME = "ng-app-id";
function removeElements(elements) {
  for (const element of elements) {
    element.remove();
  }
}
function createStyleElement(style2, doc) {
  const styleElement = doc.createElement("style");
  styleElement.textContent = style2;
  return styleElement;
}
function addServerStyles(doc, appId, inline, external) {
  const elements = doc.head?.querySelectorAll(`style[${APP_ID_ATTRIBUTE_NAME}="${appId}"],link[${APP_ID_ATTRIBUTE_NAME}="${appId}"]`);
  if (elements) {
    for (const styleElement of elements) {
      styleElement.removeAttribute(APP_ID_ATTRIBUTE_NAME);
      if (styleElement instanceof HTMLLinkElement) {
        external.set(styleElement.href.slice(styleElement.href.lastIndexOf("/") + 1), {
          usage: 0,
          elements: [styleElement]
        });
      } else if (styleElement.textContent) {
        inline.set(styleElement.textContent, {
          usage: 0,
          elements: [styleElement]
        });
      }
    }
  }
}
function createLinkElement(url, doc) {
  const linkElement = doc.createElement("link");
  linkElement.setAttribute("rel", "stylesheet");
  linkElement.setAttribute("href", url);
  return linkElement;
}
var SharedStylesHost = class _SharedStylesHost {
  doc;
  appId;
  nonce;
  /**
   * Provides usage information for active inline style content and associated HTML <style> elements.
   * Embedded styles typically originate from the `styles` metadata of a rendered component.
   */
  inline = /* @__PURE__ */ new Map();
  /**
   * Provides usage information for active external style URLs and the associated HTML <link> elements.
   * External styles typically originate from the `ɵɵExternalStylesFeature` of a rendered component.
   */
  external = /* @__PURE__ */ new Map();
  /**
   * Set of host DOM nodes that will have styles attached.
   */
  hosts = /* @__PURE__ */ new Set();
  constructor(doc, appId, nonce, platformId = {}) {
    this.doc = doc;
    this.appId = appId;
    this.nonce = nonce;
    addServerStyles(doc, appId, this.inline, this.external);
    this.hosts.add(doc.head);
  }
  /**
   * Adds embedded styles to the DOM via HTML `style` elements.
   * @param styles An array of style content strings.
   */
  addStyles(styles, urls) {
    for (const value of styles) {
      this.addUsage(value, this.inline, createStyleElement);
    }
    urls?.forEach((value) => this.addUsage(value, this.external, createLinkElement));
  }
  /**
   * Removes embedded styles from the DOM that were added as HTML `style` elements.
   * @param styles An array of style content strings.
   */
  removeStyles(styles, urls) {
    for (const value of styles) {
      this.removeUsage(value, this.inline);
    }
    urls?.forEach((value) => this.removeUsage(value, this.external));
  }
  addUsage(value, usages, creator) {
    const record = usages.get(value);
    if (record) {
      if ((typeof ngDevMode === "undefined" || ngDevMode) && record.usage === 0) {
        record.elements.forEach((element) => element.setAttribute("ng-style-reused", ""));
      }
      record.usage++;
    } else {
      usages.set(value, {
        usage: 1,
        elements: [...this.hosts].map((host) => this.addElement(host, creator(value, this.doc)))
      });
    }
  }
  removeUsage(value, usages) {
    const record = usages.get(value);
    if (record) {
      record.usage--;
      if (record.usage <= 0) {
        removeElements(record.elements);
        usages.delete(value);
      }
    }
  }
  ngOnDestroy() {
    for (const [, {
      elements
    }] of [...this.inline, ...this.external]) {
      removeElements(elements);
    }
    this.hosts.clear();
  }
  /**
   * Adds a host node to the set of style hosts and adds all existing style usage to
   * the newly added host node.
   *
   * This is currently only used for Shadow DOM encapsulation mode.
   */
  addHost(hostNode) {
    this.hosts.add(hostNode);
    for (const [style2, {
      elements
    }] of this.inline) {
      elements.push(this.addElement(hostNode, createStyleElement(style2, this.doc)));
    }
    for (const [url, {
      elements
    }] of this.external) {
      elements.push(this.addElement(hostNode, createLinkElement(url, this.doc)));
    }
  }
  removeHost(hostNode) {
    this.hosts.delete(hostNode);
  }
  addElement(host, element) {
    if (this.nonce) {
      element.setAttribute("nonce", this.nonce);
    }
    if (false) {
      element.setAttribute(APP_ID_ATTRIBUTE_NAME, this.appId);
    }
    return host.appendChild(element);
  }
  static \u0275fac = function SharedStylesHost_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SharedStylesHost)(\u0275\u0275inject(DOCUMENT), \u0275\u0275inject(APP_ID), \u0275\u0275inject(CSP_NONCE, 8), \u0275\u0275inject(PLATFORM_ID));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _SharedStylesHost,
    factory: _SharedStylesHost.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SharedStylesHost, [{
    type: Injectable
  }], () => [{
    type: Document,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [APP_ID]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [CSP_NONCE]
    }, {
      type: Optional
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }], null);
})();
var NAMESPACE_URIS = {
  "svg": "http://www.w3.org/2000/svg",
  "xhtml": "http://www.w3.org/1999/xhtml",
  "xlink": "http://www.w3.org/1999/xlink",
  "xml": "http://www.w3.org/XML/1998/namespace",
  "xmlns": "http://www.w3.org/2000/xmlns/",
  "math": "http://www.w3.org/1998/Math/MathML"
};
var COMPONENT_REGEX = /%COMP%/g;
var SOURCEMAP_URL_REGEXP = /\/\*#\s*sourceMappingURL=(.+?)\s*\*\//;
var PROTOCOL_REGEXP = /^https?:/;
var COMPONENT_VARIABLE = "%COMP%";
var HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;
var CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;
var REMOVE_STYLES_ON_COMPONENT_DESTROY_DEFAULT = true;
var REMOVE_STYLES_ON_COMPONENT_DESTROY = new InjectionToken(ngDevMode ? "RemoveStylesOnCompDestroy" : "", {
  providedIn: "root",
  factory: () => REMOVE_STYLES_ON_COMPONENT_DESTROY_DEFAULT
});
function shimContentAttribute(componentShortId) {
  return CONTENT_ATTR.replace(COMPONENT_REGEX, componentShortId);
}
function shimHostAttribute(componentShortId) {
  return HOST_ATTR.replace(COMPONENT_REGEX, componentShortId);
}
function shimStylesContent(compId, styles) {
  return styles.map((s) => s.replace(COMPONENT_REGEX, compId));
}
function addBaseHrefToCssSourceMap(baseHref, styles) {
  if (!baseHref) {
    return styles;
  }
  const absoluteBaseHrefUrl = new URL(baseHref, "http://localhost");
  return styles.map((cssContent) => {
    if (!cssContent.includes("sourceMappingURL=")) {
      return cssContent;
    }
    return cssContent.replace(SOURCEMAP_URL_REGEXP, (_, sourceMapUrl) => {
      if (sourceMapUrl[0] === "/" || sourceMapUrl.startsWith("data:") || PROTOCOL_REGEXP.test(sourceMapUrl)) {
        return `/*# sourceMappingURL=${sourceMapUrl} */`;
      }
      const {
        pathname: resolvedSourceMapUrl
      } = new URL(sourceMapUrl, absoluteBaseHrefUrl);
      return `/*# sourceMappingURL=${resolvedSourceMapUrl} */`;
    });
  });
}
var DomRendererFactory2 = class _DomRendererFactory2 {
  eventManager;
  sharedStylesHost;
  appId;
  removeStylesOnCompDestroy;
  doc;
  platformId;
  ngZone;
  nonce;
  tracingService;
  rendererByCompId = /* @__PURE__ */ new Map();
  defaultRenderer;
  platformIsServer;
  constructor(eventManager, sharedStylesHost, appId, removeStylesOnCompDestroy, doc, platformId, ngZone, nonce = null, tracingService = null) {
    this.eventManager = eventManager;
    this.sharedStylesHost = sharedStylesHost;
    this.appId = appId;
    this.removeStylesOnCompDestroy = removeStylesOnCompDestroy;
    this.doc = doc;
    this.platformId = platformId;
    this.ngZone = ngZone;
    this.nonce = nonce;
    this.tracingService = tracingService;
    this.platformIsServer = false;
    this.defaultRenderer = new DefaultDomRenderer2(eventManager, doc, ngZone, this.platformIsServer, this.tracingService);
  }
  createRenderer(element, type) {
    if (!element || !type) {
      return this.defaultRenderer;
    }
    if (false) {
      type = __spreadProps(__spreadValues({}, type), {
        encapsulation: ViewEncapsulation.Emulated
      });
    }
    const renderer = this.getOrCreateRenderer(element, type);
    if (renderer instanceof EmulatedEncapsulationDomRenderer2) {
      renderer.applyToHost(element);
    } else if (renderer instanceof NoneEncapsulationDomRenderer) {
      renderer.applyStyles();
    }
    return renderer;
  }
  getOrCreateRenderer(element, type) {
    const rendererByCompId = this.rendererByCompId;
    let renderer = rendererByCompId.get(type.id);
    if (!renderer) {
      const doc = this.doc;
      const ngZone = this.ngZone;
      const eventManager = this.eventManager;
      const sharedStylesHost = this.sharedStylesHost;
      const removeStylesOnCompDestroy = this.removeStylesOnCompDestroy;
      const platformIsServer = this.platformIsServer;
      const tracingService = this.tracingService;
      switch (type.encapsulation) {
        case ViewEncapsulation.Emulated:
          renderer = new EmulatedEncapsulationDomRenderer2(eventManager, sharedStylesHost, type, this.appId, removeStylesOnCompDestroy, doc, ngZone, platformIsServer, tracingService);
          break;
        case ViewEncapsulation.ShadowDom:
          return new ShadowDomRenderer(eventManager, sharedStylesHost, element, type, doc, ngZone, this.nonce, platformIsServer, tracingService);
        default:
          renderer = new NoneEncapsulationDomRenderer(eventManager, sharedStylesHost, type, removeStylesOnCompDestroy, doc, ngZone, platformIsServer, tracingService);
          break;
      }
      rendererByCompId.set(type.id, renderer);
    }
    return renderer;
  }
  ngOnDestroy() {
    this.rendererByCompId.clear();
  }
  /**
   * Used during HMR to clear any cached data about a component.
   * @param componentId ID of the component that is being replaced.
   */
  componentReplaced(componentId) {
    this.rendererByCompId.delete(componentId);
  }
  static \u0275fac = function DomRendererFactory2_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DomRendererFactory2)(\u0275\u0275inject(EventManager), \u0275\u0275inject(SharedStylesHost), \u0275\u0275inject(APP_ID), \u0275\u0275inject(REMOVE_STYLES_ON_COMPONENT_DESTROY), \u0275\u0275inject(DOCUMENT), \u0275\u0275inject(PLATFORM_ID), \u0275\u0275inject(NgZone), \u0275\u0275inject(CSP_NONCE), \u0275\u0275inject(TracingService, 8));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _DomRendererFactory2,
    factory: _DomRendererFactory2.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DomRendererFactory2, [{
    type: Injectable
  }], () => [{
    type: EventManager
  }, {
    type: SharedStylesHost
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [APP_ID]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [REMOVE_STYLES_ON_COMPONENT_DESTROY]
    }]
  }, {
    type: Document,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: Object,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }, {
    type: NgZone
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [CSP_NONCE]
    }]
  }, {
    type: TracingService,
    decorators: [{
      type: Inject,
      args: [TracingService]
    }, {
      type: Optional
    }]
  }], null);
})();
var DefaultDomRenderer2 = class {
  eventManager;
  doc;
  ngZone;
  platformIsServer;
  tracingService;
  data = /* @__PURE__ */ Object.create(null);
  /**
   * By default this renderer throws when encountering synthetic properties
   * This can be disabled for example by the AsyncAnimationRendererFactory
   */
  throwOnSyntheticProps = true;
  constructor(eventManager, doc, ngZone, platformIsServer, tracingService) {
    this.eventManager = eventManager;
    this.doc = doc;
    this.ngZone = ngZone;
    this.platformIsServer = platformIsServer;
    this.tracingService = tracingService;
  }
  destroy() {
  }
  destroyNode = null;
  createElement(name, namespace) {
    if (namespace) {
      return this.doc.createElementNS(NAMESPACE_URIS[namespace] || namespace, name);
    }
    return this.doc.createElement(name);
  }
  createComment(value) {
    return this.doc.createComment(value);
  }
  createText(value) {
    return this.doc.createTextNode(value);
  }
  appendChild(parent, newChild) {
    const targetParent = isTemplateNode(parent) ? parent.content : parent;
    targetParent.appendChild(newChild);
  }
  insertBefore(parent, newChild, refChild) {
    if (parent) {
      const targetParent = isTemplateNode(parent) ? parent.content : parent;
      targetParent.insertBefore(newChild, refChild);
    }
  }
  removeChild(_parent, oldChild) {
    oldChild.remove();
  }
  selectRootElement(selectorOrNode, preserveContent) {
    let el = typeof selectorOrNode === "string" ? this.doc.querySelector(selectorOrNode) : selectorOrNode;
    if (!el) {
      throw new RuntimeError(-5104, (typeof ngDevMode === "undefined" || ngDevMode) && `The selector "${selectorOrNode}" did not match any elements`);
    }
    if (!preserveContent) {
      el.textContent = "";
    }
    return el;
  }
  parentNode(node) {
    return node.parentNode;
  }
  nextSibling(node) {
    return node.nextSibling;
  }
  setAttribute(el, name, value, namespace) {
    if (namespace) {
      name = namespace + ":" + name;
      const namespaceUri = NAMESPACE_URIS[namespace];
      if (namespaceUri) {
        el.setAttributeNS(namespaceUri, name, value);
      } else {
        el.setAttribute(name, value);
      }
    } else {
      el.setAttribute(name, value);
    }
  }
  removeAttribute(el, name, namespace) {
    if (namespace) {
      const namespaceUri = NAMESPACE_URIS[namespace];
      if (namespaceUri) {
        el.removeAttributeNS(namespaceUri, name);
      } else {
        el.removeAttribute(`${namespace}:${name}`);
      }
    } else {
      el.removeAttribute(name);
    }
  }
  addClass(el, name) {
    el.classList.add(name);
  }
  removeClass(el, name) {
    el.classList.remove(name);
  }
  setStyle(el, style2, value, flags) {
    if (flags & (RendererStyleFlags2.DashCase | RendererStyleFlags2.Important)) {
      el.style.setProperty(style2, value, flags & RendererStyleFlags2.Important ? "important" : "");
    } else {
      el.style[style2] = value;
    }
  }
  removeStyle(el, style2, flags) {
    if (flags & RendererStyleFlags2.DashCase) {
      el.style.removeProperty(style2);
    } else {
      el.style[style2] = "";
    }
  }
  setProperty(el, name, value) {
    if (el == null) {
      return;
    }
    (typeof ngDevMode === "undefined" || ngDevMode) && this.throwOnSyntheticProps && checkNoSyntheticProp(name, "property");
    el[name] = value;
  }
  setValue(node, value) {
    node.nodeValue = value;
  }
  listen(target, event, callback, options) {
    (typeof ngDevMode === "undefined" || ngDevMode) && this.throwOnSyntheticProps && checkNoSyntheticProp(event, "listener");
    if (typeof target === "string") {
      target = getDOM().getGlobalEventTarget(this.doc, target);
      if (!target) {
        throw new RuntimeError(5102, (typeof ngDevMode === "undefined" || ngDevMode) && `Unsupported event target ${target} for event ${event}`);
      }
    }
    let wrappedCallback = this.decoratePreventDefault(callback);
    if (this.tracingService?.wrapEventListener) {
      wrappedCallback = this.tracingService.wrapEventListener(target, event, wrappedCallback);
    }
    return this.eventManager.addEventListener(target, event, wrappedCallback, options);
  }
  decoratePreventDefault(eventHandler) {
    return (event) => {
      if (event === "__ngUnwrap__") {
        return eventHandler;
      }
      const allowDefaultBehavior = false ? this.ngZone.runGuarded(() => eventHandler(event)) : eventHandler(event);
      if (allowDefaultBehavior === false) {
        event.preventDefault();
      }
      return void 0;
    };
  }
};
var AT_CHARCODE = (() => "@".charCodeAt(0))();
function checkNoSyntheticProp(name, nameKind) {
  if (name.charCodeAt(0) === AT_CHARCODE) {
    throw new RuntimeError(5105, `Unexpected synthetic ${nameKind} ${name} found. Please make sure that:
  - Make sure \`provideAnimationsAsync()\`, \`provideAnimations()\` or \`provideNoopAnimations()\` call was added to a list of providers used to bootstrap an application.
  - There is a corresponding animation configuration named \`${name}\` defined in the \`animations\` field of the \`@Component\` decorator (see https://angular.dev/api/core/Component#animations).`);
  }
}
function isTemplateNode(node) {
  return node.tagName === "TEMPLATE" && node.content !== void 0;
}
var ShadowDomRenderer = class extends DefaultDomRenderer2 {
  sharedStylesHost;
  hostEl;
  shadowRoot;
  constructor(eventManager, sharedStylesHost, hostEl, component, doc, ngZone, nonce, platformIsServer, tracingService) {
    super(eventManager, doc, ngZone, platformIsServer, tracingService);
    this.sharedStylesHost = sharedStylesHost;
    this.hostEl = hostEl;
    this.shadowRoot = hostEl.attachShadow({
      mode: "open"
    });
    this.sharedStylesHost.addHost(this.shadowRoot);
    let styles = component.styles;
    if (ngDevMode) {
      const baseHref = getDOM().getBaseHref(doc) ?? "";
      styles = addBaseHrefToCssSourceMap(baseHref, styles);
    }
    styles = shimStylesContent(component.id, styles);
    for (const style2 of styles) {
      const styleEl = document.createElement("style");
      if (nonce) {
        styleEl.setAttribute("nonce", nonce);
      }
      styleEl.textContent = style2;
      this.shadowRoot.appendChild(styleEl);
    }
    const styleUrls = component.getExternalStyles?.();
    if (styleUrls) {
      for (const styleUrl of styleUrls) {
        const linkEl = createLinkElement(styleUrl, doc);
        if (nonce) {
          linkEl.setAttribute("nonce", nonce);
        }
        this.shadowRoot.appendChild(linkEl);
      }
    }
  }
  nodeOrShadowRoot(node) {
    return node === this.hostEl ? this.shadowRoot : node;
  }
  appendChild(parent, newChild) {
    return super.appendChild(this.nodeOrShadowRoot(parent), newChild);
  }
  insertBefore(parent, newChild, refChild) {
    return super.insertBefore(this.nodeOrShadowRoot(parent), newChild, refChild);
  }
  removeChild(_parent, oldChild) {
    return super.removeChild(null, oldChild);
  }
  parentNode(node) {
    return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(node)));
  }
  destroy() {
    this.sharedStylesHost.removeHost(this.shadowRoot);
  }
};
var NoneEncapsulationDomRenderer = class extends DefaultDomRenderer2 {
  sharedStylesHost;
  removeStylesOnCompDestroy;
  styles;
  styleUrls;
  constructor(eventManager, sharedStylesHost, component, removeStylesOnCompDestroy, doc, ngZone, platformIsServer, tracingService, compId) {
    super(eventManager, doc, ngZone, platformIsServer, tracingService);
    this.sharedStylesHost = sharedStylesHost;
    this.removeStylesOnCompDestroy = removeStylesOnCompDestroy;
    let styles = component.styles;
    if (ngDevMode) {
      const baseHref = getDOM().getBaseHref(doc) ?? "";
      styles = addBaseHrefToCssSourceMap(baseHref, styles);
    }
    this.styles = compId ? shimStylesContent(compId, styles) : styles;
    this.styleUrls = component.getExternalStyles?.(compId);
  }
  applyStyles() {
    this.sharedStylesHost.addStyles(this.styles, this.styleUrls);
  }
  destroy() {
    if (!this.removeStylesOnCompDestroy) {
      return;
    }
    if (allLeavingAnimations.size === 0) {
      this.sharedStylesHost.removeStyles(this.styles, this.styleUrls);
    }
  }
};
var EmulatedEncapsulationDomRenderer2 = class extends NoneEncapsulationDomRenderer {
  contentAttr;
  hostAttr;
  constructor(eventManager, sharedStylesHost, component, appId, removeStylesOnCompDestroy, doc, ngZone, platformIsServer, tracingService) {
    const compId = appId + "-" + component.id;
    super(eventManager, sharedStylesHost, component, removeStylesOnCompDestroy, doc, ngZone, platformIsServer, tracingService, compId);
    this.contentAttr = shimContentAttribute(compId);
    this.hostAttr = shimHostAttribute(compId);
  }
  applyToHost(element) {
    this.applyStyles();
    this.setAttribute(element, this.hostAttr, "");
  }
  createElement(parent, name) {
    const el = super.createElement(parent, name);
    super.setAttribute(el, this.contentAttr, "");
    return el;
  }
};

// node_modules/@angular/platform-browser/fesm2022/browser.mjs
var BrowserDomAdapter = class _BrowserDomAdapter extends DomAdapter {
  supportsDOMEvents = true;
  static makeCurrent() {
    setRootDomAdapter(new _BrowserDomAdapter());
  }
  onAndCancel(el, evt, listener, options) {
    el.addEventListener(evt, listener, options);
    return () => {
      el.removeEventListener(evt, listener, options);
    };
  }
  dispatchEvent(el, evt) {
    el.dispatchEvent(evt);
  }
  remove(node) {
    node.remove();
  }
  createElement(tagName, doc) {
    doc = doc || this.getDefaultDocument();
    return doc.createElement(tagName);
  }
  createHtmlDocument() {
    return document.implementation.createHTMLDocument("fakeTitle");
  }
  getDefaultDocument() {
    return document;
  }
  isElementNode(node) {
    return node.nodeType === Node.ELEMENT_NODE;
  }
  isShadowRoot(node) {
    return node instanceof DocumentFragment;
  }
  /** @deprecated No longer being used in Ivy code. To be removed in version 14. */
  getGlobalEventTarget(doc, target) {
    if (target === "window") {
      return window;
    }
    if (target === "document") {
      return doc;
    }
    if (target === "body") {
      return doc.body;
    }
    return null;
  }
  getBaseHref(doc) {
    const href = getBaseElementHref();
    return href == null ? null : relativePath(href);
  }
  resetBaseElement() {
    baseElement = null;
  }
  getUserAgent() {
    return window.navigator.userAgent;
  }
  getCookie(name) {
    return parseCookieValue(document.cookie, name);
  }
};
var baseElement = null;
function getBaseElementHref() {
  baseElement = baseElement || document.head.querySelector("base");
  return baseElement ? baseElement.getAttribute("href") : null;
}
function relativePath(url) {
  return new URL(url, document.baseURI).pathname;
}
var BrowserGetTestability = class {
  addToWindow(registry) {
    _global["getAngularTestability"] = (elem, findInAncestors = true) => {
      const testability = registry.findTestabilityInTree(elem, findInAncestors);
      if (testability == null) {
        throw new RuntimeError(5103, (typeof ngDevMode === "undefined" || ngDevMode) && "Could not find testability for element.");
      }
      return testability;
    };
    _global["getAllAngularTestabilities"] = () => registry.getAllTestabilities();
    _global["getAllAngularRootElements"] = () => registry.getAllRootElements();
    const whenAllStable = (callback) => {
      const testabilities = _global["getAllAngularTestabilities"]();
      let count = testabilities.length;
      const decrement = function() {
        count--;
        if (count == 0) {
          callback();
        }
      };
      testabilities.forEach((testability) => {
        testability.whenStable(decrement);
      });
    };
    if (!_global["frameworkStabilizers"]) {
      _global["frameworkStabilizers"] = [];
    }
    _global["frameworkStabilizers"].push(whenAllStable);
  }
  findTestabilityInTree(registry, elem, findInAncestors) {
    if (elem == null) {
      return null;
    }
    const t = registry.getTestability(elem);
    if (t != null) {
      return t;
    } else if (!findInAncestors) {
      return null;
    }
    if (getDOM().isShadowRoot(elem)) {
      return this.findTestabilityInTree(registry, elem.host, true);
    }
    return this.findTestabilityInTree(registry, elem.parentElement, true);
  }
};
var BrowserXhr = class _BrowserXhr {
  build() {
    return new XMLHttpRequest();
  }
  static \u0275fac = function BrowserXhr_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BrowserXhr)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _BrowserXhr,
    factory: _BrowserXhr.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BrowserXhr, [{
    type: Injectable
  }], null, null);
})();
var MODIFIER_KEYS = ["alt", "control", "meta", "shift"];
var _keyMap = {
  "\b": "Backspace",
  "	": "Tab",
  "\x7F": "Delete",
  "\x1B": "Escape",
  "Del": "Delete",
  "Esc": "Escape",
  "Left": "ArrowLeft",
  "Right": "ArrowRight",
  "Up": "ArrowUp",
  "Down": "ArrowDown",
  "Menu": "ContextMenu",
  "Scroll": "ScrollLock",
  "Win": "OS"
};
var MODIFIER_KEY_GETTERS = {
  "alt": (event) => event.altKey,
  "control": (event) => event.ctrlKey,
  "meta": (event) => event.metaKey,
  "shift": (event) => event.shiftKey
};
var KeyEventsPlugin = class _KeyEventsPlugin extends EventManagerPlugin {
  /**
   * Initializes an instance of the browser plug-in.
   * @param doc The document in which key events will be detected.
   */
  constructor(doc) {
    super(doc);
  }
  /**
   * Reports whether a named key event is supported.
   * @param eventName The event name to query.
   * @return True if the named key event is supported.
   */
  supports(eventName) {
    return _KeyEventsPlugin.parseEventName(eventName) != null;
  }
  /**
   * Registers a handler for a specific element and key event.
   * @param element The HTML element to receive event notifications.
   * @param eventName The name of the key event to listen for.
   * @param handler A function to call when the notification occurs. Receives the
   * event object as an argument.
   * @returns The key event that was registered.
   */
  addEventListener(element, eventName, handler, options) {
    const parsedEvent = _KeyEventsPlugin.parseEventName(eventName);
    const outsideHandler = _KeyEventsPlugin.eventCallback(parsedEvent["fullKey"], handler, this.manager.getZone());
    return this.manager.getZone().runOutsideAngular(() => {
      return getDOM().onAndCancel(element, parsedEvent["domEventName"], outsideHandler, options);
    });
  }
  /**
   * Parses the user provided full keyboard event definition and normalizes it for
   * later internal use. It ensures the string is all lowercase, converts special
   * characters to a standard spelling, and orders all the values consistently.
   *
   * @param eventName The name of the key event to listen for.
   * @returns an object with the full, normalized string, and the dom event name
   * or null in the case when the event doesn't match a keyboard event.
   */
  static parseEventName(eventName) {
    const parts = eventName.toLowerCase().split(".");
    const domEventName = parts.shift();
    if (parts.length === 0 || !(domEventName === "keydown" || domEventName === "keyup")) {
      return null;
    }
    const key = _KeyEventsPlugin._normalizeKey(parts.pop());
    let fullKey = "";
    let codeIX = parts.indexOf("code");
    if (codeIX > -1) {
      parts.splice(codeIX, 1);
      fullKey = "code.";
    }
    MODIFIER_KEYS.forEach((modifierName) => {
      const index = parts.indexOf(modifierName);
      if (index > -1) {
        parts.splice(index, 1);
        fullKey += modifierName + ".";
      }
    });
    fullKey += key;
    if (parts.length != 0 || key.length === 0) {
      return null;
    }
    const result = {};
    result["domEventName"] = domEventName;
    result["fullKey"] = fullKey;
    return result;
  }
  /**
   * Determines whether the actual keys pressed match the configured key code string.
   * The `fullKeyCode` event is normalized in the `parseEventName` method when the
   * event is attached to the DOM during the `addEventListener` call. This is unseen
   * by the end user and is normalized for internal consistency and parsing.
   *
   * @param event The keyboard event.
   * @param fullKeyCode The normalized user defined expected key event string
   * @returns boolean.
   */
  static matchEventFullKeyCode(event, fullKeyCode) {
    let keycode = _keyMap[event.key] || event.key;
    let key = "";
    if (fullKeyCode.indexOf("code.") > -1) {
      keycode = event.code;
      key = "code.";
    }
    if (keycode == null || !keycode) return false;
    keycode = keycode.toLowerCase();
    if (keycode === " ") {
      keycode = "space";
    } else if (keycode === ".") {
      keycode = "dot";
    }
    MODIFIER_KEYS.forEach((modifierName) => {
      if (modifierName !== keycode) {
        const modifierGetter = MODIFIER_KEY_GETTERS[modifierName];
        if (modifierGetter(event)) {
          key += modifierName + ".";
        }
      }
    });
    key += keycode;
    return key === fullKeyCode;
  }
  /**
   * Configures a handler callback for a key event.
   * @param fullKey The event name that combines all simultaneous keystrokes.
   * @param handler The function that responds to the key event.
   * @param zone The zone in which the event occurred.
   * @returns A callback function.
   */
  static eventCallback(fullKey, handler, zone) {
    return (event) => {
      if (_KeyEventsPlugin.matchEventFullKeyCode(event, fullKey)) {
        zone.runGuarded(() => handler(event));
      }
    };
  }
  /** @internal */
  static _normalizeKey(keyName) {
    return keyName === "esc" ? "escape" : keyName;
  }
  static \u0275fac = function KeyEventsPlugin_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _KeyEventsPlugin)(\u0275\u0275inject(DOCUMENT));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _KeyEventsPlugin,
    factory: _KeyEventsPlugin.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(KeyEventsPlugin, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();
function bootstrapApplication(rootComponent, options, context) {
  const config = __spreadValues({
    rootComponent,
    platformRef: context?.platformRef
  }, createProvidersConfig(options));
  if (false) {
    return resolveComponentResources(fetch).catch((error) => {
      console.error(error);
      return Promise.resolve();
    }).then(() => internalCreateApplication(config));
  }
  return internalCreateApplication(config);
}
function createProvidersConfig(options) {
  return {
    appProviders: [...BROWSER_MODULE_PROVIDERS, ...options?.providers ?? []],
    platformProviders: INTERNAL_BROWSER_PLATFORM_PROVIDERS
  };
}
function initDomAdapter() {
  BrowserDomAdapter.makeCurrent();
}
function errorHandler() {
  return new ErrorHandler();
}
function _document() {
  setDocument(document);
  return document;
}
var INTERNAL_BROWSER_PLATFORM_PROVIDERS = [{
  provide: PLATFORM_ID,
  useValue: PLATFORM_BROWSER_ID
}, {
  provide: PLATFORM_INITIALIZER,
  useValue: initDomAdapter,
  multi: true
}, {
  provide: DOCUMENT,
  useFactory: _document
}];
var platformBrowser = createPlatformFactory(platformCore, "browser", INTERNAL_BROWSER_PLATFORM_PROVIDERS);
var BROWSER_MODULE_PROVIDERS_MARKER = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "BrowserModule Providers Marker" : "");
var TESTABILITY_PROVIDERS = [{
  provide: TESTABILITY_GETTER,
  useClass: BrowserGetTestability
}, {
  provide: TESTABILITY,
  useClass: Testability,
  deps: [NgZone, TestabilityRegistry, TESTABILITY_GETTER]
}, {
  provide: Testability,
  // Also provide as `Testability` for backwards-compatibility.
  useClass: Testability,
  deps: [NgZone, TestabilityRegistry, TESTABILITY_GETTER]
}];
var BROWSER_MODULE_PROVIDERS = [{
  provide: INJECTOR_SCOPE,
  useValue: "root"
}, {
  provide: ErrorHandler,
  useFactory: errorHandler
}, {
  provide: EVENT_MANAGER_PLUGINS,
  useClass: DomEventsPlugin,
  multi: true,
  deps: [DOCUMENT]
}, {
  provide: EVENT_MANAGER_PLUGINS,
  useClass: KeyEventsPlugin,
  multi: true,
  deps: [DOCUMENT]
}, DomRendererFactory2, SharedStylesHost, EventManager, {
  provide: RendererFactory2,
  useExisting: DomRendererFactory2
}, {
  provide: XhrFactory,
  useClass: BrowserXhr
}, typeof ngDevMode === "undefined" || ngDevMode ? {
  provide: BROWSER_MODULE_PROVIDERS_MARKER,
  useValue: true
} : []];
var BrowserModule = class _BrowserModule {
  constructor() {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      const providersAlreadyPresent = inject(BROWSER_MODULE_PROVIDERS_MARKER, {
        optional: true,
        skipSelf: true
      });
      if (providersAlreadyPresent) {
        throw new RuntimeError(5100, `Providers from the \`BrowserModule\` have already been loaded. If you need access to common directives such as NgIf and NgFor, import the \`CommonModule\` instead.`);
      }
    }
  }
  static \u0275fac = function BrowserModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BrowserModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _BrowserModule,
    exports: [CommonModule, ApplicationModule]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    providers: [...BROWSER_MODULE_PROVIDERS, ...TESTABILITY_PROVIDERS],
    imports: [CommonModule, ApplicationModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BrowserModule, [{
    type: NgModule,
    args: [{
      providers: [...BROWSER_MODULE_PROVIDERS, ...TESTABILITY_PROVIDERS],
      exports: [CommonModule, ApplicationModule]
    }]
  }], () => [], null);
})();

// node_modules/@angular/platform-browser/fesm2022/platform-browser.mjs
var Meta = class _Meta {
  _doc;
  _dom;
  constructor(_doc) {
    this._doc = _doc;
    this._dom = getDOM();
  }
  /**
   * Retrieves or creates a specific `<meta>` tag element in the current HTML document.
   * In searching for an existing tag, Angular attempts to match the `name` or `property` attribute
   * values in the provided tag definition, and verifies that all other attribute values are equal.
   * If an existing element is found, it is returned and is not modified in any way.
   * @param tag The definition of a `<meta>` element to match or create.
   * @param forceCreation True to create a new element without checking whether one already exists.
   * @returns The existing element with the same attributes and values if found,
   * the new element if no match is found, or `null` if the tag parameter is not defined.
   */
  addTag(tag, forceCreation = false) {
    if (!tag) return null;
    return this._getOrCreateElement(tag, forceCreation);
  }
  /**
   * Retrieves or creates a set of `<meta>` tag elements in the current HTML document.
   * In searching for an existing tag, Angular attempts to match the `name` or `property` attribute
   * values in the provided tag definition, and verifies that all other attribute values are equal.
   * @param tags An array of tag definitions to match or create.
   * @param forceCreation True to create new elements without checking whether they already exist.
   * @returns The matching elements if found, or the new elements.
   */
  addTags(tags, forceCreation = false) {
    if (!tags) return [];
    return tags.reduce((result, tag) => {
      if (tag) {
        result.push(this._getOrCreateElement(tag, forceCreation));
      }
      return result;
    }, []);
  }
  /**
   * Retrieves a `<meta>` tag element in the current HTML document.
   * @param attrSelector The tag attribute and value to match against, in the format
   * `"tag_attribute='value string'"`.
   * @returns The matching element, if any.
   */
  getTag(attrSelector) {
    if (!attrSelector) return null;
    return this._doc.querySelector(`meta[${attrSelector}]`) || null;
  }
  /**
   * Retrieves a set of `<meta>` tag elements in the current HTML document.
   * @param attrSelector The tag attribute and value to match against, in the format
   * `"tag_attribute='value string'"`.
   * @returns The matching elements, if any.
   */
  getTags(attrSelector) {
    if (!attrSelector) return [];
    const list = this._doc.querySelectorAll(`meta[${attrSelector}]`);
    return list ? [].slice.call(list) : [];
  }
  /**
   * Modifies an existing `<meta>` tag element in the current HTML document.
   * @param tag The tag description with which to replace the existing tag content.
   * @param selector A tag attribute and value to match against, to identify
   * an existing tag. A string in the format `"tag_attribute=`value string`"`.
   * If not supplied, matches a tag with the same `name` or `property` attribute value as the
   * replacement tag.
   * @return The modified element.
   */
  updateTag(tag, selector) {
    if (!tag) return null;
    selector = selector || this._parseSelector(tag);
    const meta = this.getTag(selector);
    if (meta) {
      return this._setMetaElementAttributes(tag, meta);
    }
    return this._getOrCreateElement(tag, true);
  }
  /**
   * Removes an existing `<meta>` tag element from the current HTML document.
   * @param attrSelector A tag attribute and value to match against, to identify
   * an existing tag. A string in the format `"tag_attribute=`value string`"`.
   */
  removeTag(attrSelector) {
    this.removeTagElement(this.getTag(attrSelector));
  }
  /**
   * Removes an existing `<meta>` tag element from the current HTML document.
   * @param meta The tag definition to match against to identify an existing tag.
   */
  removeTagElement(meta) {
    if (meta) {
      this._dom.remove(meta);
    }
  }
  _getOrCreateElement(meta, forceCreation = false) {
    if (!forceCreation) {
      const selector = this._parseSelector(meta);
      const elem = this.getTags(selector).filter((elem2) => this._containsAttributes(meta, elem2))[0];
      if (elem !== void 0) return elem;
    }
    const element = this._dom.createElement("meta");
    this._setMetaElementAttributes(meta, element);
    const head = this._doc.getElementsByTagName("head")[0];
    head.appendChild(element);
    return element;
  }
  _setMetaElementAttributes(tag, el) {
    Object.keys(tag).forEach((prop) => el.setAttribute(this._getMetaKeyMap(prop), tag[prop]));
    return el;
  }
  _parseSelector(tag) {
    const attr = tag.name ? "name" : "property";
    return `${attr}="${tag[attr]}"`;
  }
  _containsAttributes(tag, elem) {
    return Object.keys(tag).every((key) => elem.getAttribute(this._getMetaKeyMap(key)) === tag[key]);
  }
  _getMetaKeyMap(prop) {
    return META_KEYS_MAP[prop] || prop;
  }
  static \u0275fac = function Meta_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _Meta)(\u0275\u0275inject(DOCUMENT));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _Meta,
    factory: _Meta.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Meta, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();
var META_KEYS_MAP = {
  httpEquiv: "http-equiv"
};
var Title = class _Title {
  _doc;
  constructor(_doc) {
    this._doc = _doc;
  }
  /**
   * Get the title of the current HTML document.
   */
  getTitle() {
    return this._doc.title;
  }
  /**
   * Set the title of the current HTML document.
   * @param newTitle
   */
  setTitle(newTitle) {
    this._doc.title = newTitle || "";
  }
  static \u0275fac = function Title_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _Title)(\u0275\u0275inject(DOCUMENT));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _Title,
    factory: _Title.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Title, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();
var EVENT_NAMES = {
  // pan
  "pan": true,
  "panstart": true,
  "panmove": true,
  "panend": true,
  "pancancel": true,
  "panleft": true,
  "panright": true,
  "panup": true,
  "pandown": true,
  // pinch
  "pinch": true,
  "pinchstart": true,
  "pinchmove": true,
  "pinchend": true,
  "pinchcancel": true,
  "pinchin": true,
  "pinchout": true,
  // press
  "press": true,
  "pressup": true,
  // rotate
  "rotate": true,
  "rotatestart": true,
  "rotatemove": true,
  "rotateend": true,
  "rotatecancel": true,
  // swipe
  "swipe": true,
  "swipeleft": true,
  "swiperight": true,
  "swipeup": true,
  "swipedown": true,
  // tap
  "tap": true,
  "doubletap": true
};
var HAMMER_GESTURE_CONFIG = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "HammerGestureConfig" : "");
var HAMMER_LOADER = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "HammerLoader" : "");
var HammerGestureConfig = class _HammerGestureConfig {
  /**
   * A set of supported event names for gestures to be used in Angular.
   * Angular supports all built-in recognizers, as listed in
   * [HammerJS documentation](https://hammerjs.github.io/).
   */
  events = [];
  /**
   * Maps gesture event names to a set of configuration options
   * that specify overrides to the default values for specific properties.
   *
   * The key is a supported event name to be configured,
   * and the options object contains a set of properties, with override values
   * to be applied to the named recognizer event.
   * For example, to disable recognition of the rotate event, specify
   *  `{"rotate": {"enable": false}}`.
   *
   * Properties that are not present take the HammerJS default values.
   * For information about which properties are supported for which events,
   * and their allowed and default values, see
   * [HammerJS documentation](https://hammerjs.github.io/).
   *
   */
  overrides = {};
  /**
   * Properties whose default values can be overridden for a given event.
   * Different sets of properties apply to different events.
   * For information about which properties are supported for which events,
   * and their allowed and default values, see
   * [HammerJS documentation](https://hammerjs.github.io/).
   */
  options;
  /**
   * Creates a [HammerJS Manager](https://hammerjs.github.io/api/#hammermanager)
   * and attaches it to a given HTML element.
   * @param element The element that will recognize gestures.
   * @returns A HammerJS event-manager object.
   */
  buildHammer(element) {
    const mc = new Hammer(element, this.options);
    mc.get("pinch").set({
      enable: true
    });
    mc.get("rotate").set({
      enable: true
    });
    for (const eventName in this.overrides) {
      mc.get(eventName).set(this.overrides[eventName]);
    }
    return mc;
  }
  static \u0275fac = function HammerGestureConfig_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HammerGestureConfig)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _HammerGestureConfig,
    factory: _HammerGestureConfig.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HammerGestureConfig, [{
    type: Injectable
  }], null, null);
})();
var HammerGesturesPlugin = class _HammerGesturesPlugin extends EventManagerPlugin {
  _config;
  _injector;
  loader;
  _loaderPromise = null;
  constructor(doc, _config, _injector, loader) {
    super(doc);
    this._config = _config;
    this._injector = _injector;
    this.loader = loader;
  }
  supports(eventName) {
    if (!EVENT_NAMES.hasOwnProperty(eventName.toLowerCase()) && !this.isCustomEvent(eventName)) {
      return false;
    }
    if (!window.Hammer && !this.loader) {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        const _console = this._injector.get(Console);
        _console.warn(`The "${eventName}" event cannot be bound because Hammer.JS is not loaded and no custom loader has been specified.`);
      }
      return false;
    }
    return true;
  }
  addEventListener(element, eventName, handler) {
    const zone = this.manager.getZone();
    eventName = eventName.toLowerCase();
    if (!window.Hammer && this.loader) {
      this._loaderPromise = this._loaderPromise || zone.runOutsideAngular(() => this.loader());
      let cancelRegistration = false;
      let deregister = () => {
        cancelRegistration = true;
      };
      zone.runOutsideAngular(() => this._loaderPromise.then(() => {
        if (!window.Hammer) {
          if (typeof ngDevMode === "undefined" || ngDevMode) {
            const _console = this._injector.get(Console);
            _console.warn(`The custom HAMMER_LOADER completed, but Hammer.JS is not present.`);
          }
          deregister = () => {
          };
          return;
        }
        if (!cancelRegistration) {
          deregister = this.addEventListener(element, eventName, handler);
        }
      }).catch(() => {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          const _console = this._injector.get(Console);
          _console.warn(`The "${eventName}" event cannot be bound because the custom Hammer.JS loader failed.`);
        }
        deregister = () => {
        };
      }));
      return () => {
        deregister();
      };
    }
    return zone.runOutsideAngular(() => {
      const mc = this._config.buildHammer(element);
      const callback = function(eventObj) {
        zone.runGuarded(function() {
          handler(eventObj);
        });
      };
      mc.on(eventName, callback);
      return () => {
        mc.off(eventName, callback);
        if (typeof mc.destroy === "function") {
          mc.destroy();
        }
      };
    });
  }
  isCustomEvent(eventName) {
    return this._config.events.indexOf(eventName) > -1;
  }
  static \u0275fac = function HammerGesturesPlugin_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HammerGesturesPlugin)(\u0275\u0275inject(DOCUMENT), \u0275\u0275inject(HAMMER_GESTURE_CONFIG), \u0275\u0275inject(Injector), \u0275\u0275inject(HAMMER_LOADER, 8));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _HammerGesturesPlugin,
    factory: _HammerGesturesPlugin.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HammerGesturesPlugin, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: HammerGestureConfig,
    decorators: [{
      type: Inject,
      args: [HAMMER_GESTURE_CONFIG]
    }]
  }, {
    type: Injector
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [HAMMER_LOADER]
    }]
  }], null);
})();
var HammerModule = class _HammerModule {
  static \u0275fac = function HammerModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HammerModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _HammerModule
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    providers: [{
      provide: EVENT_MANAGER_PLUGINS,
      useClass: HammerGesturesPlugin,
      multi: true,
      deps: [DOCUMENT, HAMMER_GESTURE_CONFIG, Injector, [new Optional(), HAMMER_LOADER]]
    }, {
      provide: HAMMER_GESTURE_CONFIG,
      useClass: HammerGestureConfig
    }]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HammerModule, [{
    type: NgModule,
    args: [{
      providers: [{
        provide: EVENT_MANAGER_PLUGINS,
        useClass: HammerGesturesPlugin,
        multi: true,
        deps: [DOCUMENT, HAMMER_GESTURE_CONFIG, Injector, [new Optional(), HAMMER_LOADER]]
      }, {
        provide: HAMMER_GESTURE_CONFIG,
        useClass: HammerGestureConfig
      }]
    }]
  }], null, null);
})();
var DomSanitizer = class _DomSanitizer {
  static \u0275fac = function DomSanitizer_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DomSanitizer)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _DomSanitizer,
    factory: function DomSanitizer_Factory(__ngFactoryType__) {
      let __ngConditionalFactory__ = null;
      if (__ngFactoryType__) {
        __ngConditionalFactory__ = new (__ngFactoryType__ || _DomSanitizer)();
      } else {
        __ngConditionalFactory__ = \u0275\u0275inject(DomSanitizerImpl);
      }
      return __ngConditionalFactory__;
    },
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DomSanitizer, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useExisting: forwardRef(() => DomSanitizerImpl)
    }]
  }], null, null);
})();
var DomSanitizerImpl = class _DomSanitizerImpl extends DomSanitizer {
  _doc;
  constructor(_doc) {
    super();
    this._doc = _doc;
  }
  sanitize(ctx, value) {
    if (value == null) return null;
    switch (ctx) {
      case SecurityContext.NONE:
        return value;
      case SecurityContext.HTML:
        if (allowSanitizationBypassAndThrow(
          value,
          "HTML"
          /* BypassType.Html */
        )) {
          return unwrapSafeValue(value);
        }
        return _sanitizeHtml(this._doc, String(value)).toString();
      case SecurityContext.STYLE:
        if (allowSanitizationBypassAndThrow(
          value,
          "Style"
          /* BypassType.Style */
        )) {
          return unwrapSafeValue(value);
        }
        return value;
      case SecurityContext.SCRIPT:
        if (allowSanitizationBypassAndThrow(
          value,
          "Script"
          /* BypassType.Script */
        )) {
          return unwrapSafeValue(value);
        }
        throw new RuntimeError(5200, (typeof ngDevMode === "undefined" || ngDevMode) && "unsafe value used in a script context");
      case SecurityContext.URL:
        if (allowSanitizationBypassAndThrow(
          value,
          "URL"
          /* BypassType.Url */
        )) {
          return unwrapSafeValue(value);
        }
        return _sanitizeUrl(String(value));
      case SecurityContext.RESOURCE_URL:
        if (allowSanitizationBypassAndThrow(
          value,
          "ResourceURL"
          /* BypassType.ResourceUrl */
        )) {
          return unwrapSafeValue(value);
        }
        throw new RuntimeError(5201, (typeof ngDevMode === "undefined" || ngDevMode) && `unsafe value used in a resource URL context (see ${XSS_SECURITY_URL})`);
      default:
        throw new RuntimeError(5202, (typeof ngDevMode === "undefined" || ngDevMode) && `Unexpected SecurityContext ${ctx} (see ${XSS_SECURITY_URL})`);
    }
  }
  bypassSecurityTrustHtml(value) {
    return bypassSanitizationTrustHtml(value);
  }
  bypassSecurityTrustStyle(value) {
    return bypassSanitizationTrustStyle(value);
  }
  bypassSecurityTrustScript(value) {
    return bypassSanitizationTrustScript(value);
  }
  bypassSecurityTrustUrl(value) {
    return bypassSanitizationTrustUrl(value);
  }
  bypassSecurityTrustResourceUrl(value) {
    return bypassSanitizationTrustResourceUrl(value);
  }
  static \u0275fac = function DomSanitizerImpl_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DomSanitizerImpl)(\u0275\u0275inject(DOCUMENT));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _DomSanitizerImpl,
    factory: _DomSanitizerImpl.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DomSanitizerImpl, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();
var HydrationFeatureKind;
(function(HydrationFeatureKind2) {
  HydrationFeatureKind2[HydrationFeatureKind2["NoHttpTransferCache"] = 0] = "NoHttpTransferCache";
  HydrationFeatureKind2[HydrationFeatureKind2["HttpTransferCacheOptions"] = 1] = "HttpTransferCacheOptions";
  HydrationFeatureKind2[HydrationFeatureKind2["I18nSupport"] = 2] = "I18nSupport";
  HydrationFeatureKind2[HydrationFeatureKind2["EventReplay"] = 3] = "EventReplay";
  HydrationFeatureKind2[HydrationFeatureKind2["IncrementalHydration"] = 4] = "IncrementalHydration";
})(HydrationFeatureKind || (HydrationFeatureKind = {}));
var VERSION = new Version("20.3.7");

// node_modules/@angular/router/fesm2022/router2.mjs
var PRIMARY_OUTLET = "primary";
var RouteTitleKey = /* @__PURE__ */ Symbol("RouteTitle");
var ParamsAsMap = class {
  params;
  constructor(params) {
    this.params = params || {};
  }
  has(name) {
    return Object.prototype.hasOwnProperty.call(this.params, name);
  }
  get(name) {
    if (this.has(name)) {
      const v = this.params[name];
      return Array.isArray(v) ? v[0] : v;
    }
    return null;
  }
  getAll(name) {
    if (this.has(name)) {
      const v = this.params[name];
      return Array.isArray(v) ? v : [v];
    }
    return [];
  }
  get keys() {
    return Object.keys(this.params);
  }
};
function convertToParamMap(params) {
  return new ParamsAsMap(params);
}
function defaultUrlMatcher(segments, segmentGroup, route) {
  const parts = route.path.split("/");
  if (parts.length > segments.length) {
    return null;
  }
  if (route.pathMatch === "full" && (segmentGroup.hasChildren() || parts.length < segments.length)) {
    return null;
  }
  const posParams = {};
  for (let index = 0; index < parts.length; index++) {
    const part = parts[index];
    const segment = segments[index];
    const isParameter = part[0] === ":";
    if (isParameter) {
      posParams[part.substring(1)] = segment;
    } else if (part !== segment.path) {
      return null;
    }
  }
  return {
    consumed: segments.slice(0, parts.length),
    posParams
  };
}
function shallowEqualArrays(a, b) {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; ++i) {
    if (!shallowEqual(a[i], b[i])) return false;
  }
  return true;
}
function shallowEqual(a, b) {
  const k1 = a ? getDataKeys(a) : void 0;
  const k2 = b ? getDataKeys(b) : void 0;
  if (!k1 || !k2 || k1.length != k2.length) {
    return false;
  }
  let key;
  for (let i = 0; i < k1.length; i++) {
    key = k1[i];
    if (!equalArraysOrString(a[key], b[key])) {
      return false;
    }
  }
  return true;
}
function getDataKeys(obj) {
  return [...Object.keys(obj), ...Object.getOwnPropertySymbols(obj)];
}
function equalArraysOrString(a, b) {
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) return false;
    const aSorted = [...a].sort();
    const bSorted = [...b].sort();
    return aSorted.every((val, index) => bSorted[index] === val);
  } else {
    return a === b;
  }
}
function last2(a) {
  return a.length > 0 ? a[a.length - 1] : null;
}
function wrapIntoObservable(value) {
  if (isObservable(value)) {
    return value;
  }
  if (isPromise(value)) {
    return from(Promise.resolve(value));
  }
  return of(value);
}
var pathCompareMap = {
  "exact": equalSegmentGroups,
  "subset": containsSegmentGroup
};
var paramCompareMap = {
  "exact": equalParams,
  "subset": containsParams,
  "ignored": () => true
};
function containsTree(container, containee, options) {
  return pathCompareMap[options.paths](container.root, containee.root, options.matrixParams) && paramCompareMap[options.queryParams](container.queryParams, containee.queryParams) && !(options.fragment === "exact" && container.fragment !== containee.fragment);
}
function equalParams(container, containee) {
  return shallowEqual(container, containee);
}
function equalSegmentGroups(container, containee, matrixParams) {
  if (!equalPath(container.segments, containee.segments)) return false;
  if (!matrixParamsMatch(container.segments, containee.segments, matrixParams)) {
    return false;
  }
  if (container.numberOfChildren !== containee.numberOfChildren) return false;
  for (const c in containee.children) {
    if (!container.children[c]) return false;
    if (!equalSegmentGroups(container.children[c], containee.children[c], matrixParams)) return false;
  }
  return true;
}
function containsParams(container, containee) {
  return Object.keys(containee).length <= Object.keys(container).length && Object.keys(containee).every((key) => equalArraysOrString(container[key], containee[key]));
}
function containsSegmentGroup(container, containee, matrixParams) {
  return containsSegmentGroupHelper(container, containee, containee.segments, matrixParams);
}
function containsSegmentGroupHelper(container, containee, containeePaths, matrixParams) {
  if (container.segments.length > containeePaths.length) {
    const current = container.segments.slice(0, containeePaths.length);
    if (!equalPath(current, containeePaths)) return false;
    if (containee.hasChildren()) return false;
    if (!matrixParamsMatch(current, containeePaths, matrixParams)) return false;
    return true;
  } else if (container.segments.length === containeePaths.length) {
    if (!equalPath(container.segments, containeePaths)) return false;
    if (!matrixParamsMatch(container.segments, containeePaths, matrixParams)) return false;
    for (const c in containee.children) {
      if (!container.children[c]) return false;
      if (!containsSegmentGroup(container.children[c], containee.children[c], matrixParams)) {
        return false;
      }
    }
    return true;
  } else {
    const current = containeePaths.slice(0, container.segments.length);
    const next = containeePaths.slice(container.segments.length);
    if (!equalPath(container.segments, current)) return false;
    if (!matrixParamsMatch(container.segments, current, matrixParams)) return false;
    if (!container.children[PRIMARY_OUTLET]) return false;
    return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next, matrixParams);
  }
}
function matrixParamsMatch(containerPaths, containeePaths, options) {
  return containeePaths.every((containeeSegment, i) => {
    return paramCompareMap[options](containerPaths[i].parameters, containeeSegment.parameters);
  });
}
var UrlTree = class {
  root;
  queryParams;
  fragment;
  /** @internal */
  _queryParamMap;
  constructor(root = new UrlSegmentGroup([], {}), queryParams = {}, fragment = null) {
    this.root = root;
    this.queryParams = queryParams;
    this.fragment = fragment;
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (root.segments.length > 0) {
        throw new RuntimeError(4015, "The root `UrlSegmentGroup` should not contain `segments`. Instead, these segments belong in the `children` so they can be associated with a named outlet.");
      }
    }
  }
  get queryParamMap() {
    this._queryParamMap ??= convertToParamMap(this.queryParams);
    return this._queryParamMap;
  }
  /** @docsNotRequired */
  toString() {
    return DEFAULT_SERIALIZER.serialize(this);
  }
};
var UrlSegmentGroup = class {
  segments;
  children;
  /** The parent node in the url tree */
  parent = null;
  constructor(segments, children) {
    this.segments = segments;
    this.children = children;
    Object.values(children).forEach((v) => v.parent = this);
  }
  /** Whether the segment has child segments */
  hasChildren() {
    return this.numberOfChildren > 0;
  }
  /** Number of child segments */
  get numberOfChildren() {
    return Object.keys(this.children).length;
  }
  /** @docsNotRequired */
  toString() {
    return serializePaths(this);
  }
};
var UrlSegment = class {
  path;
  parameters;
  /** @internal */
  _parameterMap;
  constructor(path, parameters) {
    this.path = path;
    this.parameters = parameters;
  }
  get parameterMap() {
    this._parameterMap ??= convertToParamMap(this.parameters);
    return this._parameterMap;
  }
  /** @docsNotRequired */
  toString() {
    return serializePath(this);
  }
};
function equalSegments(as, bs) {
  return equalPath(as, bs) && as.every((a, i) => shallowEqual(a.parameters, bs[i].parameters));
}
function equalPath(as, bs) {
  if (as.length !== bs.length) return false;
  return as.every((a, i) => a.path === bs[i].path);
}
function mapChildrenIntoArray(segment, fn) {
  let res = [];
  Object.entries(segment.children).forEach(([childOutlet, child]) => {
    if (childOutlet === PRIMARY_OUTLET) {
      res = res.concat(fn(child, childOutlet));
    }
  });
  Object.entries(segment.children).forEach(([childOutlet, child]) => {
    if (childOutlet !== PRIMARY_OUTLET) {
      res = res.concat(fn(child, childOutlet));
    }
  });
  return res;
}
var UrlSerializer = class _UrlSerializer {
  static \u0275fac = function UrlSerializer_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _UrlSerializer)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _UrlSerializer,
    factory: () => (() => new DefaultUrlSerializer())(),
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UrlSerializer, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => new DefaultUrlSerializer()
    }]
  }], null, null);
})();
var DefaultUrlSerializer = class {
  /** Parses a url into a `UrlTree` */
  parse(url) {
    const p = new UrlParser(url);
    return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());
  }
  /** Converts a `UrlTree` into a url */
  serialize(tree2) {
    const segment = `/${serializeSegment(tree2.root, true)}`;
    const query2 = serializeQueryParams(tree2.queryParams);
    const fragment = typeof tree2.fragment === `string` ? `#${encodeUriFragment(tree2.fragment)}` : "";
    return `${segment}${query2}${fragment}`;
  }
};
var DEFAULT_SERIALIZER = new DefaultUrlSerializer();
function serializePaths(segment) {
  return segment.segments.map((p) => serializePath(p)).join("/");
}
function serializeSegment(segment, root) {
  if (!segment.hasChildren()) {
    return serializePaths(segment);
  }
  if (root) {
    const primary = segment.children[PRIMARY_OUTLET] ? serializeSegment(segment.children[PRIMARY_OUTLET], false) : "";
    const children = [];
    Object.entries(segment.children).forEach(([k, v]) => {
      if (k !== PRIMARY_OUTLET) {
        children.push(`${k}:${serializeSegment(v, false)}`);
      }
    });
    return children.length > 0 ? `${primary}(${children.join("//")})` : primary;
  } else {
    const children = mapChildrenIntoArray(segment, (v, k) => {
      if (k === PRIMARY_OUTLET) {
        return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];
      }
      return [`${k}:${serializeSegment(v, false)}`];
    });
    if (Object.keys(segment.children).length === 1 && segment.children[PRIMARY_OUTLET] != null) {
      return `${serializePaths(segment)}/${children[0]}`;
    }
    return `${serializePaths(segment)}/(${children.join("//")})`;
  }
}
function encodeUriString(s) {
  return encodeURIComponent(s).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",");
}
function encodeUriQuery(s) {
  return encodeUriString(s).replace(/%3B/gi, ";");
}
function encodeUriFragment(s) {
  return encodeURI(s);
}
function encodeUriSegment(s) {
  return encodeUriString(s).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&");
}
function decode(s) {
  return decodeURIComponent(s);
}
function decodeQuery(s) {
  return decode(s.replace(/\+/g, "%20"));
}
function serializePath(path) {
  return `${encodeUriSegment(path.path)}${serializeMatrixParams(path.parameters)}`;
}
function serializeMatrixParams(params) {
  return Object.entries(params).map(([key, value]) => `;${encodeUriSegment(key)}=${encodeUriSegment(value)}`).join("");
}
function serializeQueryParams(params) {
  const strParams = Object.entries(params).map(([name, value]) => {
    return Array.isArray(value) ? value.map((v) => `${encodeUriQuery(name)}=${encodeUriQuery(v)}`).join("&") : `${encodeUriQuery(name)}=${encodeUriQuery(value)}`;
  }).filter((s) => s);
  return strParams.length ? `?${strParams.join("&")}` : "";
}
var SEGMENT_RE = /^[^\/()?;#]+/;
function matchSegments(str) {
  const match2 = str.match(SEGMENT_RE);
  return match2 ? match2[0] : "";
}
var MATRIX_PARAM_SEGMENT_RE = /^[^\/()?;=#]+/;
function matchMatrixKeySegments(str) {
  const match2 = str.match(MATRIX_PARAM_SEGMENT_RE);
  return match2 ? match2[0] : "";
}
var QUERY_PARAM_RE = /^[^=?&#]+/;
function matchQueryParams(str) {
  const match2 = str.match(QUERY_PARAM_RE);
  return match2 ? match2[0] : "";
}
var QUERY_PARAM_VALUE_RE = /^[^&#]+/;
function matchUrlQueryParamValue(str) {
  const match2 = str.match(QUERY_PARAM_VALUE_RE);
  return match2 ? match2[0] : "";
}
var UrlParser = class {
  url;
  remaining;
  constructor(url) {
    this.url = url;
    this.remaining = url;
  }
  parseRootSegment() {
    this.consumeOptional("/");
    if (this.remaining === "" || this.peekStartsWith("?") || this.peekStartsWith("#")) {
      return new UrlSegmentGroup([], {});
    }
    return new UrlSegmentGroup([], this.parseChildren());
  }
  parseQueryParams() {
    const params = {};
    if (this.consumeOptional("?")) {
      do {
        this.parseQueryParam(params);
      } while (this.consumeOptional("&"));
    }
    return params;
  }
  parseFragment() {
    return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null;
  }
  parseChildren() {
    if (this.remaining === "") {
      return {};
    }
    this.consumeOptional("/");
    const segments = [];
    if (!this.peekStartsWith("(")) {
      segments.push(this.parseSegment());
    }
    while (this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(")) {
      this.capture("/");
      segments.push(this.parseSegment());
    }
    let children = {};
    if (this.peekStartsWith("/(")) {
      this.capture("/");
      children = this.parseParens(true);
    }
    let res = {};
    if (this.peekStartsWith("(")) {
      res = this.parseParens(false);
    }
    if (segments.length > 0 || Object.keys(children).length > 0) {
      res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);
    }
    return res;
  }
  // parse a segment with its matrix parameters
  // ie `name;k1=v1;k2`
  parseSegment() {
    const path = matchSegments(this.remaining);
    if (path === "" && this.peekStartsWith(";")) {
      throw new RuntimeError(4009, (typeof ngDevMode === "undefined" || ngDevMode) && `Empty path url segment cannot have parameters: '${this.remaining}'.`);
    }
    this.capture(path);
    return new UrlSegment(decode(path), this.parseMatrixParams());
  }
  parseMatrixParams() {
    const params = {};
    while (this.consumeOptional(";")) {
      this.parseParam(params);
    }
    return params;
  }
  parseParam(params) {
    const key = matchMatrixKeySegments(this.remaining);
    if (!key) {
      return;
    }
    this.capture(key);
    let value = "";
    if (this.consumeOptional("=")) {
      const valueMatch = matchSegments(this.remaining);
      if (valueMatch) {
        value = valueMatch;
        this.capture(value);
      }
    }
    params[decode(key)] = decode(value);
  }
  // Parse a single query parameter `name[=value]`
  parseQueryParam(params) {
    const key = matchQueryParams(this.remaining);
    if (!key) {
      return;
    }
    this.capture(key);
    let value = "";
    if (this.consumeOptional("=")) {
      const valueMatch = matchUrlQueryParamValue(this.remaining);
      if (valueMatch) {
        value = valueMatch;
        this.capture(value);
      }
    }
    const decodedKey = decodeQuery(key);
    const decodedVal = decodeQuery(value);
    if (params.hasOwnProperty(decodedKey)) {
      let currentVal = params[decodedKey];
      if (!Array.isArray(currentVal)) {
        currentVal = [currentVal];
        params[decodedKey] = currentVal;
      }
      currentVal.push(decodedVal);
    } else {
      params[decodedKey] = decodedVal;
    }
  }
  // parse `(a/b//outlet_name:c/d)`
  parseParens(allowPrimary) {
    const segments = {};
    this.capture("(");
    while (!this.consumeOptional(")") && this.remaining.length > 0) {
      const path = matchSegments(this.remaining);
      const next = this.remaining[path.length];
      if (next !== "/" && next !== ")" && next !== ";") {
        throw new RuntimeError(4010, (typeof ngDevMode === "undefined" || ngDevMode) && `Cannot parse url '${this.url}'`);
      }
      let outletName = void 0;
      if (path.indexOf(":") > -1) {
        outletName = path.slice(0, path.indexOf(":"));
        this.capture(outletName);
        this.capture(":");
      } else if (allowPrimary) {
        outletName = PRIMARY_OUTLET;
      }
      const children = this.parseChildren();
      segments[outletName] = Object.keys(children).length === 1 && children[PRIMARY_OUTLET] ? children[PRIMARY_OUTLET] : new UrlSegmentGroup([], children);
      this.consumeOptional("//");
    }
    return segments;
  }
  peekStartsWith(str) {
    return this.remaining.startsWith(str);
  }
  // Consumes the prefix when it is present and returns whether it has been consumed
  consumeOptional(str) {
    if (this.peekStartsWith(str)) {
      this.remaining = this.remaining.substring(str.length);
      return true;
    }
    return false;
  }
  capture(str) {
    if (!this.consumeOptional(str)) {
      throw new RuntimeError(4011, (typeof ngDevMode === "undefined" || ngDevMode) && `Expected "${str}".`);
    }
  }
};
function createRoot(rootCandidate) {
  return rootCandidate.segments.length > 0 ? new UrlSegmentGroup([], {
    [PRIMARY_OUTLET]: rootCandidate
  }) : rootCandidate;
}
function squashSegmentGroup(segmentGroup) {
  const newChildren = {};
  for (const [childOutlet, child] of Object.entries(segmentGroup.children)) {
    const childCandidate = squashSegmentGroup(child);
    if (childOutlet === PRIMARY_OUTLET && childCandidate.segments.length === 0 && childCandidate.hasChildren()) {
      for (const [grandChildOutlet, grandChild] of Object.entries(childCandidate.children)) {
        newChildren[grandChildOutlet] = grandChild;
      }
    } else if (childCandidate.segments.length > 0 || childCandidate.hasChildren()) {
      newChildren[childOutlet] = childCandidate;
    }
  }
  const s = new UrlSegmentGroup(segmentGroup.segments, newChildren);
  return mergeTrivialChildren(s);
}
function mergeTrivialChildren(s) {
  if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {
    const c = s.children[PRIMARY_OUTLET];
    return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);
  }
  return s;
}
function isUrlTree(v) {
  return v instanceof UrlTree;
}
function createUrlTreeFromSnapshot(relativeTo, commands, queryParams = null, fragment = null) {
  const relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeTo);
  return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, queryParams, fragment);
}
function createSegmentGroupFromRoute(route) {
  let targetGroup;
  function createSegmentGroupFromRouteRecursive(currentRoute) {
    const childOutlets = {};
    for (const childSnapshot of currentRoute.children) {
      const root = createSegmentGroupFromRouteRecursive(childSnapshot);
      childOutlets[childSnapshot.outlet] = root;
    }
    const segmentGroup = new UrlSegmentGroup(currentRoute.url, childOutlets);
    if (currentRoute === route) {
      targetGroup = segmentGroup;
    }
    return segmentGroup;
  }
  const rootCandidate = createSegmentGroupFromRouteRecursive(route.root);
  const rootSegmentGroup = createRoot(rootCandidate);
  return targetGroup ?? rootSegmentGroup;
}
function createUrlTreeFromSegmentGroup(relativeTo, commands, queryParams, fragment) {
  let root = relativeTo;
  while (root.parent) {
    root = root.parent;
  }
  if (commands.length === 0) {
    return tree(root, root, root, queryParams, fragment);
  }
  const nav = computeNavigation(commands);
  if (nav.toRoot()) {
    return tree(root, root, new UrlSegmentGroup([], {}), queryParams, fragment);
  }
  const position = findStartingPositionForTargetGroup(nav, root, relativeTo);
  const newSegmentGroup = position.processChildren ? updateSegmentGroupChildren(position.segmentGroup, position.index, nav.commands) : updateSegmentGroup(position.segmentGroup, position.index, nav.commands);
  return tree(root, position.segmentGroup, newSegmentGroup, queryParams, fragment);
}
function isMatrixParams(command) {
  return typeof command === "object" && command != null && !command.outlets && !command.segmentPath;
}
function isCommandWithOutlets(command) {
  return typeof command === "object" && command != null && command.outlets;
}
function tree(oldRoot, oldSegmentGroup, newSegmentGroup, queryParams, fragment) {
  let qp = {};
  if (queryParams) {
    Object.entries(queryParams).forEach(([name, value]) => {
      qp[name] = Array.isArray(value) ? value.map((v) => `${v}`) : `${value}`;
    });
  }
  let rootCandidate;
  if (oldRoot === oldSegmentGroup) {
    rootCandidate = newSegmentGroup;
  } else {
    rootCandidate = replaceSegment(oldRoot, oldSegmentGroup, newSegmentGroup);
  }
  const newRoot = createRoot(squashSegmentGroup(rootCandidate));
  return new UrlTree(newRoot, qp, fragment);
}
function replaceSegment(current, oldSegment, newSegment) {
  const children = {};
  Object.entries(current.children).forEach(([outletName, c]) => {
    if (c === oldSegment) {
      children[outletName] = newSegment;
    } else {
      children[outletName] = replaceSegment(c, oldSegment, newSegment);
    }
  });
  return new UrlSegmentGroup(current.segments, children);
}
var Navigation = class {
  isAbsolute;
  numberOfDoubleDots;
  commands;
  constructor(isAbsolute, numberOfDoubleDots, commands) {
    this.isAbsolute = isAbsolute;
    this.numberOfDoubleDots = numberOfDoubleDots;
    this.commands = commands;
    if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {
      throw new RuntimeError(4003, (typeof ngDevMode === "undefined" || ngDevMode) && "Root segment cannot have matrix parameters");
    }
    const cmdWithOutlet = commands.find(isCommandWithOutlets);
    if (cmdWithOutlet && cmdWithOutlet !== last2(commands)) {
      throw new RuntimeError(4004, (typeof ngDevMode === "undefined" || ngDevMode) && "{outlets:{}} has to be the last command");
    }
  }
  toRoot() {
    return this.isAbsolute && this.commands.length === 1 && this.commands[0] == "/";
  }
};
function computeNavigation(commands) {
  if (typeof commands[0] === "string" && commands.length === 1 && commands[0] === "/") {
    return new Navigation(true, 0, commands);
  }
  let numberOfDoubleDots = 0;
  let isAbsolute = false;
  const res = commands.reduce((res2, cmd, cmdIdx) => {
    if (typeof cmd === "object" && cmd != null) {
      if (cmd.outlets) {
        const outlets = {};
        Object.entries(cmd.outlets).forEach(([name, commands2]) => {
          outlets[name] = typeof commands2 === "string" ? commands2.split("/") : commands2;
        });
        return [...res2, {
          outlets
        }];
      }
      if (cmd.segmentPath) {
        return [...res2, cmd.segmentPath];
      }
    }
    if (!(typeof cmd === "string")) {
      return [...res2, cmd];
    }
    if (cmdIdx === 0) {
      cmd.split("/").forEach((urlPart, partIndex) => {
        if (partIndex == 0 && urlPart === ".") ;
        else if (partIndex == 0 && urlPart === "") {
          isAbsolute = true;
        } else if (urlPart === "..") {
          numberOfDoubleDots++;
        } else if (urlPart != "") {
          res2.push(urlPart);
        }
      });
      return res2;
    }
    return [...res2, cmd];
  }, []);
  return new Navigation(isAbsolute, numberOfDoubleDots, res);
}
var Position = class {
  segmentGroup;
  processChildren;
  index;
  constructor(segmentGroup, processChildren, index) {
    this.segmentGroup = segmentGroup;
    this.processChildren = processChildren;
    this.index = index;
  }
};
function findStartingPositionForTargetGroup(nav, root, target) {
  if (nav.isAbsolute) {
    return new Position(root, true, 0);
  }
  if (!target) {
    return new Position(root, false, NaN);
  }
  if (target.parent === null) {
    return new Position(target, true, 0);
  }
  const modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;
  const index = target.segments.length - 1 + modifier;
  return createPositionApplyingDoubleDots(target, index, nav.numberOfDoubleDots);
}
function createPositionApplyingDoubleDots(group2, index, numberOfDoubleDots) {
  let g = group2;
  let ci = index;
  let dd = numberOfDoubleDots;
  while (dd > ci) {
    dd -= ci;
    g = g.parent;
    if (!g) {
      throw new RuntimeError(4005, (typeof ngDevMode === "undefined" || ngDevMode) && "Invalid number of '../'");
    }
    ci = g.segments.length;
  }
  return new Position(g, false, ci - dd);
}
function getOutlets(commands) {
  if (isCommandWithOutlets(commands[0])) {
    return commands[0].outlets;
  }
  return {
    [PRIMARY_OUTLET]: commands
  };
}
function updateSegmentGroup(segmentGroup, startIndex, commands) {
  segmentGroup ??= new UrlSegmentGroup([], {});
  if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
    return updateSegmentGroupChildren(segmentGroup, startIndex, commands);
  }
  const m = prefixedWith(segmentGroup, startIndex, commands);
  const slicedCommands = commands.slice(m.commandIndex);
  if (m.match && m.pathIndex < segmentGroup.segments.length) {
    const g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});
    g.children[PRIMARY_OUTLET] = new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);
    return updateSegmentGroupChildren(g, 0, slicedCommands);
  } else if (m.match && slicedCommands.length === 0) {
    return new UrlSegmentGroup(segmentGroup.segments, {});
  } else if (m.match && !segmentGroup.hasChildren()) {
    return createNewSegmentGroup(segmentGroup, startIndex, commands);
  } else if (m.match) {
    return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);
  } else {
    return createNewSegmentGroup(segmentGroup, startIndex, commands);
  }
}
function updateSegmentGroupChildren(segmentGroup, startIndex, commands) {
  if (commands.length === 0) {
    return new UrlSegmentGroup(segmentGroup.segments, {});
  } else {
    const outlets = getOutlets(commands);
    const children = {};
    if (Object.keys(outlets).some((o) => o !== PRIMARY_OUTLET) && segmentGroup.children[PRIMARY_OUTLET] && segmentGroup.numberOfChildren === 1 && segmentGroup.children[PRIMARY_OUTLET].segments.length === 0) {
      const childrenOfEmptyChild = updateSegmentGroupChildren(segmentGroup.children[PRIMARY_OUTLET], startIndex, commands);
      return new UrlSegmentGroup(segmentGroup.segments, childrenOfEmptyChild.children);
    }
    Object.entries(outlets).forEach(([outlet, commands2]) => {
      if (typeof commands2 === "string") {
        commands2 = [commands2];
      }
      if (commands2 !== null) {
        children[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands2);
      }
    });
    Object.entries(segmentGroup.children).forEach(([childOutlet, child]) => {
      if (outlets[childOutlet] === void 0) {
        children[childOutlet] = child;
      }
    });
    return new UrlSegmentGroup(segmentGroup.segments, children);
  }
}
function prefixedWith(segmentGroup, startIndex, commands) {
  let currentCommandIndex = 0;
  let currentPathIndex = startIndex;
  const noMatch2 = {
    match: false,
    pathIndex: 0,
    commandIndex: 0
  };
  while (currentPathIndex < segmentGroup.segments.length) {
    if (currentCommandIndex >= commands.length) return noMatch2;
    const path = segmentGroup.segments[currentPathIndex];
    const command = commands[currentCommandIndex];
    if (isCommandWithOutlets(command)) {
      break;
    }
    const curr = `${command}`;
    const next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;
    if (currentPathIndex > 0 && curr === void 0) break;
    if (curr && next && typeof next === "object" && next.outlets === void 0) {
      if (!compare(curr, next, path)) return noMatch2;
      currentCommandIndex += 2;
    } else {
      if (!compare(curr, {}, path)) return noMatch2;
      currentCommandIndex++;
    }
    currentPathIndex++;
  }
  return {
    match: true,
    pathIndex: currentPathIndex,
    commandIndex: currentCommandIndex
  };
}
function createNewSegmentGroup(segmentGroup, startIndex, commands) {
  const paths = segmentGroup.segments.slice(0, startIndex);
  let i = 0;
  while (i < commands.length) {
    const command = commands[i];
    if (isCommandWithOutlets(command)) {
      const children = createNewSegmentChildren(command.outlets);
      return new UrlSegmentGroup(paths, children);
    }
    if (i === 0 && isMatrixParams(commands[0])) {
      const p = segmentGroup.segments[startIndex];
      paths.push(new UrlSegment(p.path, stringify(commands[0])));
      i++;
      continue;
    }
    const curr = isCommandWithOutlets(command) ? command.outlets[PRIMARY_OUTLET] : `${command}`;
    const next = i < commands.length - 1 ? commands[i + 1] : null;
    if (curr && next && isMatrixParams(next)) {
      paths.push(new UrlSegment(curr, stringify(next)));
      i += 2;
    } else {
      paths.push(new UrlSegment(curr, {}));
      i++;
    }
  }
  return new UrlSegmentGroup(paths, {});
}
function createNewSegmentChildren(outlets) {
  const children = {};
  Object.entries(outlets).forEach(([outlet, commands]) => {
    if (typeof commands === "string") {
      commands = [commands];
    }
    if (commands !== null) {
      children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);
    }
  });
  return children;
}
function stringify(params) {
  const res = {};
  Object.entries(params).forEach(([k, v]) => res[k] = `${v}`);
  return res;
}
function compare(path, params, segment) {
  return path == segment.path && shallowEqual(params, segment.parameters);
}
var IMPERATIVE_NAVIGATION = "imperative";
var EventType;
(function(EventType2) {
  EventType2[EventType2["NavigationStart"] = 0] = "NavigationStart";
  EventType2[EventType2["NavigationEnd"] = 1] = "NavigationEnd";
  EventType2[EventType2["NavigationCancel"] = 2] = "NavigationCancel";
  EventType2[EventType2["NavigationError"] = 3] = "NavigationError";
  EventType2[EventType2["RoutesRecognized"] = 4] = "RoutesRecognized";
  EventType2[EventType2["ResolveStart"] = 5] = "ResolveStart";
  EventType2[EventType2["ResolveEnd"] = 6] = "ResolveEnd";
  EventType2[EventType2["GuardsCheckStart"] = 7] = "GuardsCheckStart";
  EventType2[EventType2["GuardsCheckEnd"] = 8] = "GuardsCheckEnd";
  EventType2[EventType2["RouteConfigLoadStart"] = 9] = "RouteConfigLoadStart";
  EventType2[EventType2["RouteConfigLoadEnd"] = 10] = "RouteConfigLoadEnd";
  EventType2[EventType2["ChildActivationStart"] = 11] = "ChildActivationStart";
  EventType2[EventType2["ChildActivationEnd"] = 12] = "ChildActivationEnd";
  EventType2[EventType2["ActivationStart"] = 13] = "ActivationStart";
  EventType2[EventType2["ActivationEnd"] = 14] = "ActivationEnd";
  EventType2[EventType2["Scroll"] = 15] = "Scroll";
  EventType2[EventType2["NavigationSkipped"] = 16] = "NavigationSkipped";
})(EventType || (EventType = {}));
var RouterEvent = class {
  id;
  url;
  constructor(id, url) {
    this.id = id;
    this.url = url;
  }
};
var NavigationStart = class extends RouterEvent {
  type = EventType.NavigationStart;
  /**
   * Identifies the call or event that triggered the navigation.
   * An `imperative` trigger is a call to `router.navigateByUrl()` or `router.navigate()`.
   *
   * @see {@link NavigationEnd}
   * @see {@link NavigationCancel}
   * @see {@link NavigationError}
   */
  navigationTrigger;
  /**
   * The navigation state that was previously supplied to the `pushState` call,
   * when the navigation is triggered by a `popstate` event. Otherwise null.
   *
   * The state object is defined by `NavigationExtras`, and contains any
   * developer-defined state value, as well as a unique ID that
   * the router assigns to every router transition/navigation.
   *
   * From the perspective of the router, the router never "goes back".
   * When the user clicks on the back button in the browser,
   * a new navigation ID is created.
   *
   * Use the ID in this previous-state object to differentiate between a newly created
   * state and one returned to by a `popstate` event, so that you can restore some
   * remembered state, such as scroll position.
   *
   */
  restoredState;
  constructor(id, url, navigationTrigger = "imperative", restoredState = null) {
    super(id, url);
    this.navigationTrigger = navigationTrigger;
    this.restoredState = restoredState;
  }
  /** @docsNotRequired */
  toString() {
    return `NavigationStart(id: ${this.id}, url: '${this.url}')`;
  }
};
var NavigationEnd = class extends RouterEvent {
  urlAfterRedirects;
  type = EventType.NavigationEnd;
  constructor(id, url, urlAfterRedirects) {
    super(id, url);
    this.urlAfterRedirects = urlAfterRedirects;
  }
  /** @docsNotRequired */
  toString() {
    return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`;
  }
};
var NavigationCancellationCode;
(function(NavigationCancellationCode2) {
  NavigationCancellationCode2[NavigationCancellationCode2["Redirect"] = 0] = "Redirect";
  NavigationCancellationCode2[NavigationCancellationCode2["SupersededByNewNavigation"] = 1] = "SupersededByNewNavigation";
  NavigationCancellationCode2[NavigationCancellationCode2["NoDataFromResolver"] = 2] = "NoDataFromResolver";
  NavigationCancellationCode2[NavigationCancellationCode2["GuardRejected"] = 3] = "GuardRejected";
  NavigationCancellationCode2[NavigationCancellationCode2["Aborted"] = 4] = "Aborted";
})(NavigationCancellationCode || (NavigationCancellationCode = {}));
var NavigationSkippedCode;
(function(NavigationSkippedCode2) {
  NavigationSkippedCode2[NavigationSkippedCode2["IgnoredSameUrlNavigation"] = 0] = "IgnoredSameUrlNavigation";
  NavigationSkippedCode2[NavigationSkippedCode2["IgnoredByUrlHandlingStrategy"] = 1] = "IgnoredByUrlHandlingStrategy";
})(NavigationSkippedCode || (NavigationSkippedCode = {}));
var NavigationCancel = class extends RouterEvent {
  reason;
  code;
  type = EventType.NavigationCancel;
  constructor(id, url, reason, code) {
    super(id, url);
    this.reason = reason;
    this.code = code;
  }
  /** @docsNotRequired */
  toString() {
    return `NavigationCancel(id: ${this.id}, url: '${this.url}')`;
  }
};
var NavigationSkipped = class extends RouterEvent {
  reason;
  code;
  type = EventType.NavigationSkipped;
  constructor(id, url, reason, code) {
    super(id, url);
    this.reason = reason;
    this.code = code;
  }
};
var NavigationError = class extends RouterEvent {
  error;
  target;
  type = EventType.NavigationError;
  constructor(id, url, error, target) {
    super(id, url);
    this.error = error;
    this.target = target;
  }
  /** @docsNotRequired */
  toString() {
    return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`;
  }
};
var RoutesRecognized = class extends RouterEvent {
  urlAfterRedirects;
  state;
  type = EventType.RoutesRecognized;
  constructor(id, url, urlAfterRedirects, state2) {
    super(id, url);
    this.urlAfterRedirects = urlAfterRedirects;
    this.state = state2;
  }
  /** @docsNotRequired */
  toString() {
    return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
  }
};
var GuardsCheckStart = class extends RouterEvent {
  urlAfterRedirects;
  state;
  type = EventType.GuardsCheckStart;
  constructor(id, url, urlAfterRedirects, state2) {
    super(id, url);
    this.urlAfterRedirects = urlAfterRedirects;
    this.state = state2;
  }
  toString() {
    return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
  }
};
var GuardsCheckEnd = class extends RouterEvent {
  urlAfterRedirects;
  state;
  shouldActivate;
  type = EventType.GuardsCheckEnd;
  constructor(id, url, urlAfterRedirects, state2, shouldActivate) {
    super(id, url);
    this.urlAfterRedirects = urlAfterRedirects;
    this.state = state2;
    this.shouldActivate = shouldActivate;
  }
  toString() {
    return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`;
  }
};
var ResolveStart = class extends RouterEvent {
  urlAfterRedirects;
  state;
  type = EventType.ResolveStart;
  constructor(id, url, urlAfterRedirects, state2) {
    super(id, url);
    this.urlAfterRedirects = urlAfterRedirects;
    this.state = state2;
  }
  toString() {
    return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
  }
};
var ResolveEnd = class extends RouterEvent {
  urlAfterRedirects;
  state;
  type = EventType.ResolveEnd;
  constructor(id, url, urlAfterRedirects, state2) {
    super(id, url);
    this.urlAfterRedirects = urlAfterRedirects;
    this.state = state2;
  }
  toString() {
    return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
  }
};
var RouteConfigLoadStart = class {
  route;
  type = EventType.RouteConfigLoadStart;
  constructor(route) {
    this.route = route;
  }
  toString() {
    return `RouteConfigLoadStart(path: ${this.route.path})`;
  }
};
var RouteConfigLoadEnd = class {
  route;
  type = EventType.RouteConfigLoadEnd;
  constructor(route) {
    this.route = route;
  }
  toString() {
    return `RouteConfigLoadEnd(path: ${this.route.path})`;
  }
};
var ChildActivationStart = class {
  snapshot;
  type = EventType.ChildActivationStart;
  constructor(snapshot) {
    this.snapshot = snapshot;
  }
  toString() {
    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || "";
    return `ChildActivationStart(path: '${path}')`;
  }
};
var ChildActivationEnd = class {
  snapshot;
  type = EventType.ChildActivationEnd;
  constructor(snapshot) {
    this.snapshot = snapshot;
  }
  toString() {
    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || "";
    return `ChildActivationEnd(path: '${path}')`;
  }
};
var ActivationStart = class {
  snapshot;
  type = EventType.ActivationStart;
  constructor(snapshot) {
    this.snapshot = snapshot;
  }
  toString() {
    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || "";
    return `ActivationStart(path: '${path}')`;
  }
};
var ActivationEnd = class {
  snapshot;
  type = EventType.ActivationEnd;
  constructor(snapshot) {
    this.snapshot = snapshot;
  }
  toString() {
    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || "";
    return `ActivationEnd(path: '${path}')`;
  }
};
var Scroll = class {
  routerEvent;
  position;
  anchor;
  type = EventType.Scroll;
  constructor(routerEvent, position, anchor) {
    this.routerEvent = routerEvent;
    this.position = position;
    this.anchor = anchor;
  }
  toString() {
    const pos = this.position ? `${this.position[0]}, ${this.position[1]}` : null;
    return `Scroll(anchor: '${this.anchor}', position: '${pos}')`;
  }
};
var BeforeActivateRoutes = class {
};
var RedirectRequest = class {
  url;
  navigationBehaviorOptions;
  constructor(url, navigationBehaviorOptions) {
    this.url = url;
    this.navigationBehaviorOptions = navigationBehaviorOptions;
  }
};
function isPublicRouterEvent(e) {
  return !(e instanceof BeforeActivateRoutes) && !(e instanceof RedirectRequest);
}
function stringifyEvent(routerEvent) {
  switch (routerEvent.type) {
    case EventType.ActivationEnd:
      return `ActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || ""}')`;
    case EventType.ActivationStart:
      return `ActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || ""}')`;
    case EventType.ChildActivationEnd:
      return `ChildActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || ""}')`;
    case EventType.ChildActivationStart:
      return `ChildActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || ""}')`;
    case EventType.GuardsCheckEnd:
      return `GuardsCheckEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state}, shouldActivate: ${routerEvent.shouldActivate})`;
    case EventType.GuardsCheckStart:
      return `GuardsCheckStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;
    case EventType.NavigationCancel:
      return `NavigationCancel(id: ${routerEvent.id}, url: '${routerEvent.url}')`;
    case EventType.NavigationSkipped:
      return `NavigationSkipped(id: ${routerEvent.id}, url: '${routerEvent.url}')`;
    case EventType.NavigationEnd:
      return `NavigationEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}')`;
    case EventType.NavigationError:
      return `NavigationError(id: ${routerEvent.id}, url: '${routerEvent.url}', error: ${routerEvent.error})`;
    case EventType.NavigationStart:
      return `NavigationStart(id: ${routerEvent.id}, url: '${routerEvent.url}')`;
    case EventType.ResolveEnd:
      return `ResolveEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;
    case EventType.ResolveStart:
      return `ResolveStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;
    case EventType.RouteConfigLoadEnd:
      return `RouteConfigLoadEnd(path: ${routerEvent.route.path})`;
    case EventType.RouteConfigLoadStart:
      return `RouteConfigLoadStart(path: ${routerEvent.route.path})`;
    case EventType.RoutesRecognized:
      return `RoutesRecognized(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;
    case EventType.Scroll:
      const pos = routerEvent.position ? `${routerEvent.position[0]}, ${routerEvent.position[1]}` : null;
      return `Scroll(anchor: '${routerEvent.anchor}', position: '${pos}')`;
  }
}
function getOrCreateRouteInjectorIfNeeded(route, currentInjector) {
  if (route.providers && !route._injector) {
    route._injector = createEnvironmentInjector(route.providers, currentInjector, `Route: ${route.path}`);
  }
  return route._injector ?? currentInjector;
}
function validateConfig(config, parentPath = "", requireStandaloneComponents = false) {
  for (let i = 0; i < config.length; i++) {
    const route = config[i];
    const fullPath = getFullPath(parentPath, route);
    validateNode(route, fullPath, requireStandaloneComponents);
  }
}
function assertStandalone(fullPath, component) {
  if (component && isNgModule(component)) {
    throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}'. You are using 'loadComponent' with a module, but it must be used with standalone components. Use 'loadChildren' instead.`);
  } else if (component && !isStandalone(component)) {
    throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}'. The component must be standalone.`);
  }
}
function validateNode(route, fullPath, requireStandaloneComponents) {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (!route) {
      throw new RuntimeError(4014, `
      Invalid configuration of route '${fullPath}': Encountered undefined route.
      The reason might be an extra comma.

      Example:
      const routes: Routes = [
        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },
        { path: 'dashboard',  component: DashboardComponent },, << two commas
        { path: 'detail/:id', component: HeroDetailComponent }
      ];
    `);
    }
    if (Array.isArray(route)) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': Array cannot be specified`);
    }
    if (!route.redirectTo && !route.component && !route.loadComponent && !route.children && !route.loadChildren && route.outlet && route.outlet !== PRIMARY_OUTLET) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': a componentless route without children or loadChildren cannot have a named outlet set`);
    }
    if (route.redirectTo && route.children) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and children cannot be used together`);
    }
    if (route.redirectTo && route.loadChildren) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and loadChildren cannot be used together`);
    }
    if (route.children && route.loadChildren) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': children and loadChildren cannot be used together`);
    }
    if (route.component && route.loadComponent) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': component and loadComponent cannot be used together`);
    }
    if (route.redirectTo) {
      if (route.component || route.loadComponent) {
        throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and component/loadComponent cannot be used together`);
      }
      if (route.canMatch || route.canActivate) {
        throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and ${route.canMatch ? "canMatch" : "canActivate"} cannot be used together.Redirects happen before guards are executed.`);
      }
    }
    if (route.path && route.matcher) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': path and matcher cannot be used together`);
    }
    if (route.redirectTo === void 0 && !route.component && !route.loadComponent && !route.children && !route.loadChildren) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}'. One of the following must be provided: component, loadComponent, redirectTo, children or loadChildren`);
    }
    if (route.path === void 0 && route.matcher === void 0) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': routes must have either a path or a matcher specified`);
    }
    if (typeof route.path === "string" && route.path.charAt(0) === "/") {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': path cannot start with a slash`);
    }
    if (route.path === "" && route.redirectTo !== void 0 && route.pathMatch === void 0) {
      const exp = `The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`;
      throw new RuntimeError(4014, `Invalid configuration of route '{path: "${fullPath}", redirectTo: "${route.redirectTo}"}': please provide 'pathMatch'. ${exp}`);
    }
    if (requireStandaloneComponents) {
      assertStandalone(fullPath, route.component);
    }
  }
  if (route.children) {
    validateConfig(route.children, fullPath, requireStandaloneComponents);
  }
}
function getFullPath(parentPath, currentRoute) {
  if (!currentRoute) {
    return parentPath;
  }
  if (!parentPath && !currentRoute.path) {
    return "";
  } else if (parentPath && !currentRoute.path) {
    return `${parentPath}/`;
  } else if (!parentPath && currentRoute.path) {
    return currentRoute.path;
  } else {
    return `${parentPath}/${currentRoute.path}`;
  }
}
function getOutlet(route) {
  return route.outlet || PRIMARY_OUTLET;
}
function sortByMatchingOutlets(routes2, outletName) {
  const sortedConfig = routes2.filter((r) => getOutlet(r) === outletName);
  sortedConfig.push(...routes2.filter((r) => getOutlet(r) !== outletName));
  return sortedConfig;
}
function getClosestRouteInjector(snapshot) {
  if (!snapshot) return null;
  if (snapshot.routeConfig?._injector) {
    return snapshot.routeConfig._injector;
  }
  for (let s = snapshot.parent; s; s = s.parent) {
    const route = s.routeConfig;
    if (route?._loadedInjector) return route._loadedInjector;
    if (route?._injector) return route._injector;
  }
  return null;
}
var OutletContext = class {
  rootInjector;
  outlet = null;
  route = null;
  children;
  attachRef = null;
  get injector() {
    return getClosestRouteInjector(this.route?.snapshot) ?? this.rootInjector;
  }
  constructor(rootInjector) {
    this.rootInjector = rootInjector;
    this.children = new ChildrenOutletContexts(this.rootInjector);
  }
};
var ChildrenOutletContexts = class _ChildrenOutletContexts {
  rootInjector;
  // contexts for child outlets, by name.
  contexts = /* @__PURE__ */ new Map();
  /** @docs-private */
  constructor(rootInjector) {
    this.rootInjector = rootInjector;
  }
  /** Called when a `RouterOutlet` directive is instantiated */
  onChildOutletCreated(childName, outlet) {
    const context = this.getOrCreateContext(childName);
    context.outlet = outlet;
    this.contexts.set(childName, context);
  }
  /**
   * Called when a `RouterOutlet` directive is destroyed.
   * We need to keep the context as the outlet could be destroyed inside a NgIf and might be
   * re-created later.
   */
  onChildOutletDestroyed(childName) {
    const context = this.getContext(childName);
    if (context) {
      context.outlet = null;
      context.attachRef = null;
    }
  }
  /**
   * Called when the corresponding route is deactivated during navigation.
   * Because the component get destroyed, all children outlet are destroyed.
   */
  onOutletDeactivated() {
    const contexts = this.contexts;
    this.contexts = /* @__PURE__ */ new Map();
    return contexts;
  }
  onOutletReAttached(contexts) {
    this.contexts = contexts;
  }
  getOrCreateContext(childName) {
    let context = this.getContext(childName);
    if (!context) {
      context = new OutletContext(this.rootInjector);
      this.contexts.set(childName, context);
    }
    return context;
  }
  getContext(childName) {
    return this.contexts.get(childName) || null;
  }
  static \u0275fac = function ChildrenOutletContexts_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ChildrenOutletContexts)(\u0275\u0275inject(EnvironmentInjector));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _ChildrenOutletContexts,
    factory: _ChildrenOutletContexts.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChildrenOutletContexts, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: EnvironmentInjector
  }], null);
})();
var Tree = class {
  /** @internal */
  _root;
  constructor(root) {
    this._root = root;
  }
  get root() {
    return this._root.value;
  }
  /**
   * @internal
   */
  parent(t) {
    const p = this.pathFromRoot(t);
    return p.length > 1 ? p[p.length - 2] : null;
  }
  /**
   * @internal
   */
  children(t) {
    const n = findNode(t, this._root);
    return n ? n.children.map((t2) => t2.value) : [];
  }
  /**
   * @internal
   */
  firstChild(t) {
    const n = findNode(t, this._root);
    return n && n.children.length > 0 ? n.children[0].value : null;
  }
  /**
   * @internal
   */
  siblings(t) {
    const p = findPath(t, this._root);
    if (p.length < 2) return [];
    const c = p[p.length - 2].children.map((c2) => c2.value);
    return c.filter((cc) => cc !== t);
  }
  /**
   * @internal
   */
  pathFromRoot(t) {
    return findPath(t, this._root).map((s) => s.value);
  }
};
function findNode(value, node) {
  if (value === node.value) return node;
  for (const child of node.children) {
    const node2 = findNode(value, child);
    if (node2) return node2;
  }
  return null;
}
function findPath(value, node) {
  if (value === node.value) return [node];
  for (const child of node.children) {
    const path = findPath(value, child);
    if (path.length) {
      path.unshift(node);
      return path;
    }
  }
  return [];
}
var TreeNode = class {
  value;
  children;
  constructor(value, children) {
    this.value = value;
    this.children = children;
  }
  toString() {
    return `TreeNode(${this.value})`;
  }
};
function nodeChildrenAsMap(node) {
  const map2 = {};
  if (node) {
    node.children.forEach((child) => map2[child.value.outlet] = child);
  }
  return map2;
}
var RouterState = class extends Tree {
  snapshot;
  /** @internal */
  constructor(root, snapshot) {
    super(root);
    this.snapshot = snapshot;
    setRouterState(this, root);
  }
  toString() {
    return this.snapshot.toString();
  }
};
function createEmptyState(rootComponent) {
  const snapshot = createEmptyStateSnapshot(rootComponent);
  const emptyUrl = new BehaviorSubject([new UrlSegment("", {})]);
  const emptyParams = new BehaviorSubject({});
  const emptyData = new BehaviorSubject({});
  const emptyQueryParams = new BehaviorSubject({});
  const fragment = new BehaviorSubject("");
  const activated = new ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);
  activated.snapshot = snapshot.root;
  return new RouterState(new TreeNode(activated, []), snapshot);
}
function createEmptyStateSnapshot(rootComponent) {
  const emptyParams = {};
  const emptyData = {};
  const emptyQueryParams = {};
  const fragment = "";
  const activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, {});
  return new RouterStateSnapshot("", new TreeNode(activated, []));
}
var ActivatedRoute = class {
  urlSubject;
  paramsSubject;
  queryParamsSubject;
  fragmentSubject;
  dataSubject;
  outlet;
  component;
  /** The current snapshot of this route */
  snapshot;
  /** @internal */
  _futureSnapshot;
  /** @internal */
  _routerState;
  /** @internal */
  _paramMap;
  /** @internal */
  _queryParamMap;
  /** An Observable of the resolved route title */
  title;
  /** An observable of the URL segments matched by this route. */
  url;
  /** An observable of the matrix parameters scoped to this route. */
  params;
  /** An observable of the query parameters shared by all the routes. */
  queryParams;
  /** An observable of the URL fragment shared by all the routes. */
  fragment;
  /** An observable of the static and resolved data of this route. */
  data;
  /** @internal */
  constructor(urlSubject, paramsSubject, queryParamsSubject, fragmentSubject, dataSubject, outlet, component, futureSnapshot) {
    this.urlSubject = urlSubject;
    this.paramsSubject = paramsSubject;
    this.queryParamsSubject = queryParamsSubject;
    this.fragmentSubject = fragmentSubject;
    this.dataSubject = dataSubject;
    this.outlet = outlet;
    this.component = component;
    this._futureSnapshot = futureSnapshot;
    this.title = this.dataSubject?.pipe(map((d) => d[RouteTitleKey])) ?? of(void 0);
    this.url = urlSubject;
    this.params = paramsSubject;
    this.queryParams = queryParamsSubject;
    this.fragment = fragmentSubject;
    this.data = dataSubject;
  }
  /** The configuration used to match this route. */
  get routeConfig() {
    return this._futureSnapshot.routeConfig;
  }
  /** The root of the router state. */
  get root() {
    return this._routerState.root;
  }
  /** The parent of this route in the router state tree. */
  get parent() {
    return this._routerState.parent(this);
  }
  /** The first child of this route in the router state tree. */
  get firstChild() {
    return this._routerState.firstChild(this);
  }
  /** The children of this route in the router state tree. */
  get children() {
    return this._routerState.children(this);
  }
  /** The path from the root of the router state tree to this route. */
  get pathFromRoot() {
    return this._routerState.pathFromRoot(this);
  }
  /**
   * An Observable that contains a map of the required and optional parameters
   * specific to the route.
   * The map supports retrieving single and multiple values from the same parameter.
   */
  get paramMap() {
    this._paramMap ??= this.params.pipe(map((p) => convertToParamMap(p)));
    return this._paramMap;
  }
  /**
   * An Observable that contains a map of the query parameters available to all routes.
   * The map supports retrieving single and multiple values from the query parameter.
   */
  get queryParamMap() {
    this._queryParamMap ??= this.queryParams.pipe(map((p) => convertToParamMap(p)));
    return this._queryParamMap;
  }
  toString() {
    return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})`;
  }
};
function getInherited(route, parent, paramsInheritanceStrategy = "emptyOnly") {
  let inherited;
  const {
    routeConfig
  } = route;
  if (parent !== null && (paramsInheritanceStrategy === "always" || // inherit parent data if route is empty path
  routeConfig?.path === "" || // inherit parent data if parent was componentless
  !parent.component && !parent.routeConfig?.loadComponent)) {
    inherited = {
      params: __spreadValues(__spreadValues({}, parent.params), route.params),
      data: __spreadValues(__spreadValues({}, parent.data), route.data),
      resolve: __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, route.data), parent.data), routeConfig?.data), route._resolvedData)
    };
  } else {
    inherited = {
      params: __spreadValues({}, route.params),
      data: __spreadValues({}, route.data),
      resolve: __spreadValues(__spreadValues({}, route.data), route._resolvedData ?? {})
    };
  }
  if (routeConfig && hasStaticTitle(routeConfig)) {
    inherited.resolve[RouteTitleKey] = routeConfig.title;
  }
  return inherited;
}
var ActivatedRouteSnapshot = class {
  url;
  params;
  queryParams;
  fragment;
  data;
  outlet;
  component;
  /** The configuration used to match this route **/
  routeConfig;
  /** @internal */
  _resolve;
  /** @internal */
  _resolvedData;
  /** @internal */
  _routerState;
  /** @internal */
  _paramMap;
  /** @internal */
  _queryParamMap;
  /** The resolved route title */
  get title() {
    return this.data?.[RouteTitleKey];
  }
  /** @internal */
  constructor(url, params, queryParams, fragment, data, outlet, component, routeConfig, resolve) {
    this.url = url;
    this.params = params;
    this.queryParams = queryParams;
    this.fragment = fragment;
    this.data = data;
    this.outlet = outlet;
    this.component = component;
    this.routeConfig = routeConfig;
    this._resolve = resolve;
  }
  /** The root of the router state */
  get root() {
    return this._routerState.root;
  }
  /** The parent of this route in the router state tree */
  get parent() {
    return this._routerState.parent(this);
  }
  /** The first child of this route in the router state tree */
  get firstChild() {
    return this._routerState.firstChild(this);
  }
  /** The children of this route in the router state tree */
  get children() {
    return this._routerState.children(this);
  }
  /** The path from the root of the router state tree to this route */
  get pathFromRoot() {
    return this._routerState.pathFromRoot(this);
  }
  get paramMap() {
    this._paramMap ??= convertToParamMap(this.params);
    return this._paramMap;
  }
  get queryParamMap() {
    this._queryParamMap ??= convertToParamMap(this.queryParams);
    return this._queryParamMap;
  }
  toString() {
    const url = this.url.map((segment) => segment.toString()).join("/");
    const matched = this.routeConfig ? this.routeConfig.path : "";
    return `Route(url:'${url}', path:'${matched}')`;
  }
};
var RouterStateSnapshot = class extends Tree {
  url;
  /** @internal */
  constructor(url, root) {
    super(root);
    this.url = url;
    setRouterState(this, root);
  }
  toString() {
    return serializeNode(this._root);
  }
};
function setRouterState(state2, node) {
  node.value._routerState = state2;
  node.children.forEach((c) => setRouterState(state2, c));
}
function serializeNode(node) {
  const c = node.children.length > 0 ? ` { ${node.children.map(serializeNode).join(", ")} } ` : "";
  return `${node.value}${c}`;
}
function advanceActivatedRoute(route) {
  if (route.snapshot) {
    const currentSnapshot = route.snapshot;
    const nextSnapshot = route._futureSnapshot;
    route.snapshot = nextSnapshot;
    if (!shallowEqual(currentSnapshot.queryParams, nextSnapshot.queryParams)) {
      route.queryParamsSubject.next(nextSnapshot.queryParams);
    }
    if (currentSnapshot.fragment !== nextSnapshot.fragment) {
      route.fragmentSubject.next(nextSnapshot.fragment);
    }
    if (!shallowEqual(currentSnapshot.params, nextSnapshot.params)) {
      route.paramsSubject.next(nextSnapshot.params);
    }
    if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {
      route.urlSubject.next(nextSnapshot.url);
    }
    if (!shallowEqual(currentSnapshot.data, nextSnapshot.data)) {
      route.dataSubject.next(nextSnapshot.data);
    }
  } else {
    route.snapshot = route._futureSnapshot;
    route.dataSubject.next(route._futureSnapshot.data);
  }
}
function equalParamsAndUrlSegments(a, b) {
  const equalUrlParams = shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);
  const parentsMismatch = !a.parent !== !b.parent;
  return equalUrlParams && !parentsMismatch && (!a.parent || equalParamsAndUrlSegments(a.parent, b.parent));
}
function hasStaticTitle(config) {
  return typeof config.title === "string" || config.title === null;
}
var ROUTER_OUTLET_DATA = new InjectionToken(ngDevMode ? "RouterOutlet data" : "");
var RouterOutlet = class _RouterOutlet {
  activated = null;
  /** @internal */
  get activatedComponentRef() {
    return this.activated;
  }
  _activatedRoute = null;
  /**
   * The name of the outlet
   *
   */
  name = PRIMARY_OUTLET;
  activateEvents = new EventEmitter();
  deactivateEvents = new EventEmitter();
  /**
   * Emits an attached component instance when the `RouteReuseStrategy` instructs to re-attach a
   * previously detached subtree.
   **/
  attachEvents = new EventEmitter();
  /**
   * Emits a detached component instance when the `RouteReuseStrategy` instructs to detach the
   * subtree.
   */
  detachEvents = new EventEmitter();
  /**
   * Data that will be provided to the child injector through the `ROUTER_OUTLET_DATA` token.
   *
   * When unset, the value of the token is `undefined` by default.
   */
  routerOutletData = input(void 0, ...ngDevMode ? [{
    debugName: "routerOutletData"
  }] : []);
  parentContexts = inject(ChildrenOutletContexts);
  location = inject(ViewContainerRef);
  changeDetector = inject(ChangeDetectorRef);
  inputBinder = inject(INPUT_BINDER, {
    optional: true
  });
  /** @docs-private */
  supportsBindingToComponentInputs = true;
  /** @docs-private */
  ngOnChanges(changes) {
    if (changes["name"]) {
      const {
        firstChange,
        previousValue
      } = changes["name"];
      if (firstChange) {
        return;
      }
      if (this.isTrackedInParentContexts(previousValue)) {
        this.deactivate();
        this.parentContexts.onChildOutletDestroyed(previousValue);
      }
      this.initializeOutletWithName();
    }
  }
  /** @docs-private */
  ngOnDestroy() {
    if (this.isTrackedInParentContexts(this.name)) {
      this.parentContexts.onChildOutletDestroyed(this.name);
    }
    this.inputBinder?.unsubscribeFromRouteData(this);
  }
  isTrackedInParentContexts(outletName) {
    return this.parentContexts.getContext(outletName)?.outlet === this;
  }
  /** @docs-private */
  ngOnInit() {
    this.initializeOutletWithName();
  }
  initializeOutletWithName() {
    this.parentContexts.onChildOutletCreated(this.name, this);
    if (this.activated) {
      return;
    }
    const context = this.parentContexts.getContext(this.name);
    if (context?.route) {
      if (context.attachRef) {
        this.attach(context.attachRef, context.route);
      } else {
        this.activateWith(context.route, context.injector);
      }
    }
  }
  get isActivated() {
    return !!this.activated;
  }
  /**
   * @returns The currently activated component instance.
   * @throws An error if the outlet is not activated.
   */
  get component() {
    if (!this.activated) throw new RuntimeError(4012, (typeof ngDevMode === "undefined" || ngDevMode) && "Outlet is not activated");
    return this.activated.instance;
  }
  get activatedRoute() {
    if (!this.activated) throw new RuntimeError(4012, (typeof ngDevMode === "undefined" || ngDevMode) && "Outlet is not activated");
    return this._activatedRoute;
  }
  get activatedRouteData() {
    if (this._activatedRoute) {
      return this._activatedRoute.snapshot.data;
    }
    return {};
  }
  /**
   * Called when the `RouteReuseStrategy` instructs to detach the subtree
   */
  detach() {
    if (!this.activated) throw new RuntimeError(4012, (typeof ngDevMode === "undefined" || ngDevMode) && "Outlet is not activated");
    this.location.detach();
    const cmp = this.activated;
    this.activated = null;
    this._activatedRoute = null;
    this.detachEvents.emit(cmp.instance);
    return cmp;
  }
  /**
   * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree
   */
  attach(ref, activatedRoute) {
    this.activated = ref;
    this._activatedRoute = activatedRoute;
    this.location.insert(ref.hostView);
    this.inputBinder?.bindActivatedRouteToOutletComponent(this);
    this.attachEvents.emit(ref.instance);
  }
  deactivate() {
    if (this.activated) {
      const c = this.component;
      this.activated.destroy();
      this.activated = null;
      this._activatedRoute = null;
      this.deactivateEvents.emit(c);
    }
  }
  activateWith(activatedRoute, environmentInjector) {
    if (this.isActivated) {
      throw new RuntimeError(4013, (typeof ngDevMode === "undefined" || ngDevMode) && "Cannot activate an already activated outlet");
    }
    this._activatedRoute = activatedRoute;
    const location = this.location;
    const snapshot = activatedRoute.snapshot;
    const component = snapshot.component;
    const childContexts = this.parentContexts.getOrCreateContext(this.name).children;
    const injector = new OutletInjector(activatedRoute, childContexts, location.injector, this.routerOutletData);
    this.activated = location.createComponent(component, {
      index: location.length,
      injector,
      environmentInjector
    });
    this.changeDetector.markForCheck();
    this.inputBinder?.bindActivatedRouteToOutletComponent(this);
    this.activateEvents.emit(this.activated.instance);
  }
  static \u0275fac = function RouterOutlet_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RouterOutlet)();
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _RouterOutlet,
    selectors: [["router-outlet"]],
    inputs: {
      name: "name",
      routerOutletData: [1, "routerOutletData"]
    },
    outputs: {
      activateEvents: "activate",
      deactivateEvents: "deactivate",
      attachEvents: "attach",
      detachEvents: "detach"
    },
    exportAs: ["outlet"],
    features: [\u0275\u0275NgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterOutlet, [{
    type: Directive,
    args: [{
      selector: "router-outlet",
      exportAs: "outlet"
    }]
  }], null, {
    name: [{
      type: Input
    }],
    activateEvents: [{
      type: Output,
      args: ["activate"]
    }],
    deactivateEvents: [{
      type: Output,
      args: ["deactivate"]
    }],
    attachEvents: [{
      type: Output,
      args: ["attach"]
    }],
    detachEvents: [{
      type: Output,
      args: ["detach"]
    }],
    routerOutletData: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "routerOutletData",
        required: false
      }]
    }]
  });
})();
var OutletInjector = class {
  route;
  childContexts;
  parent;
  outletData;
  constructor(route, childContexts, parent, outletData) {
    this.route = route;
    this.childContexts = childContexts;
    this.parent = parent;
    this.outletData = outletData;
  }
  get(token, notFoundValue) {
    if (token === ActivatedRoute) {
      return this.route;
    }
    if (token === ChildrenOutletContexts) {
      return this.childContexts;
    }
    if (token === ROUTER_OUTLET_DATA) {
      return this.outletData;
    }
    return this.parent.get(token, notFoundValue);
  }
};
var INPUT_BINDER = new InjectionToken("");
var RoutedComponentInputBinder = class _RoutedComponentInputBinder {
  outletDataSubscriptions = /* @__PURE__ */ new Map();
  bindActivatedRouteToOutletComponent(outlet) {
    this.unsubscribeFromRouteData(outlet);
    this.subscribeToRouteData(outlet);
  }
  unsubscribeFromRouteData(outlet) {
    this.outletDataSubscriptions.get(outlet)?.unsubscribe();
    this.outletDataSubscriptions.delete(outlet);
  }
  subscribeToRouteData(outlet) {
    const {
      activatedRoute
    } = outlet;
    const dataSubscription = combineLatest([activatedRoute.queryParams, activatedRoute.params, activatedRoute.data]).pipe(switchMap(([queryParams, params, data], index) => {
      data = __spreadValues(__spreadValues(__spreadValues({}, queryParams), params), data);
      if (index === 0) {
        return of(data);
      }
      return Promise.resolve(data);
    })).subscribe((data) => {
      if (!outlet.isActivated || !outlet.activatedComponentRef || outlet.activatedRoute !== activatedRoute || activatedRoute.component === null) {
        this.unsubscribeFromRouteData(outlet);
        return;
      }
      const mirror = reflectComponentType(activatedRoute.component);
      if (!mirror) {
        this.unsubscribeFromRouteData(outlet);
        return;
      }
      for (const {
        templateName
      } of mirror.inputs) {
        outlet.activatedComponentRef.setInput(templateName, data[templateName]);
      }
    });
    this.outletDataSubscriptions.set(outlet, dataSubscription);
  }
  static \u0275fac = function RoutedComponentInputBinder_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RoutedComponentInputBinder)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _RoutedComponentInputBinder,
    factory: _RoutedComponentInputBinder.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RoutedComponentInputBinder, [{
    type: Injectable
  }], null, null);
})();
var \u0275EmptyOutletComponent = class _\u0275EmptyOutletComponent {
  static \u0275fac = function \u0275EmptyOutletComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _\u0275EmptyOutletComponent)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _\u0275EmptyOutletComponent,
    selectors: [["ng-component"]],
    exportAs: ["emptyRouterOutlet"],
    decls: 1,
    vars: 0,
    template: function _EmptyOutletComponent_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275element(0, "router-outlet");
      }
    },
    dependencies: [RouterOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(\u0275EmptyOutletComponent, [{
    type: Component,
    args: [{
      template: `<router-outlet/>`,
      imports: [RouterOutlet],
      // Used to avoid component ID collisions with user code.
      exportAs: "emptyRouterOutlet"
    }]
  }], null, null);
})();
function standardizeConfig(r) {
  const children = r.children && r.children.map(standardizeConfig);
  const c = children ? __spreadProps(__spreadValues({}, r), {
    children
  }) : __spreadValues({}, r);
  if (!c.component && !c.loadComponent && (children || c.loadChildren) && c.outlet && c.outlet !== PRIMARY_OUTLET) {
    c.component = \u0275EmptyOutletComponent;
  }
  return c;
}
function createRouterState(routeReuseStrategy, curr, prevState) {
  const root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : void 0);
  return new RouterState(root, curr);
}
function createNode(routeReuseStrategy, curr, prevState) {
  if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {
    const value = prevState.value;
    value._futureSnapshot = curr.value;
    const children = createOrReuseChildren(routeReuseStrategy, curr, prevState);
    return new TreeNode(value, children);
  } else {
    if (routeReuseStrategy.shouldAttach(curr.value)) {
      const detachedRouteHandle = routeReuseStrategy.retrieve(curr.value);
      if (detachedRouteHandle !== null) {
        const tree2 = detachedRouteHandle.route;
        tree2.value._futureSnapshot = curr.value;
        tree2.children = curr.children.map((c) => createNode(routeReuseStrategy, c));
        return tree2;
      }
    }
    const value = createActivatedRoute(curr.value);
    const children = curr.children.map((c) => createNode(routeReuseStrategy, c));
    return new TreeNode(value, children);
  }
}
function createOrReuseChildren(routeReuseStrategy, curr, prevState) {
  return curr.children.map((child) => {
    for (const p of prevState.children) {
      if (routeReuseStrategy.shouldReuseRoute(child.value, p.value.snapshot)) {
        return createNode(routeReuseStrategy, child, p);
      }
    }
    return createNode(routeReuseStrategy, child);
  });
}
function createActivatedRoute(c) {
  return new ActivatedRoute(new BehaviorSubject(c.url), new BehaviorSubject(c.params), new BehaviorSubject(c.queryParams), new BehaviorSubject(c.fragment), new BehaviorSubject(c.data), c.outlet, c.component, c);
}
var RedirectCommand = class {
  redirectTo;
  navigationBehaviorOptions;
  constructor(redirectTo, navigationBehaviorOptions) {
    this.redirectTo = redirectTo;
    this.navigationBehaviorOptions = navigationBehaviorOptions;
  }
};
var NAVIGATION_CANCELING_ERROR = "ngNavigationCancelingError";
function redirectingNavigationError(urlSerializer, redirect) {
  const {
    redirectTo,
    navigationBehaviorOptions
  } = isUrlTree(redirect) ? {
    redirectTo: redirect,
    navigationBehaviorOptions: void 0
  } : redirect;
  const error = navigationCancelingError(ngDevMode && `Redirecting to "${urlSerializer.serialize(redirectTo)}"`, NavigationCancellationCode.Redirect);
  error.url = redirectTo;
  error.navigationBehaviorOptions = navigationBehaviorOptions;
  return error;
}
function navigationCancelingError(message, code) {
  const error = new Error(`NavigationCancelingError: ${message || ""}`);
  error[NAVIGATION_CANCELING_ERROR] = true;
  error.cancellationCode = code;
  return error;
}
function isRedirectingNavigationCancelingError(error) {
  return isNavigationCancelingError(error) && isUrlTree(error.url);
}
function isNavigationCancelingError(error) {
  return !!error && error[NAVIGATION_CANCELING_ERROR];
}
var warnedAboutUnsupportedInputBinding = false;
var activateRoutes = (rootContexts, routeReuseStrategy, forwardEvent, inputBindingEnabled) => map((t) => {
  new ActivateRoutes(routeReuseStrategy, t.targetRouterState, t.currentRouterState, forwardEvent, inputBindingEnabled).activate(rootContexts);
  return t;
});
var ActivateRoutes = class {
  routeReuseStrategy;
  futureState;
  currState;
  forwardEvent;
  inputBindingEnabled;
  constructor(routeReuseStrategy, futureState, currState, forwardEvent, inputBindingEnabled) {
    this.routeReuseStrategy = routeReuseStrategy;
    this.futureState = futureState;
    this.currState = currState;
    this.forwardEvent = forwardEvent;
    this.inputBindingEnabled = inputBindingEnabled;
  }
  activate(parentContexts) {
    const futureRoot = this.futureState._root;
    const currRoot = this.currState ? this.currState._root : null;
    this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);
    advanceActivatedRoute(this.futureState.root);
    this.activateChildRoutes(futureRoot, currRoot, parentContexts);
  }
  // De-activate the child route that are not re-used for the future state
  deactivateChildRoutes(futureNode, currNode, contexts) {
    const children = nodeChildrenAsMap(currNode);
    futureNode.children.forEach((futureChild) => {
      const childOutletName = futureChild.value.outlet;
      this.deactivateRoutes(futureChild, children[childOutletName], contexts);
      delete children[childOutletName];
    });
    Object.values(children).forEach((v) => {
      this.deactivateRouteAndItsChildren(v, contexts);
    });
  }
  deactivateRoutes(futureNode, currNode, parentContext) {
    const future = futureNode.value;
    const curr = currNode ? currNode.value : null;
    if (future === curr) {
      if (future.component) {
        const context = parentContext.getContext(future.outlet);
        if (context) {
          this.deactivateChildRoutes(futureNode, currNode, context.children);
        }
      } else {
        this.deactivateChildRoutes(futureNode, currNode, parentContext);
      }
    } else {
      if (curr) {
        this.deactivateRouteAndItsChildren(currNode, parentContext);
      }
    }
  }
  deactivateRouteAndItsChildren(route, parentContexts) {
    if (route.value.component && this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {
      this.detachAndStoreRouteSubtree(route, parentContexts);
    } else {
      this.deactivateRouteAndOutlet(route, parentContexts);
    }
  }
  detachAndStoreRouteSubtree(route, parentContexts) {
    const context = parentContexts.getContext(route.value.outlet);
    const contexts = context && route.value.component ? context.children : parentContexts;
    const children = nodeChildrenAsMap(route);
    for (const treeNode of Object.values(children)) {
      this.deactivateRouteAndItsChildren(treeNode, contexts);
    }
    if (context && context.outlet) {
      const componentRef = context.outlet.detach();
      const contexts2 = context.children.onOutletDeactivated();
      this.routeReuseStrategy.store(route.value.snapshot, {
        componentRef,
        route,
        contexts: contexts2
      });
    }
  }
  deactivateRouteAndOutlet(route, parentContexts) {
    const context = parentContexts.getContext(route.value.outlet);
    const contexts = context && route.value.component ? context.children : parentContexts;
    const children = nodeChildrenAsMap(route);
    for (const treeNode of Object.values(children)) {
      this.deactivateRouteAndItsChildren(treeNode, contexts);
    }
    if (context) {
      if (context.outlet) {
        context.outlet.deactivate();
        context.children.onOutletDeactivated();
      }
      context.attachRef = null;
      context.route = null;
    }
  }
  activateChildRoutes(futureNode, currNode, contexts) {
    const children = nodeChildrenAsMap(currNode);
    futureNode.children.forEach((c) => {
      this.activateRoutes(c, children[c.value.outlet], contexts);
      this.forwardEvent(new ActivationEnd(c.value.snapshot));
    });
    if (futureNode.children.length) {
      this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));
    }
  }
  activateRoutes(futureNode, currNode, parentContexts) {
    const future = futureNode.value;
    const curr = currNode ? currNode.value : null;
    advanceActivatedRoute(future);
    if (future === curr) {
      if (future.component) {
        const context = parentContexts.getOrCreateContext(future.outlet);
        this.activateChildRoutes(futureNode, currNode, context.children);
      } else {
        this.activateChildRoutes(futureNode, currNode, parentContexts);
      }
    } else {
      if (future.component) {
        const context = parentContexts.getOrCreateContext(future.outlet);
        if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {
          const stored = this.routeReuseStrategy.retrieve(future.snapshot);
          this.routeReuseStrategy.store(future.snapshot, null);
          context.children.onOutletReAttached(stored.contexts);
          context.attachRef = stored.componentRef;
          context.route = stored.route.value;
          if (context.outlet) {
            context.outlet.attach(stored.componentRef, stored.route.value);
          }
          advanceActivatedRoute(stored.route.value);
          this.activateChildRoutes(futureNode, null, context.children);
        } else {
          context.attachRef = null;
          context.route = future;
          if (context.outlet) {
            context.outlet.activateWith(future, context.injector);
          }
          this.activateChildRoutes(futureNode, null, context.children);
        }
      } else {
        this.activateChildRoutes(futureNode, null, parentContexts);
      }
    }
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      const context = parentContexts.getOrCreateContext(future.outlet);
      const outlet = context.outlet;
      if (outlet && this.inputBindingEnabled && !outlet.supportsBindingToComponentInputs && !warnedAboutUnsupportedInputBinding) {
        console.warn(`'withComponentInputBinding' feature is enabled but this application is using an outlet that may not support binding to component inputs.`);
        warnedAboutUnsupportedInputBinding = true;
      }
    }
  }
};
var CanActivate = class {
  path;
  route;
  constructor(path) {
    this.path = path;
    this.route = this.path[this.path.length - 1];
  }
};
var CanDeactivate = class {
  component;
  route;
  constructor(component, route) {
    this.component = component;
    this.route = route;
  }
};
function getAllRouteGuards(future, curr, parentContexts) {
  const futureRoot = future._root;
  const currRoot = curr ? curr._root : null;
  return getChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);
}
function getCanActivateChild(p) {
  const canActivateChild = p.routeConfig ? p.routeConfig.canActivateChild : null;
  if (!canActivateChild || canActivateChild.length === 0) return null;
  return {
    node: p,
    guards: canActivateChild
  };
}
function getTokenOrFunctionIdentity(tokenOrFunction, injector) {
  const NOT_FOUND = Symbol();
  const result = injector.get(tokenOrFunction, NOT_FOUND);
  if (result === NOT_FOUND) {
    if (typeof tokenOrFunction === "function" && !isInjectable(tokenOrFunction)) {
      return tokenOrFunction;
    } else {
      return injector.get(tokenOrFunction);
    }
  }
  return result;
}
function getChildRouteGuards(futureNode, currNode, contexts, futurePath, checks = {
  canDeactivateChecks: [],
  canActivateChecks: []
}) {
  const prevChildren = nodeChildrenAsMap(currNode);
  futureNode.children.forEach((c) => {
    getRouteGuards(c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]), checks);
    delete prevChildren[c.value.outlet];
  });
  Object.entries(prevChildren).forEach(([k, v]) => deactivateRouteAndItsChildren(v, contexts.getContext(k), checks));
  return checks;
}
function getRouteGuards(futureNode, currNode, parentContexts, futurePath, checks = {
  canDeactivateChecks: [],
  canActivateChecks: []
}) {
  const future = futureNode.value;
  const curr = currNode ? currNode.value : null;
  const context = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;
  if (curr && future.routeConfig === curr.routeConfig) {
    const shouldRun = shouldRunGuardsAndResolvers(curr, future, future.routeConfig.runGuardsAndResolvers);
    if (shouldRun) {
      checks.canActivateChecks.push(new CanActivate(futurePath));
    } else {
      future.data = curr.data;
      future._resolvedData = curr._resolvedData;
    }
    if (future.component) {
      getChildRouteGuards(futureNode, currNode, context ? context.children : null, futurePath, checks);
    } else {
      getChildRouteGuards(futureNode, currNode, parentContexts, futurePath, checks);
    }
    if (shouldRun && context && context.outlet && context.outlet.isActivated) {
      checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, curr));
    }
  } else {
    if (curr) {
      deactivateRouteAndItsChildren(currNode, context, checks);
    }
    checks.canActivateChecks.push(new CanActivate(futurePath));
    if (future.component) {
      getChildRouteGuards(futureNode, null, context ? context.children : null, futurePath, checks);
    } else {
      getChildRouteGuards(futureNode, null, parentContexts, futurePath, checks);
    }
  }
  return checks;
}
function shouldRunGuardsAndResolvers(curr, future, mode) {
  if (typeof mode === "function") {
    return mode(curr, future);
  }
  switch (mode) {
    case "pathParamsChange":
      return !equalPath(curr.url, future.url);
    case "pathParamsOrQueryParamsChange":
      return !equalPath(curr.url, future.url) || !shallowEqual(curr.queryParams, future.queryParams);
    case "always":
      return true;
    case "paramsOrQueryParamsChange":
      return !equalParamsAndUrlSegments(curr, future) || !shallowEqual(curr.queryParams, future.queryParams);
    case "paramsChange":
    default:
      return !equalParamsAndUrlSegments(curr, future);
  }
}
function deactivateRouteAndItsChildren(route, context, checks) {
  const children = nodeChildrenAsMap(route);
  const r = route.value;
  Object.entries(children).forEach(([childName, node]) => {
    if (!r.component) {
      deactivateRouteAndItsChildren(node, context, checks);
    } else if (context) {
      deactivateRouteAndItsChildren(node, context.children.getContext(childName), checks);
    } else {
      deactivateRouteAndItsChildren(node, null, checks);
    }
  });
  if (!r.component) {
    checks.canDeactivateChecks.push(new CanDeactivate(null, r));
  } else if (context && context.outlet && context.outlet.isActivated) {
    checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, r));
  } else {
    checks.canDeactivateChecks.push(new CanDeactivate(null, r));
  }
}
function isFunction(v) {
  return typeof v === "function";
}
function isBoolean(v) {
  return typeof v === "boolean";
}
function isCanLoad(guard) {
  return guard && isFunction(guard.canLoad);
}
function isCanActivate(guard) {
  return guard && isFunction(guard.canActivate);
}
function isCanActivateChild(guard) {
  return guard && isFunction(guard.canActivateChild);
}
function isCanDeactivate(guard) {
  return guard && isFunction(guard.canDeactivate);
}
function isCanMatch(guard) {
  return guard && isFunction(guard.canMatch);
}
function isEmptyError(e) {
  return e instanceof EmptyError || e?.name === "EmptyError";
}
var INITIAL_VALUE = /* @__PURE__ */ Symbol("INITIAL_VALUE");
function prioritizedGuardValue() {
  return switchMap((obs) => {
    return combineLatest(obs.map((o) => o.pipe(take(1), startWith(INITIAL_VALUE)))).pipe(map((results) => {
      for (const result of results) {
        if (result === true) {
          continue;
        } else if (result === INITIAL_VALUE) {
          return INITIAL_VALUE;
        } else if (result === false || isRedirect(result)) {
          return result;
        }
      }
      return true;
    }), filter((item) => item !== INITIAL_VALUE), take(1));
  });
}
function isRedirect(val) {
  return isUrlTree(val) || val instanceof RedirectCommand;
}
function checkGuards(injector, forwardEvent) {
  return mergeMap((t) => {
    const {
      targetSnapshot,
      currentSnapshot,
      guards: {
        canActivateChecks,
        canDeactivateChecks
      }
    } = t;
    if (canDeactivateChecks.length === 0 && canActivateChecks.length === 0) {
      return of(__spreadProps(__spreadValues({}, t), {
        guardsResult: true
      }));
    }
    return runCanDeactivateChecks(canDeactivateChecks, targetSnapshot, currentSnapshot, injector).pipe(mergeMap((canDeactivate) => {
      return canDeactivate && isBoolean(canDeactivate) ? runCanActivateChecks(targetSnapshot, canActivateChecks, injector, forwardEvent) : of(canDeactivate);
    }), map((guardsResult) => __spreadProps(__spreadValues({}, t), {
      guardsResult
    })));
  });
}
function runCanDeactivateChecks(checks, futureRSS, currRSS, injector) {
  return from(checks).pipe(mergeMap((check) => runCanDeactivate(check.component, check.route, currRSS, futureRSS, injector)), first((result) => {
    return result !== true;
  }, true));
}
function runCanActivateChecks(futureSnapshot, checks, injector, forwardEvent) {
  return from(checks).pipe(concatMap((check) => {
    return concat(fireChildActivationStart(check.route.parent, forwardEvent), fireActivationStart(check.route, forwardEvent), runCanActivateChild(futureSnapshot, check.path, injector), runCanActivate(futureSnapshot, check.route, injector));
  }), first((result) => {
    return result !== true;
  }, true));
}
function fireActivationStart(snapshot, forwardEvent) {
  if (snapshot !== null && forwardEvent) {
    forwardEvent(new ActivationStart(snapshot));
  }
  return of(true);
}
function fireChildActivationStart(snapshot, forwardEvent) {
  if (snapshot !== null && forwardEvent) {
    forwardEvent(new ChildActivationStart(snapshot));
  }
  return of(true);
}
function runCanActivate(futureRSS, futureARS, injector) {
  const canActivate = futureARS.routeConfig ? futureARS.routeConfig.canActivate : null;
  if (!canActivate || canActivate.length === 0) return of(true);
  const canActivateObservables = canActivate.map((canActivate2) => {
    return defer(() => {
      const closestInjector = getClosestRouteInjector(futureARS) ?? injector;
      const guard = getTokenOrFunctionIdentity(canActivate2, closestInjector);
      const guardVal = isCanActivate(guard) ? guard.canActivate(futureARS, futureRSS) : runInInjectionContext(closestInjector, () => guard(futureARS, futureRSS));
      return wrapIntoObservable(guardVal).pipe(first());
    });
  });
  return of(canActivateObservables).pipe(prioritizedGuardValue());
}
function runCanActivateChild(futureRSS, path, injector) {
  const futureARS = path[path.length - 1];
  const canActivateChildGuards = path.slice(0, path.length - 1).reverse().map((p) => getCanActivateChild(p)).filter((_) => _ !== null);
  const canActivateChildGuardsMapped = canActivateChildGuards.map((d) => {
    return defer(() => {
      const guardsMapped = d.guards.map((canActivateChild) => {
        const closestInjector = getClosestRouteInjector(d.node) ?? injector;
        const guard = getTokenOrFunctionIdentity(canActivateChild, closestInjector);
        const guardVal = isCanActivateChild(guard) ? guard.canActivateChild(futureARS, futureRSS) : runInInjectionContext(closestInjector, () => guard(futureARS, futureRSS));
        return wrapIntoObservable(guardVal).pipe(first());
      });
      return of(guardsMapped).pipe(prioritizedGuardValue());
    });
  });
  return of(canActivateChildGuardsMapped).pipe(prioritizedGuardValue());
}
function runCanDeactivate(component, currARS, currRSS, futureRSS, injector) {
  const canDeactivate = currARS && currARS.routeConfig ? currARS.routeConfig.canDeactivate : null;
  if (!canDeactivate || canDeactivate.length === 0) return of(true);
  const canDeactivateObservables = canDeactivate.map((c) => {
    const closestInjector = getClosestRouteInjector(currARS) ?? injector;
    const guard = getTokenOrFunctionIdentity(c, closestInjector);
    const guardVal = isCanDeactivate(guard) ? guard.canDeactivate(component, currARS, currRSS, futureRSS) : runInInjectionContext(closestInjector, () => guard(component, currARS, currRSS, futureRSS));
    return wrapIntoObservable(guardVal).pipe(first());
  });
  return of(canDeactivateObservables).pipe(prioritizedGuardValue());
}
function runCanLoadGuards(injector, route, segments, urlSerializer) {
  const canLoad = route.canLoad;
  if (canLoad === void 0 || canLoad.length === 0) {
    return of(true);
  }
  const canLoadObservables = canLoad.map((injectionToken) => {
    const guard = getTokenOrFunctionIdentity(injectionToken, injector);
    const guardVal = isCanLoad(guard) ? guard.canLoad(route, segments) : runInInjectionContext(injector, () => guard(route, segments));
    return wrapIntoObservable(guardVal);
  });
  return of(canLoadObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));
}
function redirectIfUrlTree(urlSerializer) {
  return pipe(tap((result) => {
    if (typeof result === "boolean") return;
    throw redirectingNavigationError(urlSerializer, result);
  }), map((result) => result === true));
}
function runCanMatchGuards(injector, route, segments, urlSerializer) {
  const canMatch = route.canMatch;
  if (!canMatch || canMatch.length === 0) return of(true);
  const canMatchObservables = canMatch.map((injectionToken) => {
    const guard = getTokenOrFunctionIdentity(injectionToken, injector);
    const guardVal = isCanMatch(guard) ? guard.canMatch(route, segments) : runInInjectionContext(injector, () => guard(route, segments));
    return wrapIntoObservable(guardVal);
  });
  return of(canMatchObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));
}
var NoMatch = class {
  segmentGroup;
  constructor(segmentGroup) {
    this.segmentGroup = segmentGroup || null;
  }
};
var AbsoluteRedirect = class extends Error {
  urlTree;
  constructor(urlTree) {
    super();
    this.urlTree = urlTree;
  }
};
function noMatch$1(segmentGroup) {
  return throwError(new NoMatch(segmentGroup));
}
function namedOutletsRedirect(redirectTo) {
  return throwError(new RuntimeError(4e3, (typeof ngDevMode === "undefined" || ngDevMode) && `Only absolute redirects can have named outlets. redirectTo: '${redirectTo}'`));
}
function canLoadFails(route) {
  return throwError(navigationCancelingError((typeof ngDevMode === "undefined" || ngDevMode) && `Cannot load children because the guard of the route "path: '${route.path}'" returned false`, NavigationCancellationCode.GuardRejected));
}
var ApplyRedirects = class {
  urlSerializer;
  urlTree;
  constructor(urlSerializer, urlTree) {
    this.urlSerializer = urlSerializer;
    this.urlTree = urlTree;
  }
  lineralizeSegments(route, urlTree) {
    let res = [];
    let c = urlTree.root;
    while (true) {
      res = res.concat(c.segments);
      if (c.numberOfChildren === 0) {
        return of(res);
      }
      if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {
        return namedOutletsRedirect(`${route.redirectTo}`);
      }
      c = c.children[PRIMARY_OUTLET];
    }
  }
  applyRedirectCommands(segments, redirectTo, posParams, currentSnapshot, injector) {
    return getRedirectResult(redirectTo, currentSnapshot, injector).pipe(map((redirect) => {
      if (redirect instanceof UrlTree) {
        throw new AbsoluteRedirect(redirect);
      }
      const newTree = this.applyRedirectCreateUrlTree(redirect, this.urlSerializer.parse(redirect), segments, posParams);
      if (redirect[0] === "/") {
        throw new AbsoluteRedirect(newTree);
      }
      return newTree;
    }));
  }
  applyRedirectCreateUrlTree(redirectTo, urlTree, segments, posParams) {
    const newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);
    return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);
  }
  createQueryParams(redirectToParams, actualParams) {
    const res = {};
    Object.entries(redirectToParams).forEach(([k, v]) => {
      const copySourceValue = typeof v === "string" && v[0] === ":";
      if (copySourceValue) {
        const sourceName = v.substring(1);
        res[k] = actualParams[sourceName];
      } else {
        res[k] = v;
      }
    });
    return res;
  }
  createSegmentGroup(redirectTo, group2, segments, posParams) {
    const updatedSegments = this.createSegments(redirectTo, group2.segments, segments, posParams);
    let children = {};
    Object.entries(group2.children).forEach(([name, child]) => {
      children[name] = this.createSegmentGroup(redirectTo, child, segments, posParams);
    });
    return new UrlSegmentGroup(updatedSegments, children);
  }
  createSegments(redirectTo, redirectToSegments, actualSegments, posParams) {
    return redirectToSegments.map((s) => s.path[0] === ":" ? this.findPosParam(redirectTo, s, posParams) : this.findOrReturn(s, actualSegments));
  }
  findPosParam(redirectTo, redirectToUrlSegment, posParams) {
    const pos = posParams[redirectToUrlSegment.path.substring(1)];
    if (!pos) throw new RuntimeError(4001, (typeof ngDevMode === "undefined" || ngDevMode) && `Cannot redirect to '${redirectTo}'. Cannot find '${redirectToUrlSegment.path}'.`);
    return pos;
  }
  findOrReturn(redirectToUrlSegment, actualSegments) {
    let idx = 0;
    for (const s of actualSegments) {
      if (s.path === redirectToUrlSegment.path) {
        actualSegments.splice(idx);
        return s;
      }
      idx++;
    }
    return redirectToUrlSegment;
  }
};
function getRedirectResult(redirectTo, currentSnapshot, injector) {
  if (typeof redirectTo === "string") {
    return of(redirectTo);
  }
  const redirectToFn = redirectTo;
  const {
    queryParams,
    fragment,
    routeConfig,
    url,
    outlet,
    params,
    data,
    title
  } = currentSnapshot;
  return wrapIntoObservable(runInInjectionContext(injector, () => redirectToFn({
    params,
    data,
    queryParams,
    fragment,
    routeConfig,
    url,
    outlet,
    title
  })));
}
var noMatch = {
  matched: false,
  consumedSegments: [],
  remainingSegments: [],
  parameters: {},
  positionalParamSegments: {}
};
function matchWithChecks(segmentGroup, route, segments, injector, urlSerializer) {
  const result = match(segmentGroup, route, segments);
  if (!result.matched) {
    return of(result);
  }
  injector = getOrCreateRouteInjectorIfNeeded(route, injector);
  return runCanMatchGuards(injector, route, segments, urlSerializer).pipe(map((v) => v === true ? result : __spreadValues({}, noMatch)));
}
function match(segmentGroup, route, segments) {
  if (route.path === "**") {
    return createWildcardMatchResult(segments);
  }
  if (route.path === "") {
    if (route.pathMatch === "full" && (segmentGroup.hasChildren() || segments.length > 0)) {
      return __spreadValues({}, noMatch);
    }
    return {
      matched: true,
      consumedSegments: [],
      remainingSegments: segments,
      parameters: {},
      positionalParamSegments: {}
    };
  }
  const matcher = route.matcher || defaultUrlMatcher;
  const res = matcher(segments, segmentGroup, route);
  if (!res) return __spreadValues({}, noMatch);
  const posParams = {};
  Object.entries(res.posParams ?? {}).forEach(([k, v]) => {
    posParams[k] = v.path;
  });
  const parameters = res.consumed.length > 0 ? __spreadValues(__spreadValues({}, posParams), res.consumed[res.consumed.length - 1].parameters) : posParams;
  return {
    matched: true,
    consumedSegments: res.consumed,
    remainingSegments: segments.slice(res.consumed.length),
    // TODO(atscott): investigate combining parameters and positionalParamSegments
    parameters,
    positionalParamSegments: res.posParams ?? {}
  };
}
function createWildcardMatchResult(segments) {
  return {
    matched: true,
    parameters: segments.length > 0 ? last2(segments).parameters : {},
    consumedSegments: segments,
    remainingSegments: [],
    positionalParamSegments: {}
  };
}
function split(segmentGroup, consumedSegments, slicedSegments, config) {
  if (slicedSegments.length > 0 && containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)) {
    const s2 = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));
    return {
      segmentGroup: s2,
      slicedSegments: []
    };
  }
  if (slicedSegments.length === 0 && containsEmptyPathMatches(segmentGroup, slicedSegments, config)) {
    const s2 = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));
    return {
      segmentGroup: s2,
      slicedSegments
    };
  }
  const s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);
  return {
    segmentGroup: s,
    slicedSegments
  };
}
function addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, routes2, children) {
  const res = {};
  for (const r of routes2) {
    if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {
      const s = new UrlSegmentGroup([], {});
      res[getOutlet(r)] = s;
    }
  }
  return __spreadValues(__spreadValues({}, children), res);
}
function createChildrenForEmptyPaths(routes2, primarySegment) {
  const res = {};
  res[PRIMARY_OUTLET] = primarySegment;
  for (const r of routes2) {
    if (r.path === "" && getOutlet(r) !== PRIMARY_OUTLET) {
      const s = new UrlSegmentGroup([], {});
      res[getOutlet(r)] = s;
    }
  }
  return res;
}
function containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes2) {
  return routes2.some((r) => emptyPathMatch(segmentGroup, slicedSegments, r) && getOutlet(r) !== PRIMARY_OUTLET);
}
function containsEmptyPathMatches(segmentGroup, slicedSegments, routes2) {
  return routes2.some((r) => emptyPathMatch(segmentGroup, slicedSegments, r));
}
function emptyPathMatch(segmentGroup, slicedSegments, r) {
  if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === "full") {
    return false;
  }
  return r.path === "";
}
function noLeftoversInUrl(segmentGroup, segments, outlet) {
  return segments.length === 0 && !segmentGroup.children[outlet];
}
var NoLeftoversInUrl = class {
};
function recognize$1(injector, configLoader, rootComponentType, config, urlTree, urlSerializer, paramsInheritanceStrategy = "emptyOnly") {
  return new Recognizer(injector, configLoader, rootComponentType, config, urlTree, paramsInheritanceStrategy, urlSerializer).recognize();
}
var MAX_ALLOWED_REDIRECTS = 31;
var Recognizer = class {
  injector;
  configLoader;
  rootComponentType;
  config;
  urlTree;
  paramsInheritanceStrategy;
  urlSerializer;
  applyRedirects;
  absoluteRedirectCount = 0;
  allowRedirects = true;
  constructor(injector, configLoader, rootComponentType, config, urlTree, paramsInheritanceStrategy, urlSerializer) {
    this.injector = injector;
    this.configLoader = configLoader;
    this.rootComponentType = rootComponentType;
    this.config = config;
    this.urlTree = urlTree;
    this.paramsInheritanceStrategy = paramsInheritanceStrategy;
    this.urlSerializer = urlSerializer;
    this.applyRedirects = new ApplyRedirects(this.urlSerializer, this.urlTree);
  }
  noMatchError(e) {
    return new RuntimeError(4002, typeof ngDevMode === "undefined" || ngDevMode ? `Cannot match any routes. URL Segment: '${e.segmentGroup}'` : `'${e.segmentGroup}'`);
  }
  recognize() {
    const rootSegmentGroup = split(this.urlTree.root, [], [], this.config).segmentGroup;
    return this.match(rootSegmentGroup).pipe(map(({
      children,
      rootSnapshot
    }) => {
      const rootNode = new TreeNode(rootSnapshot, children);
      const routeState = new RouterStateSnapshot("", rootNode);
      const tree2 = createUrlTreeFromSnapshot(rootSnapshot, [], this.urlTree.queryParams, this.urlTree.fragment);
      tree2.queryParams = this.urlTree.queryParams;
      routeState.url = this.urlSerializer.serialize(tree2);
      return {
        state: routeState,
        tree: tree2
      };
    }));
  }
  match(rootSegmentGroup) {
    const rootSnapshot = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze(__spreadValues({}, this.urlTree.queryParams)), this.urlTree.fragment, Object.freeze({}), PRIMARY_OUTLET, this.rootComponentType, null, {});
    return this.processSegmentGroup(this.injector, this.config, rootSegmentGroup, PRIMARY_OUTLET, rootSnapshot).pipe(map((children) => {
      return {
        children,
        rootSnapshot
      };
    }), catchError((e) => {
      if (e instanceof AbsoluteRedirect) {
        this.urlTree = e.urlTree;
        return this.match(e.urlTree.root);
      }
      if (e instanceof NoMatch) {
        throw this.noMatchError(e);
      }
      throw e;
    }));
  }
  processSegmentGroup(injector, config, segmentGroup, outlet, parentRoute) {
    if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
      return this.processChildren(injector, config, segmentGroup, parentRoute);
    }
    return this.processSegment(injector, config, segmentGroup, segmentGroup.segments, outlet, true, parentRoute).pipe(map((child) => child instanceof TreeNode ? [child] : []));
  }
  /**
   * Matches every child outlet in the `segmentGroup` to a `Route` in the config. Returns `null` if
   * we cannot find a match for _any_ of the children.
   *
   * @param config - The `Routes` to match against
   * @param segmentGroup - The `UrlSegmentGroup` whose children need to be matched against the
   *     config.
   */
  processChildren(injector, config, segmentGroup, parentRoute) {
    const childOutlets = [];
    for (const child of Object.keys(segmentGroup.children)) {
      if (child === "primary") {
        childOutlets.unshift(child);
      } else {
        childOutlets.push(child);
      }
    }
    return from(childOutlets).pipe(concatMap((childOutlet) => {
      const child = segmentGroup.children[childOutlet];
      const sortedConfig = sortByMatchingOutlets(config, childOutlet);
      return this.processSegmentGroup(injector, sortedConfig, child, childOutlet, parentRoute);
    }), scan((children, outletChildren) => {
      children.push(...outletChildren);
      return children;
    }), defaultIfEmpty(null), last(), mergeMap((children) => {
      if (children === null) return noMatch$1(segmentGroup);
      const mergedChildren = mergeEmptyPathMatches(children);
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        checkOutletNameUniqueness(mergedChildren);
      }
      sortActivatedRouteSnapshots(mergedChildren);
      return of(mergedChildren);
    }));
  }
  processSegment(injector, routes2, segmentGroup, segments, outlet, allowRedirects, parentRoute) {
    return from(routes2).pipe(concatMap((r) => {
      return this.processSegmentAgainstRoute(r._injector ?? injector, routes2, r, segmentGroup, segments, outlet, allowRedirects, parentRoute).pipe(catchError((e) => {
        if (e instanceof NoMatch) {
          return of(null);
        }
        throw e;
      }));
    }), first((x) => !!x), catchError((e) => {
      if (isEmptyError(e)) {
        if (noLeftoversInUrl(segmentGroup, segments, outlet)) {
          return of(new NoLeftoversInUrl());
        }
        return noMatch$1(segmentGroup);
      }
      throw e;
    }));
  }
  processSegmentAgainstRoute(injector, routes2, route, rawSegment, segments, outlet, allowRedirects, parentRoute) {
    if (getOutlet(route) !== outlet && (outlet === PRIMARY_OUTLET || !emptyPathMatch(rawSegment, segments, route))) {
      return noMatch$1(rawSegment);
    }
    if (route.redirectTo === void 0) {
      return this.matchSegmentAgainstRoute(injector, rawSegment, route, segments, outlet, parentRoute);
    }
    if (this.allowRedirects && allowRedirects) {
      return this.expandSegmentAgainstRouteUsingRedirect(injector, rawSegment, routes2, route, segments, outlet, parentRoute);
    }
    return noMatch$1(rawSegment);
  }
  expandSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes2, route, segments, outlet, parentRoute) {
    const {
      matched,
      parameters,
      consumedSegments,
      positionalParamSegments,
      remainingSegments
    } = match(segmentGroup, route, segments);
    if (!matched) return noMatch$1(segmentGroup);
    if (typeof route.redirectTo === "string" && route.redirectTo[0] === "/") {
      this.absoluteRedirectCount++;
      if (this.absoluteRedirectCount > MAX_ALLOWED_REDIRECTS) {
        if (ngDevMode) {
          throw new RuntimeError(4016, `Detected possible infinite redirect when redirecting from '${this.urlTree}' to '${route.redirectTo}'.
This is currently a dev mode only error but will become a call stack size exceeded error in production in a future major version.`);
        }
        this.allowRedirects = false;
      }
    }
    const currentSnapshot = new ActivatedRouteSnapshot(segments, parameters, Object.freeze(__spreadValues({}, this.urlTree.queryParams)), this.urlTree.fragment, getData(route), getOutlet(route), route.component ?? route._loadedComponent ?? null, route, getResolve(route));
    const inherited = getInherited(currentSnapshot, parentRoute, this.paramsInheritanceStrategy);
    currentSnapshot.params = Object.freeze(inherited.params);
    currentSnapshot.data = Object.freeze(inherited.data);
    const newTree$ = this.applyRedirects.applyRedirectCommands(consumedSegments, route.redirectTo, positionalParamSegments, currentSnapshot, injector);
    return newTree$.pipe(switchMap((newTree) => this.applyRedirects.lineralizeSegments(route, newTree)), mergeMap((newSegments) => {
      return this.processSegment(injector, routes2, segmentGroup, newSegments.concat(remainingSegments), outlet, false, parentRoute);
    }));
  }
  matchSegmentAgainstRoute(injector, rawSegment, route, segments, outlet, parentRoute) {
    const matchResult = matchWithChecks(rawSegment, route, segments, injector, this.urlSerializer);
    if (route.path === "**") {
      rawSegment.children = {};
    }
    return matchResult.pipe(switchMap((result) => {
      if (!result.matched) {
        return noMatch$1(rawSegment);
      }
      injector = route._injector ?? injector;
      return this.getChildConfig(injector, route, segments).pipe(switchMap(({
        routes: childConfig
      }) => {
        const childInjector = route._loadedInjector ?? injector;
        const {
          parameters,
          consumedSegments,
          remainingSegments
        } = result;
        const snapshot = new ActivatedRouteSnapshot(consumedSegments, parameters, Object.freeze(__spreadValues({}, this.urlTree.queryParams)), this.urlTree.fragment, getData(route), getOutlet(route), route.component ?? route._loadedComponent ?? null, route, getResolve(route));
        const inherited = getInherited(snapshot, parentRoute, this.paramsInheritanceStrategy);
        snapshot.params = Object.freeze(inherited.params);
        snapshot.data = Object.freeze(inherited.data);
        const {
          segmentGroup,
          slicedSegments
        } = split(rawSegment, consumedSegments, remainingSegments, childConfig);
        if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {
          return this.processChildren(childInjector, childConfig, segmentGroup, snapshot).pipe(map((children) => {
            return new TreeNode(snapshot, children);
          }));
        }
        if (childConfig.length === 0 && slicedSegments.length === 0) {
          return of(new TreeNode(snapshot, []));
        }
        const matchedOnOutlet = getOutlet(route) === outlet;
        return this.processSegment(childInjector, childConfig, segmentGroup, slicedSegments, matchedOnOutlet ? PRIMARY_OUTLET : outlet, true, snapshot).pipe(map((child) => {
          return new TreeNode(snapshot, child instanceof TreeNode ? [child] : []);
        }));
      }));
    }));
  }
  getChildConfig(injector, route, segments) {
    if (route.children) {
      return of({
        routes: route.children,
        injector
      });
    }
    if (route.loadChildren) {
      if (route._loadedRoutes !== void 0) {
        return of({
          routes: route._loadedRoutes,
          injector: route._loadedInjector
        });
      }
      return runCanLoadGuards(injector, route, segments, this.urlSerializer).pipe(mergeMap((shouldLoadResult) => {
        if (shouldLoadResult) {
          return this.configLoader.loadChildren(injector, route).pipe(tap((cfg) => {
            route._loadedRoutes = cfg.routes;
            route._loadedInjector = cfg.injector;
          }));
        }
        return canLoadFails(route);
      }));
    }
    return of({
      routes: [],
      injector
    });
  }
};
function sortActivatedRouteSnapshots(nodes) {
  nodes.sort((a, b) => {
    if (a.value.outlet === PRIMARY_OUTLET) return -1;
    if (b.value.outlet === PRIMARY_OUTLET) return 1;
    return a.value.outlet.localeCompare(b.value.outlet);
  });
}
function hasEmptyPathConfig(node) {
  const config = node.value.routeConfig;
  return config && config.path === "";
}
function mergeEmptyPathMatches(nodes) {
  const result = [];
  const mergedNodes = /* @__PURE__ */ new Set();
  for (const node of nodes) {
    if (!hasEmptyPathConfig(node)) {
      result.push(node);
      continue;
    }
    const duplicateEmptyPathNode = result.find((resultNode) => node.value.routeConfig === resultNode.value.routeConfig);
    if (duplicateEmptyPathNode !== void 0) {
      duplicateEmptyPathNode.children.push(...node.children);
      mergedNodes.add(duplicateEmptyPathNode);
    } else {
      result.push(node);
    }
  }
  for (const mergedNode of mergedNodes) {
    const mergedChildren = mergeEmptyPathMatches(mergedNode.children);
    result.push(new TreeNode(mergedNode.value, mergedChildren));
  }
  return result.filter((n) => !mergedNodes.has(n));
}
function checkOutletNameUniqueness(nodes) {
  const names = {};
  nodes.forEach((n) => {
    const routeWithSameOutletName = names[n.value.outlet];
    if (routeWithSameOutletName) {
      const p = routeWithSameOutletName.url.map((s) => s.toString()).join("/");
      const c = n.value.url.map((s) => s.toString()).join("/");
      throw new RuntimeError(4006, (typeof ngDevMode === "undefined" || ngDevMode) && `Two segments cannot have the same outlet name: '${p}' and '${c}'.`);
    }
    names[n.value.outlet] = n.value;
  });
}
function getData(route) {
  return route.data || {};
}
function getResolve(route) {
  return route.resolve || {};
}
function recognize(injector, configLoader, rootComponentType, config, serializer, paramsInheritanceStrategy) {
  return mergeMap((t) => recognize$1(injector, configLoader, rootComponentType, config, t.extractedUrl, serializer, paramsInheritanceStrategy).pipe(map(({
    state: targetSnapshot,
    tree: urlAfterRedirects
  }) => {
    return __spreadProps(__spreadValues({}, t), {
      targetSnapshot,
      urlAfterRedirects
    });
  })));
}
function resolveData(paramsInheritanceStrategy, injector) {
  return mergeMap((t) => {
    const {
      targetSnapshot,
      guards: {
        canActivateChecks
      }
    } = t;
    if (!canActivateChecks.length) {
      return of(t);
    }
    const routesWithResolversToRun = new Set(canActivateChecks.map((check) => check.route));
    const routesNeedingDataUpdates = /* @__PURE__ */ new Set();
    for (const route of routesWithResolversToRun) {
      if (routesNeedingDataUpdates.has(route)) {
        continue;
      }
      for (const newRoute of flattenRouteTree(route)) {
        routesNeedingDataUpdates.add(newRoute);
      }
    }
    let routesProcessed = 0;
    return from(routesNeedingDataUpdates).pipe(concatMap((route) => {
      if (routesWithResolversToRun.has(route)) {
        return runResolve(route, targetSnapshot, paramsInheritanceStrategy, injector);
      } else {
        route.data = getInherited(route, route.parent, paramsInheritanceStrategy).resolve;
        return of(void 0);
      }
    }), tap(() => routesProcessed++), takeLast(1), mergeMap((_) => routesProcessed === routesNeedingDataUpdates.size ? of(t) : EMPTY));
  });
}
function flattenRouteTree(route) {
  const descendants = route.children.map((child) => flattenRouteTree(child)).flat();
  return [route, ...descendants];
}
function runResolve(futureARS, futureRSS, paramsInheritanceStrategy, injector) {
  const config = futureARS.routeConfig;
  const resolve = futureARS._resolve;
  if (config?.title !== void 0 && !hasStaticTitle(config)) {
    resolve[RouteTitleKey] = config.title;
  }
  return defer(() => {
    futureARS.data = getInherited(futureARS, futureARS.parent, paramsInheritanceStrategy).resolve;
    return resolveNode(resolve, futureARS, futureRSS, injector).pipe(map((resolvedData) => {
      futureARS._resolvedData = resolvedData;
      futureARS.data = __spreadValues(__spreadValues({}, futureARS.data), resolvedData);
      return null;
    }));
  });
}
function resolveNode(resolve, futureARS, futureRSS, injector) {
  const keys = getDataKeys(resolve);
  if (keys.length === 0) {
    return of({});
  }
  const data = {};
  return from(keys).pipe(mergeMap((key) => getResolver(resolve[key], futureARS, futureRSS, injector).pipe(first(), tap((value) => {
    if (value instanceof RedirectCommand) {
      throw redirectingNavigationError(new DefaultUrlSerializer(), value);
    }
    data[key] = value;
  }))), takeLast(1), map(() => data), catchError((e) => isEmptyError(e) ? EMPTY : throwError(e)));
}
function getResolver(injectionToken, futureARS, futureRSS, injector) {
  const closestInjector = getClosestRouteInjector(futureARS) ?? injector;
  const resolver = getTokenOrFunctionIdentity(injectionToken, closestInjector);
  const resolverValue = resolver.resolve ? resolver.resolve(futureARS, futureRSS) : runInInjectionContext(closestInjector, () => resolver(futureARS, futureRSS));
  return wrapIntoObservable(resolverValue);
}
function switchTap(next) {
  return switchMap((v) => {
    const nextResult = next(v);
    if (nextResult) {
      return from(nextResult).pipe(map(() => v));
    }
    return of(v);
  });
}
var TitleStrategy = class _TitleStrategy {
  /**
   * @returns The `title` of the deepest primary route.
   */
  buildTitle(snapshot) {
    let pageTitle;
    let route = snapshot.root;
    while (route !== void 0) {
      pageTitle = this.getResolvedTitleForRoute(route) ?? pageTitle;
      route = route.children.find((child) => child.outlet === PRIMARY_OUTLET);
    }
    return pageTitle;
  }
  /**
   * Given an `ActivatedRouteSnapshot`, returns the final value of the
   * `Route.title` property, which can either be a static string or a resolved value.
   */
  getResolvedTitleForRoute(snapshot) {
    return snapshot.data[RouteTitleKey];
  }
  static \u0275fac = function TitleStrategy_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TitleStrategy)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _TitleStrategy,
    factory: () => (() => inject(DefaultTitleStrategy))(),
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TitleStrategy, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => inject(DefaultTitleStrategy)
    }]
  }], null, null);
})();
var DefaultTitleStrategy = class _DefaultTitleStrategy extends TitleStrategy {
  title;
  constructor(title) {
    super();
    this.title = title;
  }
  /**
   * Sets the title of the browser to the given value.
   *
   * @param title The `pageTitle` from the deepest primary route.
   */
  updateTitle(snapshot) {
    const title = this.buildTitle(snapshot);
    if (title !== void 0) {
      this.title.setTitle(title);
    }
  }
  static \u0275fac = function DefaultTitleStrategy_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DefaultTitleStrategy)(\u0275\u0275inject(Title));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _DefaultTitleStrategy,
    factory: _DefaultTitleStrategy.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DefaultTitleStrategy, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: Title
  }], null);
})();
var ROUTER_CONFIGURATION = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "router config" : "", {
  providedIn: "root",
  factory: () => ({})
});
var ROUTES = new InjectionToken(ngDevMode ? "ROUTES" : "");
var RouterConfigLoader = class _RouterConfigLoader {
  componentLoaders = /* @__PURE__ */ new WeakMap();
  childrenLoaders = /* @__PURE__ */ new WeakMap();
  onLoadStartListener;
  onLoadEndListener;
  compiler = inject(Compiler);
  loadComponent(injector, route) {
    if (this.componentLoaders.get(route)) {
      return this.componentLoaders.get(route);
    } else if (route._loadedComponent) {
      return of(route._loadedComponent);
    }
    if (this.onLoadStartListener) {
      this.onLoadStartListener(route);
    }
    const loadRunner = wrapIntoObservable(runInInjectionContext(injector, () => route.loadComponent())).pipe(map(maybeUnwrapDefaultExport), switchMap(maybeResolveResources), tap((component) => {
      if (this.onLoadEndListener) {
        this.onLoadEndListener(route);
      }
      (typeof ngDevMode === "undefined" || ngDevMode) && assertStandalone(route.path ?? "", component);
      route._loadedComponent = component;
    }), finalize(() => {
      this.componentLoaders.delete(route);
    }));
    const loader = new ConnectableObservable(loadRunner, () => new Subject()).pipe(refCount());
    this.componentLoaders.set(route, loader);
    return loader;
  }
  loadChildren(parentInjector, route) {
    if (this.childrenLoaders.get(route)) {
      return this.childrenLoaders.get(route);
    } else if (route._loadedRoutes) {
      return of({
        routes: route._loadedRoutes,
        injector: route._loadedInjector
      });
    }
    if (this.onLoadStartListener) {
      this.onLoadStartListener(route);
    }
    const moduleFactoryOrRoutes$ = loadChildren(route, this.compiler, parentInjector, this.onLoadEndListener);
    const loadRunner = moduleFactoryOrRoutes$.pipe(finalize(() => {
      this.childrenLoaders.delete(route);
    }));
    const loader = new ConnectableObservable(loadRunner, () => new Subject()).pipe(refCount());
    this.childrenLoaders.set(route, loader);
    return loader;
  }
  static \u0275fac = function RouterConfigLoader_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RouterConfigLoader)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _RouterConfigLoader,
    factory: _RouterConfigLoader.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterConfigLoader, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
function loadChildren(route, compiler, parentInjector, onLoadEndListener) {
  return wrapIntoObservable(runInInjectionContext(parentInjector, () => route.loadChildren())).pipe(map(maybeUnwrapDefaultExport), switchMap(maybeResolveResources), mergeMap((t) => {
    if (t instanceof NgModuleFactory$1 || Array.isArray(t)) {
      return of(t);
    } else {
      return from(compiler.compileModuleAsync(t));
    }
  }), map((factoryOrRoutes) => {
    if (onLoadEndListener) {
      onLoadEndListener(route);
    }
    let injector;
    let rawRoutes;
    let requireStandaloneComponents = false;
    if (Array.isArray(factoryOrRoutes)) {
      rawRoutes = factoryOrRoutes;
      requireStandaloneComponents = true;
    } else {
      injector = factoryOrRoutes.create(parentInjector).injector;
      rawRoutes = injector.get(ROUTES, [], {
        optional: true,
        self: true
      }).flat();
    }
    const routes2 = rawRoutes.map(standardizeConfig);
    (typeof ngDevMode === "undefined" || ngDevMode) && validateConfig(routes2, route.path, requireStandaloneComponents);
    return {
      routes: routes2,
      injector
    };
  }));
}
function isWrappedDefaultExport(value) {
  return value && typeof value === "object" && "default" in value;
}
function maybeUnwrapDefaultExport(input2) {
  return isWrappedDefaultExport(input2) ? input2["default"] : input2;
}
function maybeResolveResources(value) {
  if (false) {
    return resolveComponentResources(fetch).catch((error) => {
      console.error(error);
      return Promise.resolve();
    }).then(() => value);
  }
  return of(value);
}
var UrlHandlingStrategy = class _UrlHandlingStrategy {
  static \u0275fac = function UrlHandlingStrategy_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _UrlHandlingStrategy)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _UrlHandlingStrategy,
    factory: () => (() => inject(DefaultUrlHandlingStrategy))(),
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UrlHandlingStrategy, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => inject(DefaultUrlHandlingStrategy)
    }]
  }], null, null);
})();
var DefaultUrlHandlingStrategy = class _DefaultUrlHandlingStrategy {
  shouldProcessUrl(url) {
    return true;
  }
  extract(url) {
    return url;
  }
  merge(newUrlPart, wholeUrl) {
    return newUrlPart;
  }
  static \u0275fac = function DefaultUrlHandlingStrategy_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DefaultUrlHandlingStrategy)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _DefaultUrlHandlingStrategy,
    factory: _DefaultUrlHandlingStrategy.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DefaultUrlHandlingStrategy, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var CREATE_VIEW_TRANSITION = new InjectionToken(ngDevMode ? "view transition helper" : "");
var VIEW_TRANSITION_OPTIONS = new InjectionToken(ngDevMode ? "view transition options" : "");
function createViewTransition(injector, from2, to) {
  const transitionOptions = injector.get(VIEW_TRANSITION_OPTIONS);
  const document2 = injector.get(DOCUMENT);
  if (!document2.startViewTransition || transitionOptions.skipNextTransition) {
    transitionOptions.skipNextTransition = false;
    return new Promise((resolve) => setTimeout(resolve));
  }
  let resolveViewTransitionStarted;
  const viewTransitionStarted = new Promise((resolve) => {
    resolveViewTransitionStarted = resolve;
  });
  const transition2 = document2.startViewTransition(() => {
    resolveViewTransitionStarted();
    return createRenderPromise(injector);
  });
  transition2.ready.catch((error) => {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      console.error(error);
    }
  });
  const {
    onViewTransitionCreated
  } = transitionOptions;
  if (onViewTransitionCreated) {
    runInInjectionContext(injector, () => onViewTransitionCreated({
      transition: transition2,
      from: from2,
      to
    }));
  }
  return viewTransitionStarted;
}
function createRenderPromise(injector) {
  return new Promise((resolve) => {
    afterNextRender({
      read: () => setTimeout(resolve)
    }, {
      injector
    });
  });
}
var NAVIGATION_ERROR_HANDLER = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "navigation error handler" : "");
var NavigationTransitions = class _NavigationTransitions {
  // Some G3 targets expect the navigation object to be mutated (and not getting a new reference on changes).
  currentNavigation = signal(null, ...ngDevMode ? [{
    debugName: "currentNavigation",
    equal: () => false
  }] : [{
    equal: () => false
  }]);
  currentTransition = null;
  lastSuccessfulNavigation = null;
  /**
   * These events are used to communicate back to the Router about the state of the transition. The
   * Router wants to respond to these events in various ways. Because the `NavigationTransition`
   * class is not public, this event subject is not publicly exposed.
   */
  events = new Subject();
  /**
   * Used to abort the current transition with an error.
   */
  transitionAbortWithErrorSubject = new Subject();
  configLoader = inject(RouterConfigLoader);
  environmentInjector = inject(EnvironmentInjector);
  destroyRef = inject(DestroyRef);
  urlSerializer = inject(UrlSerializer);
  rootContexts = inject(ChildrenOutletContexts);
  location = inject(Location);
  inputBindingEnabled = inject(INPUT_BINDER, {
    optional: true
  }) !== null;
  titleStrategy = inject(TitleStrategy);
  options = inject(ROUTER_CONFIGURATION, {
    optional: true
  }) || {};
  paramsInheritanceStrategy = this.options.paramsInheritanceStrategy || "emptyOnly";
  urlHandlingStrategy = inject(UrlHandlingStrategy);
  createViewTransition = inject(CREATE_VIEW_TRANSITION, {
    optional: true
  });
  navigationErrorHandler = inject(NAVIGATION_ERROR_HANDLER, {
    optional: true
  });
  navigationId = 0;
  get hasRequestedNavigation() {
    return this.navigationId !== 0;
  }
  transitions;
  /**
   * Hook that enables you to pause navigation after the preactivation phase.
   * Used by `RouterModule`.
   *
   * @internal
   */
  afterPreactivation = () => of(void 0);
  /** @internal */
  rootComponentType = null;
  destroyed = false;
  constructor() {
    const onLoadStart = (r) => this.events.next(new RouteConfigLoadStart(r));
    const onLoadEnd = (r) => this.events.next(new RouteConfigLoadEnd(r));
    this.configLoader.onLoadEndListener = onLoadEnd;
    this.configLoader.onLoadStartListener = onLoadStart;
    this.destroyRef.onDestroy(() => {
      this.destroyed = true;
    });
  }
  complete() {
    this.transitions?.complete();
  }
  handleNavigationRequest(request) {
    const id = ++this.navigationId;
    untracked(() => {
      this.transitions?.next(__spreadProps(__spreadValues({}, request), {
        extractedUrl: this.urlHandlingStrategy.extract(request.rawUrl),
        targetSnapshot: null,
        targetRouterState: null,
        guards: {
          canActivateChecks: [],
          canDeactivateChecks: []
        },
        guardsResult: null,
        abortController: new AbortController(),
        id
      }));
    });
  }
  setupNavigations(router) {
    this.transitions = new BehaviorSubject(null);
    return this.transitions.pipe(
      filter((t) => t !== null),
      // Using switchMap so we cancel executing navigations when a new one comes in
      switchMap((overallTransitionState) => {
        let completedOrAborted = false;
        return of(overallTransitionState).pipe(
          switchMap((t) => {
            if (this.navigationId > overallTransitionState.id) {
              const cancellationReason = typeof ngDevMode === "undefined" || ngDevMode ? `Navigation ID ${overallTransitionState.id} is not equal to the current navigation id ${this.navigationId}` : "";
              this.cancelNavigationTransition(overallTransitionState, cancellationReason, NavigationCancellationCode.SupersededByNewNavigation);
              return EMPTY;
            }
            this.currentTransition = overallTransitionState;
            this.currentNavigation.set({
              id: t.id,
              initialUrl: t.rawUrl,
              extractedUrl: t.extractedUrl,
              targetBrowserUrl: typeof t.extras.browserUrl === "string" ? this.urlSerializer.parse(t.extras.browserUrl) : t.extras.browserUrl,
              trigger: t.source,
              extras: t.extras,
              previousNavigation: !this.lastSuccessfulNavigation ? null : __spreadProps(__spreadValues({}, this.lastSuccessfulNavigation), {
                previousNavigation: null
              }),
              abort: () => t.abortController.abort()
            });
            const urlTransition = !router.navigated || this.isUpdatingInternalState() || this.isUpdatedBrowserUrl();
            const onSameUrlNavigation = t.extras.onSameUrlNavigation ?? router.onSameUrlNavigation;
            if (!urlTransition && onSameUrlNavigation !== "reload") {
              const reason = typeof ngDevMode === "undefined" || ngDevMode ? `Navigation to ${t.rawUrl} was ignored because it is the same as the current Router URL.` : "";
              this.events.next(new NavigationSkipped(t.id, this.urlSerializer.serialize(t.rawUrl), reason, NavigationSkippedCode.IgnoredSameUrlNavigation));
              t.resolve(false);
              return EMPTY;
            }
            if (this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl)) {
              return of(t).pipe(
                // Fire NavigationStart event
                switchMap((t2) => {
                  this.events.next(new NavigationStart(t2.id, this.urlSerializer.serialize(t2.extractedUrl), t2.source, t2.restoredState));
                  if (t2.id !== this.navigationId) {
                    return EMPTY;
                  }
                  return Promise.resolve(t2);
                }),
                // Recognize
                recognize(this.environmentInjector, this.configLoader, this.rootComponentType, router.config, this.urlSerializer, this.paramsInheritanceStrategy),
                // Update URL if in `eager` update mode
                tap((t2) => {
                  overallTransitionState.targetSnapshot = t2.targetSnapshot;
                  overallTransitionState.urlAfterRedirects = t2.urlAfterRedirects;
                  this.currentNavigation.update((nav) => {
                    nav.finalUrl = t2.urlAfterRedirects;
                    return nav;
                  });
                  const routesRecognized = new RoutesRecognized(t2.id, this.urlSerializer.serialize(t2.extractedUrl), this.urlSerializer.serialize(t2.urlAfterRedirects), t2.targetSnapshot);
                  this.events.next(routesRecognized);
                })
              );
            } else if (urlTransition && this.urlHandlingStrategy.shouldProcessUrl(t.currentRawUrl)) {
              const {
                id,
                extractedUrl,
                source,
                restoredState,
                extras
              } = t;
              const navStart = new NavigationStart(id, this.urlSerializer.serialize(extractedUrl), source, restoredState);
              this.events.next(navStart);
              const targetSnapshot = createEmptyState(this.rootComponentType).snapshot;
              this.currentTransition = overallTransitionState = __spreadProps(__spreadValues({}, t), {
                targetSnapshot,
                urlAfterRedirects: extractedUrl,
                extras: __spreadProps(__spreadValues({}, extras), {
                  skipLocationChange: false,
                  replaceUrl: false
                })
              });
              this.currentNavigation.update((nav) => {
                nav.finalUrl = extractedUrl;
                return nav;
              });
              return of(overallTransitionState);
            } else {
              const reason = typeof ngDevMode === "undefined" || ngDevMode ? `Navigation was ignored because the UrlHandlingStrategy indicated neither the current URL ${t.currentRawUrl} nor target URL ${t.rawUrl} should be processed.` : "";
              this.events.next(new NavigationSkipped(t.id, this.urlSerializer.serialize(t.extractedUrl), reason, NavigationSkippedCode.IgnoredByUrlHandlingStrategy));
              t.resolve(false);
              return EMPTY;
            }
          }),
          // --- GUARDS ---
          tap((t) => {
            const guardsStart = new GuardsCheckStart(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot);
            this.events.next(guardsStart);
          }),
          map((t) => {
            this.currentTransition = overallTransitionState = __spreadProps(__spreadValues({}, t), {
              guards: getAllRouteGuards(t.targetSnapshot, t.currentSnapshot, this.rootContexts)
            });
            return overallTransitionState;
          }),
          checkGuards(this.environmentInjector, (evt) => this.events.next(evt)),
          tap((t) => {
            overallTransitionState.guardsResult = t.guardsResult;
            if (t.guardsResult && typeof t.guardsResult !== "boolean") {
              throw redirectingNavigationError(this.urlSerializer, t.guardsResult);
            }
            const guardsEnd = new GuardsCheckEnd(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot, !!t.guardsResult);
            this.events.next(guardsEnd);
          }),
          filter((t) => {
            if (!t.guardsResult) {
              this.cancelNavigationTransition(t, "", NavigationCancellationCode.GuardRejected);
              return false;
            }
            return true;
          }),
          // --- RESOLVE ---
          switchTap((t) => {
            if (t.guards.canActivateChecks.length === 0) {
              return void 0;
            }
            return of(t).pipe(tap((t2) => {
              const resolveStart = new ResolveStart(t2.id, this.urlSerializer.serialize(t2.extractedUrl), this.urlSerializer.serialize(t2.urlAfterRedirects), t2.targetSnapshot);
              this.events.next(resolveStart);
            }), switchMap((t2) => {
              let dataResolved = false;
              return of(t2).pipe(resolveData(this.paramsInheritanceStrategy, this.environmentInjector), tap({
                next: () => dataResolved = true,
                complete: () => {
                  if (!dataResolved) {
                    this.cancelNavigationTransition(t2, typeof ngDevMode === "undefined" || ngDevMode ? `At least one route resolver didn't emit any value.` : "", NavigationCancellationCode.NoDataFromResolver);
                  }
                }
              }));
            }), tap((t2) => {
              const resolveEnd = new ResolveEnd(t2.id, this.urlSerializer.serialize(t2.extractedUrl), this.urlSerializer.serialize(t2.urlAfterRedirects), t2.targetSnapshot);
              this.events.next(resolveEnd);
            }));
          }),
          // --- LOAD COMPONENTS ---
          switchTap((t) => {
            const loadComponents = (route) => {
              const loaders = [];
              if (route.routeConfig?.loadComponent) {
                const injector = getClosestRouteInjector(route) ?? this.environmentInjector;
                loaders.push(this.configLoader.loadComponent(injector, route.routeConfig).pipe(tap((loadedComponent) => {
                  route.component = loadedComponent;
                }), map(() => void 0)));
              }
              for (const child of route.children) {
                loaders.push(...loadComponents(child));
              }
              return loaders;
            };
            return combineLatest(loadComponents(t.targetSnapshot.root)).pipe(defaultIfEmpty(null), take(1));
          }),
          switchTap(() => this.afterPreactivation()),
          switchMap(() => {
            const {
              currentSnapshot,
              targetSnapshot
            } = overallTransitionState;
            const viewTransitionStarted = this.createViewTransition?.(this.environmentInjector, currentSnapshot.root, targetSnapshot.root);
            return viewTransitionStarted ? from(viewTransitionStarted).pipe(map(() => overallTransitionState)) : of(overallTransitionState);
          }),
          map((t) => {
            const targetRouterState = createRouterState(router.routeReuseStrategy, t.targetSnapshot, t.currentRouterState);
            this.currentTransition = overallTransitionState = __spreadProps(__spreadValues({}, t), {
              targetRouterState
            });
            this.currentNavigation.update((nav) => {
              nav.targetRouterState = targetRouterState;
              return nav;
            });
            return overallTransitionState;
          }),
          tap(() => {
            this.events.next(new BeforeActivateRoutes());
          }),
          activateRoutes(this.rootContexts, router.routeReuseStrategy, (evt) => this.events.next(evt), this.inputBindingEnabled),
          // Ensure that if some observable used to drive the transition doesn't
          // complete, the navigation still finalizes This should never happen, but
          // this is done as a safety measure to avoid surfacing this error (#49567).
          take(1),
          takeUntil(new Observable((subscriber) => {
            const abortSignal = overallTransitionState.abortController.signal;
            const handler = () => subscriber.next();
            abortSignal.addEventListener("abort", handler);
            return () => abortSignal.removeEventListener("abort", handler);
          }).pipe(
            // Ignore aborts if we are already completed, canceled, or are in the activation stage (we have targetRouterState)
            filter(() => !completedOrAborted && !overallTransitionState.targetRouterState),
            tap(() => {
              this.cancelNavigationTransition(overallTransitionState, overallTransitionState.abortController.signal.reason + "", NavigationCancellationCode.Aborted);
            })
          )),
          tap({
            next: (t) => {
              completedOrAborted = true;
              this.lastSuccessfulNavigation = untracked(this.currentNavigation);
              this.events.next(new NavigationEnd(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects)));
              this.titleStrategy?.updateTitle(t.targetRouterState.snapshot);
              t.resolve(true);
            },
            complete: () => {
              completedOrAborted = true;
            }
          }),
          // There used to be a lot more logic happening directly within the
          // transition Observable. Some of this logic has been refactored out to
          // other places but there may still be errors that happen there. This gives
          // us a way to cancel the transition from the outside. This may also be
          // required in the future to support something like the abort signal of the
          // Navigation API where the navigation gets aborted from outside the
          // transition.
          takeUntil(this.transitionAbortWithErrorSubject.pipe(tap((err) => {
            throw err;
          }))),
          finalize(() => {
            if (!completedOrAborted) {
              const cancelationReason = typeof ngDevMode === "undefined" || ngDevMode ? `Navigation ID ${overallTransitionState.id} is not equal to the current navigation id ${this.navigationId}` : "";
              this.cancelNavigationTransition(overallTransitionState, cancelationReason, NavigationCancellationCode.SupersededByNewNavigation);
            }
            if (this.currentTransition?.id === overallTransitionState.id) {
              this.currentNavigation.set(null);
              this.currentTransition = null;
            }
          }),
          catchError((e) => {
            if (this.destroyed) {
              overallTransitionState.resolve(false);
              return EMPTY;
            }
            completedOrAborted = true;
            if (isNavigationCancelingError(e)) {
              this.events.next(new NavigationCancel(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), e.message, e.cancellationCode));
              if (!isRedirectingNavigationCancelingError(e)) {
                overallTransitionState.resolve(false);
              } else {
                this.events.next(new RedirectRequest(e.url, e.navigationBehaviorOptions));
              }
            } else {
              const navigationError = new NavigationError(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), e, overallTransitionState.targetSnapshot ?? void 0);
              try {
                const navigationErrorHandlerResult = runInInjectionContext(this.environmentInjector, () => this.navigationErrorHandler?.(navigationError));
                if (navigationErrorHandlerResult instanceof RedirectCommand) {
                  const {
                    message,
                    cancellationCode
                  } = redirectingNavigationError(this.urlSerializer, navigationErrorHandlerResult);
                  this.events.next(new NavigationCancel(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), message, cancellationCode));
                  this.events.next(new RedirectRequest(navigationErrorHandlerResult.redirectTo, navigationErrorHandlerResult.navigationBehaviorOptions));
                } else {
                  this.events.next(navigationError);
                  throw e;
                }
              } catch (ee) {
                if (this.options.resolveNavigationPromiseOnError) {
                  overallTransitionState.resolve(false);
                } else {
                  overallTransitionState.reject(ee);
                }
              }
            }
            return EMPTY;
          })
        );
      })
    );
  }
  cancelNavigationTransition(t, reason, code) {
    const navCancel = new NavigationCancel(t.id, this.urlSerializer.serialize(t.extractedUrl), reason, code);
    this.events.next(navCancel);
    t.resolve(false);
  }
  /**
   * @returns Whether we're navigating to somewhere that is not what the Router is
   * currently set to.
   */
  isUpdatingInternalState() {
    return this.currentTransition?.extractedUrl.toString() !== this.currentTransition?.currentUrlTree.toString();
  }
  /**
   * @returns Whether we're updating the browser URL to something new (navigation is going
   * to somewhere not displayed in the URL bar and we will update the URL
   * bar if navigation succeeds).
   */
  isUpdatedBrowserUrl() {
    const currentBrowserUrl = this.urlHandlingStrategy.extract(this.urlSerializer.parse(this.location.path(true)));
    const currentNavigation = untracked(this.currentNavigation);
    const targetBrowserUrl = currentNavigation?.targetBrowserUrl ?? currentNavigation?.extractedUrl;
    return currentBrowserUrl.toString() !== targetBrowserUrl?.toString() && !currentNavigation?.extras.skipLocationChange;
  }
  static \u0275fac = function NavigationTransitions_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NavigationTransitions)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _NavigationTransitions,
    factory: _NavigationTransitions.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigationTransitions, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function isBrowserTriggeredNavigation(source) {
  return source !== IMPERATIVE_NAVIGATION;
}
var RouteReuseStrategy = class _RouteReuseStrategy {
  static \u0275fac = function RouteReuseStrategy_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RouteReuseStrategy)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _RouteReuseStrategy,
    factory: () => (() => inject(DefaultRouteReuseStrategy))(),
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouteReuseStrategy, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => inject(DefaultRouteReuseStrategy)
    }]
  }], null, null);
})();
var BaseRouteReuseStrategy = class {
  /**
   * Whether the given route should detach for later reuse.
   * Always returns false for `BaseRouteReuseStrategy`.
   * */
  shouldDetach(route) {
    return false;
  }
  /**
   * A no-op; the route is never stored since this strategy never detaches routes for later re-use.
   */
  store(route, detachedTree) {
  }
  /** Returns `false`, meaning the route (and its subtree) is never reattached */
  shouldAttach(route) {
    return false;
  }
  /** Returns `null` because this strategy does not store routes for later re-use. */
  retrieve(route) {
    return null;
  }
  /**
   * Determines if a route should be reused.
   * This strategy returns `true` when the future route config and current route config are
   * identical.
   */
  shouldReuseRoute(future, curr) {
    return future.routeConfig === curr.routeConfig;
  }
};
var DefaultRouteReuseStrategy = class _DefaultRouteReuseStrategy extends BaseRouteReuseStrategy {
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275DefaultRouteReuseStrategy_BaseFactory;
    return function DefaultRouteReuseStrategy_Factory(__ngFactoryType__) {
      return (\u0275DefaultRouteReuseStrategy_BaseFactory || (\u0275DefaultRouteReuseStrategy_BaseFactory = \u0275\u0275getInheritedFactory(_DefaultRouteReuseStrategy)))(__ngFactoryType__ || _DefaultRouteReuseStrategy);
    };
  })();
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _DefaultRouteReuseStrategy,
    factory: _DefaultRouteReuseStrategy.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DefaultRouteReuseStrategy, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var StateManager = class _StateManager {
  urlSerializer = inject(UrlSerializer);
  options = inject(ROUTER_CONFIGURATION, {
    optional: true
  }) || {};
  canceledNavigationResolution = this.options.canceledNavigationResolution || "replace";
  location = inject(Location);
  urlHandlingStrategy = inject(UrlHandlingStrategy);
  urlUpdateStrategy = this.options.urlUpdateStrategy || "deferred";
  currentUrlTree = new UrlTree();
  /**
   * Returns the currently activated `UrlTree`.
   *
   * This `UrlTree` shows only URLs that the `Router` is configured to handle (through
   * `UrlHandlingStrategy`).
   *
   * The value is set after finding the route config tree to activate but before activating the
   * route.
   */
  getCurrentUrlTree() {
    return this.currentUrlTree;
  }
  rawUrlTree = this.currentUrlTree;
  /**
   * Returns a `UrlTree` that is represents what the browser is actually showing.
   *
   * In the life of a navigation transition:
   * 1. When a navigation begins, the raw `UrlTree` is updated to the full URL that's being
   * navigated to.
   * 2. During a navigation, redirects are applied, which might only apply to _part_ of the URL (due
   * to `UrlHandlingStrategy`).
   * 3. Just before activation, the raw `UrlTree` is updated to include the redirects on top of the
   * original raw URL.
   *
   * Note that this is _only_ here to support `UrlHandlingStrategy.extract` and
   * `UrlHandlingStrategy.shouldProcessUrl`. Without those APIs, the current `UrlTree` would not
   * deviated from the raw `UrlTree`.
   *
   * For `extract`, a raw `UrlTree` is needed because `extract` may only return part
   * of the navigation URL. Thus, the current `UrlTree` may only represent _part_ of the browser
   * URL. When a navigation gets cancelled and the router needs to reset the URL or a new navigation
   * occurs, it needs to know the _whole_ browser URL, not just the part handled by
   * `UrlHandlingStrategy`.
   * For `shouldProcessUrl`, when the return is `false`, the router ignores the navigation but
   * still updates the raw `UrlTree` with the assumption that the navigation was caused by the
   * location change listener due to a URL update by the AngularJS router. In this case, the router
   * still need to know what the browser's URL is for future navigations.
   */
  getRawUrlTree() {
    return this.rawUrlTree;
  }
  createBrowserPath({
    finalUrl,
    initialUrl,
    targetBrowserUrl
  }) {
    const rawUrl = finalUrl !== void 0 ? this.urlHandlingStrategy.merge(finalUrl, initialUrl) : initialUrl;
    const url = targetBrowserUrl ?? rawUrl;
    const path = url instanceof UrlTree ? this.urlSerializer.serialize(url) : url;
    return path;
  }
  commitTransition({
    targetRouterState,
    finalUrl,
    initialUrl
  }) {
    if (finalUrl && targetRouterState) {
      this.currentUrlTree = finalUrl;
      this.rawUrlTree = this.urlHandlingStrategy.merge(finalUrl, initialUrl);
      this.routerState = targetRouterState;
    } else {
      this.rawUrlTree = initialUrl;
    }
  }
  routerState = createEmptyState(null);
  /** Returns the current RouterState. */
  getRouterState() {
    return this.routerState;
  }
  stateMemento = this.createStateMemento();
  updateStateMemento() {
    this.stateMemento = this.createStateMemento();
  }
  createStateMemento() {
    return {
      rawUrlTree: this.rawUrlTree,
      currentUrlTree: this.currentUrlTree,
      routerState: this.routerState
    };
  }
  resetInternalState({
    finalUrl
  }) {
    this.routerState = this.stateMemento.routerState;
    this.currentUrlTree = this.stateMemento.currentUrlTree;
    this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, finalUrl ?? this.rawUrlTree);
  }
  static \u0275fac = function StateManager_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _StateManager)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _StateManager,
    factory: () => (() => inject(HistoryStateManager))(),
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StateManager, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => inject(HistoryStateManager)
    }]
  }], null, null);
})();
var HistoryStateManager = class _HistoryStateManager extends StateManager {
  /**
   * The id of the currently active page in the router.
   * Updated to the transition's target id on a successful navigation.
   *
   * This is used to track what page the router last activated. When an attempted navigation fails,
   * the router can then use this to compute how to restore the state back to the previously active
   * page.
   */
  currentPageId = 0;
  lastSuccessfulId = -1;
  restoredState() {
    return this.location.getState();
  }
  /**
   * The ɵrouterPageId of whatever page is currently active in the browser history. This is
   * important for computing the target page id for new navigations because we need to ensure each
   * page id in the browser history is 1 more than the previous entry.
   */
  get browserPageId() {
    if (this.canceledNavigationResolution !== "computed") {
      return this.currentPageId;
    }
    return this.restoredState()?.\u0275routerPageId ?? this.currentPageId;
  }
  registerNonRouterCurrentEntryChangeListener(listener) {
    return this.location.subscribe((event) => {
      if (event["type"] === "popstate") {
        setTimeout(() => {
          listener(event["url"], event.state, "popstate");
        });
      }
    });
  }
  handleRouterEvent(e, currentTransition) {
    if (e instanceof NavigationStart) {
      this.updateStateMemento();
    } else if (e instanceof NavigationSkipped) {
      this.commitTransition(currentTransition);
    } else if (e instanceof RoutesRecognized) {
      if (this.urlUpdateStrategy === "eager") {
        if (!currentTransition.extras.skipLocationChange) {
          this.setBrowserUrl(this.createBrowserPath(currentTransition), currentTransition);
        }
      }
    } else if (e instanceof BeforeActivateRoutes) {
      this.commitTransition(currentTransition);
      if (this.urlUpdateStrategy === "deferred" && !currentTransition.extras.skipLocationChange) {
        this.setBrowserUrl(this.createBrowserPath(currentTransition), currentTransition);
      }
    } else if (e instanceof NavigationCancel && e.code !== NavigationCancellationCode.SupersededByNewNavigation && e.code !== NavigationCancellationCode.Redirect) {
      this.restoreHistory(currentTransition);
    } else if (e instanceof NavigationError) {
      this.restoreHistory(currentTransition, true);
    } else if (e instanceof NavigationEnd) {
      this.lastSuccessfulId = e.id;
      this.currentPageId = this.browserPageId;
    }
  }
  setBrowserUrl(path, {
    extras,
    id
  }) {
    const {
      replaceUrl,
      state: state2
    } = extras;
    if (this.location.isCurrentPathEqualTo(path) || !!replaceUrl) {
      const currentBrowserPageId = this.browserPageId;
      const newState = __spreadValues(__spreadValues({}, state2), this.generateNgRouterState(id, currentBrowserPageId));
      this.location.replaceState(path, "", newState);
    } else {
      const newState = __spreadValues(__spreadValues({}, state2), this.generateNgRouterState(id, this.browserPageId + 1));
      this.location.go(path, "", newState);
    }
  }
  /**
   * Performs the necessary rollback action to restore the browser URL to the
   * state before the transition.
   */
  restoreHistory(navigation, restoringFromCaughtError = false) {
    if (this.canceledNavigationResolution === "computed") {
      const currentBrowserPageId = this.browserPageId;
      const targetPagePosition = this.currentPageId - currentBrowserPageId;
      if (targetPagePosition !== 0) {
        this.location.historyGo(targetPagePosition);
      } else if (this.getCurrentUrlTree() === navigation.finalUrl && targetPagePosition === 0) {
        this.resetInternalState(navigation);
        this.resetUrlToCurrentUrlTree();
      } else ;
    } else if (this.canceledNavigationResolution === "replace") {
      if (restoringFromCaughtError) {
        this.resetInternalState(navigation);
      }
      this.resetUrlToCurrentUrlTree();
    }
  }
  resetUrlToCurrentUrlTree() {
    this.location.replaceState(this.urlSerializer.serialize(this.getRawUrlTree()), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId));
  }
  generateNgRouterState(navigationId, routerPageId) {
    if (this.canceledNavigationResolution === "computed") {
      return {
        navigationId,
        \u0275routerPageId: routerPageId
      };
    }
    return {
      navigationId
    };
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275HistoryStateManager_BaseFactory;
    return function HistoryStateManager_Factory(__ngFactoryType__) {
      return (\u0275HistoryStateManager_BaseFactory || (\u0275HistoryStateManager_BaseFactory = \u0275\u0275getInheritedFactory(_HistoryStateManager)))(__ngFactoryType__ || _HistoryStateManager);
    };
  })();
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _HistoryStateManager,
    factory: _HistoryStateManager.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HistoryStateManager, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
function afterNextNavigation(router, action) {
  router.events.pipe(filter((e) => e instanceof NavigationEnd || e instanceof NavigationCancel || e instanceof NavigationError || e instanceof NavigationSkipped), map((e) => {
    if (e instanceof NavigationEnd || e instanceof NavigationSkipped) {
      return 0;
    }
    const redirecting = e instanceof NavigationCancel ? e.code === NavigationCancellationCode.Redirect || e.code === NavigationCancellationCode.SupersededByNewNavigation : false;
    return redirecting ? 2 : 1;
  }), filter(
    (result) => result !== 2
    /* NavigationResult.REDIRECTING */
  ), take(1)).subscribe(() => {
    action();
  });
}
var exactMatchOptions = {
  paths: "exact",
  fragment: "ignored",
  matrixParams: "ignored",
  queryParams: "exact"
};
var subsetMatchOptions = {
  paths: "subset",
  fragment: "ignored",
  matrixParams: "ignored",
  queryParams: "subset"
};
var Router = class _Router {
  get currentUrlTree() {
    return this.stateManager.getCurrentUrlTree();
  }
  get rawUrlTree() {
    return this.stateManager.getRawUrlTree();
  }
  disposed = false;
  nonRouterCurrentEntryChangeSubscription;
  console = inject(Console);
  stateManager = inject(StateManager);
  options = inject(ROUTER_CONFIGURATION, {
    optional: true
  }) || {};
  pendingTasks = inject(PendingTasksInternal);
  urlUpdateStrategy = this.options.urlUpdateStrategy || "deferred";
  navigationTransitions = inject(NavigationTransitions);
  urlSerializer = inject(UrlSerializer);
  location = inject(Location);
  urlHandlingStrategy = inject(UrlHandlingStrategy);
  injector = inject(EnvironmentInjector);
  /**
   * The private `Subject` type for the public events exposed in the getter. This is used internally
   * to push events to. The separate field allows us to expose separate types in the public API
   * (i.e., an Observable rather than the Subject).
   */
  _events = new Subject();
  /**
   * An event stream for routing events.
   */
  get events() {
    return this._events;
  }
  /**
   * The current state of routing in this NgModule.
   */
  get routerState() {
    return this.stateManager.getRouterState();
  }
  /**
   * True if at least one navigation event has occurred,
   * false otherwise.
   */
  navigated = false;
  /**
   * A strategy for re-using routes.
   *
   * @deprecated Configure using `providers` instead:
   *   `{provide: RouteReuseStrategy, useClass: MyStrategy}`.
   */
  routeReuseStrategy = inject(RouteReuseStrategy);
  /**
   * How to handle a navigation request to the current URL.
   *
   *
   * @deprecated Configure this through `provideRouter` or `RouterModule.forRoot` instead.
   * @see {@link withRouterConfig}
   * @see {@link provideRouter}
   * @see {@link RouterModule}
   */
  onSameUrlNavigation = this.options.onSameUrlNavigation || "ignore";
  config = inject(ROUTES, {
    optional: true
  })?.flat() ?? [];
  /**
   * Indicates whether the application has opted in to binding Router data to component inputs.
   *
   * This option is enabled by the `withComponentInputBinding` feature of `provideRouter` or
   * `bindToComponentInputs` in the `ExtraOptions` of `RouterModule.forRoot`.
   */
  componentInputBindingEnabled = !!inject(INPUT_BINDER, {
    optional: true
  });
  /**
   * Signal of the current `Navigation` object when the router is navigating, and `null` when idle.
   *
   * Note: The current navigation becomes to null after the NavigationEnd event is emitted.
   */
  currentNavigation = this.navigationTransitions.currentNavigation.asReadonly();
  constructor() {
    this.resetConfig(this.config);
    this.navigationTransitions.setupNavigations(this).subscribe({
      error: (e) => {
        this.console.warn(ngDevMode ? `Unhandled Navigation Error: ${e}` : e);
      }
    });
    this.subscribeToNavigationEvents();
  }
  eventsSubscription = new Subscription();
  subscribeToNavigationEvents() {
    const subscription = this.navigationTransitions.events.subscribe((e) => {
      try {
        const currentTransition = this.navigationTransitions.currentTransition;
        const currentNavigation = untracked(this.navigationTransitions.currentNavigation);
        if (currentTransition !== null && currentNavigation !== null) {
          this.stateManager.handleRouterEvent(e, currentNavigation);
          if (e instanceof NavigationCancel && e.code !== NavigationCancellationCode.Redirect && e.code !== NavigationCancellationCode.SupersededByNewNavigation) {
            this.navigated = true;
          } else if (e instanceof NavigationEnd) {
            this.navigated = true;
          } else if (e instanceof RedirectRequest) {
            const opts = e.navigationBehaviorOptions;
            const mergedTree = this.urlHandlingStrategy.merge(e.url, currentTransition.currentRawUrl);
            const extras = __spreadValues({
              browserUrl: currentTransition.extras.browserUrl,
              info: currentTransition.extras.info,
              skipLocationChange: currentTransition.extras.skipLocationChange,
              // The URL is already updated at this point if we have 'eager' URL
              // updates or if the navigation was triggered by the browser (back
              // button, URL bar, etc). We want to replace that item in history
              // if the navigation is rejected.
              replaceUrl: currentTransition.extras.replaceUrl || this.urlUpdateStrategy === "eager" || isBrowserTriggeredNavigation(currentTransition.source)
            }, opts);
            this.scheduleNavigation(mergedTree, IMPERATIVE_NAVIGATION, null, extras, {
              resolve: currentTransition.resolve,
              reject: currentTransition.reject,
              promise: currentTransition.promise
            });
          }
        }
        if (isPublicRouterEvent(e)) {
          this._events.next(e);
        }
      } catch (e2) {
        this.navigationTransitions.transitionAbortWithErrorSubject.next(e2);
      }
    });
    this.eventsSubscription.add(subscription);
  }
  /** @internal */
  resetRootComponentType(rootComponentType) {
    this.routerState.root.component = rootComponentType;
    this.navigationTransitions.rootComponentType = rootComponentType;
  }
  /**
   * Sets up the location change listener and performs the initial navigation.
   */
  initialNavigation() {
    this.setUpLocationChangeListener();
    if (!this.navigationTransitions.hasRequestedNavigation) {
      this.navigateToSyncWithBrowser(this.location.path(true), IMPERATIVE_NAVIGATION, this.stateManager.restoredState());
    }
  }
  /**
   * Sets up the location change listener. This listener detects navigations triggered from outside
   * the Router (the browser back/forward buttons, for example) and schedules a corresponding Router
   * navigation so that the correct events, guards, etc. are triggered.
   */
  setUpLocationChangeListener() {
    this.nonRouterCurrentEntryChangeSubscription ??= this.stateManager.registerNonRouterCurrentEntryChangeListener((url, state2, source) => {
      this.navigateToSyncWithBrowser(url, source, state2);
    });
  }
  /**
   * Schedules a router navigation to synchronize Router state with the browser state.
   *
   * This is done as a response to a popstate event and the initial navigation. These
   * two scenarios represent times when the browser URL/state has been updated and
   * the Router needs to respond to ensure its internal state matches.
   */
  navigateToSyncWithBrowser(url, source, state2) {
    const extras = {
      replaceUrl: true
    };
    const restoredState = state2?.navigationId ? state2 : null;
    if (state2) {
      const stateCopy = __spreadValues({}, state2);
      delete stateCopy.navigationId;
      delete stateCopy.\u0275routerPageId;
      if (Object.keys(stateCopy).length !== 0) {
        extras.state = stateCopy;
      }
    }
    const urlTree = this.parseUrl(url);
    this.scheduleNavigation(urlTree, source, restoredState, extras).catch((e) => {
      if (this.disposed) {
        return;
      }
      this.injector.get(INTERNAL_APPLICATION_ERROR_HANDLER)(e);
    });
  }
  /** The current URL. */
  get url() {
    return this.serializeUrl(this.currentUrlTree);
  }
  /**
   * Returns the current `Navigation` object when the router is navigating,
   * and `null` when idle.
   *
   * @deprecated 20.2 Use the `currentNavigation` signal instead.
   */
  getCurrentNavigation() {
    return untracked(this.navigationTransitions.currentNavigation);
  }
  /**
   * The `Navigation` object of the most recent navigation to succeed and `null` if there
   *     has not been a successful navigation yet.
   */
  get lastSuccessfulNavigation() {
    return this.navigationTransitions.lastSuccessfulNavigation;
  }
  /**
   * Resets the route configuration used for navigation and generating links.
   *
   * @param config The route array for the new configuration.
   *
   * @usageNotes
   *
   * ```ts
   * router.resetConfig([
   *  { path: 'team/:id', component: TeamCmp, children: [
   *    { path: 'simple', component: SimpleCmp },
   *    { path: 'user/:name', component: UserCmp }
   *  ]}
   * ]);
   * ```
   */
  resetConfig(config) {
    (typeof ngDevMode === "undefined" || ngDevMode) && validateConfig(config);
    this.config = config.map(standardizeConfig);
    this.navigated = false;
  }
  /** @docs-private */
  ngOnDestroy() {
    this.dispose();
  }
  /** Disposes of the router. */
  dispose() {
    this._events.unsubscribe();
    this.navigationTransitions.complete();
    if (this.nonRouterCurrentEntryChangeSubscription) {
      this.nonRouterCurrentEntryChangeSubscription.unsubscribe();
      this.nonRouterCurrentEntryChangeSubscription = void 0;
    }
    this.disposed = true;
    this.eventsSubscription.unsubscribe();
  }
  /**
   * Appends URL segments to the current URL tree to create a new URL tree.
   *
   * @param commands An array of URL fragments with which to construct the new URL tree.
   * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path
   * segments, followed by the parameters for each segment.
   * The fragments are applied to the current URL tree or the one provided  in the `relativeTo`
   * property of the options object, if supplied.
   * @param navigationExtras Options that control the navigation strategy.
   * @returns The new URL tree.
   *
   * @usageNotes
   *
   * ```
   * // create /team/33/user/11
   * router.createUrlTree(['/team', 33, 'user', 11]);
   *
   * // create /team/33;expand=true/user/11
   * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);
   *
   * // you can collapse static segments like this (this works only with the first passed-in value):
   * router.createUrlTree(['/team/33/user', userId]);
   *
   * // If the first segment can contain slashes, and you do not want the router to split it,
   * // you can do the following:
   * router.createUrlTree([{segmentPath: '/one/two'}]);
   *
   * // create /team/33/(user/11//right:chat)
   * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);
   *
   * // remove the right secondary node
   * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);
   *
   * // assuming the current url is `/team/33/user/11` and the route points to `user/11`
   *
   * // navigate to /team/33/user/11/details
   * router.createUrlTree(['details'], {relativeTo: route});
   *
   * // navigate to /team/33/user/22
   * router.createUrlTree(['../22'], {relativeTo: route});
   *
   * // navigate to /team/44/user/22
   * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});
   *
   * Note that a value of `null` or `undefined` for `relativeTo` indicates that the
   * tree should be created relative to the root.
   * ```
   */
  createUrlTree(commands, navigationExtras = {}) {
    const {
      relativeTo,
      queryParams,
      fragment,
      queryParamsHandling,
      preserveFragment
    } = navigationExtras;
    const f = preserveFragment ? this.currentUrlTree.fragment : fragment;
    let q = null;
    switch (queryParamsHandling ?? this.options.defaultQueryParamsHandling) {
      case "merge":
        q = __spreadValues(__spreadValues({}, this.currentUrlTree.queryParams), queryParams);
        break;
      case "preserve":
        q = this.currentUrlTree.queryParams;
        break;
      default:
        q = queryParams || null;
    }
    if (q !== null) {
      q = this.removeEmptyProps(q);
    }
    let relativeToUrlSegmentGroup;
    try {
      const relativeToSnapshot = relativeTo ? relativeTo.snapshot : this.routerState.snapshot.root;
      relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeToSnapshot);
    } catch (e) {
      if (typeof commands[0] !== "string" || commands[0][0] !== "/") {
        commands = [];
      }
      relativeToUrlSegmentGroup = this.currentUrlTree.root;
    }
    return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, q, f ?? null);
  }
  /**
   * Navigates to a view using an absolute route path.
   *
   * @param url An absolute path for a defined route. The function does not apply any delta to the
   *     current URL.
   * @param extras An object containing properties that modify the navigation strategy.
   *
   * @returns A Promise that resolves to 'true' when navigation succeeds,
   * to 'false' when navigation fails, or is rejected on error.
   *
   * @usageNotes
   *
   * The following calls request navigation to an absolute path.
   *
   * ```ts
   * router.navigateByUrl("/team/33/user/11");
   *
   * // Navigate without updating the URL
   * router.navigateByUrl("/team/33/user/11", { skipLocationChange: true });
   * ```
   *
   * @see [Routing and Navigation guide](guide/routing/common-router-tasks)
   *
   */
  navigateByUrl(url, extras = {
    skipLocationChange: false
  }) {
    const urlTree = isUrlTree(url) ? url : this.parseUrl(url);
    const mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);
    return this.scheduleNavigation(mergedTree, IMPERATIVE_NAVIGATION, null, extras);
  }
  /**
   * Navigate based on the provided array of commands and a starting point.
   * If no starting route is provided, the navigation is absolute.
   *
   * @param commands An array of URL fragments with which to construct the target URL.
   * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path
   * segments, followed by the parameters for each segment.
   * The fragments are applied to the current URL or the one provided  in the `relativeTo` property
   * of the options object, if supplied.
   * @param extras An options object that determines how the URL should be constructed or
   *     interpreted.
   *
   * @returns A Promise that resolves to `true` when navigation succeeds, or `false` when navigation
   *     fails. The Promise is rejected when an error occurs if `resolveNavigationPromiseOnError` is
   * not `true`.
   *
   * @usageNotes
   *
   * The following calls request navigation to a dynamic route path relative to the current URL.
   *
   * ```ts
   * router.navigate(['team', 33, 'user', 11], {relativeTo: route});
   *
   * // Navigate without updating the URL, overriding the default behavior
   * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});
   * ```
   *
   * @see [Routing and Navigation guide](guide/routing/common-router-tasks)
   *
   */
  navigate(commands, extras = {
    skipLocationChange: false
  }) {
    validateCommands(commands);
    return this.navigateByUrl(this.createUrlTree(commands, extras), extras);
  }
  /** Serializes a `UrlTree` into a string */
  serializeUrl(url) {
    return this.urlSerializer.serialize(url);
  }
  /** Parses a string into a `UrlTree` */
  parseUrl(url) {
    try {
      return this.urlSerializer.parse(url);
    } catch (e) {
      this.console.warn(formatRuntimeError(4018, ngDevMode && `Error parsing URL ${url}. Falling back to '/' instead. 
` + e));
      return this.urlSerializer.parse("/");
    }
  }
  isActive(url, matchOptions) {
    let options;
    if (matchOptions === true) {
      options = __spreadValues({}, exactMatchOptions);
    } else if (matchOptions === false) {
      options = __spreadValues({}, subsetMatchOptions);
    } else {
      options = matchOptions;
    }
    if (isUrlTree(url)) {
      return containsTree(this.currentUrlTree, url, options);
    }
    const urlTree = this.parseUrl(url);
    return containsTree(this.currentUrlTree, urlTree, options);
  }
  removeEmptyProps(params) {
    return Object.entries(params).reduce((result, [key, value]) => {
      if (value !== null && value !== void 0) {
        result[key] = value;
      }
      return result;
    }, {});
  }
  scheduleNavigation(rawUrl, source, restoredState, extras, priorPromise) {
    if (this.disposed) {
      return Promise.resolve(false);
    }
    let resolve;
    let reject;
    let promise;
    if (priorPromise) {
      resolve = priorPromise.resolve;
      reject = priorPromise.reject;
      promise = priorPromise.promise;
    } else {
      promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
    }
    const taskId = this.pendingTasks.add();
    afterNextNavigation(this, () => {
      queueMicrotask(() => this.pendingTasks.remove(taskId));
    });
    this.navigationTransitions.handleNavigationRequest({
      source,
      restoredState,
      currentUrlTree: this.currentUrlTree,
      currentRawUrl: this.currentUrlTree,
      rawUrl,
      extras,
      resolve,
      reject,
      promise,
      currentSnapshot: this.routerState.snapshot,
      currentRouterState: this.routerState
    });
    return promise.catch((e) => {
      return Promise.reject(e);
    });
  }
  static \u0275fac = function Router_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _Router)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _Router,
    factory: _Router.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Router, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function validateCommands(commands) {
  for (let i = 0; i < commands.length; i++) {
    const cmd = commands[i];
    if (cmd == null) {
      throw new RuntimeError(4008, (typeof ngDevMode === "undefined" || ngDevMode) && `The requested path contains ${cmd} segment at index ${i}`);
    }
  }
}

// node_modules/@angular/router/fesm2022/router_module.mjs
var RouterLink = class _RouterLink {
  router;
  route;
  tabIndexAttribute;
  renderer;
  el;
  locationStrategy;
  /** @nodoc */
  reactiveHref = signal(null, ...ngDevMode ? [{
    debugName: "reactiveHref"
  }] : []);
  /**
   * Represents an `href` attribute value applied to a host element,
   * when a host element is an `<a>`/`<area>` tag or a compatible custom element.
   * For other tags, the value is `null`.
   */
  get href() {
    return untracked(this.reactiveHref);
  }
  /** @deprecated */
  set href(value) {
    this.reactiveHref.set(value);
  }
  /**
   * Represents the `target` attribute on a host element.
   * This is only used when the host element is
   * an `<a>`/`<area>` tag or a compatible custom element.
   */
  target;
  /**
   * Passed to {@link Router#createUrlTree} as part of the
   * `UrlCreationOptions`.
   * @see {@link UrlCreationOptions#queryParams}
   * @see {@link Router#createUrlTree}
   */
  queryParams;
  /**
   * Passed to {@link Router#createUrlTree} as part of the
   * `UrlCreationOptions`.
   * @see {@link UrlCreationOptions#fragment}
   * @see {@link Router#createUrlTree}
   */
  fragment;
  /**
   * Passed to {@link Router#createUrlTree} as part of the
   * `UrlCreationOptions`.
   * @see {@link UrlCreationOptions#queryParamsHandling}
   * @see {@link Router#createUrlTree}
   */
  queryParamsHandling;
  /**
   * Passed to {@link Router#navigateByUrl} as part of the
   * `NavigationBehaviorOptions`.
   * @see {@link NavigationBehaviorOptions#state}
   * @see {@link Router#navigateByUrl}
   */
  state;
  /**
   * Passed to {@link Router#navigateByUrl} as part of the
   * `NavigationBehaviorOptions`.
   * @see {@link NavigationBehaviorOptions#info}
   * @see {@link Router#navigateByUrl}
   */
  info;
  /**
   * Passed to {@link Router#createUrlTree} as part of the
   * `UrlCreationOptions`.
   * Specify a value here when you do not want to use the default value
   * for `routerLink`, which is the current activated route.
   * Note that a value of `undefined` here will use the `routerLink` default.
   * @see {@link UrlCreationOptions#relativeTo}
   * @see {@link Router#createUrlTree}
   */
  relativeTo;
  /** Whether a host element is an `<a>`/`<area>` tag or a compatible custom element. */
  isAnchorElement;
  subscription;
  /** @internal */
  onChanges = new Subject();
  applicationErrorHandler = inject(INTERNAL_APPLICATION_ERROR_HANDLER);
  options = inject(ROUTER_CONFIGURATION, {
    optional: true
  });
  constructor(router, route, tabIndexAttribute, renderer, el, locationStrategy) {
    this.router = router;
    this.route = route;
    this.tabIndexAttribute = tabIndexAttribute;
    this.renderer = renderer;
    this.el = el;
    this.locationStrategy = locationStrategy;
    this.reactiveHref.set(inject(new HostAttributeToken("href"), {
      optional: true
    }));
    const tagName = el.nativeElement.tagName?.toLowerCase();
    this.isAnchorElement = tagName === "a" || tagName === "area" || !!// Avoid breaking in an SSR context where customElements might not be defined.
    (typeof customElements === "object" && // observedAttributes is an optional static property/getter on a custom element.
    // The spec states that this must be an array of strings.
    customElements.get(tagName)?.observedAttributes?.includes?.("href"));
    if (!this.isAnchorElement) {
      this.subscribeToNavigationEventsIfNecessary();
    } else {
      this.setTabIndexIfNotOnNativeEl("0");
    }
  }
  subscribeToNavigationEventsIfNecessary() {
    if (this.subscription !== void 0 || !this.isAnchorElement) {
      return;
    }
    let createSubcription = this.preserveFragment;
    const dependsOnRouterState = (handling) => handling === "merge" || handling === "preserve";
    createSubcription ||= dependsOnRouterState(this.queryParamsHandling);
    createSubcription ||= !this.queryParamsHandling && !dependsOnRouterState(this.options?.defaultQueryParamsHandling);
    if (!createSubcription) {
      return;
    }
    this.subscription = this.router.events.subscribe((s) => {
      if (s instanceof NavigationEnd) {
        this.updateHref();
      }
    });
  }
  /**
   * Passed to {@link Router#createUrlTree} as part of the
   * `UrlCreationOptions`.
   * @see {@link UrlCreationOptions#preserveFragment}
   * @see {@link Router#createUrlTree}
   */
  preserveFragment = false;
  /**
   * Passed to {@link Router#navigateByUrl} as part of the
   * `NavigationBehaviorOptions`.
   * @see {@link NavigationBehaviorOptions#skipLocationChange}
   * @see {@link Router#navigateByUrl}
   */
  skipLocationChange = false;
  /**
   * Passed to {@link Router#navigateByUrl} as part of the
   * `NavigationBehaviorOptions`.
   * @see {@link NavigationBehaviorOptions#replaceUrl}
   * @see {@link Router#navigateByUrl}
   */
  replaceUrl = false;
  /**
   * Modifies the tab index if there was not a tabindex attribute on the element during
   * instantiation.
   */
  setTabIndexIfNotOnNativeEl(newTabIndex) {
    if (this.tabIndexAttribute != null || this.isAnchorElement) {
      return;
    }
    this.applyAttributeValue("tabindex", newTabIndex);
  }
  /** @docs-private */
  // TODO(atscott): Remove changes parameter in major version as a breaking change.
  ngOnChanges(changes) {
    if (ngDevMode && isUrlTree(this.routerLinkInput) && (this.fragment !== void 0 || this.queryParams || this.queryParamsHandling || this.preserveFragment || this.relativeTo)) {
      throw new RuntimeError(4017, "Cannot configure queryParams or fragment when using a UrlTree as the routerLink input value.");
    }
    if (this.isAnchorElement) {
      this.updateHref();
      this.subscribeToNavigationEventsIfNecessary();
    }
    this.onChanges.next(this);
  }
  routerLinkInput = null;
  /**
   * Commands to pass to {@link Router#createUrlTree} or a `UrlTree`.
   *   - **array**: commands to pass to {@link Router#createUrlTree}.
   *   - **string**: shorthand for array of commands with just the string, i.e. `['/route']`
   *   - **UrlTree**: a `UrlTree` for this link rather than creating one from the commands
   *     and other inputs that correspond to properties of `UrlCreationOptions`.
   *   - **null|undefined**: effectively disables the `routerLink`
   * @see {@link Router#createUrlTree}
   */
  set routerLink(commandsOrUrlTree) {
    if (commandsOrUrlTree == null) {
      this.routerLinkInput = null;
      this.setTabIndexIfNotOnNativeEl(null);
    } else {
      if (isUrlTree(commandsOrUrlTree)) {
        this.routerLinkInput = commandsOrUrlTree;
      } else {
        this.routerLinkInput = Array.isArray(commandsOrUrlTree) ? commandsOrUrlTree : [commandsOrUrlTree];
      }
      this.setTabIndexIfNotOnNativeEl("0");
    }
  }
  /** @docs-private */
  onClick(button, ctrlKey, shiftKey, altKey, metaKey) {
    const urlTree = this.urlTree;
    if (urlTree === null) {
      return true;
    }
    if (this.isAnchorElement) {
      if (button !== 0 || ctrlKey || shiftKey || altKey || metaKey) {
        return true;
      }
      if (typeof this.target === "string" && this.target != "_self") {
        return true;
      }
    }
    const extras = {
      skipLocationChange: this.skipLocationChange,
      replaceUrl: this.replaceUrl,
      state: this.state,
      info: this.info
    };
    this.router.navigateByUrl(urlTree, extras)?.catch((e) => {
      this.applicationErrorHandler(e);
    });
    return !this.isAnchorElement;
  }
  /** @docs-private */
  ngOnDestroy() {
    this.subscription?.unsubscribe();
  }
  updateHref() {
    const urlTree = this.urlTree;
    this.reactiveHref.set(urlTree !== null && this.locationStrategy ? this.locationStrategy?.prepareExternalUrl(this.router.serializeUrl(urlTree)) ?? "" : null);
  }
  applyAttributeValue(attrName, attrValue) {
    const renderer = this.renderer;
    const nativeElement = this.el.nativeElement;
    if (attrValue !== null) {
      renderer.setAttribute(nativeElement, attrName, attrValue);
    } else {
      renderer.removeAttribute(nativeElement, attrName);
    }
  }
  get urlTree() {
    if (this.routerLinkInput === null) {
      return null;
    } else if (isUrlTree(this.routerLinkInput)) {
      return this.routerLinkInput;
    }
    return this.router.createUrlTree(this.routerLinkInput, {
      // If the `relativeTo` input is not defined, we want to use `this.route` by default.
      // Otherwise, we should use the value provided by the user in the input.
      relativeTo: this.relativeTo !== void 0 ? this.relativeTo : this.route,
      queryParams: this.queryParams,
      fragment: this.fragment,
      queryParamsHandling: this.queryParamsHandling,
      preserveFragment: this.preserveFragment
    });
  }
  static \u0275fac = function RouterLink_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RouterLink)(\u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(ActivatedRoute), \u0275\u0275injectAttribute("tabindex"), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(LocationStrategy));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _RouterLink,
    selectors: [["", "routerLink", ""]],
    hostVars: 2,
    hostBindings: function RouterLink_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener("click", function RouterLink_click_HostBindingHandler($event) {
          return ctx.onClick($event.button, $event.ctrlKey, $event.shiftKey, $event.altKey, $event.metaKey);
        });
      }
      if (rf & 2) {
        \u0275\u0275attribute("href", ctx.reactiveHref(), \u0275\u0275sanitizeUrlOrResourceUrl)("target", ctx.target);
      }
    },
    inputs: {
      target: "target",
      queryParams: "queryParams",
      fragment: "fragment",
      queryParamsHandling: "queryParamsHandling",
      state: "state",
      info: "info",
      relativeTo: "relativeTo",
      preserveFragment: [2, "preserveFragment", "preserveFragment", booleanAttribute],
      skipLocationChange: [2, "skipLocationChange", "skipLocationChange", booleanAttribute],
      replaceUrl: [2, "replaceUrl", "replaceUrl", booleanAttribute],
      routerLink: "routerLink"
    },
    features: [\u0275\u0275NgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterLink, [{
    type: Directive,
    args: [{
      selector: "[routerLink]",
      host: {
        "[attr.href]": "reactiveHref()"
      }
    }]
  }], () => [{
    type: Router
  }, {
    type: ActivatedRoute
  }, {
    type: void 0,
    decorators: [{
      type: Attribute,
      args: ["tabindex"]
    }]
  }, {
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: LocationStrategy
  }], {
    target: [{
      type: HostBinding,
      args: ["attr.target"]
    }, {
      type: Input
    }],
    queryParams: [{
      type: Input
    }],
    fragment: [{
      type: Input
    }],
    queryParamsHandling: [{
      type: Input
    }],
    state: [{
      type: Input
    }],
    info: [{
      type: Input
    }],
    relativeTo: [{
      type: Input
    }],
    preserveFragment: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    skipLocationChange: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    replaceUrl: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    routerLink: [{
      type: Input
    }],
    onClick: [{
      type: HostListener,
      args: ["click", ["$event.button", "$event.ctrlKey", "$event.shiftKey", "$event.altKey", "$event.metaKey"]]
    }]
  });
})();
var RouterLinkActive = class _RouterLinkActive {
  router;
  element;
  renderer;
  cdr;
  link;
  links;
  classes = [];
  routerEventsSubscription;
  linkInputChangesSubscription;
  _isActive = false;
  get isActive() {
    return this._isActive;
  }
  /**
   * Options to configure how to determine if the router link is active.
   *
   * These options are passed to the `Router.isActive()` function.
   *
   * @see {@link Router#isActive}
   */
  routerLinkActiveOptions = {
    exact: false
  };
  /**
   * Aria-current attribute to apply when the router link is active.
   *
   * Possible values: `'page'` | `'step'` | `'location'` | `'date'` | `'time'` | `true` | `false`.
   *
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-current}
   */
  ariaCurrentWhenActive;
  /**
   *
   * You can use the output `isActiveChange` to get notified each time the link becomes
   * active or inactive.
   *
   * Emits:
   * true  -> Route is active
   * false -> Route is inactive
   *
   * ```html
   * <a
   *  routerLink="/user/bob"
   *  routerLinkActive="active-link"
   *  (isActiveChange)="this.onRouterLinkActive($event)">Bob</a>
   * ```
   */
  isActiveChange = new EventEmitter();
  constructor(router, element, renderer, cdr, link) {
    this.router = router;
    this.element = element;
    this.renderer = renderer;
    this.cdr = cdr;
    this.link = link;
    this.routerEventsSubscription = router.events.subscribe((s) => {
      if (s instanceof NavigationEnd) {
        this.update();
      }
    });
  }
  /** @docs-private */
  ngAfterContentInit() {
    of(this.links.changes, of(null)).pipe(mergeAll()).subscribe((_) => {
      this.update();
      this.subscribeToEachLinkOnChanges();
    });
  }
  subscribeToEachLinkOnChanges() {
    this.linkInputChangesSubscription?.unsubscribe();
    const allLinkChanges = [...this.links.toArray(), this.link].filter((link) => !!link).map((link) => link.onChanges);
    this.linkInputChangesSubscription = from(allLinkChanges).pipe(mergeAll()).subscribe((link) => {
      if (this._isActive !== this.isLinkActive(this.router)(link)) {
        this.update();
      }
    });
  }
  set routerLinkActive(data) {
    const classes = Array.isArray(data) ? data : data.split(" ");
    this.classes = classes.filter((c) => !!c);
  }
  /** @docs-private */
  ngOnChanges(changes) {
    this.update();
  }
  /** @docs-private */
  ngOnDestroy() {
    this.routerEventsSubscription.unsubscribe();
    this.linkInputChangesSubscription?.unsubscribe();
  }
  update() {
    if (!this.links || !this.router.navigated) return;
    queueMicrotask(() => {
      const hasActiveLinks = this.hasActiveLinks();
      this.classes.forEach((c) => {
        if (hasActiveLinks) {
          this.renderer.addClass(this.element.nativeElement, c);
        } else {
          this.renderer.removeClass(this.element.nativeElement, c);
        }
      });
      if (hasActiveLinks && this.ariaCurrentWhenActive !== void 0) {
        this.renderer.setAttribute(this.element.nativeElement, "aria-current", this.ariaCurrentWhenActive.toString());
      } else {
        this.renderer.removeAttribute(this.element.nativeElement, "aria-current");
      }
      if (this._isActive !== hasActiveLinks) {
        this._isActive = hasActiveLinks;
        this.cdr.markForCheck();
        this.isActiveChange.emit(hasActiveLinks);
      }
    });
  }
  isLinkActive(router) {
    const options = isActiveMatchOptions(this.routerLinkActiveOptions) ? this.routerLinkActiveOptions : (
      // While the types should disallow `undefined` here, it's possible without strict inputs
      this.routerLinkActiveOptions.exact || false
    );
    return (link) => {
      const urlTree = link.urlTree;
      return urlTree ? router.isActive(urlTree, options) : false;
    };
  }
  hasActiveLinks() {
    const isActiveCheckFn = this.isLinkActive(this.router);
    return this.link && isActiveCheckFn(this.link) || this.links.some(isActiveCheckFn);
  }
  static \u0275fac = function RouterLinkActive_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RouterLinkActive)(\u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(RouterLink, 8));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _RouterLinkActive,
    selectors: [["", "routerLinkActive", ""]],
    contentQueries: function RouterLinkActive_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        \u0275\u0275contentQuery(dirIndex, RouterLink, 5);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.links = _t);
      }
    },
    inputs: {
      routerLinkActiveOptions: "routerLinkActiveOptions",
      ariaCurrentWhenActive: "ariaCurrentWhenActive",
      routerLinkActive: "routerLinkActive"
    },
    outputs: {
      isActiveChange: "isActiveChange"
    },
    exportAs: ["routerLinkActive"],
    features: [\u0275\u0275NgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterLinkActive, [{
    type: Directive,
    args: [{
      selector: "[routerLinkActive]",
      exportAs: "routerLinkActive"
    }]
  }], () => [{
    type: Router
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: ChangeDetectorRef
  }, {
    type: RouterLink,
    decorators: [{
      type: Optional
    }]
  }], {
    links: [{
      type: ContentChildren,
      args: [RouterLink, {
        descendants: true
      }]
    }],
    routerLinkActiveOptions: [{
      type: Input
    }],
    ariaCurrentWhenActive: [{
      type: Input
    }],
    isActiveChange: [{
      type: Output
    }],
    routerLinkActive: [{
      type: Input
    }]
  });
})();
function isActiveMatchOptions(options) {
  return !!options.paths;
}
var PreloadingStrategy = class {
};
var PreloadAllModules = class _PreloadAllModules {
  preload(route, fn) {
    return fn().pipe(catchError(() => of(null)));
  }
  static \u0275fac = function PreloadAllModules_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PreloadAllModules)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _PreloadAllModules,
    factory: _PreloadAllModules.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PreloadAllModules, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var NoPreloading = class _NoPreloading {
  preload(route, fn) {
    return of(null);
  }
  static \u0275fac = function NoPreloading_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NoPreloading)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _NoPreloading,
    factory: _NoPreloading.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NoPreloading, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var RouterPreloader = class _RouterPreloader {
  router;
  injector;
  preloadingStrategy;
  loader;
  subscription;
  constructor(router, injector, preloadingStrategy, loader) {
    this.router = router;
    this.injector = injector;
    this.preloadingStrategy = preloadingStrategy;
    this.loader = loader;
  }
  setUpPreloading() {
    this.subscription = this.router.events.pipe(filter((e) => e instanceof NavigationEnd), concatMap(() => this.preload())).subscribe(() => {
    });
  }
  preload() {
    return this.processRoutes(this.injector, this.router.config);
  }
  /** @docs-private */
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  }
  processRoutes(injector, routes2) {
    const res = [];
    for (const route of routes2) {
      if (route.providers && !route._injector) {
        route._injector = createEnvironmentInjector(route.providers, injector, `Route: ${route.path}`);
      }
      const injectorForCurrentRoute = route._injector ?? injector;
      const injectorForChildren = route._loadedInjector ?? injectorForCurrentRoute;
      if (route.loadChildren && !route._loadedRoutes && route.canLoad === void 0 || route.loadComponent && !route._loadedComponent) {
        res.push(this.preloadConfig(injectorForCurrentRoute, route));
      }
      if (route.children || route._loadedRoutes) {
        res.push(this.processRoutes(injectorForChildren, route.children ?? route._loadedRoutes));
      }
    }
    return from(res).pipe(mergeAll());
  }
  preloadConfig(injector, route) {
    return this.preloadingStrategy.preload(route, () => {
      let loadedChildren$;
      if (route.loadChildren && route.canLoad === void 0) {
        loadedChildren$ = this.loader.loadChildren(injector, route);
      } else {
        loadedChildren$ = of(null);
      }
      const recursiveLoadChildren$ = loadedChildren$.pipe(mergeMap((config) => {
        if (config === null) {
          return of(void 0);
        }
        route._loadedRoutes = config.routes;
        route._loadedInjector = config.injector;
        return this.processRoutes(config.injector ?? injector, config.routes);
      }));
      if (route.loadComponent && !route._loadedComponent) {
        const loadComponent$ = this.loader.loadComponent(injector, route);
        return from([recursiveLoadChildren$, loadComponent$]).pipe(mergeAll());
      } else {
        return recursiveLoadChildren$;
      }
    });
  }
  static \u0275fac = function RouterPreloader_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RouterPreloader)(\u0275\u0275inject(Router), \u0275\u0275inject(EnvironmentInjector), \u0275\u0275inject(PreloadingStrategy), \u0275\u0275inject(RouterConfigLoader));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _RouterPreloader,
    factory: _RouterPreloader.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterPreloader, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: Router
  }, {
    type: EnvironmentInjector
  }, {
    type: PreloadingStrategy
  }, {
    type: RouterConfigLoader
  }], null);
})();
var ROUTER_SCROLLER = new InjectionToken("");
var RouterScroller = class _RouterScroller {
  urlSerializer;
  transitions;
  viewportScroller;
  zone;
  options;
  routerEventsSubscription;
  scrollEventsSubscription;
  lastId = 0;
  lastSource = IMPERATIVE_NAVIGATION;
  restoredId = 0;
  store = {};
  /** @docs-private */
  constructor(urlSerializer, transitions, viewportScroller, zone, options = {}) {
    this.urlSerializer = urlSerializer;
    this.transitions = transitions;
    this.viewportScroller = viewportScroller;
    this.zone = zone;
    this.options = options;
    options.scrollPositionRestoration ||= "disabled";
    options.anchorScrolling ||= "disabled";
  }
  init() {
    if (this.options.scrollPositionRestoration !== "disabled") {
      this.viewportScroller.setHistoryScrollRestoration("manual");
    }
    this.routerEventsSubscription = this.createScrollEvents();
    this.scrollEventsSubscription = this.consumeScrollEvents();
  }
  createScrollEvents() {
    return this.transitions.events.subscribe((e) => {
      if (e instanceof NavigationStart) {
        this.store[this.lastId] = this.viewportScroller.getScrollPosition();
        this.lastSource = e.navigationTrigger;
        this.restoredId = e.restoredState ? e.restoredState.navigationId : 0;
      } else if (e instanceof NavigationEnd) {
        this.lastId = e.id;
        this.scheduleScrollEvent(e, this.urlSerializer.parse(e.urlAfterRedirects).fragment);
      } else if (e instanceof NavigationSkipped && e.code === NavigationSkippedCode.IgnoredSameUrlNavigation) {
        this.lastSource = void 0;
        this.restoredId = 0;
        this.scheduleScrollEvent(e, this.urlSerializer.parse(e.url).fragment);
      }
    });
  }
  consumeScrollEvents() {
    return this.transitions.events.subscribe((e) => {
      if (!(e instanceof Scroll)) return;
      const instantScroll = {
        behavior: "instant"
      };
      if (e.position) {
        if (this.options.scrollPositionRestoration === "top") {
          this.viewportScroller.scrollToPosition([0, 0], instantScroll);
        } else if (this.options.scrollPositionRestoration === "enabled") {
          this.viewportScroller.scrollToPosition(e.position, instantScroll);
        }
      } else {
        if (e.anchor && this.options.anchorScrolling === "enabled") {
          this.viewportScroller.scrollToAnchor(e.anchor);
        } else if (this.options.scrollPositionRestoration !== "disabled") {
          this.viewportScroller.scrollToPosition([0, 0]);
        }
      }
    });
  }
  scheduleScrollEvent(routerEvent, anchor) {
    this.zone.runOutsideAngular(() => __async(this, null, function* () {
      yield new Promise((resolve) => {
        setTimeout(resolve);
        if (typeof requestAnimationFrame !== "undefined") {
          requestAnimationFrame(resolve);
        }
      });
      this.zone.run(() => {
        this.transitions.events.next(new Scroll(routerEvent, this.lastSource === "popstate" ? this.store[this.restoredId] : null, anchor));
      });
    }));
  }
  /** @docs-private */
  ngOnDestroy() {
    this.routerEventsSubscription?.unsubscribe();
    this.scrollEventsSubscription?.unsubscribe();
  }
  static \u0275fac = function RouterScroller_Factory(__ngFactoryType__) {
    \u0275\u0275invalidFactory();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _RouterScroller,
    factory: _RouterScroller.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterScroller, [{
    type: Injectable
  }], () => [{
    type: UrlSerializer
  }, {
    type: NavigationTransitions
  }, {
    type: ViewportScroller
  }, {
    type: NgZone
  }, {
    type: void 0
  }], null);
})();
function getLoadedRoutes(route) {
  return route._loadedRoutes;
}
function getRouterInstance(injector) {
  return injector.get(Router, null, {
    optional: true
  });
}
function navigateByUrl(router, url) {
  if (!(router instanceof Router)) {
    throw new Error("The provided router is not an Angular Router.");
  }
  return router.navigateByUrl(url);
}
function provideRouter(routes2, ...features) {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    publishExternalGlobalUtil("\u0275getLoadedRoutes", getLoadedRoutes);
    publishExternalGlobalUtil("\u0275getRouterInstance", getRouterInstance);
    publishExternalGlobalUtil("\u0275navigateByUrl", navigateByUrl);
  }
  return makeEnvironmentProviders([{
    provide: ROUTES,
    multi: true,
    useValue: routes2
  }, typeof ngDevMode === "undefined" || ngDevMode ? {
    provide: ROUTER_IS_PROVIDED,
    useValue: true
  } : [], {
    provide: ActivatedRoute,
    useFactory: rootRoute,
    deps: [Router]
  }, {
    provide: APP_BOOTSTRAP_LISTENER,
    multi: true,
    useFactory: getBootstrapListener
  }, features.map((feature) => feature.\u0275providers)]);
}
function rootRoute(router) {
  return router.routerState.root;
}
function routerFeature(kind, providers) {
  return {
    \u0275kind: kind,
    \u0275providers: providers
  };
}
var ROUTER_IS_PROVIDED = new InjectionToken("", {
  providedIn: "root",
  factory: () => false
});
function getBootstrapListener() {
  const injector = inject(Injector);
  return (bootstrappedComponentRef) => {
    const ref = injector.get(ApplicationRef);
    if (bootstrappedComponentRef !== ref.components[0]) {
      return;
    }
    const router = injector.get(Router);
    const bootstrapDone = injector.get(BOOTSTRAP_DONE);
    if (injector.get(INITIAL_NAVIGATION) === 1) {
      router.initialNavigation();
    }
    injector.get(ROUTER_PRELOADER, null, {
      optional: true
    })?.setUpPreloading();
    injector.get(ROUTER_SCROLLER, null, {
      optional: true
    })?.init();
    router.resetRootComponentType(ref.componentTypes[0]);
    if (!bootstrapDone.closed) {
      bootstrapDone.next();
      bootstrapDone.complete();
      bootstrapDone.unsubscribe();
    }
  };
}
var BOOTSTRAP_DONE = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "bootstrap done indicator" : "", {
  factory: () => {
    return new Subject();
  }
});
var INITIAL_NAVIGATION = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "initial navigation" : "", {
  providedIn: "root",
  factory: () => 1
  /* InitialNavigation.EnabledNonBlocking */
});
function withEnabledBlockingInitialNavigation() {
  const providers = [{
    provide: IS_ENABLED_BLOCKING_INITIAL_NAVIGATION,
    useValue: true
  }, {
    provide: INITIAL_NAVIGATION,
    useValue: 0
    /* InitialNavigation.EnabledBlocking */
  }, provideAppInitializer(() => {
    const injector = inject(Injector);
    const locationInitialized = injector.get(LOCATION_INITIALIZED, Promise.resolve());
    return locationInitialized.then(() => {
      return new Promise((resolve) => {
        const router = injector.get(Router);
        const bootstrapDone = injector.get(BOOTSTRAP_DONE);
        afterNextNavigation(router, () => {
          resolve(true);
        });
        injector.get(NavigationTransitions).afterPreactivation = () => {
          resolve(true);
          return bootstrapDone.closed ? of(void 0) : bootstrapDone;
        };
        router.initialNavigation();
      });
    });
  })];
  return routerFeature(2, providers);
}
function withDisabledInitialNavigation() {
  const providers = [provideAppInitializer(() => {
    inject(Router).setUpLocationChangeListener();
  }), {
    provide: INITIAL_NAVIGATION,
    useValue: 2
    /* InitialNavigation.Disabled */
  }];
  return routerFeature(3, providers);
}
function withDebugTracing() {
  let providers = [];
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    providers = [{
      provide: ENVIRONMENT_INITIALIZER,
      multi: true,
      useFactory: () => {
        const router = inject(Router);
        return () => router.events.subscribe((e) => {
          console.group?.(`Router Event: ${e.constructor.name}`);
          console.log(stringifyEvent(e));
          console.log(e);
          console.groupEnd?.();
        });
      }
    }];
  } else {
    providers = [];
  }
  return routerFeature(1, providers);
}
var ROUTER_PRELOADER = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "router preloader" : "");
function withPreloading(preloadingStrategy) {
  const providers = [{
    provide: ROUTER_PRELOADER,
    useExisting: RouterPreloader
  }, {
    provide: PreloadingStrategy,
    useExisting: preloadingStrategy
  }];
  return routerFeature(0, providers);
}
function withComponentInputBinding() {
  const providers = [RoutedComponentInputBinder, {
    provide: INPUT_BINDER,
    useExisting: RoutedComponentInputBinder
  }];
  return routerFeature(8, providers);
}
function withViewTransitions(options) {
  performanceMarkFeature("NgRouterViewTransitions");
  const providers = [{
    provide: CREATE_VIEW_TRANSITION,
    useValue: createViewTransition
  }, {
    provide: VIEW_TRANSITION_OPTIONS,
    useValue: __spreadValues({
      skipNextTransition: !!options?.skipInitialTransition
    }, options)
  }];
  return routerFeature(9, providers);
}
var ROUTER_DIRECTIVES = [RouterOutlet, RouterLink, RouterLinkActive, \u0275EmptyOutletComponent];
var ROUTER_FORROOT_GUARD = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "router duplicate forRoot guard" : "");
var ROUTER_PROVIDERS = [
  Location,
  {
    provide: UrlSerializer,
    useClass: DefaultUrlSerializer
  },
  Router,
  ChildrenOutletContexts,
  {
    provide: ActivatedRoute,
    useFactory: rootRoute,
    deps: [Router]
  },
  RouterConfigLoader,
  // Only used to warn when `provideRoutes` is used without `RouterModule` or `provideRouter`. Can
  // be removed when `provideRoutes` is removed.
  typeof ngDevMode === "undefined" || ngDevMode ? {
    provide: ROUTER_IS_PROVIDED,
    useValue: true
  } : []
];
var RouterModule = class _RouterModule {
  constructor() {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      inject(ROUTER_FORROOT_GUARD, {
        optional: true
      });
    }
  }
  /**
   * Creates and configures a module with all the router providers and directives.
   * Optionally sets up an application listener to perform an initial navigation.
   *
   * When registering the NgModule at the root, import as follows:
   *
   * ```ts
   * @NgModule({
   *   imports: [RouterModule.forRoot(ROUTES)]
   * })
   * class MyNgModule {}
   * ```
   *
   * @param routes An array of `Route` objects that define the navigation paths for the application.
   * @param config An `ExtraOptions` configuration object that controls how navigation is performed.
   * @return The new `NgModule`.
   *
   */
  static forRoot(routes2, config) {
    return {
      ngModule: _RouterModule,
      providers: [ROUTER_PROVIDERS, typeof ngDevMode === "undefined" || ngDevMode ? config?.enableTracing ? withDebugTracing().\u0275providers : [] : [], {
        provide: ROUTES,
        multi: true,
        useValue: routes2
      }, typeof ngDevMode === "undefined" || ngDevMode ? {
        provide: ROUTER_FORROOT_GUARD,
        useFactory: provideForRootGuard,
        deps: [[Router, new Optional(), new SkipSelf()]]
      } : [], config?.errorHandler ? {
        provide: NAVIGATION_ERROR_HANDLER,
        useValue: config.errorHandler
      } : [], {
        provide: ROUTER_CONFIGURATION,
        useValue: config ? config : {}
      }, config?.useHash ? provideHashLocationStrategy() : providePathLocationStrategy(), provideRouterScroller(), config?.preloadingStrategy ? withPreloading(config.preloadingStrategy).\u0275providers : [], config?.initialNavigation ? provideInitialNavigation(config) : [], config?.bindToComponentInputs ? withComponentInputBinding().\u0275providers : [], config?.enableViewTransitions ? withViewTransitions().\u0275providers : [], provideRouterInitializer()]
    };
  }
  /**
   * Creates a module with all the router directives and a provider registering routes,
   * without creating a new Router service.
   * When registering for submodules and lazy-loaded submodules, create the NgModule as follows:
   *
   * ```ts
   * @NgModule({
   *   imports: [RouterModule.forChild(ROUTES)]
   * })
   * class MyNgModule {}
   * ```
   *
   * @param routes An array of `Route` objects that define the navigation paths for the submodule.
   * @return The new NgModule.
   *
   */
  static forChild(routes2) {
    return {
      ngModule: _RouterModule,
      providers: [{
        provide: ROUTES,
        multi: true,
        useValue: routes2
      }]
    };
  }
  static \u0275fac = function RouterModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RouterModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _RouterModule,
    imports: [RouterOutlet, RouterLink, RouterLinkActive, \u0275EmptyOutletComponent],
    exports: [RouterOutlet, RouterLink, RouterLinkActive, \u0275EmptyOutletComponent]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterModule, [{
    type: NgModule,
    args: [{
      imports: ROUTER_DIRECTIVES,
      exports: ROUTER_DIRECTIVES
    }]
  }], () => [], null);
})();
function provideRouterScroller() {
  return {
    provide: ROUTER_SCROLLER,
    useFactory: () => {
      const viewportScroller = inject(ViewportScroller);
      const zone = inject(NgZone);
      const config = inject(ROUTER_CONFIGURATION);
      const transitions = inject(NavigationTransitions);
      const urlSerializer = inject(UrlSerializer);
      if (config.scrollOffset) {
        viewportScroller.setOffset(config.scrollOffset);
      }
      return new RouterScroller(urlSerializer, transitions, viewportScroller, zone, config);
    }
  };
}
function provideHashLocationStrategy() {
  return {
    provide: LocationStrategy,
    useClass: HashLocationStrategy
  };
}
function providePathLocationStrategy() {
  return {
    provide: LocationStrategy,
    useClass: PathLocationStrategy
  };
}
function provideForRootGuard(router) {
  if (router) {
    throw new RuntimeError(4007, `The Router was provided more than once. This can happen if 'forRoot' is used outside of the root injector. Lazy loaded modules should use RouterModule.forChild() instead.`);
  }
  return "guarded";
}
function provideInitialNavigation(config) {
  return [config.initialNavigation === "disabled" ? withDisabledInitialNavigation().\u0275providers : [], config.initialNavigation === "enabledBlocking" ? withEnabledBlockingInitialNavigation().\u0275providers : []];
}
var ROUTER_INITIALIZER = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "Router Initializer" : "");
function provideRouterInitializer() {
  return [
    // ROUTER_INITIALIZER token should be removed. It's public API but shouldn't be. We can just
    // have `getBootstrapListener` directly attached to APP_BOOTSTRAP_LISTENER.
    {
      provide: ROUTER_INITIALIZER,
      useFactory: getBootstrapListener
    },
    {
      provide: APP_BOOTSTRAP_LISTENER,
      multi: true,
      useExisting: ROUTER_INITIALIZER
    }
  ];
}

// node_modules/@angular/router/fesm2022/router.mjs
var VERSION2 = new Version("20.3.7");

// node_modules/@angular/animations/fesm2022/private_export.mjs
var AnimationMetadataType;
(function(AnimationMetadataType2) {
  AnimationMetadataType2[AnimationMetadataType2["State"] = 0] = "State";
  AnimationMetadataType2[AnimationMetadataType2["Transition"] = 1] = "Transition";
  AnimationMetadataType2[AnimationMetadataType2["Sequence"] = 2] = "Sequence";
  AnimationMetadataType2[AnimationMetadataType2["Group"] = 3] = "Group";
  AnimationMetadataType2[AnimationMetadataType2["Animate"] = 4] = "Animate";
  AnimationMetadataType2[AnimationMetadataType2["Keyframes"] = 5] = "Keyframes";
  AnimationMetadataType2[AnimationMetadataType2["Style"] = 6] = "Style";
  AnimationMetadataType2[AnimationMetadataType2["Trigger"] = 7] = "Trigger";
  AnimationMetadataType2[AnimationMetadataType2["Reference"] = 8] = "Reference";
  AnimationMetadataType2[AnimationMetadataType2["AnimateChild"] = 9] = "AnimateChild";
  AnimationMetadataType2[AnimationMetadataType2["AnimateRef"] = 10] = "AnimateRef";
  AnimationMetadataType2[AnimationMetadataType2["Query"] = 11] = "Query";
  AnimationMetadataType2[AnimationMetadataType2["Stagger"] = 12] = "Stagger";
})(AnimationMetadataType || (AnimationMetadataType = {}));
var AUTO_STYLE = "*";
function trigger(name, definitions) {
  return { type: AnimationMetadataType.Trigger, name, definitions, options: {} };
}
function animate(timings, styles = null) {
  return { type: AnimationMetadataType.Animate, styles, timings };
}
function sequence(steps, options = null) {
  return { type: AnimationMetadataType.Sequence, steps, options };
}
function style(tokens) {
  return { type: AnimationMetadataType.Style, styles: tokens, offset: null };
}
function state(name, styles, options) {
  return { type: AnimationMetadataType.State, name, styles, options };
}
function transition(stateChangeExpr, steps, options = null) {
  return { type: AnimationMetadataType.Transition, expr: stateChangeExpr, animation: steps, options };
}
var NoopAnimationPlayer = class {
  _onDoneFns = [];
  _onStartFns = [];
  _onDestroyFns = [];
  _originalOnDoneFns = [];
  _originalOnStartFns = [];
  _started = false;
  _destroyed = false;
  _finished = false;
  _position = 0;
  parentPlayer = null;
  totalTime;
  constructor(duration = 0, delay2 = 0) {
    this.totalTime = duration + delay2;
  }
  _onFinish() {
    if (!this._finished) {
      this._finished = true;
      this._onDoneFns.forEach((fn) => fn());
      this._onDoneFns = [];
    }
  }
  onStart(fn) {
    this._originalOnStartFns.push(fn);
    this._onStartFns.push(fn);
  }
  onDone(fn) {
    this._originalOnDoneFns.push(fn);
    this._onDoneFns.push(fn);
  }
  onDestroy(fn) {
    this._onDestroyFns.push(fn);
  }
  hasStarted() {
    return this._started;
  }
  init() {
  }
  play() {
    if (!this.hasStarted()) {
      this._onStart();
      this.triggerMicrotask();
    }
    this._started = true;
  }
  /** @internal */
  triggerMicrotask() {
    queueMicrotask(() => this._onFinish());
  }
  _onStart() {
    this._onStartFns.forEach((fn) => fn());
    this._onStartFns = [];
  }
  pause() {
  }
  restart() {
  }
  finish() {
    this._onFinish();
  }
  destroy() {
    if (!this._destroyed) {
      this._destroyed = true;
      if (!this.hasStarted()) {
        this._onStart();
      }
      this.finish();
      this._onDestroyFns.forEach((fn) => fn());
      this._onDestroyFns = [];
    }
  }
  reset() {
    this._started = false;
    this._finished = false;
    this._onStartFns = this._originalOnStartFns;
    this._onDoneFns = this._originalOnDoneFns;
  }
  setPosition(position) {
    this._position = this.totalTime ? position * this.totalTime : 1;
  }
  getPosition() {
    return this.totalTime ? this._position / this.totalTime : 1;
  }
  /** @internal */
  triggerCallback(phaseName) {
    const methods = phaseName == "start" ? this._onStartFns : this._onDoneFns;
    methods.forEach((fn) => fn());
    methods.length = 0;
  }
};
var AnimationGroupPlayer = class {
  _onDoneFns = [];
  _onStartFns = [];
  _finished = false;
  _started = false;
  _destroyed = false;
  _onDestroyFns = [];
  parentPlayer = null;
  totalTime = 0;
  players;
  constructor(_players) {
    this.players = _players;
    let doneCount = 0;
    let destroyCount = 0;
    let startCount = 0;
    const total = this.players.length;
    if (total == 0) {
      queueMicrotask(() => this._onFinish());
    } else {
      this.players.forEach((player) => {
        player.onDone(() => {
          if (++doneCount == total) {
            this._onFinish();
          }
        });
        player.onDestroy(() => {
          if (++destroyCount == total) {
            this._onDestroy();
          }
        });
        player.onStart(() => {
          if (++startCount == total) {
            this._onStart();
          }
        });
      });
    }
    this.totalTime = this.players.reduce((time, player) => Math.max(time, player.totalTime), 0);
  }
  _onFinish() {
    if (!this._finished) {
      this._finished = true;
      this._onDoneFns.forEach((fn) => fn());
      this._onDoneFns = [];
    }
  }
  init() {
    this.players.forEach((player) => player.init());
  }
  onStart(fn) {
    this._onStartFns.push(fn);
  }
  _onStart() {
    if (!this.hasStarted()) {
      this._started = true;
      this._onStartFns.forEach((fn) => fn());
      this._onStartFns = [];
    }
  }
  onDone(fn) {
    this._onDoneFns.push(fn);
  }
  onDestroy(fn) {
    this._onDestroyFns.push(fn);
  }
  hasStarted() {
    return this._started;
  }
  play() {
    if (!this.parentPlayer) {
      this.init();
    }
    this._onStart();
    this.players.forEach((player) => player.play());
  }
  pause() {
    this.players.forEach((player) => player.pause());
  }
  restart() {
    this.players.forEach((player) => player.restart());
  }
  finish() {
    this._onFinish();
    this.players.forEach((player) => player.finish());
  }
  destroy() {
    this._onDestroy();
  }
  _onDestroy() {
    if (!this._destroyed) {
      this._destroyed = true;
      this._onFinish();
      this.players.forEach((player) => player.destroy());
      this._onDestroyFns.forEach((fn) => fn());
      this._onDestroyFns = [];
    }
  }
  reset() {
    this.players.forEach((player) => player.reset());
    this._destroyed = false;
    this._finished = false;
    this._started = false;
  }
  setPosition(p) {
    const timeAtPosition = p * this.totalTime;
    this.players.forEach((player) => {
      const position = player.totalTime ? Math.min(1, timeAtPosition / player.totalTime) : 1;
      player.setPosition(position);
    });
  }
  getPosition() {
    const longestPlayer = this.players.reduce((longestSoFar, player) => {
      const newPlayerIsLongest = longestSoFar === null || player.totalTime > longestSoFar.totalTime;
      return newPlayerIsLongest ? player : longestSoFar;
    }, null);
    return longestPlayer != null ? longestPlayer.getPosition() : 0;
  }
  beforeDestroy() {
    this.players.forEach((player) => {
      if (player.beforeDestroy) {
        player.beforeDestroy();
      }
    });
  }
  /** @internal */
  triggerCallback(phaseName) {
    const methods = phaseName == "start" ? this._onStartFns : this._onDoneFns;
    methods.forEach((fn) => fn());
    methods.length = 0;
  }
};
var \u0275PRE_STYLE = "!";

// node_modules/@angular/animations/fesm2022/animations.mjs
var AnimationBuilder = class _AnimationBuilder {
  static \u0275fac = function AnimationBuilder_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AnimationBuilder)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _AnimationBuilder,
    factory: () => (() => inject(BrowserAnimationBuilder))(),
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AnimationBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => inject(BrowserAnimationBuilder)
    }]
  }], null, null);
})();
var AnimationFactory = class {
};
var BrowserAnimationBuilder = class _BrowserAnimationBuilder extends AnimationBuilder {
  animationModuleType = inject(ANIMATION_MODULE_TYPE, {
    optional: true
  });
  _nextAnimationId = 0;
  _renderer;
  constructor(rootRenderer, doc) {
    super();
    const typeData = {
      id: "0",
      encapsulation: ViewEncapsulation.None,
      styles: [],
      data: {
        animation: []
      }
    };
    this._renderer = rootRenderer.createRenderer(doc.body, typeData);
    if (this.animationModuleType === null && !isAnimationRenderer(this._renderer)) {
      throw new RuntimeError(3600, (typeof ngDevMode === "undefined" || ngDevMode) && "Angular detected that the `AnimationBuilder` was injected, but animation support was not enabled. Please make sure that you enable animations in your application by calling `provideAnimations()` or `provideAnimationsAsync()` function.");
    }
  }
  build(animation2) {
    const id = this._nextAnimationId;
    this._nextAnimationId++;
    const entry = Array.isArray(animation2) ? sequence(animation2) : animation2;
    issueAnimationCommand(this._renderer, null, id, "register", [entry]);
    return new BrowserAnimationFactory(id, this._renderer);
  }
  static \u0275fac = function BrowserAnimationBuilder_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BrowserAnimationBuilder)(\u0275\u0275inject(RendererFactory2), \u0275\u0275inject(DOCUMENT));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _BrowserAnimationBuilder,
    factory: _BrowserAnimationBuilder.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BrowserAnimationBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: RendererFactory2
  }, {
    type: Document,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();
var BrowserAnimationFactory = class extends AnimationFactory {
  _id;
  _renderer;
  constructor(_id, _renderer) {
    super();
    this._id = _id;
    this._renderer = _renderer;
  }
  create(element, options) {
    return new RendererAnimationPlayer(this._id, element, options || {}, this._renderer);
  }
};
var RendererAnimationPlayer = class {
  id;
  element;
  _renderer;
  parentPlayer = null;
  _started = false;
  constructor(id, element, options, _renderer) {
    this.id = id;
    this.element = element;
    this._renderer = _renderer;
    this._command("create", options);
  }
  _listen(eventName, callback) {
    return this._renderer.listen(this.element, `@@${this.id}:${eventName}`, callback);
  }
  _command(command, ...args) {
    issueAnimationCommand(this._renderer, this.element, this.id, command, args);
  }
  onDone(fn) {
    this._listen("done", fn);
  }
  onStart(fn) {
    this._listen("start", fn);
  }
  onDestroy(fn) {
    this._listen("destroy", fn);
  }
  init() {
    this._command("init");
  }
  hasStarted() {
    return this._started;
  }
  play() {
    this._command("play");
    this._started = true;
  }
  pause() {
    this._command("pause");
  }
  restart() {
    this._command("restart");
  }
  finish() {
    this._command("finish");
  }
  destroy() {
    this._command("destroy");
  }
  reset() {
    this._command("reset");
    this._started = false;
  }
  setPosition(p) {
    this._command("setPosition", p);
  }
  getPosition() {
    return unwrapAnimationRenderer(this._renderer)?.engine?.players[this.id]?.getPosition() ?? 0;
  }
  totalTime = 0;
};
function issueAnimationCommand(renderer, element, id, command, args) {
  renderer.setProperty(element, `@@${id}:${command}`, args);
}
function unwrapAnimationRenderer(renderer) {
  const type = renderer.\u0275type;
  if (type === 0) {
    return renderer;
  } else if (type === 1) {
    return renderer.animationRenderer;
  }
  return null;
}
function isAnimationRenderer(renderer) {
  const type = renderer.\u0275type;
  return type === 0 || type === 1;
}

// node_modules/@nebular/theme/fesm2022/nebular-theme.mjs
function NbOverlayContainerComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 2);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r0.content);
  }
}
function NbOverlayContainerComponent_ng_template_1_Template(rf, ctx) {
}
var _c0 = ["*"];
var _c1 = [[["nb-card-header"]], [["nb-card-body"]], "*", [["nb-card-footer"]]];
var _c2 = ["nb-card-header", "nb-card-body", "*", "nb-card-footer"];
var _c3 = [[["nb-card-front"]], [["nb-card-back"]]];
var _c4 = ["nb-card-front", "nb-card-back"];
function NbRevealCardComponent_a_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 2);
    \u0275\u0275listener("click", function NbRevealCardComponent_a_3_Template_a_click_0_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.toggle());
    });
    \u0275\u0275element(1, "nb-icon", 3);
    \u0275\u0275elementEnd();
  }
}
function NbFlipCardComponent_a_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 4);
    \u0275\u0275listener("click", function NbFlipCardComponent_a_3_Template_a_click_0_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.toggle());
    });
    \u0275\u0275element(1, "nb-icon", 5);
    \u0275\u0275elementEnd();
  }
}
function NbFlipCardComponent_a_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 4);
    \u0275\u0275listener("click", function NbFlipCardComponent_a_6_Template_a_click_0_listener() {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.toggle());
    });
    \u0275\u0275element(1, "nb-icon", 5);
    \u0275\u0275elementEnd();
  }
}
var _c5 = [[["nb-card"]]];
var _c6 = ["nb-card"];
var _c7 = ["nbButton", ""];
function NbCalendarPickerRowComponent_ng_template_0_Template(rf, ctx) {
}
function NbCalendarPickerComponent_nb_calendar_picker_row_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nb-calendar-picker-row", 1);
    \u0275\u0275listener("select", function NbCalendarPickerComponent_nb_calendar_picker_row_0_Template_nb_calendar_picker_row_select_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.select.emit($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const row_r3 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("row", row_r3)("visibleDate", ctx_r1.visibleDate)("selectedValue", ctx_r1.selectedValue)("component", ctx_r1.cellComponent)("min", ctx_r1.min)("max", ctx_r1.max)("filter", ctx_r1.filter)("size", ctx_r1.size);
  }
}
function NbCalendarDaysNamesComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 1);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const day_r1 = ctx.$implicit;
    \u0275\u0275classProp("holiday", day_r1.isHoliday);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(day_r1.name);
  }
}
function NbCalendarWeekNumberComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 3);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const weekNumber_r1 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(weekNumber_r1);
  }
}
var _c8 = "[_nghost-%COMP%]{display:flex;flex-direction:column}\n\n\n\n\n\n";
function NbCalendarDayPickerComponent_nb_calendar_week_numbers_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nb-calendar-week-numbers", 4);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("weeks", ctx_r0.weeks)("size", ctx_r0.size)("weekNumberSymbol", ctx_r0.weekNumberSymbol);
  }
}
function NbBaseCalendarComponent_nb_card_header_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nb-card-header", 5)(1, "nb-calendar-view-mode", 6);
    \u0275\u0275listener("changeMode", function NbBaseCalendarComponent_nb_card_header_1_Template_nb_calendar_view_mode_changeMode_1_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onChangeViewMode());
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "nb-calendar-pageable-navigation", 7);
    \u0275\u0275listener("prev", function NbBaseCalendarComponent_nb_card_header_1_Template_nb_calendar_pageable_navigation_prev_2_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.navigatePrev());
    })("next", function NbBaseCalendarComponent_nb_card_header_1_Template_nb_calendar_pageable_navigation_next_2_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.navigateNext());
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("date", ctx_r1.visibleDate)("viewMode", ctx_r1.activeViewMode);
  }
}
function NbBaseCalendarComponent_nb_calendar_day_picker_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nb-calendar-day-picker", 8);
    \u0275\u0275listener("dateChange", function NbBaseCalendarComponent_nb_calendar_day_picker_3_Template_nb_calendar_day_picker_dateChange_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.dateChange.emit($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("boundingMonths", ctx_r1.boundingMonth)("cellComponent", ctx_r1.dayCellComponent)("min", ctx_r1.min)("max", ctx_r1.max)("filter", ctx_r1.filter)("visibleDate", ctx_r1.visibleDate)("size", ctx_r1.size)("date", ctx_r1.date)("showWeekNumber", ctx_r1.showWeekNumber)("firstDayOfWeek", ctx_r1.firstDayOfWeek)("weekNumberSymbol", ctx_r1.weekNumberSymbol);
  }
}
function NbBaseCalendarComponent_nb_calendar_year_picker_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nb-calendar-year-picker", 9);
    \u0275\u0275listener("yearChange", function NbBaseCalendarComponent_nb_calendar_year_picker_4_Template_nb_calendar_year_picker_yearChange_0_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r1 = \u0275\u0275nextContext();
      ctx_r1.setVisibleDate($event);
      return \u0275\u0275resetView(ctx_r1.setViewMode(ctx_r1.ViewMode.MONTH));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("cellComponent", ctx_r1.yearCellComponent)("date", ctx_r1.date)("min", ctx_r1.min)("max", ctx_r1.max)("filter", ctx_r1.filter)("size", ctx_r1.size)("year", ctx_r1.visibleDate);
  }
}
function NbBaseCalendarComponent_nb_calendar_month_picker_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nb-calendar-month-picker", 10);
    \u0275\u0275listener("monthChange", function NbBaseCalendarComponent_nb_calendar_month_picker_5_Template_nb_calendar_month_picker_monthChange_0_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r1 = \u0275\u0275nextContext();
      ctx_r1.setVisibleDate($event);
      return \u0275\u0275resetView(ctx_r1.setViewMode(ctx_r1.ViewMode.DATE));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("cellComponent", ctx_r1.monthCellComponent)("min", ctx_r1.min)("max", ctx_r1.max)("filter", ctx_r1.filter)("size", ctx_r1.size)("month", ctx_r1.visibleDate)("date", ctx_r1.date);
  }
}
function NbCalendarActionsComponent_button_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 2);
    \u0275\u0275listener("click", function NbCalendarActionsComponent_button_0_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.setCurrentTime.emit());
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r1.currentTimeText);
  }
}
var _c9 = [[["nb-list-item"]]];
var _c10 = ["nb-list-item"];
var _c11 = ["valueContainer"];
function NbTimePickerComponent_nb_card_0_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "div", 8);
    \u0275\u0275text(2, "Time");
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_3_div_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 8);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(3);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r0.secondsText);
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_3_div_5_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(4);
    \u0275\u0275textInterpolate(ctx_r0.ampmText);
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_3_div_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 8);
    \u0275\u0275template(1, NbTimePickerComponent_nb_card_0_ng_template_3_div_5_ng_template_1_Template, 1, 1, "ng-template", 10);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(3);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.showAmPmLabel);
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 8);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "div", 8);
    \u0275\u0275text(3);
    \u0275\u0275elementEnd();
    \u0275\u0275template(4, NbTimePickerComponent_nb_card_0_ng_template_3_div_4_Template, 2, 1, "div", 9)(5, NbTimePickerComponent_nb_card_0_ng_template_3_div_5_Template, 2, 1, "div", 9);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r0.hoursText);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r0.minutesText);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.withSeconds);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.twelveHoursFormat);
  }
}
function NbTimePickerComponent_nb_card_0_ng_container_6_nb_list_item_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nb-list-item", 13)(1, "nb-timepicker-cell", 14);
    \u0275\u0275listener("select", function NbTimePickerComponent_nb_card_0_ng_container_6_nb_list_item_2_Template_nb_timepicker_cell_select_1_listener() {
      const item_r3 = \u0275\u0275restoreView(_r2).$implicit;
      const ctx_r0 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r0.selectFullTime(item_r3));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const item_r3 = ctx.$implicit;
    const ctx_r0 = \u0275\u0275nextContext(3);
    \u0275\u0275classProp("selected", ctx_r0.isSelectedFullTimeValue(item_r3));
    \u0275\u0275advance();
    \u0275\u0275property("value", ctx_r0.getFullTimeString(item_r3))("selected", ctx_r0.isSelectedFullTimeValue(item_r3));
  }
}
function NbTimePickerComponent_nb_card_0_ng_container_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "nb-list", 11);
    \u0275\u0275template(2, NbTimePickerComponent_nb_card_0_ng_container_6_nb_list_item_2_Template, 2, 4, "nb-list-item", 12);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", ctx_r0.fullTimeOptions)("ngForTrackBy", ctx_r0.trackBySingleColumnValue.bind(ctx_r0));
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_item_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nb-list-item", 13)(1, "nb-timepicker-cell", 14);
    \u0275\u0275listener("select", function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_item_1_Template_nb_timepicker_cell_select_1_listener() {
      const item_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r0 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r0.setHour(item_r5.value));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const item_r5 = ctx.$implicit;
    const ctx_r0 = \u0275\u0275nextContext(3);
    \u0275\u0275classProp("selected", ctx_r0.isSelectedHour(item_r5.value));
    \u0275\u0275advance();
    \u0275\u0275property("value", item_r5.text)("selected", ctx_r0.isSelectedHour(item_r5.value));
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_item_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nb-list-item", 13)(1, "nb-timepicker-cell", 14);
    \u0275\u0275listener("select", function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_item_3_Template_nb_timepicker_cell_select_1_listener() {
      const item_r7 = \u0275\u0275restoreView(_r6).$implicit;
      const ctx_r0 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r0.setMinute(item_r7.value));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const item_r7 = ctx.$implicit;
    const ctx_r0 = \u0275\u0275nextContext(3);
    \u0275\u0275classProp("selected", ctx_r0.isSelectedMinute(item_r7.value));
    \u0275\u0275advance();
    \u0275\u0275property("value", item_r7.text)("selected", ctx_r0.isSelectedMinute(item_r7.value));
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_4_nb_list_item_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nb-list-item", 13)(1, "nb-timepicker-cell", 14);
    \u0275\u0275listener("select", function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_4_nb_list_item_1_Template_nb_timepicker_cell_select_1_listener() {
      const item_r9 = \u0275\u0275restoreView(_r8).$implicit;
      const ctx_r0 = \u0275\u0275nextContext(4);
      return \u0275\u0275resetView(ctx_r0.setSecond(item_r9.value));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const item_r9 = ctx.$implicit;
    const ctx_r0 = \u0275\u0275nextContext(4);
    \u0275\u0275classProp("selected", ctx_r0.isSelectedSecond(item_r9.value));
    \u0275\u0275advance();
    \u0275\u0275property("value", item_r9.text)("selected", ctx_r0.isSelectedSecond(item_r9.value));
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nb-list", 11);
    \u0275\u0275template(1, NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_4_nb_list_item_1_Template, 2, 4, "nb-list-item", 12);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(3);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r0.secondsColumnOptions)("ngForTrackBy", ctx_r0.trackByTimeValues);
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_5_nb_list_item_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nb-list-item", 17)(1, "nb-timepicker-cell", 14);
    \u0275\u0275listener("select", function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_5_nb_list_item_1_Template_nb_timepicker_cell_select_1_listener() {
      const dayPeriod_r11 = \u0275\u0275restoreView(_r10).$implicit;
      const ctx_r0 = \u0275\u0275nextContext(4);
      return \u0275\u0275resetView(ctx_r0.changeDayPeriod(dayPeriod_r11));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const dayPeriod_r11 = ctx.$implicit;
    const ctx_r0 = \u0275\u0275nextContext(4);
    \u0275\u0275classProp("selected", ctx_r0.isSelectedDayPeriod(dayPeriod_r11));
    \u0275\u0275advance();
    \u0275\u0275property("value", dayPeriod_r11)("selected", ctx_r0.isSelectedDayPeriod(dayPeriod_r11));
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nb-list", 11);
    \u0275\u0275template(1, NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_5_nb_list_item_1_Template, 2, 4, "nb-list-item", 16);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(3);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r0.dayPeriodColumnOptions)("ngForTrackBy", ctx_r0.trackByDayPeriod);
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nb-list", 11);
    \u0275\u0275template(1, NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_item_1_Template, 2, 4, "nb-list-item", 12);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "nb-list", 11);
    \u0275\u0275template(3, NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_item_3_Template, 2, 4, "nb-list-item", 12);
    \u0275\u0275elementEnd();
    \u0275\u0275template(4, NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_4_Template, 2, 2, "nb-list", 15)(5, NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_5_Template, 2, 2, "nb-list", 15);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r0.hoursColumnOptions)("ngForTrackBy", ctx_r0.trackByTimeValues);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", ctx_r0.minutesColumnOptions)("ngForTrackBy", ctx_r0.trackByTimeValues);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.showSeconds());
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.twelveHoursFormat);
  }
}
function NbTimePickerComponent_nb_card_0_nb_card_footer_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nb-card-footer", 18)(1, "nb-calendar-actions", 19);
    \u0275\u0275listener("setCurrentTime", function NbTimePickerComponent_nb_card_0_nb_card_footer_9_Template_nb_calendar_actions_setCurrentTime_1_listener() {
      \u0275\u0275restoreView(_r12);
      const ctx_r0 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r0.setCurrentTime());
    })("saveValue", function NbTimePickerComponent_nb_card_0_nb_card_footer_9_Template_nb_calendar_actions_saveValue_1_listener() {
      \u0275\u0275restoreView(_r12);
      const ctx_r0 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r0.saveValue());
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("applyButtonText", ctx_r0.applyButtonText)("currentTimeButtonText", ctx_r0.currentTimeButtonText);
  }
}
function NbTimePickerComponent_nb_card_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nb-card", 3)(1, "nb-card-header", 4);
    \u0275\u0275template(2, NbTimePickerComponent_nb_card_0_ng_container_2_Template, 3, 0, "ng-container", 5)(3, NbTimePickerComponent_nb_card_0_ng_template_3_Template, 6, 4, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "div", 6);
    \u0275\u0275template(6, NbTimePickerComponent_nb_card_0_ng_container_6_Template, 3, 2, "ng-container", 5)(7, NbTimePickerComponent_nb_card_0_ng_template_7_Template, 6, 6, "ng-template", null, 1, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementEnd();
    \u0275\u0275template(9, NbTimePickerComponent_nb_card_0_nb_card_footer_9_Template, 2, 2, "nb-card-footer", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const fullTimeHeadersBlock_r13 = \u0275\u0275reference(4);
    const fullTimeColumnBlock_r14 = \u0275\u0275reference(8);
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275classProp("supports-scrollbar-theming", !ctx_r0.isFirefox());
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx_r0.singleColumn)("ngIfElse", fullTimeHeadersBlock_r13);
    \u0275\u0275advance(4);
    \u0275\u0275property("ngIf", ctx_r0.singleColumn)("ngIfElse", fullTimeColumnBlock_r14);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngIf", ctx_r0.showFooter);
  }
}
var _c12 = ["layoutTopDynamicArea"];
var _c13 = ["scrollableContainer"];
var _c14 = ["layoutContainer"];
var _c15 = [[["nb-layout-header", 3, "subheader", ""]], [["nb-sidebar"]], [["nb-layout-header", "subheader", ""]], [["nb-layout-column"]], [["nb-layout-footer"]]];
var _c16 = ["nb-layout-header:not([subheader])", "nb-sidebar", "nb-layout-header[subheader]", "nb-layout-column", "nb-layout-footer"];
var _c17 = ["nbMenuItem", ""];
function NbMenuItemComponent_span_0_nb_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nb-icon", 7);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("config", ctx_r0.menuItem.icon);
  }
}
function NbMenuItemComponent_span_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275template(1, NbMenuItemComponent_span_0_nb_icon_1_Template, 1, 1, "nb-icon", 6);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.menuItem.icon);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r0.menuItem.title, "\n");
  }
}
function NbMenuItemComponent_a_1_nb_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nb-icon", 7);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("config", ctx_r0.menuItem.icon);
  }
}
function NbMenuItemComponent_a_1_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0, 11);
  }
  if (rf & 2) {
    \u0275\u0275nextContext(2);
    const badgeTemplate_r3 = \u0275\u0275reference(7);
    \u0275\u0275property("ngTemplateOutlet", badgeTemplate_r3);
  }
}
function NbMenuItemComponent_a_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 8);
    \u0275\u0275listener("mouseenter", function NbMenuItemComponent_a_1_Template_a_mouseenter_0_listener() {
      \u0275\u0275restoreView(_r2);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.onHoverItem(ctx_r0.menuItem));
    })("click", function NbMenuItemComponent_a_1_Template_a_click_0_listener() {
      \u0275\u0275restoreView(_r2);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.onItemClick(ctx_r0.menuItem));
    });
    \u0275\u0275template(1, NbMenuItemComponent_a_1_nb_icon_1_Template, 1, 1, "nb-icon", 6);
    \u0275\u0275elementStart(2, "span", 9);
    \u0275\u0275text(3);
    \u0275\u0275elementEnd();
    \u0275\u0275template(4, NbMenuItemComponent_a_1_ng_container_4_Template, 1, 1, "ng-container", 10);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275classProp("active", ctx_r0.menuItem.selected);
    \u0275\u0275property("routerLink", ctx_r0.menuItem.link)("queryParams", ctx_r0.menuItem.queryParams)("fragment", ctx_r0.menuItem.fragment)("queryParamsHandling", ctx_r0.menuItem.queryParamsHandling)("preserveFragment", ctx_r0.menuItem.preserveFragment)("skipLocationChange", ctx_r0.menuItem.skipLocationChange);
    \u0275\u0275attribute("target", ctx_r0.menuItem.target)("title", ctx_r0.menuItem.title)("role", ctx_r0.menuItem.ariaRole);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.menuItem.icon);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r0.menuItem.title);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.badge);
  }
}
function NbMenuItemComponent_a_2_nb_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nb-icon", 7);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("config", ctx_r0.menuItem.icon);
  }
}
function NbMenuItemComponent_a_2_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0, 11);
  }
  if (rf & 2) {
    \u0275\u0275nextContext(2);
    const badgeTemplate_r3 = \u0275\u0275reference(7);
    \u0275\u0275property("ngTemplateOutlet", badgeTemplate_r3);
  }
}
function NbMenuItemComponent_a_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 12);
    \u0275\u0275listener("mouseenter", function NbMenuItemComponent_a_2_Template_a_mouseenter_0_listener() {
      \u0275\u0275restoreView(_r4);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.onHoverItem(ctx_r0.menuItem));
    })("click", function NbMenuItemComponent_a_2_Template_a_click_0_listener() {
      \u0275\u0275restoreView(_r4);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.onSelectItem(ctx_r0.menuItem));
    });
    \u0275\u0275template(1, NbMenuItemComponent_a_2_nb_icon_1_Template, 1, 1, "nb-icon", 6);
    \u0275\u0275elementStart(2, "span", 9);
    \u0275\u0275text(3);
    \u0275\u0275elementEnd();
    \u0275\u0275template(4, NbMenuItemComponent_a_2_ng_container_4_Template, 1, 1, "ng-container", 10);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275classProp("active", ctx_r0.menuItem.selected);
    \u0275\u0275attribute("href", ctx_r0.menuItem.url, \u0275\u0275sanitizeUrl)("target", ctx_r0.menuItem.target)("title", ctx_r0.menuItem.title)("role", ctx_r0.menuItem.ariaRole);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.menuItem.icon);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r0.menuItem.title);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.badge);
  }
}
function NbMenuItemComponent_a_3_nb_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nb-icon", 7);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("config", ctx_r0.menuItem.icon);
  }
}
function NbMenuItemComponent_a_3_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0, 11);
  }
  if (rf & 2) {
    \u0275\u0275nextContext(2);
    const badgeTemplate_r3 = \u0275\u0275reference(7);
    \u0275\u0275property("ngTemplateOutlet", badgeTemplate_r3);
  }
}
function NbMenuItemComponent_a_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 12);
    \u0275\u0275listener("mouseenter", function NbMenuItemComponent_a_3_Template_a_mouseenter_0_listener() {
      \u0275\u0275restoreView(_r5);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.onHoverItem(ctx_r0.menuItem));
    })("click", function NbMenuItemComponent_a_3_Template_a_click_0_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r0 = \u0275\u0275nextContext();
      $event.preventDefault();
      return \u0275\u0275resetView(ctx_r0.onItemClick(ctx_r0.menuItem));
    });
    \u0275\u0275template(1, NbMenuItemComponent_a_3_nb_icon_1_Template, 1, 1, "nb-icon", 6);
    \u0275\u0275elementStart(2, "span", 9);
    \u0275\u0275text(3);
    \u0275\u0275elementEnd();
    \u0275\u0275template(4, NbMenuItemComponent_a_3_ng_container_4_Template, 1, 1, "ng-container", 10);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275classProp("active", ctx_r0.menuItem.selected);
    \u0275\u0275attribute("target", ctx_r0.menuItem.target)("title", ctx_r0.menuItem.title)("role", ctx_r0.menuItem.ariaRole);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.menuItem.icon);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r0.menuItem.title);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.badge);
  }
}
function NbMenuItemComponent_a_4_nb_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nb-icon", 7);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("config", ctx_r0.menuItem.icon);
  }
}
function NbMenuItemComponent_a_4_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0, 11);
  }
  if (rf & 2) {
    \u0275\u0275nextContext(2);
    const badgeTemplate_r3 = \u0275\u0275reference(7);
    \u0275\u0275property("ngTemplateOutlet", badgeTemplate_r3);
  }
}
function NbMenuItemComponent_a_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 13);
    \u0275\u0275listener("click", function NbMenuItemComponent_a_4_Template_a_click_0_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r0 = \u0275\u0275nextContext();
      $event.preventDefault();
      return \u0275\u0275resetView(ctx_r0.onToggleSubMenu(ctx_r0.menuItem));
    })("mouseenter", function NbMenuItemComponent_a_4_Template_a_mouseenter_0_listener() {
      \u0275\u0275restoreView(_r6);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.onHoverItem(ctx_r0.menuItem));
    });
    \u0275\u0275template(1, NbMenuItemComponent_a_4_nb_icon_1_Template, 1, 1, "nb-icon", 6);
    \u0275\u0275elementStart(2, "span", 9);
    \u0275\u0275text(3);
    \u0275\u0275elementEnd();
    \u0275\u0275template(4, NbMenuItemComponent_a_4_ng_container_4_Template, 1, 1, "ng-container", 10);
    \u0275\u0275element(5, "nb-icon", 14);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275classProp("active", ctx_r0.menuItem.selected);
    \u0275\u0275attribute("target", ctx_r0.menuItem.target)("title", ctx_r0.menuItem.title)("aria-expanded", ctx_r0.menuItem.expanded ?? false)("role", ctx_r0.menuItem.ariaRole);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.menuItem.icon);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r0.menuItem.title);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.badge);
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx_r0.getExpandStateIcon());
  }
}
function NbMenuItemComponent_ul_5_ng_container_1_li_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li", 18);
    \u0275\u0275listener("hoverItem", function NbMenuItemComponent_ul_5_ng_container_1_li_1_Template_li_hoverItem_0_listener($event) {
      \u0275\u0275restoreView(_r7);
      const ctx_r0 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r0.onHoverItem($event));
    })("toggleSubMenu", function NbMenuItemComponent_ul_5_ng_container_1_li_1_Template_li_toggleSubMenu_0_listener($event) {
      \u0275\u0275restoreView(_r7);
      const ctx_r0 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r0.onToggleSubMenu($event));
    })("selectItem", function NbMenuItemComponent_ul_5_ng_container_1_li_1_Template_li_selectItem_0_listener($event) {
      \u0275\u0275restoreView(_r7);
      const ctx_r0 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r0.onSelectItem($event));
    })("itemClick", function NbMenuItemComponent_ul_5_ng_container_1_li_1_Template_li_itemClick_0_listener($event) {
      \u0275\u0275restoreView(_r7);
      const ctx_r0 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r0.onItemClick($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r8 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275classProp("menu-group", item_r8.group);
    \u0275\u0275property("menuItem", item_r8)("badge", item_r8.badge);
  }
}
function NbMenuItemComponent_ul_5_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NbMenuItemComponent_ul_5_ng_container_1_li_1_Template, 1, 4, "li", 17);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const item_r8 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !item_r8.hidden);
  }
}
function NbMenuItemComponent_ul_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "ul", 15);
    \u0275\u0275template(1, NbMenuItemComponent_ul_5_ng_container_1_Template, 2, 1, "ng-container", 16);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275classProp("collapsed", !(ctx_r0.menuItem.children && ctx_r0.menuItem.expanded))("expanded", ctx_r0.menuItem.expanded);
    \u0275\u0275property("@toggle", ctx_r0.toggleState);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r0.menuItem.children);
  }
}
function NbMenuItemComponent_ng_template_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nb-badge", 19);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("text", ctx_r0.badge.text)("dotMode", ctx_r0.badge.dotMode)("status", ctx_r0.badge.status);
  }
}
function NbMenuComponent_ng_container_1_li_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li", 3);
    \u0275\u0275listener("hoverItem", function NbMenuComponent_ng_container_1_li_1_Template_li_hoverItem_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onHoverItem($event));
    })("toggleSubMenu", function NbMenuComponent_ng_container_1_li_1_Template_li_toggleSubMenu_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onToggleSubMenu($event));
    })("selectItem", function NbMenuComponent_ng_container_1_li_1_Template_li_selectItem_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onSelectItem($event));
    })("itemClick", function NbMenuComponent_ng_container_1_li_1_Template_li_itemClick_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onItemClick($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r3 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275classProp("menu-group", item_r3.group);
    \u0275\u0275property("menuItem", item_r3)("badge", item_r3.badge);
  }
}
function NbMenuComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NbMenuComponent_ng_container_1_li_1_Template, 1, 4, "li", 2);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const item_r3 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !item_r3.hidden);
  }
}
function NbRouteTabsetComponent_ng_container_1_li_1_nb_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nb-icon", 8);
  }
  if (rf & 2) {
    const tab_r1 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275property("config", tab_r1.icon);
  }
}
function NbRouteTabsetComponent_ng_container_1_li_1_span_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 9);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const tab_r1 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(tab_r1.title);
  }
}
function NbRouteTabsetComponent_ng_container_1_li_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "li", 4)(1, "a", 5);
    \u0275\u0275template(2, NbRouteTabsetComponent_ng_container_1_li_1_nb_icon_2_Template, 1, 1, "nb-icon", 6)(3, NbRouteTabsetComponent_ng_container_1_li_1_span_3_Template, 2, 1, "span", 7);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const tab_r1 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275classProp("responsive", tab_r1.responsive);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", tab_r1.icon);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", tab_r1.title);
  }
}
function NbRouteTabsetComponent_ng_container_1_ng_template_2_nb_icon_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nb-icon", 8);
  }
  if (rf & 2) {
    const tab_r1 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275property("config", tab_r1.icon);
  }
}
function NbRouteTabsetComponent_ng_container_1_ng_template_2_span_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 9);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const tab_r1 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(tab_r1.title);
  }
}
function NbRouteTabsetComponent_ng_container_1_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li", 10);
    \u0275\u0275pipe(1, "nbMergeConfigs");
    \u0275\u0275elementStart(2, "a", 11);
    \u0275\u0275listener("click", function NbRouteTabsetComponent_ng_container_1_ng_template_2_Template_a_click_2_listener() {
      \u0275\u0275restoreView(_r2);
      const tab_r1 = \u0275\u0275nextContext().$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.selectTab(tab_r1));
    });
    \u0275\u0275template(3, NbRouteTabsetComponent_ng_container_1_ng_template_2_nb_icon_3_Template, 1, 1, "nb-icon", 6)(4, NbRouteTabsetComponent_ng_container_1_ng_template_2_span_4_Template, 2, 1, "span", 7);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const tab_r1 = \u0275\u0275nextContext().$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("routerLinkActiveOptions", \u0275\u0275pipeBind2(1, 13, ctx_r2.activeLinkOptions, tab_r1.activeLinkOptions));
    \u0275\u0275advance(2);
    \u0275\u0275classProp("responsive", tab_r1.responsive);
    \u0275\u0275property("routerLink", tab_r1.route)("queryParams", tab_r1.queryParams)("queryParamsHandling", tab_r1.queryParamsHandling)("fragment", tab_r1.fragment)("preserveFragment", tab_r1.preserveFragment)("skipLocationChange", tab_r1.skipLocationChange)("replaceUrl", tab_r1.replaceUrl)("state", tab_r1.state);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", tab_r1.icon);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", tab_r1.title);
  }
}
function NbRouteTabsetComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NbRouteTabsetComponent_ng_container_1_li_1_Template, 4, 4, "li", 3)(2, NbRouteTabsetComponent_ng_container_1_ng_template_2_Template, 5, 16, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const tab_r1 = ctx.$implicit;
    const enabled_r4 = \u0275\u0275reference(3);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", tab_r1.disabled)("ngIfElse", enabled_r4);
  }
}
var _c18 = [[["nb-sidebar-header"]], "*", [["nb-sidebar-footer"]]];
var _c19 = ["nb-sidebar-header", "*", "nb-sidebar-footer"];
function NbTabComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0, 2);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.tabContentDirective.templateRef);
  }
}
function NbTabComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275projection(0);
  }
}
var _c20 = [[["nb-tab"]]];
var _c21 = ["nb-tab"];
function NbTabsetComponent_li_1_nb_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nb-icon", 8);
  }
  if (rf & 2) {
    const tab_r2 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("config", tab_r2.tabIcon);
  }
}
function NbTabsetComponent_li_1_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0, 9);
  }
  if (rf & 2) {
    const tab_r2 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("ngTemplateOutlet", tab_r2.tabTitleDirective.templateRef);
  }
}
function NbTabsetComponent_li_1_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 10);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const tab_r2 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(tab_r2.tabTitle);
  }
}
function NbTabsetComponent_li_1_nb_badge_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nb-badge", 11);
  }
  if (rf & 2) {
    const tab_r2 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("text", tab_r2.badgeText)("dotMode", tab_r2.badgeDot)("status", tab_r2.badgeStatus)("position", tab_r2.badgePosition);
  }
}
function NbTabsetComponent_li_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li", 3);
    \u0275\u0275listener("click", function NbTabsetComponent_li_1_Template_li_click_0_listener() {
      const tab_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.selectTab(tab_r2));
    })("keyup.space", function NbTabsetComponent_li_1_Template_li_keyup_space_0_listener() {
      const tab_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.selectTab(tab_r2));
    })("keyup.enter", function NbTabsetComponent_li_1_Template_li_keyup_enter_0_listener() {
      const tab_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.selectTab(tab_r2));
    });
    \u0275\u0275elementStart(1, "a", 4);
    \u0275\u0275listener("click", function NbTabsetComponent_li_1_Template_a_click_1_listener($event) {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView($event.preventDefault());
    });
    \u0275\u0275template(2, NbTabsetComponent_li_1_nb_icon_2_Template, 1, 1, "nb-icon", 5)(3, NbTabsetComponent_li_1_ng_container_3_Template, 1, 1, "ng-container", 6)(4, NbTabsetComponent_li_1_ng_template_4_Template, 2, 1, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementEnd();
    \u0275\u0275template(6, NbTabsetComponent_li_1_nb_badge_6_Template, 1, 4, "nb-badge", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const tab_r2 = ctx.$implicit;
    const textTitleTemplate_r4 = \u0275\u0275reference(5);
    \u0275\u0275classProp("responsive", tab_r2.responsive)("active", tab_r2.active)("disabled", tab_r2.disabled);
    \u0275\u0275attribute("tabindex", tab_r2.disabled ? -1 : 0)("data-tab-id", tab_r2.tabId);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", tab_r2.tabIcon);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", tab_r2.tabTitleDirective)("ngIfElse", textTitleTemplate_r4);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngIf", tab_r2.badgeText || tab_r2.badgeDot);
  }
}
function NbUserComponent_div_1_nb_badge_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nb-badge", 8);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("text", ctx_r0.badgeText)("status", ctx_r0.badgeStatus)("position", ctx_r0.badgePosition);
  }
}
function NbUserComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 6);
    \u0275\u0275template(1, NbUserComponent_div_1_nb_badge_1_Template, 1, 3, "nb-badge", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275styleProp("background-image", ctx_r0.imageBackgroundStyle);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.badgeText);
  }
}
function NbUserComponent_div_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r0.getInitials(), " ");
  }
}
function NbUserComponent_div_2_nb_badge_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nb-badge", 8);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("text", ctx_r0.badgeText)("status", ctx_r0.badgeStatus)("position", ctx_r0.badgePosition);
  }
}
function NbUserComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 9);
    \u0275\u0275template(1, NbUserComponent_div_2_ng_container_1_Template, 2, 1, "ng-container", 10)(2, NbUserComponent_div_2_nb_badge_2_Template, 1, 3, "nb-badge", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275styleProp("background-color", ctx_r0.color);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.showInitials);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.badgeText);
  }
}
function NbUserComponent_div_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 11);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r0.name);
  }
}
function NbUserComponent_div_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 12);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r0.title);
  }
}
function NbActionComponent_ng_container_0_a_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "a", 6);
    \u0275\u0275element(1, "nb-icon", 7);
    \u0275\u0275elementContainer(2, 8);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    const badgeTemplate_r2 = \u0275\u0275reference(4);
    \u0275\u0275property("routerLink", ctx_r0.link)("title", ctx_r0.title);
    \u0275\u0275advance();
    \u0275\u0275property("config", ctx_r0.icon);
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", badgeTemplate_r2);
  }
}
function NbActionComponent_ng_container_0_a_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "a", 9);
    \u0275\u0275element(1, "nb-icon", 7);
    \u0275\u0275elementContainer(2, 8);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    const badgeTemplate_r2 = \u0275\u0275reference(4);
    \u0275\u0275property("href", ctx_r0.href, \u0275\u0275sanitizeUrl)("title", ctx_r0.title);
    \u0275\u0275advance();
    \u0275\u0275property("config", ctx_r0.icon);
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", badgeTemplate_r2);
  }
}
function NbActionComponent_ng_container_0_a_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 10);
    \u0275\u0275listener("click", function NbActionComponent_ng_container_0_a_3_Template_a_click_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      return \u0275\u0275resetView($event.preventDefault());
    });
    \u0275\u0275element(1, "nb-icon", 7);
    \u0275\u0275elementContainer(2, 8);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    const badgeTemplate_r2 = \u0275\u0275reference(4);
    \u0275\u0275property("title", ctx_r0.title);
    \u0275\u0275advance();
    \u0275\u0275property("config", ctx_r0.icon);
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", badgeTemplate_r2);
  }
}
function NbActionComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NbActionComponent_ng_container_0_a_1_Template, 3, 4, "a", 3)(2, NbActionComponent_ng_container_0_a_2_Template, 3, 4, "a", 4)(3, NbActionComponent_ng_container_0_a_3_Template, 3, 3, "a", 5);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.link);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.href && !ctx_r0.link);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r0.href && !ctx_r0.link);
  }
}
function NbActionComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275projection(0);
    \u0275\u0275elementContainer(1, 8);
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const badgeTemplate_r2 = \u0275\u0275reference(4);
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", badgeTemplate_r2);
  }
}
function NbActionComponent_ng_template_3_nb_badge_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nb-badge", 12);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("text", ctx_r0.badgeText)("dotMode", ctx_r0.badgeDot)("status", ctx_r0.badgeStatus)("position", ctx_r0.badgePosition);
  }
}
function NbActionComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, NbActionComponent_ng_template_3_nb_badge_0_Template, 1, 4, "nb-badge", 11);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("ngIf", ctx_r0.badgeText || ctx_r0.badgeDot);
  }
}
var _c22 = [[["nb-action"]]];
var _c23 = ["nb-action"];
var _c24 = ["searchInput"];
var _c25 = ["searchButton"];
function NbSearchComponent_nb_search_field_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nb-search-field", 4);
    \u0275\u0275listener("search", function NbSearchComponent_nb_search_field_3_Template_nb_search_field_search_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.search($event));
    })("searchInput", function NbSearchComponent_nb_search_field_3_Template_nb_search_field_searchInput_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.emitInput($event));
    })("close", function NbSearchComponent_nb_search_field_3_Template_nb_search_field_close_0_listener() {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.emitDeactivate());
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("show", ctx_r2.showSearchField)("type", ctx_r2.type)("placeholder", ctx_r2.placeholder)("hint", ctx_r2.hint);
  }
}
function NbCheckboxComponent_nb_icon_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nb-icon", 6);
  }
}
function NbCheckboxComponent_nb_icon_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nb-icon", 7);
  }
}
function NbProgressBarComponent_span_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1("", ctx_r0.value, "%");
  }
}
function NbAlertComponent_button_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 1);
    \u0275\u0275listener("click", function NbAlertComponent_button_0_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onClose());
    });
    \u0275\u0275elementStart(1, "span", 2);
    \u0275\u0275text(2, "\xD7");
    \u0275\u0275elementEnd()();
  }
}
function NbChatFormComponent_div_0_ng_container_1_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div")(1, "span", 9);
    \u0275\u0275listener("click", function NbChatFormComponent_div_0_ng_container_1_div_1_Template_span_click_1_listener() {
      \u0275\u0275restoreView(_r1);
      const file_r2 = \u0275\u0275nextContext().$implicit;
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.removeFile(file_r2));
    });
    \u0275\u0275text(2, "\xD7");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const file_r2 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275styleProp("background-image", file_r2.urlStyle);
  }
}
function NbChatFormComponent_div_0_ng_container_1_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275element(1, "nb-icon", 10);
    \u0275\u0275elementStart(2, "span", 9);
    \u0275\u0275listener("click", function NbChatFormComponent_div_0_ng_container_1_div_2_Template_span_click_2_listener() {
      \u0275\u0275restoreView(_r4);
      const file_r2 = \u0275\u0275nextContext().$implicit;
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.removeFile(file_r2));
    });
    \u0275\u0275text(3, "\xD7");
    \u0275\u0275elementEnd()();
  }
}
function NbChatFormComponent_div_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NbChatFormComponent_div_0_ng_container_1_div_1_Template, 3, 2, "div", 7)(2, NbChatFormComponent_div_0_ng_container_1_div_2_Template, 4, 0, "div", 8);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const file_r2 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", file_r2.urlStyle);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !file_r2.urlStyle);
  }
}
function NbChatFormComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 5);
    \u0275\u0275template(1, NbChatFormComponent_div_0_ng_container_1_Template, 3, 2, "ng-container", 6);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r2.droppedFiles);
  }
}
function NbChatFormComponent_button_3_nb_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nb-icon", 13);
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275property("icon", ctx_r2.buttonIcon);
  }
}
function NbChatFormComponent_button_3_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275textInterpolate(ctx_r2.buttonTitle);
  }
}
function NbChatFormComponent_button_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 11);
    \u0275\u0275listener("click", function NbChatFormComponent_button_3_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r5);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.sendMessage());
    });
    \u0275\u0275template(1, NbChatFormComponent_button_3_nb_icon_1_Template, 1, 1, "nb-icon", 12)(2, NbChatFormComponent_button_3_ng_template_2_Template, 1, 1, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const title_r6 = \u0275\u0275reference(3);
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275classProp("with-icon", !ctx_r2.buttonTitle);
    \u0275\u0275property("status", ctx_r2.getButtonStatus());
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r2.buttonTitle)("ngIfElse", title_r6);
  }
}
function NbChatMessageTextComponent_p_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "p", 2);
    \u0275\u0275text(1);
    \u0275\u0275elementStart(2, "time");
    \u0275\u0275text(3);
    \u0275\u0275pipe(4, "date");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1("", ctx_r0.sender, " ");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind2(4, 2, ctx_r0.date, ctx_r0.dateFormat));
  }
}
function NbChatMessageTextComponent_p_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "p", 3);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r0.message);
  }
}
function NbChatMessageFileComponent_ng_container_2_a_2_nb_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nb-icon", 7);
  }
  if (rf & 2) {
    const file_r1 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("icon", file_r1.icon);
  }
}
function NbChatMessageFileComponent_ng_container_2_a_2_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div");
  }
  if (rf & 2) {
    const file_r1 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275styleProp("background-image", file_r1.urlStyle);
  }
}
function NbChatMessageFileComponent_ng_container_2_a_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "a", 4);
    \u0275\u0275template(1, NbChatMessageFileComponent_ng_container_2_a_2_nb_icon_1_Template, 1, 1, "nb-icon", 5)(2, NbChatMessageFileComponent_ng_container_2_a_2_div_2_Template, 1, 2, "div", 6);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const file_r1 = ctx.$implicit;
    \u0275\u0275property("href", file_r1.url, \u0275\u0275sanitizeUrl);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !file_r1.urlStyle && file_r1.icon);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", file_r1.urlStyle);
  }
}
function NbChatMessageFileComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "div", 2);
    \u0275\u0275template(2, NbChatMessageFileComponent_ng_container_2_a_2_Template, 3, 3, "a", 3);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", ctx_r1.readyFiles);
  }
}
function NbChatMessageFileComponent_ng_container_3_nb_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nb-icon", 7);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("icon", ctx_r1.readyFiles[0].icon);
  }
}
function NbChatMessageFileComponent_ng_container_3_div_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div");
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275styleProp("background-image", ctx_r1.readyFiles[0].urlStyle);
  }
}
function NbChatMessageFileComponent_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "a", 4);
    \u0275\u0275template(2, NbChatMessageFileComponent_ng_container_3_nb_icon_2_Template, 1, 1, "nb-icon", 5)(3, NbChatMessageFileComponent_ng_container_3_div_3_Template, 1, 2, "div", 6);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("href", ctx_r1.readyFiles[0].url, \u0275\u0275sanitizeUrl);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.readyFiles[0].urlStyle && ctx_r1.readyFiles[0].icon);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.readyFiles[0].urlStyle);
  }
}
function NbChatMessageQuoteComponent_p_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "p", 3);
    \u0275\u0275text(1);
    \u0275\u0275elementStart(2, "time");
    \u0275\u0275text(3);
    \u0275\u0275pipe(4, "date");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1("", ctx_r0.sender, " ");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind2(4, 2, ctx_r0.date, ctx_r0.dateFormat));
  }
}
var _c26 = (a0) => [a0];
function NbChatAvatarComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r0.initials, " ");
  }
}
function NbChatMessageComponent_nb_chat_avatar_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nb-chat-avatar", 4);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("initials", ctx_r0.getInitials())("avatarStyle", ctx_r0.avatarStyle);
  }
}
function NbChatMessageComponent_ng_container_2_nb_chat_message_file_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nb-chat-message-file", 10);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("sender", ctx_r0.sender)("date", ctx_r0.date)("dateFormat", ctx_r0.dateFormat)("message", ctx_r0.message)("files", ctx_r0.files);
  }
}
function NbChatMessageComponent_ng_container_2_nb_chat_message_quote_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nb-chat-message-quote", 11);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("sender", ctx_r0.sender)("date", ctx_r0.date)("dateFormat", ctx_r0.dateFormat)("message", ctx_r0.message)("quote", ctx_r0.quote);
  }
}
function NbChatMessageComponent_ng_container_2_nb_chat_message_map_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nb-chat-message-map", 12);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("sender", ctx_r0.sender)("date", ctx_r0.date)("message", ctx_r0.message)("latitude", ctx_r0.latitude)("longitude", ctx_r0.longitude);
  }
}
function NbChatMessageComponent_ng_container_2_nb_chat_message_text_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nb-chat-message-text", 13);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("sender", ctx_r0.sender)("date", ctx_r0.date)("dateFormat", ctx_r0.dateFormat)("message", ctx_r0.message);
  }
}
function NbChatMessageComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0, 5);
    \u0275\u0275template(1, NbChatMessageComponent_ng_container_2_nb_chat_message_file_1_Template, 1, 5, "nb-chat-message-file", 6)(2, NbChatMessageComponent_ng_container_2_nb_chat_message_quote_2_Template, 1, 5, "nb-chat-message-quote", 7)(3, NbChatMessageComponent_ng_container_2_nb_chat_message_map_3_Template, 1, 5, "nb-chat-message-map", 8)(4, NbChatMessageComponent_ng_container_2_nb_chat_message_text_4_Template, 1, 4, "nb-chat-message-text", 9);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("ngSwitch", ctx_r0.type);
    \u0275\u0275advance();
    \u0275\u0275property("ngSwitchCase", "file");
    \u0275\u0275advance();
    \u0275\u0275property("ngSwitchCase", "quote");
    \u0275\u0275advance();
    \u0275\u0275property("ngSwitchCase", "map");
  }
}
function NbChatMessageComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nb-chat-message-text", 13);
    \u0275\u0275elementStart(1, "div");
    \u0275\u0275elementContainer(2, 14);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("sender", ctx_r0.sender)("date", ctx_r0.date)("dateFormat", ctx_r0.dateFormat)("message", ctx_r0.message);
    \u0275\u0275advance();
    \u0275\u0275classProp("nb-custom-message", ctx_r0._areDefaultStylesEnabled())("nb-custom-message-no-space", ctx_r0._addNoSpaceClass)("nb-custom-message-reply", ctx_r0._addReplyClass)("nb-custom-message-not-reply", ctx_r0._addNotReplyClass)("nb-custom-message-full-width", !ctx_r0._areDefaultStylesEnabled());
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r0._getTemplate())("ngTemplateOutletContext", ctx_r0._getTemplateContext());
  }
}
var _c27 = ["scrollable"];
var _c28 = [[["nb-chat-message"]], [["nb-chat-form"]]];
var _c29 = ["nb-chat-message", "nb-chat-form"];
var _c30 = (a0) => ({
  $implicit: a0
});
function NbChatComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0, 8);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.titleTemplate.templateRef)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c30, ctx_r0.titleTemplate.context));
  }
}
function NbChatComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275textInterpolate1(" ", ctx_r0.title, " ");
  }
}
function NbChatComponent_p_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "p", 9);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r0.noMessagesPlaceholder);
  }
}
function NbSpinnerComponent_span_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 2);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r0.message);
  }
}
function NbStepComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275projection(0);
  }
}
var _c31 = [[["nb-step"]]];
var _c32 = ["nb-step"];
function NbStepperComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275projection(0);
  }
}
function NbStepperComponent_ng_container_2_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div", 6);
  }
  if (rf & 2) {
    const index_r1 = \u0275\u0275nextContext().index;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275classProp("connector-past", index_r1 <= ctx_r1.selectedIndex);
  }
}
function NbStepperComponent_ng_container_2_div_2_span_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const index_r1 = \u0275\u0275nextContext(2).index;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(index_r1 + 1);
  }
}
function NbStepperComponent_ng_container_2_div_2_nb_icon_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nb-icon", 12);
  }
}
function NbStepperComponent_ng_container_2_div_2_ng_container_5_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function NbStepperComponent_ng_container_2_div_2_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NbStepperComponent_ng_container_2_div_2_ng_container_5_ng_container_1_Template, 1, 0, "ng-container", 13);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const step_r4 = \u0275\u0275nextContext(2).$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.getStepTemplate(step_r4));
  }
}
function NbStepperComponent_ng_container_2_div_2_span_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const step_r4 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(step_r4.label);
  }
}
function NbStepperComponent_ng_container_2_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 7);
    \u0275\u0275listener("click", function NbStepperComponent_ng_container_2_div_2_Template_div_click_0_listener() {
      \u0275\u0275restoreView(_r3);
      const step_r4 = \u0275\u0275nextContext().$implicit;
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.changeStep(step_r4));
    });
    \u0275\u0275elementStart(1, "div", 8);
    \u0275\u0275template(2, NbStepperComponent_ng_container_2_div_2_span_2_Template, 2, 1, "span", 9)(3, NbStepperComponent_ng_container_2_div_2_nb_icon_3_Template, 1, 0, "nb-icon", 10);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "div", 11);
    \u0275\u0275template(5, NbStepperComponent_ng_container_2_div_2_ng_container_5_Template, 2, 1, "ng-container", 9)(6, NbStepperComponent_ng_container_2_div_2_span_6_Template, 2, 1, "span", 9);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const step_r4 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275classProp("selected", ctx_r1.isStepSelected(step_r4))("completed", !ctx_r1.isStepSelected(step_r4) && step_r4.completed)("noninteractive", ctx_r1.disableStepNavigation);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", !step_r4.completed || ctx_r1.isStepSelected(step_r4));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.isStepSelected(step_r4) && step_r4.completed);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", step_r4.isLabelTemplate);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !step_r4.isLabelTemplate);
  }
}
function NbStepperComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NbStepperComponent_ng_container_2_div_1_Template, 1, 2, "div", 4)(2, NbStepperComponent_ng_container_2_div_2_Template, 7, 10, "div", 5);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const step_r4 = ctx.$implicit;
    const first_r5 = ctx.first;
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !first_r5 && !step_r4.hidden);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !step_r4.hidden);
  }
}
var _c33 = [[["nb-accordion-item"]]];
var _c34 = ["nb-accordion-item"];
var _c35 = [[["nb-accordion-item-header"]], [["nb-accordion-item-body"]]];
var _c36 = ["nb-accordion-item-header", "nb-accordion-item-body"];
var _c37 = (a0) => ({
  value: a0
});
var _c38 = [[["nb-accordion-item-title"]], [["nb-accordion-item-description"]], "*"];
var _c39 = ["nb-accordion-item-title", "nb-accordion-item-description", "*"];
function NbAccordionItemHeaderComponent_nb_icon_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nb-icon", 1);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("@expansionIndicator", ctx_r0.state);
  }
}
function NbDialogContainerComponent_ng_template_0_Template(rf, ctx) {
}
function NbToastComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 4);
    \u0275\u0275element(1, "nb-icon", 5);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("config", ctx_r0.icon);
  }
}
function NbToastrContainerComponent_nb_toast_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nb-toast", 1);
  }
  if (rf & 2) {
    const toast_r1 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("@fadeIn", ctx_r1.fadeIn)("toast", toast_r1);
  }
}
function NbTooltipComponent_nb_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nb-icon", 4);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("config", ctx_r0.context.icon);
  }
}
function NbTooltipComponent_span_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r0.content);
  }
}
function NbOptionComponent_nb_checkbox_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nb-checkbox", 1);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("checked", ctx_r0.selected)("disabled", ctx_r0.disabled);
  }
}
var _c40 = ["selectButton"];
var _c41 = [[["nb-select-label"]], [["nb-option"], ["nb-option-group"]]];
var _c42 = ["nb-select-label", "nb-option, nb-option-group"];
function NbSelectComponent_ng_container_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275projection(1);
    \u0275\u0275elementContainerEnd();
  }
}
function NbSelectComponent_ng_container_3_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275textInterpolate(ctx_r1.selectionView);
  }
}
function NbSelectComponent_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NbSelectComponent_ng_container_3_ng_container_1_Template, 2, 0, "ng-container", 5)(2, NbSelectComponent_ng_container_3_ng_template_2_Template, 1, 1, "ng-template", null, 2, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const defaultSelectionTemplate_r3 = \u0275\u0275reference(3);
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.customLabel)("ngIfElse", defaultSelectionTemplate_r3);
  }
}
function NbSelectComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275textInterpolate(ctx_r1.placeholder);
  }
}
function NbSelectComponent_nb_option_list_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nb-option-list", 8);
    \u0275\u0275projection(1, 1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275styleProp("width", ctx_r1.optionsWidth, "px");
    \u0275\u0275property("size", ctx_r1.size)("position", ctx_r1.overlayPosition)("ngClass", ctx_r1.optionsListClass);
  }
}
var _c43 = [[["nb-option"], ["ng-container"]]];
var _c44 = ["nb-option, ng-container"];
var _c45 = ["*", [["", "nbPrefix", ""]], [["", "nbSuffix", ""]]];
var _c46 = ["*", "[nbPrefix]", "[nbSuffix]"];
function NbFormFieldComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 2);
    \u0275\u0275pipe(1, "async");
    \u0275\u0275projection(2, 1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("ngClass", \u0275\u0275pipeBind1(1, 1, ctx_r0.prefixClasses$));
  }
}
function NbFormFieldComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 2);
    \u0275\u0275pipe(1, "async");
    \u0275\u0275projection(2, 2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("ngClass", \u0275\u0275pipeBind1(1, 1, ctx_r0.suffixClasses$));
  }
}
var _c47 = ["optionsAutocompleteInput"];
function NbSelectWithAutocompleteComponent_ng_container_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275projection(1);
    \u0275\u0275elementContainerEnd();
  }
}
function NbSelectWithAutocompleteComponent_ng_container_3_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275textInterpolate(ctx_r1.selectionView);
  }
}
function NbSelectWithAutocompleteComponent_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NbSelectWithAutocompleteComponent_ng_container_3_ng_container_1_Template, 2, 0, "ng-container", 6)(2, NbSelectWithAutocompleteComponent_ng_container_3_ng_template_2_Template, 1, 1, "ng-template", null, 3, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const defaultSelectionTemplate_r3 = \u0275\u0275reference(3);
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.customLabel)("ngIfElse", defaultSelectionTemplate_r3);
  }
}
function NbSelectWithAutocompleteComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275textInterpolate(ctx_r1.placeholder);
  }
}
function NbSelectWithAutocompleteComponent_nb_option_list_11_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nb-option-list", 12);
    \u0275\u0275projection(1, 1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275styleProp("width", ctx_r1.optionsWidth, "px");
    \u0275\u0275property("size", ctx_r1.size)("position", ctx_r1.overlayPosition)("ngClass", ctx_r1.optionsListClass);
  }
}
var _c48 = [[["nb-option"], ["nb-option-group"]]];
var _c49 = ["nb-option, nb-option-group"];
function NbAutocompleteComponent_nb_option_list_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nb-option-list", 1);
    \u0275\u0275projection(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275styleProp("width", ctx_r0.optionsWidth, "px");
    \u0275\u0275classProp("empty", !(ctx_r0.options == null ? null : ctx_r0.options.length));
    \u0275\u0275property("size", ctx_r0.size)("position", ctx_r0.overlayPosition)("id", ctx_r0.id)("ngClass", ctx_r0.optionsListClass);
  }
}
var _c50 = ["viewContainerRef"];
function NbWindowComponent_div_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function NbWindowComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 4);
    \u0275\u0275template(1, NbWindowComponent_div_2_ng_container_1_Template, 1, 0, "ng-container", 5);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.config.titleTemplate)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c30, ctx_r0.config.titleTemplateContext));
  }
}
function NbWindowComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 6);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r0.config.title);
  }
}
function NbWindowComponent_ng_container_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "button", 7);
    \u0275\u0275listener("click", function NbWindowComponent_ng_container_6_Template_button_click_1_listener() {
      \u0275\u0275restoreView(_r2);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.minimize());
    });
    \u0275\u0275element(2, "nb-icon", 8);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
}
function NbWindowComponent_ng_container_7_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 7);
    \u0275\u0275listener("click", function NbWindowComponent_ng_container_7_button_1_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r3);
      const ctx_r0 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r0.maximize());
    });
    \u0275\u0275element(1, "nb-icon", 10);
    \u0275\u0275elementEnd();
  }
}
function NbWindowComponent_ng_container_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NbWindowComponent_ng_container_7_button_1_Template, 2, 0, "button", 9);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.isFullScreen);
  }
}
function NbWindowComponent_ng_container_8_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 7);
    \u0275\u0275listener("click", function NbWindowComponent_ng_container_8_button_1_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r4);
      const ctx_r0 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r0.maximizeOrFullScreen());
    });
    \u0275\u0275element(1, "nb-icon", 11);
    \u0275\u0275elementEnd();
  }
}
function NbWindowComponent_ng_container_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NbWindowComponent_ng_container_8_button_1_Template, 2, 0, "button", 9);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.minimized || ctx_r0.maximized);
  }
}
function NbWindowComponent_ng_container_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "button", 7);
    \u0275\u0275listener("click", function NbWindowComponent_ng_container_9_Template_button_click_1_listener() {
      \u0275\u0275restoreView(_r5);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.close());
    });
    \u0275\u0275element(2, "nb-icon", 12);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
}
function NbWindowComponent_nb_card_body_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nb-card-body");
    \u0275\u0275element(1, "nb-overlay-container");
    \u0275\u0275elementEnd();
  }
}
var _c51 = ["input"];
var _c52 = [[["nb-radio"]]];
var _c53 = ["nb-radio"];
function NbTagComponent_nb_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nb-icon", 1);
    \u0275\u0275listener("click", function NbTagComponent_nb_icon_1_Template_nb_icon_click_0_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1._remove());
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275classMap(\u0275\u0275interpolate1("nb-tag-remove size-", ctx_r1.size));
  }
}
var _c54 = [[["nb-tag"], ["input", "nbTagInput", ""]]];
var _c55 = ["nb-tag, input[nbTagInput]"];
function NbSortIconComponent_ng_container_0_nb_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nb-icon", 3);
  }
}
function NbSortIconComponent_ng_container_0_nb_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nb-icon", 4);
  }
}
function NbSortIconComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NbSortIconComponent_ng_container_0_nb_icon_1_Template, 1, 0, "nb-icon", 1)(2, NbSortIconComponent_ng_container_0_nb_icon_2_Template, 1, 0, "nb-icon", 2);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.isAscending());
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.isDescending());
  }
}
var _c56 = ["nbSortHeader", ""];
function NbSortHeaderComponent_nb_sort_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nb-sort-icon", 4);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("direction", ctx_r1.direction);
  }
}
function NbSortHeaderComponent_ng_template_3_Template(rf, ctx) {
}
var _c57 = ["nbTreeGrid", ""];
var _c58 = ["nbTreeGridRow", ""];
var _c59 = ["nbTreeGridHeaderRow", ""];
var _c60 = ["nbTreeGridFooterRow", ""];
function NbToggleComponent_nb_icon_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nb-icon", 6);
  }
}
var NB_THEME_OPTIONS = new InjectionToken("Nebular Theme Options");
var NB_MEDIA_BREAKPOINTS = new InjectionToken("Nebular Media Breakpoints");
var NB_BUILT_IN_JS_THEMES = new InjectionToken("Nebular Built-in JS Themes");
var NB_JS_THEMES = new InjectionToken("Nebular JS Themes");
var NB_WINDOW = new InjectionToken("Window");
var NB_DOCUMENT = new InjectionToken("Document");
var DEFAULT_MEDIA_BREAKPOINTS = [{
  name: "xs",
  width: 0
}, {
  name: "is",
  width: 400
}, {
  name: "sm",
  width: 576
}, {
  name: "md",
  width: 768
}, {
  name: "lg",
  width: 992
}, {
  name: "xl",
  width: 1200
}, {
  name: "xxl",
  width: 1400
}, {
  name: "xxxl",
  width: 1600
}];
var _NbMediaBreakpointsService = class _NbMediaBreakpointsService {
  constructor(breakpoints) {
    this.breakpoints = breakpoints;
    this.breakpointsMap = this.breakpoints.reduce((res, b) => {
      res[b.name] = b.width;
      return res;
    }, {});
  }
  /**
   * Returns a configured breakpoint by width
   * @param width number
   * @returns {Z|{name: string, width: number}}
   */
  getByWidth(width) {
    const unknown = {
      name: "unknown",
      width
    };
    const breakpoints = this.getBreakpoints();
    return breakpoints.find((point, index) => {
      const next = breakpoints[index + 1];
      return width >= point.width && (!next || width < next.width);
    }) || unknown;
  }
  /**
   * Returns a configured breakpoint by name
   * @param name string
   * @returns NbMediaBreakpoint
   */
  getByName(name) {
    const unknown = {
      name: "unknown",
      width: NaN
    };
    const breakpoints = this.getBreakpoints();
    return breakpoints.find((point) => name === point.name) || unknown;
  }
  /**
   * Returns a list of configured breakpoints for the theme
   * @returns NbMediaBreakpoint[]
   */
  getBreakpoints() {
    return this.breakpoints;
  }
  /**
   * Returns a map of configured breakpoints for the theme
   * @returns {[p: string]: number}
   */
  getBreakpointsMap() {
    return this.breakpointsMap;
  }
};
_NbMediaBreakpointsService.\u0275fac = function NbMediaBreakpointsService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbMediaBreakpointsService)(\u0275\u0275inject(NB_MEDIA_BREAKPOINTS));
};
_NbMediaBreakpointsService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbMediaBreakpointsService,
  factory: _NbMediaBreakpointsService.\u0275fac
});
var NbMediaBreakpointsService = _NbMediaBreakpointsService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbMediaBreakpointsService, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_MEDIA_BREAKPOINTS]
    }]
  }], null);
})();
var palette$3 = {
  primary: "#3366ff",
  success: "#00d68f",
  info: "#0095ff",
  warning: "#ffaa00",
  danger: "#ff3d71"
};
var DEFAULT_THEME = {
  name: "default",
  variables: {
    fontMain: "Open Sans, sans-serif",
    fontSecondary: "Raleway, sans-serif",
    bg: "#ffffff",
    bg2: "#f7f9fc",
    bg3: "#edf1f7",
    bg4: "#e4e9f2",
    border: "#ffffff",
    border2: "#f7f9fc",
    border3: "#edf1f7",
    border4: "#e4e9f2",
    border5: "#c5cee0",
    fg: "#8f9bb3",
    fgHeading: "#1a2138",
    fgText: "#1a2138",
    fgHighlight: palette$3.primary,
    layoutBg: "#f7f9fc",
    separator: "#edf1f7",
    primary: palette$3.primary,
    success: palette$3.success,
    info: palette$3.info,
    warning: palette$3.warning,
    danger: palette$3.danger,
    primaryLight: "#598bff",
    successLight: "#2ce69b",
    infoLight: "#42aaff",
    warningLight: "#ffc94d",
    dangerLight: "#ff708d"
  }
};
var palette$2 = {
  primary: "#a16eff",
  success: "#00d68f",
  info: "#0095ff",
  warning: "#ffaa00",
  danger: "#ff3d71"
};
var COSMIC_THEME = {
  name: "cosmic",
  variables: {
    fontMain: "Open Sans, sans-serif",
    fontSecondary: "Raleway, sans-serif",
    bg: "#323259",
    bg2: "#252547",
    bg3: "#1b1b38",
    bg4: "#13132b",
    border: "#323259",
    border2: "#252547",
    border3: "#1b1b38",
    border4: "#13132b",
    border5: "#13132b",
    fg: "#b4b4db",
    fgHeading: "#ffffff",
    fgText: "#ffffff",
    fgHighlight: palette$2.primary,
    layoutBg: "#151a30",
    separator: "#151a30",
    primary: palette$2.primary,
    success: palette$2.success,
    info: palette$2.info,
    warning: palette$2.warning,
    danger: palette$2.danger,
    primaryLight: "#b18aff",
    successLight: "#2ce69b",
    infoLight: "#42aaff",
    warningLight: "#ffc94d",
    dangerLight: "#ff708d"
  }
};
var palette$1 = {
  primary: "#73a1ff",
  success: "#5dcfe3",
  info: "#ba7fec",
  warning: "#ffa36b",
  danger: "#ff6b83"
};
var CORPORATE_THEME = {
  name: "corporate",
  base: "default",
  variables: {
    fontMain: "Open Sans, sans-serif",
    fontSecondary: "Raleway, sans-serif",
    bg: "#ffffff",
    bg2: "#f7f9fc",
    bg3: "#edf1f7",
    bg4: "#e4e9f2",
    border: "#ffffff",
    border2: "#f7f9fc",
    border3: "#edf1f7",
    border4: "#e4e9f2",
    border5: "#c5cee0",
    fg: "#8f9bb3",
    fgHeading: "#1a2138",
    fgText: "#1a2138",
    fgHighlight: palette$1.primary,
    layoutBg: "#f7f9fc",
    separator: "#edf1f7",
    primary: palette$1.primary,
    success: palette$1.success,
    info: palette$1.info,
    warning: palette$1.warning,
    danger: palette$1.danger,
    primaryLight: "#598bff",
    successLight: "#2ce69b",
    infoLight: "#42aaff",
    warningLight: "#ffc94d",
    dangerLight: "#ff708d"
  }
};
var palette = {
  primary: "#3366ff",
  success: "#00d68f",
  info: "#0095ff",
  warning: "#ffaa00",
  danger: "#ff3d71"
};
var DARK_THEME = {
  name: "dark",
  variables: {
    fontMain: "Open Sans, sans-serif",
    fontSecondary: "Raleway, sans-serif",
    bg: "#222b45",
    bg2: "#1a2138",
    bg3: "#151a30",
    bg4: "#101426",
    border: "#222b45",
    border2: "#1a2138",
    border3: "#151a30",
    border4: "#101426",
    border5: "#101426",
    fg: "#8f9bb3",
    fgHeading: "#ffffff",
    fgText: "#ffffff",
    fgHighlight: palette.primary,
    layoutBg: "#1b1b38",
    separator: "#1b1b38",
    primary: palette.primary,
    success: palette.success,
    info: palette.info,
    warning: palette.warning,
    danger: palette.danger,
    primaryLight: "#598bff",
    successLight: "#2ce69b",
    infoLight: "#42aaff",
    warningLight: "#ffc94d",
    dangerLight: "#ff708d"
  }
};
var BUILT_IN_THEMES = [DEFAULT_THEME, COSMIC_THEME, CORPORATE_THEME, DARK_THEME];
var _NbJSThemesRegistry = class _NbJSThemesRegistry {
  constructor(builtInThemes, newThemes = []) {
    this.themes = {};
    const themes = this.combineByNames(newThemes, builtInThemes);
    themes.forEach((theme) => {
      this.register(theme, theme.name, theme.base);
    });
  }
  /**
   * Registers a new JS theme
   * @param config any
   * @param themeName string
   * @param baseTheme string
   */
  register(config, themeName, baseTheme) {
    const base = this.has(baseTheme) ? this.get(baseTheme) : {};
    this.themes[themeName] = this.mergeDeep({}, base, config);
  }
  /**
   * Checks whether the theme is registered
   * @param themeName
   * @returns boolean
   */
  has(themeName) {
    return !!this.themes[themeName];
  }
  /**
   * Return a theme
   * @param themeName
   * @returns NbJSThemeOptions
   */
  get(themeName) {
    if (!this.themes[themeName]) {
      throw Error(`NbThemeConfig: no theme '${themeName}' found registered.`);
    }
    return JSON.parse(JSON.stringify(this.themes[themeName]));
  }
  combineByNames(newThemes, oldThemes) {
    if (newThemes) {
      const mergedThemes = [];
      newThemes.forEach((theme) => {
        const sameOld = oldThemes.find((tm) => tm.name === theme.name) || {};
        const mergedTheme = this.mergeDeep({}, sameOld, theme);
        mergedThemes.push(mergedTheme);
      });
      oldThemes.forEach((theme) => {
        if (!mergedThemes.find((tm) => tm.name === theme.name)) {
          mergedThemes.push(theme);
        }
      });
      return mergedThemes;
    }
    return oldThemes;
  }
  isObject(item) {
    return item && typeof item === "object" && !Array.isArray(item);
  }
  // TODO: move to helpers
  mergeDeep(target, ...sources) {
    if (!sources.length) {
      return target;
    }
    const source = sources.shift();
    if (this.isObject(target) && this.isObject(source)) {
      for (const key in source) {
        if (this.isObject(source[key])) {
          if (!target[key]) {
            Object.assign(target, {
              [key]: {}
            });
          }
          this.mergeDeep(target[key], source[key]);
        } else {
          Object.assign(target, {
            [key]: source[key]
          });
        }
      }
    }
    return this.mergeDeep(target, ...sources);
  }
};
_NbJSThemesRegistry.\u0275fac = function NbJSThemesRegistry_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbJSThemesRegistry)(\u0275\u0275inject(NB_BUILT_IN_JS_THEMES), \u0275\u0275inject(NB_JS_THEMES));
};
_NbJSThemesRegistry.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbJSThemesRegistry,
  factory: _NbJSThemesRegistry.\u0275fac
});
var NbJSThemesRegistry = _NbJSThemesRegistry;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbJSThemesRegistry, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_BUILT_IN_JS_THEMES]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_JS_THEMES]
    }]
  }], null);
})();
var _NbThemeService = class _NbThemeService {
  constructor(options, breakpointService, jsThemesRegistry) {
    this.options = options;
    this.breakpointService = breakpointService;
    this.jsThemesRegistry = jsThemesRegistry;
    this.themeChanges$ = new ReplaySubject(1);
    this.appendLayoutClass$ = new Subject();
    this.removeLayoutClass$ = new Subject();
    this.changeWindowWidth$ = new ReplaySubject(2);
    if (options && options.name) {
      this.changeTheme(options.name);
    }
  }
  /**
   * Change current application theme
   * @param {string} name
   */
  changeTheme(name) {
    this.themeChanges$.next({
      name,
      previous: this.currentTheme
    });
    this.currentTheme = name;
  }
  changeWindowWidth(width) {
    this.changeWindowWidth$.next(width);
  }
  /**
   * Returns a theme object with variables (color/paddings/etc) on a theme change.
   * Once subscribed - returns current theme.
   *
   * @returns {Observable<NbJSThemeOptions>}
   */
  getJsTheme() {
    return this.onThemeChange().pipe(map((theme) => {
      return this.jsThemesRegistry.get(theme.name);
    }));
  }
  /**
   * Triggers media query breakpoint change
   * Returns a pair where the first item is previous media breakpoint and the second item is current breakpoit.
   * ```ts
   *  [{ name: 'xs', width: 0 }, { name: 'md', width: 768 }] // change from `xs` to `md`
   * ```
   * @returns {Observable<[NbMediaBreakpoint, NbMediaBreakpoint]>}
   */
  onMediaQueryChange() {
    return this.changeWindowWidth$.pipe(startWith(void 0), pairwise(), map(([prevWidth, width]) => {
      return [this.breakpointService.getByWidth(prevWidth), this.breakpointService.getByWidth(width)];
    }), filter(([prevPoint, point]) => {
      return prevPoint.name !== point.name;
    }), distinctUntilChanged(null, (params) => params[0].name + params[1].name), share());
  }
  /**
   * Triggered when current theme is changed
   * @returns {Observable<any>}
   */
  onThemeChange() {
    return this.themeChanges$.pipe(share());
  }
  /**
   * Append a class to nb-layout
   * @param {string} className
   */
  appendLayoutClass(className) {
    this.appendLayoutClass$.next(className);
  }
  /**
   * Triggered when a new class is added to nb-layout through `appendLayoutClass` method
   * @returns {Observable<any>}
   */
  onAppendLayoutClass() {
    return this.appendLayoutClass$.pipe(share());
  }
  /**
   * Removes a class from nb-layout
   * @param {string} className
   */
  removeLayoutClass(className) {
    this.removeLayoutClass$.next(className);
  }
  /**
   * Triggered when a class is removed from nb-layout through `removeLayoutClass` method
   * @returns {Observable<any>}
   */
  onRemoveLayoutClass() {
    return this.removeLayoutClass$.pipe(share());
  }
};
_NbThemeService.\u0275fac = function NbThemeService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbThemeService)(\u0275\u0275inject(NB_THEME_OPTIONS), \u0275\u0275inject(NbMediaBreakpointsService), \u0275\u0275inject(NbJSThemesRegistry));
};
_NbThemeService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbThemeService,
  factory: _NbThemeService.\u0275fac
});
var NbThemeService = _NbThemeService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbThemeService, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_THEME_OPTIONS]
    }]
  }, {
    type: NbMediaBreakpointsService
  }, {
    type: NbJSThemesRegistry
  }], null);
})();
var _NbSpinnerService = class _NbSpinnerService {
  constructor(document2) {
    this.document = document2;
    this.loaders = [];
    this.selector = "nb-global-spinner";
  }
  /**
   * Appends new loader to the list of loader to be completed before
   * spinner will be hidden
   * @param method Promise<any>
   */
  registerLoader(method) {
    this.loaders.push(method);
  }
  /**
   * Clears the list of loader
   */
  clear() {
    this.loaders = [];
  }
  /**
   * Start the loader process, show spinnder and execute loaders
   */
  load() {
    this.showSpinner();
    this.executeAll();
  }
  executeAll(done = (values) => {
  }) {
    Promise.all(this.loaders).then((values) => {
      this.hideSpinner();
      done.call(null, values);
    }).catch((error) => {
      console.error(error);
    });
  }
  // TODO is there any better way of doing this?
  showSpinner() {
    const el = this.getSpinnerElement();
    if (el) {
      el.style["display"] = "block";
    }
  }
  hideSpinner() {
    const el = this.getSpinnerElement();
    if (el) {
      el.style["display"] = "none";
    }
  }
  getSpinnerElement() {
    return this.document.getElementById(this.selector);
  }
};
_NbSpinnerService.\u0275fac = function NbSpinnerService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbSpinnerService)(\u0275\u0275inject(NB_DOCUMENT));
};
_NbSpinnerService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbSpinnerService,
  factory: _NbSpinnerService.\u0275fac
});
var NbSpinnerService = _NbSpinnerService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSpinnerService, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }], null);
})();
var NbLayoutDirection;
(function(NbLayoutDirection2) {
  NbLayoutDirection2["LTR"] = "ltr";
  NbLayoutDirection2["RTL"] = "rtl";
})(NbLayoutDirection || (NbLayoutDirection = {}));
var NB_LAYOUT_DIRECTION = new InjectionToken("Layout direction");
var _NbLayoutDirectionService = class _NbLayoutDirectionService {
  constructor(direction = NbLayoutDirection.LTR) {
    this.direction = direction;
    this.$directionChange = new ReplaySubject(1);
    this.setDirection(direction);
  }
  /**
   * Returns true if layout direction set to left to right.
   * @returns boolean.
   * */
  isLtr() {
    return this.direction === NbLayoutDirection.LTR;
  }
  /**
   * Returns true if layout direction set to right to left.
   * @returns boolean.
   * */
  isRtl() {
    return this.direction === NbLayoutDirection.RTL;
  }
  /**
   * Returns current layout direction.
   * @returns NbLayoutDirection.
   * */
  getDirection() {
    return this.direction;
  }
  /**
   * Sets layout direction
   * @param {NbLayoutDirection} direction
   */
  setDirection(direction) {
    this.direction = direction;
    this.$directionChange.next(direction);
  }
  /**
   * Triggered when direction was changed.
   * @returns Observable<NbLayoutDirection>.
   */
  onDirectionChange() {
    return this.$directionChange.pipe(share());
  }
};
_NbLayoutDirectionService.\u0275fac = function NbLayoutDirectionService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbLayoutDirectionService)(\u0275\u0275inject(NB_LAYOUT_DIRECTION, 8));
};
_NbLayoutDirectionService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbLayoutDirectionService,
  factory: _NbLayoutDirectionService.\u0275fac
});
var NbLayoutDirectionService = _NbLayoutDirectionService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbLayoutDirectionService, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NB_LAYOUT_DIRECTION]
    }]
  }], null);
})();
var _NbLayoutScrollService = class _NbLayoutScrollService {
  constructor() {
    this.scrollPositionReq$ = new Subject();
    this.manualScroll$ = new Subject();
    this.scroll$ = new Subject();
    this.scrollable$ = new Subject();
  }
  /**
   * Returns scroll position
   *
   * @returns {Observable<NbScrollPosition>}
   */
  getPosition() {
    return new Observable((observer) => {
      const listener = new Subject();
      listener.subscribe(observer);
      this.scrollPositionReq$.next({
        listener
      });
      return () => listener.complete();
    });
  }
  /**
   * Sets scroll position
   *
   * @param {number} x
   * @param {number} y
   */
  scrollTo(x = null, y = null) {
    this.manualScroll$.next({
      x,
      y
    });
  }
  /**
   * Returns a stream of scroll events
   *
   * @returns {Observable<any>}
   */
  onScroll() {
    return this.scroll$.pipe(share());
  }
  /**
   * @private
   * @returns Observable<NbScrollPosition>.
   */
  onManualScroll() {
    return this.manualScroll$.pipe(share());
  }
  /**
   * @private
   * @returns {Subject<any>}
   */
  onGetPosition() {
    return this.scrollPositionReq$;
  }
  onScrollableChange() {
    return this.scrollable$.pipe(share());
  }
  /**
   * @private
   * @param {any} event
   */
  fireScrollChange(event) {
    this.scroll$.next(event);
  }
  scrollable(scrollable) {
    this.scrollable$.next(scrollable);
  }
};
_NbLayoutScrollService.\u0275fac = function NbLayoutScrollService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbLayoutScrollService)();
};
_NbLayoutScrollService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbLayoutScrollService,
  factory: _NbLayoutScrollService.\u0275fac
});
var NbLayoutScrollService = _NbLayoutScrollService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbLayoutScrollService, [{
    type: Injectable
  }], null, null);
})();
var _NbLayoutRulerService = class _NbLayoutRulerService {
  constructor() {
    this.contentDimensionsReq$ = new Subject();
  }
  /**
   * Content dimensions
   * @returns {Observable<NbLayoutDimensions>}
   */
  getDimensions() {
    return new Observable((observer) => {
      const listener = new Subject();
      listener.subscribe(observer);
      this.contentDimensionsReq$.next({
        listener
      });
      return () => listener.complete();
    });
  }
  /**
   * @private
   * @returns {Subject<any>}
   */
  onGetDimensions() {
    return this.contentDimensionsReq$;
  }
};
_NbLayoutRulerService.\u0275fac = function NbLayoutRulerService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbLayoutRulerService)();
};
_NbLayoutRulerService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbLayoutRulerService,
  factory: _NbLayoutRulerService.\u0275fac
});
var NbLayoutRulerService = _NbLayoutRulerService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbLayoutRulerService, [{
    type: Injectable
  }], null, null);
})();
var _NbSharedModule = class _NbSharedModule {
};
_NbSharedModule.\u0275fac = function NbSharedModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbSharedModule)();
};
_NbSharedModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbSharedModule,
  exports: [
    CommonModule,
    // TODO: probably we don't need FormsModule in SharedModule
    FormsModule,
    RouterModule
  ]
});
_NbSharedModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [
    CommonModule,
    // TODO: probably we don't need FormsModule in SharedModule
    FormsModule,
    RouterModule
  ]
});
var NbSharedModule = _NbSharedModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSharedModule, [{
    type: NgModule,
    args: [{
      exports: [
        CommonModule,
        // TODO: probably we don't need FormsModule in SharedModule
        FormsModule,
        RouterModule
      ]
    }]
  }], null, null);
})();
var NbFocusTrap = class extends FocusTrap {
  constructor(element, checker, ngZone, document2, deferAnchors) {
    super(element, checker, ngZone, document2, deferAnchors);
    this.element = element;
    this.checker = checker;
    this.ngZone = ngZone;
    this.document = document2;
    this.savePreviouslyFocusedElement();
  }
  restoreFocus() {
    this.previouslyFocusedElement.focus();
    this.destroy();
  }
  blurPreviouslyFocusedElement() {
    this.previouslyFocusedElement.blur();
  }
  savePreviouslyFocusedElement() {
    this.previouslyFocusedElement = this.document.activeElement;
  }
};
var _NbFocusTrapFactoryService = class _NbFocusTrapFactoryService extends FocusTrapFactory {
  constructor(checker, ngZone, document2) {
    super(checker, ngZone, document2);
    this.checker = checker;
    this.ngZone = ngZone;
    this.document = document2;
  }
  create(element, deferCaptureElements) {
    return new NbFocusTrap(element, this.checker, this.ngZone, this.document, deferCaptureElements);
  }
};
_NbFocusTrapFactoryService.\u0275fac = function NbFocusTrapFactoryService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbFocusTrapFactoryService)(\u0275\u0275inject(InteractivityChecker), \u0275\u0275inject(NgZone), \u0275\u0275inject(NB_DOCUMENT));
};
_NbFocusTrapFactoryService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbFocusTrapFactoryService,
  factory: _NbFocusTrapFactoryService.\u0275fac
});
var NbFocusTrapFactoryService = _NbFocusTrapFactoryService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFocusTrapFactoryService, [{
    type: Injectable
  }], () => [{
    type: InteractivityChecker
  }, {
    type: NgZone
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }], null);
})();
var NbFocusKeyManager = class extends FocusKeyManager {
};
var NbFocusKeyManagerFactoryService = class {
  create(items) {
    return new NbFocusKeyManager(items);
  }
};
var NbActiveDescendantKeyManager = class extends ActiveDescendantKeyManager {
};
var NbActiveDescendantKeyManagerFactoryService = class {
  create(items) {
    return new NbActiveDescendantKeyManager(items);
  }
};
var NbKeyManagerActiveItemMode;
(function(NbKeyManagerActiveItemMode2) {
  NbKeyManagerActiveItemMode2[NbKeyManagerActiveItemMode2["RESET_ACTIVE"] = -1] = "RESET_ACTIVE";
  NbKeyManagerActiveItemMode2[NbKeyManagerActiveItemMode2["FIRST_ACTIVE"] = 0] = "FIRST_ACTIVE";
})(NbKeyManagerActiveItemMode || (NbKeyManagerActiveItemMode = {}));
var _NbFocusMonitor = class _NbFocusMonitor extends FocusMonitor {
};
_NbFocusMonitor.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NbFocusMonitor_BaseFactory;
  return function NbFocusMonitor_Factory(__ngFactoryType__) {
    return (\u0275NbFocusMonitor_BaseFactory || (\u0275NbFocusMonitor_BaseFactory = \u0275\u0275getInheritedFactory(_NbFocusMonitor)))(__ngFactoryType__ || _NbFocusMonitor);
  };
})();
_NbFocusMonitor.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbFocusMonitor,
  factory: _NbFocusMonitor.\u0275fac
});
var NbFocusMonitor = _NbFocusMonitor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFocusMonitor, [{
    type: Injectable
  }], null, null);
})();
var _NbA11yModule = class _NbA11yModule {
  static forRoot() {
    return {
      ngModule: _NbA11yModule,
      providers: [NbFocusTrapFactoryService, NbFocusKeyManagerFactoryService, NbActiveDescendantKeyManagerFactoryService, {
        provide: NbFocusMonitor,
        useClass: FocusMonitor
      }]
    };
  }
};
_NbA11yModule.\u0275fac = function NbA11yModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbA11yModule)();
};
_NbA11yModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbA11yModule
});
_NbA11yModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var NbA11yModule = _NbA11yModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbA11yModule, [{
    type: NgModule,
    args: [{}]
  }], null, null);
})();
var _NbPortalDirective = class _NbPortalDirective extends CdkPortal {
};
_NbPortalDirective.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NbPortalDirective_BaseFactory;
  return function NbPortalDirective_Factory(__ngFactoryType__) {
    return (\u0275NbPortalDirective_BaseFactory || (\u0275NbPortalDirective_BaseFactory = \u0275\u0275getInheritedFactory(_NbPortalDirective)))(__ngFactoryType__ || _NbPortalDirective);
  };
})();
_NbPortalDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbPortalDirective,
  selectors: [["", "nbPortal", ""]],
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature]
});
var NbPortalDirective = _NbPortalDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPortalDirective, [{
    type: Directive,
    args: [{
      selector: "[nbPortal]",
      standalone: false
    }]
  }], null, null);
})();
var _NbPortalOutletDirective = class _NbPortalOutletDirective extends CdkPortalOutlet {
};
_NbPortalOutletDirective.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NbPortalOutletDirective_BaseFactory;
  return function NbPortalOutletDirective_Factory(__ngFactoryType__) {
    return (\u0275NbPortalOutletDirective_BaseFactory || (\u0275NbPortalOutletDirective_BaseFactory = \u0275\u0275getInheritedFactory(_NbPortalOutletDirective)))(__ngFactoryType__ || _NbPortalOutletDirective);
  };
})();
_NbPortalOutletDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbPortalOutletDirective,
  selectors: [["", "nbPortalOutlet", ""]],
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature]
});
var NbPortalOutletDirective = _NbPortalOutletDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPortalOutletDirective, [{
    type: Directive,
    args: [{
      selector: "[nbPortalOutlet]",
      standalone: false
    }]
  }], null, null);
})();
var NbComponentPortal = class extends ComponentPortal {
};
var _NbOverlay = class _NbOverlay extends Overlay {
};
_NbOverlay.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NbOverlay_BaseFactory;
  return function NbOverlay_Factory(__ngFactoryType__) {
    return (\u0275NbOverlay_BaseFactory || (\u0275NbOverlay_BaseFactory = \u0275\u0275getInheritedFactory(_NbOverlay)))(__ngFactoryType__ || _NbOverlay);
  };
})();
_NbOverlay.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbOverlay,
  factory: _NbOverlay.\u0275fac
});
var NbOverlay = _NbOverlay;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOverlay, [{
    type: Injectable
  }], null, null);
})();
var _NbOverlayPositionBuilder = class _NbOverlayPositionBuilder extends OverlayPositionBuilder {
};
_NbOverlayPositionBuilder.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NbOverlayPositionBuilder_BaseFactory;
  return function NbOverlayPositionBuilder_Factory(__ngFactoryType__) {
    return (\u0275NbOverlayPositionBuilder_BaseFactory || (\u0275NbOverlayPositionBuilder_BaseFactory = \u0275\u0275getInheritedFactory(_NbOverlayPositionBuilder)))(__ngFactoryType__ || _NbOverlayPositionBuilder);
  };
})();
_NbOverlayPositionBuilder.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbOverlayPositionBuilder,
  factory: _NbOverlayPositionBuilder.\u0275fac
});
var NbOverlayPositionBuilder = _NbOverlayPositionBuilder;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOverlayPositionBuilder, [{
    type: Injectable
  }], null, null);
})();
var NbTemplatePortal = class extends TemplatePortal {
  constructor(template, viewContainerRef, context) {
    super(template, viewContainerRef, context);
  }
};
var _NbOverlayContainer = class _NbOverlayContainer extends OverlayContainer {
};
_NbOverlayContainer.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NbOverlayContainer_BaseFactory;
  return function NbOverlayContainer_Factory(__ngFactoryType__) {
    return (\u0275NbOverlayContainer_BaseFactory || (\u0275NbOverlayContainer_BaseFactory = \u0275\u0275getInheritedFactory(_NbOverlayContainer)))(__ngFactoryType__ || _NbOverlayContainer);
  };
})();
_NbOverlayContainer.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbOverlayContainer,
  factory: _NbOverlayContainer.\u0275fac
});
var NbOverlayContainer = _NbOverlayContainer;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOverlayContainer, [{
    type: Injectable
  }], null, null);
})();
var NbFlexibleConnectedPositionStrategy = class extends FlexibleConnectedPositionStrategy {
};
var CDK_MODULES = [OverlayModule, PortalModule];
var _NbCdkMappingModule = class _NbCdkMappingModule {
  static forRoot() {
    return {
      ngModule: _NbCdkMappingModule,
      providers: [NbOverlay, NbOverlayPositionBuilder]
    };
  }
};
_NbCdkMappingModule.\u0275fac = function NbCdkMappingModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbCdkMappingModule)();
};
_NbCdkMappingModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbCdkMappingModule,
  declarations: [NbPortalDirective, NbPortalOutletDirective],
  imports: [OverlayModule, PortalModule],
  exports: [OverlayModule, PortalModule, NbPortalDirective, NbPortalOutletDirective]
});
_NbCdkMappingModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CDK_MODULES, OverlayModule, PortalModule]
});
var NbCdkMappingModule = _NbCdkMappingModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCdkMappingModule, [{
    type: NgModule,
    args: [{
      imports: [...CDK_MODULES],
      exports: [...CDK_MODULES, NbPortalDirective, NbPortalOutletDirective],
      declarations: [NbPortalDirective, NbPortalOutletDirective]
    }]
  }], null, null);
})();
var NbGlobalLogicalPosition;
(function(NbGlobalLogicalPosition2) {
  NbGlobalLogicalPosition2["TOP_START"] = "top-start";
  NbGlobalLogicalPosition2["TOP_END"] = "top-end";
  NbGlobalLogicalPosition2["BOTTOM_START"] = "bottom-start";
  NbGlobalLogicalPosition2["BOTTOM_END"] = "bottom-end";
})(NbGlobalLogicalPosition || (NbGlobalLogicalPosition = {}));
var NbGlobalPhysicalPosition;
(function(NbGlobalPhysicalPosition2) {
  NbGlobalPhysicalPosition2["TOP_RIGHT"] = "top-right";
  NbGlobalPhysicalPosition2["TOP_LEFT"] = "top-left";
  NbGlobalPhysicalPosition2["BOTTOM_RIGHT"] = "bottom-right";
  NbGlobalPhysicalPosition2["BOTTOM_LEFT"] = "bottom-left";
})(NbGlobalPhysicalPosition || (NbGlobalPhysicalPosition = {}));
var _NbPositionHelper = class _NbPositionHelper {
  constructor(layoutDirection) {
    this.layoutDirection = layoutDirection;
  }
  toLogicalPosition(position) {
    if (Object.values(NbGlobalLogicalPosition).includes(position)) {
      return position;
    }
    if (this.layoutDirection.isLtr()) {
      return this.toLogicalPositionWhenLtr(position);
    } else {
      return this.toLogicalPositionWhenRtl(position);
    }
  }
  toPhysicalPosition(position) {
    if (Object.values(NbGlobalPhysicalPosition).includes(position)) {
      return position;
    }
    if (this.layoutDirection.isLtr()) {
      return this.toPhysicalPositionWhenLtr(position);
    } else {
      return this.toPhysicalPositionWhenRtl(position);
    }
  }
  isTopPosition(position) {
    const logicalPosition = this.toLogicalPosition(position);
    return logicalPosition === NbGlobalLogicalPosition.TOP_END || logicalPosition === NbGlobalLogicalPosition.TOP_START;
  }
  isRightPosition(position) {
    const physicalPosition = this.toPhysicalPosition(position);
    return physicalPosition === NbGlobalPhysicalPosition.TOP_RIGHT || physicalPosition === NbGlobalPhysicalPosition.BOTTOM_RIGHT;
  }
  toLogicalPositionWhenLtr(position) {
    switch (position) {
      case NbGlobalPhysicalPosition.TOP_RIGHT:
        return NbGlobalLogicalPosition.TOP_END;
      case NbGlobalPhysicalPosition.TOP_LEFT:
        return NbGlobalLogicalPosition.TOP_START;
      case NbGlobalPhysicalPosition.BOTTOM_RIGHT:
        return NbGlobalLogicalPosition.BOTTOM_END;
      case NbGlobalPhysicalPosition.BOTTOM_LEFT:
        return NbGlobalLogicalPosition.BOTTOM_START;
    }
  }
  toLogicalPositionWhenRtl(position) {
    switch (position) {
      case NbGlobalPhysicalPosition.TOP_RIGHT:
        return NbGlobalLogicalPosition.TOP_START;
      case NbGlobalPhysicalPosition.TOP_LEFT:
        return NbGlobalLogicalPosition.TOP_END;
      case NbGlobalPhysicalPosition.BOTTOM_RIGHT:
        return NbGlobalLogicalPosition.BOTTOM_START;
      case NbGlobalPhysicalPosition.BOTTOM_LEFT:
        return NbGlobalLogicalPosition.BOTTOM_END;
    }
  }
  toPhysicalPositionWhenLtr(position) {
    switch (position) {
      case NbGlobalLogicalPosition.TOP_START:
        return NbGlobalPhysicalPosition.TOP_LEFT;
      case NbGlobalLogicalPosition.TOP_END:
        return NbGlobalPhysicalPosition.TOP_RIGHT;
      case NbGlobalLogicalPosition.BOTTOM_START:
        return NbGlobalPhysicalPosition.BOTTOM_LEFT;
      case NbGlobalLogicalPosition.BOTTOM_END:
        return NbGlobalPhysicalPosition.BOTTOM_RIGHT;
    }
  }
  toPhysicalPositionWhenRtl(position) {
    switch (position) {
      case NbGlobalLogicalPosition.TOP_START:
        return NbGlobalPhysicalPosition.TOP_RIGHT;
      case NbGlobalLogicalPosition.TOP_END:
        return NbGlobalPhysicalPosition.TOP_LEFT;
      case NbGlobalLogicalPosition.BOTTOM_START:
        return NbGlobalPhysicalPosition.BOTTOM_RIGHT;
      case NbGlobalLogicalPosition.BOTTOM_END:
        return NbGlobalPhysicalPosition.BOTTOM_LEFT;
    }
  }
};
_NbPositionHelper.\u0275fac = function NbPositionHelper_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbPositionHelper)(\u0275\u0275inject(NbLayoutDirectionService));
};
_NbPositionHelper.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbPositionHelper,
  factory: _NbPositionHelper.\u0275fac
});
var NbPositionHelper = _NbPositionHelper;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPositionHelper, [{
    type: Injectable
  }], () => [{
    type: NbLayoutDirectionService
  }], null);
})();
var _NbPlatform = class _NbPlatform extends Platform {
};
_NbPlatform.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NbPlatform_BaseFactory;
  return function NbPlatform_Factory(__ngFactoryType__) {
    return (\u0275NbPlatform_BaseFactory || (\u0275NbPlatform_BaseFactory = \u0275\u0275getInheritedFactory(_NbPlatform)))(__ngFactoryType__ || _NbPlatform);
  };
})();
_NbPlatform.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbPlatform,
  factory: (__ngFactoryType__) => Platform.\u0275fac(__ngFactoryType__),
  providedIn: "root"
});
var NbPlatform = _NbPlatform;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPlatform, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useClass: Platform
    }]
  }], null, null);
})();
var _NbViewportRulerAdapter = class _NbViewportRulerAdapter extends ViewportRuler {
  constructor(platform, ngZone, ruler, scroll, document2) {
    super(platform, ngZone, document2);
    this.ruler = ruler;
    this.scroll = scroll;
  }
  getViewportSize() {
    let res;
    this.ruler.getDimensions().pipe(map((dimensions) => ({
      width: dimensions.clientWidth,
      height: dimensions.clientHeight
    }))).subscribe((rect) => res = rect);
    return res;
  }
  getViewportScrollPosition() {
    let res;
    this.scroll.getPosition().pipe(map((position) => ({
      top: position.y,
      left: position.x
    }))).subscribe((position) => res = position);
    return res;
  }
};
_NbViewportRulerAdapter.\u0275fac = function NbViewportRulerAdapter_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbViewportRulerAdapter)(\u0275\u0275inject(NbPlatform), \u0275\u0275inject(NgZone), \u0275\u0275inject(NbLayoutRulerService), \u0275\u0275inject(NbLayoutScrollService), \u0275\u0275inject(NB_DOCUMENT));
};
_NbViewportRulerAdapter.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbViewportRulerAdapter,
  factory: _NbViewportRulerAdapter.\u0275fac
});
var NbViewportRulerAdapter = _NbViewportRulerAdapter;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbViewportRulerAdapter, [{
    type: Injectable
  }], () => [{
    type: NbPlatform
  }, {
    type: NgZone
  }, {
    type: NbLayoutRulerService
  }, {
    type: NbLayoutScrollService
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }], null);
})();
function throwLayoutNotFoundError() {
  throw new Error(`[NbOverlayContainerAdapter]: Layout not found.
  When using Nebular '<nb-layout>' is required and should wrap other nebular components.`);
}
var _NbOverlayContainerAdapter = class _NbOverlayContainerAdapter extends NbOverlayContainer {
  setContainer(container) {
    this.container = container;
  }
  clearContainer() {
    this.container = null;
    this._containerElement = null;
  }
  _createContainer() {
    this.checkContainer();
    const container = this._document.createElement("div");
    container.classList.add("cdk-overlay-container");
    this.container.appendChild(container);
    this._containerElement = container;
  }
  checkContainer() {
    if (!this.container) {
      throwLayoutNotFoundError();
    }
  }
};
_NbOverlayContainerAdapter.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NbOverlayContainerAdapter_BaseFactory;
  return function NbOverlayContainerAdapter_Factory(__ngFactoryType__) {
    return (\u0275NbOverlayContainerAdapter_BaseFactory || (\u0275NbOverlayContainerAdapter_BaseFactory = \u0275\u0275getInheritedFactory(_NbOverlayContainerAdapter)))(__ngFactoryType__ || _NbOverlayContainerAdapter);
  };
})();
_NbOverlayContainerAdapter.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbOverlayContainerAdapter,
  factory: _NbOverlayContainerAdapter.\u0275fac
});
var NbOverlayContainerAdapter = _NbOverlayContainerAdapter;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOverlayContainerAdapter, [{
    type: Injectable
  }], null, null);
})();
var NbAdjustment;
(function(NbAdjustment2) {
  NbAdjustment2["NOOP"] = "noop";
  NbAdjustment2["CLOCKWISE"] = "clockwise";
  NbAdjustment2["COUNTERCLOCKWISE"] = "counterclockwise";
  NbAdjustment2["VERTICAL"] = "vertical";
  NbAdjustment2["HORIZONTAL"] = "horizontal";
})(NbAdjustment || (NbAdjustment = {}));
var NbPosition;
(function(NbPosition2) {
  NbPosition2["TOP"] = "top";
  NbPosition2["BOTTOM"] = "bottom";
  NbPosition2["LEFT"] = "left";
  NbPosition2["RIGHT"] = "right";
  NbPosition2["START"] = "start";
  NbPosition2["END"] = "end";
  NbPosition2["TOP_END"] = "top-end";
  NbPosition2["TOP_START"] = "top-start";
  NbPosition2["BOTTOM_END"] = "bottom-end";
  NbPosition2["BOTTOM_START"] = "bottom-start";
  NbPosition2["END_TOP"] = "end-top";
  NbPosition2["END_BOTTOM"] = "end-bottom";
  NbPosition2["START_TOP"] = "start-top";
  NbPosition2["START_BOTTOM"] = "start-bottom";
})(NbPosition || (NbPosition = {}));
var POSITIONS = {
  [NbPosition.RIGHT](offset) {
    return {
      originX: "end",
      originY: "center",
      overlayX: "start",
      overlayY: "center",
      offsetX: offset
    };
  },
  [NbPosition.BOTTOM](offset) {
    return {
      originX: "center",
      originY: "bottom",
      overlayX: "center",
      overlayY: "top",
      offsetY: offset
    };
  },
  [NbPosition.LEFT](offset) {
    return {
      originX: "start",
      originY: "center",
      overlayX: "end",
      overlayY: "center",
      offsetX: -offset
    };
  },
  [NbPosition.TOP](offset) {
    return {
      originX: "center",
      originY: "top",
      overlayX: "center",
      overlayY: "bottom",
      offsetY: -offset
    };
  },
  [NbPosition.START](offset) {
    return this[NbPosition.LEFT](offset);
  },
  [NbPosition.END](offset) {
    return this[NbPosition.RIGHT](offset);
  },
  [NbPosition.END_TOP](offset) {
    return {
      originX: "end",
      originY: "bottom",
      overlayX: "start",
      overlayY: "bottom",
      offsetX: offset
    };
  },
  [NbPosition.END_BOTTOM](offset) {
    return {
      originX: "end",
      originY: "top",
      overlayX: "start",
      overlayY: "top",
      offsetX: offset
    };
  },
  [NbPosition.BOTTOM_START](offset) {
    return {
      originX: "end",
      originY: "bottom",
      overlayX: "end",
      overlayY: "top",
      offsetY: offset
    };
  },
  [NbPosition.BOTTOM_END](offset) {
    return {
      originX: "start",
      originY: "bottom",
      overlayX: "start",
      overlayY: "top",
      offsetY: offset
    };
  },
  [NbPosition.START_TOP](offset) {
    return {
      originX: "start",
      originY: "bottom",
      overlayX: "end",
      overlayY: "bottom",
      offsetX: -offset
    };
  },
  [NbPosition.START_BOTTOM](offset) {
    return {
      originX: "start",
      originY: "top",
      overlayX: "end",
      overlayY: "top",
      offsetX: -offset
    };
  },
  [NbPosition.TOP_START](offset) {
    return {
      originX: "end",
      originY: "top",
      overlayX: "end",
      overlayY: "bottom",
      offsetY: -offset
    };
  },
  [NbPosition.TOP_END](offset) {
    return {
      originX: "start",
      originY: "top",
      overlayX: "start",
      overlayY: "bottom",
      offsetY: -offset
    };
  }
};
var RTL_PHYSICAL_POSITIONS = __spreadProps(__spreadValues({}, POSITIONS), {
  [NbPosition.RIGHT](offset) {
    return {
      originX: "start",
      originY: "center",
      overlayX: "end",
      overlayY: "center",
      offsetX: offset
    };
  },
  [NbPosition.LEFT](offset) {
    return {
      originX: "end",
      originY: "center",
      overlayX: "start",
      overlayY: "center",
      offsetX: -offset
    };
  },
  [NbPosition.START](offset) {
    return this[NbPosition.RIGHT](offset);
  },
  [NbPosition.END](offset) {
    return this[NbPosition.LEFT](offset);
  }
});
var COUNTER_CLOCKWISE_POSITIONS = [NbPosition.TOP, NbPosition.TOP_END, NbPosition.TOP_START, NbPosition.START, NbPosition.START_TOP, NbPosition.START_BOTTOM, NbPosition.BOTTOM, NbPosition.BOTTOM_START, NbPosition.BOTTOM_END, NbPosition.END, NbPosition.END_BOTTOM, NbPosition.END_TOP];
var CLOCKWISE_POSITIONS = [NbPosition.TOP, NbPosition.TOP_START, NbPosition.TOP_END, NbPosition.END, NbPosition.END_TOP, NbPosition.END_BOTTOM, NbPosition.BOTTOM, NbPosition.BOTTOM_END, NbPosition.BOTTOM_START, NbPosition.START, NbPosition.START_BOTTOM, NbPosition.START_TOP];
var VERTICAL_POSITIONS = [NbPosition.BOTTOM, NbPosition.TOP];
var HORIZONTAL_POSITIONS = [NbPosition.START, NbPosition.END];
function comparePositions(p1, p2) {
  return p1.originX === p2.originX && p1.originY === p2.originY && p1.overlayX === p2.overlayX && p1.overlayY === p2.overlayY;
}
var NbAdjustableConnectedPositionStrategy = class extends NbFlexibleConnectedPositionStrategy {
  constructor() {
    super(...arguments);
    this._offset = 15;
    this.positionChange = this.positionChanges.pipe(map((positionChange) => positionChange.connectionPair), map((connectionPair) => {
      return this.appliedPositions.find(({
        connectedPosition
      }) => {
        return comparePositions(connectedPosition, connectionPair);
      }).key;
    }));
  }
  attach(overlayRef) {
    this.applyPositions();
    super.attach(overlayRef);
  }
  direction(direction) {
    this._direction = direction;
    return this;
  }
  apply() {
    this.applyPositions();
    super.apply();
  }
  position(position) {
    this._position = position;
    return this;
  }
  adjustment(adjustment) {
    this._adjustment = adjustment;
    return this;
  }
  offset(offset) {
    this._offset = offset;
    return this;
  }
  applyPositions() {
    const positions = this.createPositions();
    this.persistChosenPositions(positions);
    this.withPositions(this.appliedPositions.map(({
      connectedPosition
    }) => connectedPosition));
  }
  createPositions() {
    switch (this._adjustment) {
      case NbAdjustment.NOOP:
        return [this._position];
      case NbAdjustment.CLOCKWISE:
        return this.reorderPreferredPositions(CLOCKWISE_POSITIONS);
      case NbAdjustment.COUNTERCLOCKWISE:
        return this.reorderPreferredPositions(COUNTER_CLOCKWISE_POSITIONS);
      case NbAdjustment.HORIZONTAL:
        return this.reorderPreferredPositions(HORIZONTAL_POSITIONS);
      case NbAdjustment.VERTICAL:
        return this.reorderPreferredPositions(VERTICAL_POSITIONS);
    }
  }
  mapToLogicalPosition(position) {
    if (position === NbPosition.LEFT) {
      return this._direction === NbLayoutDirection.LTR ? NbPosition.START : NbPosition.END;
    }
    if (position === NbPosition.RIGHT) {
      return this._direction === NbLayoutDirection.LTR ? NbPosition.END : NbPosition.START;
    }
    return position;
  }
  persistChosenPositions(positions) {
    const positionGrid = this._direction === NbLayoutDirection.RTL ? RTL_PHYSICAL_POSITIONS : POSITIONS;
    this.appliedPositions = positions.map((position) => ({
      key: position,
      connectedPosition: positionGrid[position](this._offset)
    }));
  }
  reorderPreferredPositions(positions) {
    const startPosition = this.mapToLogicalPosition(this._position);
    const startPositionIndex = positions.indexOf(startPosition);
    const firstPart = positions.slice(startPositionIndex);
    const secondPart = positions.slice(0, startPositionIndex);
    return firstPart.concat(secondPart);
  }
};
var NbGlobalPositionStrategy = class extends GlobalPositionStrategy {
  position(position) {
    switch (position) {
      case NbGlobalLogicalPosition.TOP_START:
        return this.top().left();
      case NbGlobalLogicalPosition.TOP_END:
        return this.top().right();
      case NbGlobalLogicalPosition.BOTTOM_START:
        return this.bottom().left();
      case NbGlobalLogicalPosition.BOTTOM_END:
        return this.bottom().right();
    }
  }
};
var _NbPositionBuilderService = class _NbPositionBuilderService {
  constructor(document2, viewportRuler, platform, positionBuilder, overlayContainer) {
    this.document = document2;
    this.viewportRuler = viewportRuler;
    this.platform = platform;
    this.positionBuilder = positionBuilder;
    this.overlayContainer = overlayContainer;
  }
  global() {
    return new NbGlobalPositionStrategy();
  }
  connectedTo(elementRef) {
    return new NbAdjustableConnectedPositionStrategy(elementRef, this.viewportRuler, this.document, this.platform, this.overlayContainer).withFlexibleDimensions(false).withPush(false);
  }
};
_NbPositionBuilderService.\u0275fac = function NbPositionBuilderService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbPositionBuilderService)(\u0275\u0275inject(NB_DOCUMENT), \u0275\u0275inject(NbViewportRulerAdapter), \u0275\u0275inject(NbPlatform), \u0275\u0275inject(NbOverlayPositionBuilder), \u0275\u0275inject(NbOverlayContainerAdapter));
};
_NbPositionBuilderService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbPositionBuilderService,
  factory: _NbPositionBuilderService.\u0275fac
});
var NbPositionBuilderService = _NbPositionBuilderService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPositionBuilderService, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: NbViewportRulerAdapter
  }, {
    type: NbPlatform
  }, {
    type: NbOverlayPositionBuilder
  }, {
    type: NbOverlayContainerAdapter
  }], null);
})();
var _NbPositionedContainerComponent = class _NbPositionedContainerComponent {
  get top() {
    return this.position === NbPosition.TOP;
  }
  get topStart() {
    return this.position === NbPosition.TOP_START;
  }
  get topEnd() {
    return this.position === NbPosition.TOP_END;
  }
  get right() {
    return this.position === NbPosition.RIGHT || this.position === NbPosition.END;
  }
  get endTop() {
    return this.position === NbPosition.END_TOP;
  }
  get endBottom() {
    return this.position === NbPosition.END_BOTTOM;
  }
  get bottom() {
    return this.position === NbPosition.BOTTOM;
  }
  get bottomStart() {
    return this.position === NbPosition.BOTTOM_START;
  }
  get bottomEnd() {
    return this.position === NbPosition.BOTTOM_END;
  }
  get left() {
    return this.position === NbPosition.LEFT || this.position === NbPosition.START;
  }
  get startTop() {
    return this.position === NbPosition.START_TOP;
  }
  get startBottom() {
    return this.position === NbPosition.START_BOTTOM;
  }
};
_NbPositionedContainerComponent.\u0275fac = function NbPositionedContainerComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbPositionedContainerComponent)();
};
_NbPositionedContainerComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbPositionedContainerComponent,
  selectors: [["ng-component"]],
  hostVars: 24,
  hostBindings: function NbPositionedContainerComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("nb-overlay-top", ctx.top)("nb-overlay-top-start", ctx.topStart)("nb-overlay-top-end", ctx.topEnd)("nb-overlay-right", ctx.right)("nb-overlay-end-top", ctx.endTop)("nb-overlay-end-bottom", ctx.endBottom)("nb-overlay-bottom", ctx.bottom)("nb-overlay-bottom-start", ctx.bottomStart)("nb-overlay-bottom-end", ctx.bottomEnd)("nb-overlay-left", ctx.left)("nb-overlay-start-top", ctx.startTop)("nb-overlay-start-bottom", ctx.startBottom);
    }
  },
  inputs: {
    position: "position"
  },
  standalone: false,
  decls: 0,
  vars: 0,
  template: function NbPositionedContainerComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
var NbPositionedContainerComponent = _NbPositionedContainerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPositionedContainerComponent, [{
    type: Component,
    args: [{
      template: "",
      standalone: false
    }]
  }], null, {
    position: [{
      type: Input
    }],
    top: [{
      type: HostBinding,
      args: ["class.nb-overlay-top"]
    }],
    topStart: [{
      type: HostBinding,
      args: ["class.nb-overlay-top-start"]
    }],
    topEnd: [{
      type: HostBinding,
      args: ["class.nb-overlay-top-end"]
    }],
    right: [{
      type: HostBinding,
      args: ["class.nb-overlay-right"]
    }],
    endTop: [{
      type: HostBinding,
      args: ["class.nb-overlay-end-top"]
    }],
    endBottom: [{
      type: HostBinding,
      args: ["class.nb-overlay-end-bottom"]
    }],
    bottom: [{
      type: HostBinding,
      args: ["class.nb-overlay-bottom"]
    }],
    bottomStart: [{
      type: HostBinding,
      args: ["class.nb-overlay-bottom-start"]
    }],
    bottomEnd: [{
      type: HostBinding,
      args: ["class.nb-overlay-bottom-end"]
    }],
    left: [{
      type: HostBinding,
      args: ["class.nb-overlay-left"]
    }],
    startTop: [{
      type: HostBinding,
      args: ["class.nb-overlay-start-top"]
    }],
    startBottom: [{
      type: HostBinding,
      args: ["class.nb-overlay-start-bottom"]
    }]
  });
})();
var _NbOverlayContainerComponent = class _NbOverlayContainerComponent {
  constructor(vcr, injector, changeDetectorRef) {
    this.vcr = vcr;
    this.injector = injector;
    this.changeDetectorRef = changeDetectorRef;
    this.isAttached = false;
  }
  get isStringContent() {
    return !!this.content;
  }
  attachComponentPortal(portal, context) {
    portal.injector = this.createChildInjector();
    const componentRef = this.portalOutlet.attachComponentPortal(portal);
    if (context) {
      Object.assign(componentRef.instance, context);
    }
    componentRef.changeDetectorRef.markForCheck();
    componentRef.changeDetectorRef.detectChanges();
    this.isAttached = true;
    return componentRef;
  }
  attachTemplatePortal(portal) {
    const templateRef = this.portalOutlet.attachTemplatePortal(portal);
    templateRef.detectChanges();
    this.isAttached = true;
    return templateRef;
  }
  attachStringContent(content) {
    this.content = content;
    this.changeDetectorRef.markForCheck();
    this.changeDetectorRef.detectChanges();
    this.isAttached = true;
  }
  detach() {
    if (this.portalOutlet.hasAttached()) {
      this.portalOutlet.detach();
    }
    this.attachStringContent(null);
    this.isAttached = false;
  }
  createChildInjector() {
    return Injector.create({
      parent: this.injector,
      providers: []
    });
  }
};
_NbOverlayContainerComponent.\u0275fac = function NbOverlayContainerComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbOverlayContainerComponent)(\u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(Injector), \u0275\u0275directiveInject(ChangeDetectorRef));
};
_NbOverlayContainerComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbOverlayContainerComponent,
  selectors: [["nb-overlay-container"]],
  viewQuery: function NbOverlayContainerComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(NbPortalOutletDirective, 7);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.portalOutlet = _t.first);
    }
  },
  standalone: false,
  decls: 2,
  vars: 1,
  consts: [["class", "primitive-overlay", 4, "ngIf"], ["nbPortalOutlet", ""], [1, "primitive-overlay"]],
  template: function NbOverlayContainerComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NbOverlayContainerComponent_div_0_Template, 2, 1, "div", 0)(1, NbOverlayContainerComponent_ng_template_1_Template, 0, 0, "ng-template", 1);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.isStringContent);
    }
  },
  dependencies: [NbPortalOutletDirective, NgIf],
  encapsulation: 2
});
var NbOverlayContainerComponent = _NbOverlayContainerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOverlayContainerComponent, [{
    type: Component,
    args: [{
      selector: "nb-overlay-container",
      template: `
    <div *ngIf="isStringContent" class="primitive-overlay">{{ content }}</div>
    <ng-template nbPortalOutlet></ng-template>
  `,
      standalone: false
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: Injector
  }, {
    type: ChangeDetectorRef
  }], {
    portalOutlet: [{
      type: ViewChild,
      args: [NbPortalOutletDirective, {
        static: true
      }]
    }]
  });
})();
function patch(container, containerContext) {
  Object.assign(container.instance, containerContext);
  container.changeDetectorRef.detectChanges();
  return container;
}
function createContainer(ref, container, context) {
  const containerRef = ref.attach(new NbComponentPortal(container, null, null));
  patch(containerRef, context);
  return containerRef;
}
var _NbOverlayService = class _NbOverlayService {
  constructor(overlay, layoutDirection) {
    this.overlay = overlay;
    this.layoutDirection = layoutDirection;
  }
  get scrollStrategies() {
    return this.overlay.scrollStrategies;
  }
  create(config) {
    const overlayRef = this.overlay.create(config);
    this.layoutDirection.onDirectionChange().subscribe((dir) => overlayRef.setDirection(dir));
    return overlayRef;
  }
};
_NbOverlayService.\u0275fac = function NbOverlayService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbOverlayService)(\u0275\u0275inject(NbOverlay), \u0275\u0275inject(NbLayoutDirectionService));
};
_NbOverlayService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbOverlayService,
  factory: _NbOverlayService.\u0275fac
});
var NbOverlayService = _NbOverlayService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOverlayService, [{
    type: Injectable
  }], () => [{
    type: NbOverlay
  }, {
    type: NbLayoutDirectionService
  }], null);
})();
var _NbScrollDispatcherAdapter = class _NbScrollDispatcherAdapter extends ScrollDispatcher {
  constructor(ngZone, platform, scrollService, document2) {
    super(ngZone, platform, document2);
    this.scrollService = scrollService;
  }
  scrolled(auditTimeInMs) {
    return merge(super.scrolled(auditTimeInMs), this.scrollService.onScroll());
  }
};
_NbScrollDispatcherAdapter.\u0275fac = function NbScrollDispatcherAdapter_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbScrollDispatcherAdapter)(\u0275\u0275inject(NgZone), \u0275\u0275inject(NbPlatform), \u0275\u0275inject(NbLayoutScrollService), \u0275\u0275inject(NB_DOCUMENT));
};
_NbScrollDispatcherAdapter.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbScrollDispatcherAdapter,
  factory: _NbScrollDispatcherAdapter.\u0275fac
});
var NbScrollDispatcherAdapter = _NbScrollDispatcherAdapter;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbScrollDispatcherAdapter, [{
    type: Injectable
  }], () => [{
    type: NgZone
  }, {
    type: NbPlatform
  }, {
    type: NbLayoutScrollService
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }], null);
})();
var _NbBlockScrollStrategyAdapter = class _NbBlockScrollStrategyAdapter extends BlockScrollStrategy {
  constructor(document2, viewportRuler, scrollService) {
    super(viewportRuler, document2);
    this.scrollService = scrollService;
  }
  enable() {
    super.enable();
    this.scrollService.scrollable(false);
  }
  disable() {
    super.disable();
    this.scrollService.scrollable(true);
  }
};
_NbBlockScrollStrategyAdapter.\u0275fac = function NbBlockScrollStrategyAdapter_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbBlockScrollStrategyAdapter)(\u0275\u0275inject(NB_DOCUMENT), \u0275\u0275inject(NbViewportRulerAdapter), \u0275\u0275inject(NbLayoutScrollService));
};
_NbBlockScrollStrategyAdapter.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbBlockScrollStrategyAdapter,
  factory: _NbBlockScrollStrategyAdapter.\u0275fac
});
var NbBlockScrollStrategyAdapter = _NbBlockScrollStrategyAdapter;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbBlockScrollStrategyAdapter, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: NbViewportRulerAdapter
  }, {
    type: NbLayoutScrollService
  }], null);
})();
var _NbScrollStrategyOptions = class _NbScrollStrategyOptions extends ScrollStrategyOptions {
  constructor(scrollService, scrollDispatcher, viewportRuler, ngZone, document2) {
    super(scrollDispatcher, viewportRuler, ngZone, document2);
    this.scrollService = scrollService;
    this.scrollDispatcher = scrollDispatcher;
    this.viewportRuler = viewportRuler;
    this.ngZone = ngZone;
    this.document = document2;
    this.block = () => new NbBlockScrollStrategyAdapter(this.document, this.viewportRuler, this.scrollService);
  }
};
_NbScrollStrategyOptions.\u0275fac = function NbScrollStrategyOptions_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbScrollStrategyOptions)(\u0275\u0275inject(NbLayoutScrollService), \u0275\u0275inject(ScrollDispatcher), \u0275\u0275inject(NbViewportRulerAdapter), \u0275\u0275inject(NgZone), \u0275\u0275inject(NB_DOCUMENT));
};
_NbScrollStrategyOptions.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbScrollStrategyOptions,
  factory: _NbScrollStrategyOptions.\u0275fac
});
var NbScrollStrategyOptions = _NbScrollStrategyOptions;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbScrollStrategyOptions, [{
    type: Injectable
  }], () => [{
    type: NbLayoutScrollService
  }, {
    type: ScrollDispatcher
  }, {
    type: NbViewportRulerAdapter
  }, {
    type: NgZone
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }], null);
})();
var _NbCdkAdapterModule = class _NbCdkAdapterModule {
  static forRoot() {
    return {
      ngModule: _NbCdkAdapterModule,
      providers: [NbViewportRulerAdapter, NbOverlayContainerAdapter, NbBlockScrollStrategyAdapter, NbScrollDispatcherAdapter, NbScrollStrategyOptions, {
        provide: OverlayContainer,
        useExisting: NbOverlayContainerAdapter
      }, {
        provide: NbOverlayContainer,
        useExisting: NbOverlayContainerAdapter
      }, {
        provide: ScrollDispatcher,
        useExisting: NbScrollDispatcherAdapter
      }, {
        provide: ScrollStrategyOptions,
        useExisting: NbScrollStrategyOptions
      }]
    };
  }
};
_NbCdkAdapterModule.\u0275fac = function NbCdkAdapterModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbCdkAdapterModule)();
};
_NbCdkAdapterModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbCdkAdapterModule
});
_NbCdkAdapterModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var NbCdkAdapterModule = _NbCdkAdapterModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCdkAdapterModule, [{
    type: NgModule,
    args: [{}]
  }], null, null);
})();
var NbTrigger;
(function(NbTrigger2) {
  NbTrigger2["NOOP"] = "noop";
  NbTrigger2["CLICK"] = "click";
  NbTrigger2["HOVER"] = "hover";
  NbTrigger2["HINT"] = "hint";
  NbTrigger2["FOCUS"] = "focus";
})(NbTrigger || (NbTrigger = {}));
var NbTriggerStrategyBase = class {
  destroy() {
    this.destroyed$.next();
  }
  isNotOnHostOrContainer(element) {
    return !this.isOnHost(element) && !this.isOnContainer(element);
  }
  isOnHostOrContainer(element) {
    return this.isOnHost(element) || this.isOnContainer(element);
  }
  isOnHost(element) {
    return this.host.contains(element);
  }
  isOnContainer(element) {
    return this.container() && this.container().location.nativeElement.contains(element);
  }
  constructor(document2, host, container) {
    this.document = document2;
    this.host = host;
    this.container = container;
    this.destroyed$ = new Subject();
  }
};
var NbClickTriggerStrategy = class extends NbTriggerStrategyBase {
  constructor() {
    super(...arguments);
    this.click$ = fromEvent(this.document, "click").pipe(map((event) => [!this.container() && this.isOnHost(event.target), event]), share(), takeUntil(this.destroyed$));
    this.show$ = this.click$.pipe(filter(([shouldShow]) => shouldShow), map(([, event]) => event), takeUntil(this.destroyed$));
    this.hide$ = this.click$.pipe(filter(([shouldShow, event]) => !shouldShow && !this.isOnContainer(event.target)), map(([, event]) => event), takeUntil(this.destroyed$));
  }
};
var NbHoverTriggerStrategy = class extends NbTriggerStrategyBase {
  constructor() {
    super(...arguments);
    this.show$ = fromEvent(this.host, "mouseenter").pipe(
      filter(() => !this.container()),
      // this `delay & takeUntil & repeat` operators combination is a synonym for `conditional debounce`
      // meaning that if one event occurs in some time after the initial one we won't react to it
      delay(100),
      // eslint-disable-next-line rxjs/no-unsafe-takeuntil
      takeUntil(fromEvent(this.host, "mouseleave")),
      repeat(),
      takeUntil(this.destroyed$)
    );
    this.hide$ = fromEvent(this.host, "mouseleave").pipe(switchMap(() => fromEvent(this.document, "mousemove").pipe(debounceTime(100), takeWhile(() => !!this.container()), filter((event) => this.isNotOnHostOrContainer(event.target)))), takeUntil(this.destroyed$));
  }
};
var NbHintTriggerStrategy = class extends NbTriggerStrategyBase {
  constructor() {
    super(...arguments);
    this.show$ = fromEvent(this.host, "mouseenter").pipe(
      // this `delay & takeUntil & repeat` operators combination is a synonym for `conditional debounce`
      // meaning that if one event occurs in some time after the initial one we won't react to it
      delay(100),
      // eslint-disable-next-line rxjs/no-unsafe-takeuntil
      takeUntil(fromEvent(this.host, "mouseleave")),
      repeat(),
      takeUntil(this.destroyed$)
    );
    this.hide$ = fromEvent(this.host, "mouseleave").pipe(takeUntil(this.destroyed$));
  }
};
var NbFocusTriggerStrategy = class extends NbTriggerStrategyBase {
  constructor() {
    super(...arguments);
    this.focusOut$ = fromEvent(this.host, "focusout").pipe(switchMap(() => fromEvent(this.document, "focusin").pipe(takeWhile(() => !!this.container()), filter((event) => this.isNotOnHostOrContainer(event.target)))), takeUntil(this.destroyed$));
    this.clickIn$ = fromEvent(this.host, "click").pipe(filter(() => !this.container()), takeUntil(this.destroyed$));
    this.clickOut$ = fromEvent(this.document, "click").pipe(
      filter(() => !!this.container()),
      /**
       * Event target of `click` could be different from `activeElement`.
       * If during click you return focus to the host, it won't be opened.
       */
      filter((event) => {
        if (this.isNotOnHostOrContainer(event.target)) {
          return this.isNotOnHostOrContainer(this.document.activeElement);
        }
        return false;
      }),
      takeUntil(this.destroyed$)
    );
    this.tabKeyPress$ = fromEvent(this.document, "keydown").pipe(filter((event) => event.keyCode === 9), filter(() => !!this.container()), takeUntil(this.destroyed$));
    this.show$ = merge(fromEvent(this.host, "focusin"), this.clickIn$).pipe(
      filter(() => !this.container()),
      debounceTime(100),
      // eslint-disable-next-line rxjs/no-unsafe-takeuntil
      takeUntil(fromEvent(this.host, "focusout")),
      repeat(),
      takeUntil(this.destroyed$)
    );
    this.hide$ = merge(this.focusOut$, this.tabKeyPress$, this.clickOut$).pipe(takeUntil(this.destroyed$));
  }
};
var NbNoopTriggerStrategy = class extends NbTriggerStrategyBase {
  constructor() {
    super(...arguments);
    this.show$ = EMPTY;
    this.hide$ = EMPTY;
  }
};
var _NbTriggerStrategyBuilderService = class _NbTriggerStrategyBuilderService {
  constructor(_document2) {
    this._document = _document2;
  }
  trigger(trigger2) {
    this._trigger = trigger2;
    return this;
  }
  host(host) {
    this._host = host;
    return this;
  }
  container(container) {
    this._container = container;
    return this;
  }
  build() {
    switch (this._trigger) {
      case NbTrigger.CLICK:
        return new NbClickTriggerStrategy(this._document, this._host, this._container);
      case NbTrigger.HINT:
        return new NbHintTriggerStrategy(this._document, this._host, this._container);
      case NbTrigger.HOVER:
        return new NbHoverTriggerStrategy(this._document, this._host, this._container);
      case NbTrigger.FOCUS:
        return new NbFocusTriggerStrategy(this._document, this._host, this._container);
      case NbTrigger.NOOP:
        return new NbNoopTriggerStrategy(this._document, this._host, this._container);
      default:
        throw new Error("Trigger have to be provided");
    }
  }
};
_NbTriggerStrategyBuilderService.\u0275fac = function NbTriggerStrategyBuilderService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbTriggerStrategyBuilderService)(\u0275\u0275inject(NB_DOCUMENT));
};
_NbTriggerStrategyBuilderService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbTriggerStrategyBuilderService,
  factory: _NbTriggerStrategyBuilderService.\u0275fac
});
var NbTriggerStrategyBuilderService = _NbTriggerStrategyBuilderService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTriggerStrategyBuilderService, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }], null);
})();
var _NbOverlayModule = class _NbOverlayModule {
  static forRoot() {
    return {
      ngModule: _NbOverlayModule,
      providers: [NbPositionBuilderService, NbTriggerStrategyBuilderService, NbOverlayService, NbPositionHelper, ...NbCdkMappingModule.forRoot().providers, ...NbCdkAdapterModule.forRoot().providers, ...NbA11yModule.forRoot().providers]
    };
  }
};
_NbOverlayModule.\u0275fac = function NbOverlayModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbOverlayModule)();
};
_NbOverlayModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbOverlayModule,
  declarations: [NbPositionedContainerComponent, NbOverlayContainerComponent],
  imports: [NbCdkMappingModule, NbSharedModule],
  exports: [NbCdkMappingModule, NbCdkAdapterModule, NbOverlayContainerComponent]
});
_NbOverlayModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NbCdkMappingModule, NbSharedModule, NbCdkMappingModule, NbCdkAdapterModule]
});
var NbOverlayModule = _NbOverlayModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOverlayModule, [{
    type: NgModule,
    args: [{
      imports: [NbCdkMappingModule, NbSharedModule],
      declarations: [NbPositionedContainerComponent, NbOverlayContainerComponent],
      exports: [NbCdkMappingModule, NbCdkAdapterModule, NbOverlayContainerComponent]
    }]
  }], null, null);
})();
var _NbStatusService = class _NbStatusService {
  constructor() {
    this.coreStatuses = ["basic", "primary", "info", "warning", "danger", "control"];
  }
  isCoreStatus(status) {
    return this.coreStatuses.includes(status);
  }
  isCustomStatus(status) {
    if (this.isValidStatusString(status)) {
      return !this.isCoreStatus(status);
    }
    return false;
  }
  getStatusClass(status) {
    if (this.isValidStatusString(status)) {
      return `status-${status}`;
    }
    return void 0;
  }
  isValidStatusString(status) {
    return typeof status === "string" && status.length > 0;
  }
};
_NbStatusService.\u0275fac = function NbStatusService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbStatusService)();
};
_NbStatusService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbStatusService,
  factory: _NbStatusService.\u0275fac
});
var NbStatusService = _NbStatusService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbStatusService, [{
    type: Injectable
  }], null, null);
})();
function windowFactory(platformId) {
  if (isPlatformBrowser(platformId)) {
    return window;
  }
  return void 0;
}
var _NbThemeModule = class _NbThemeModule {
  // TODO: check the options (throw exception?)
  /**
   * Main Theme Module
   *
   * @param nbThemeOptions {NbThemeOptions} Main theme options
   * @param nbJSThemes {NbJSThemeOptions[]} List of JS Themes, will be merged with default themes
   * @param nbMediaBreakpoints {NbMediaBreakpoint} Available media breakpoints
   * @param layoutDirection {NbLayoutDirection} Layout direction
   *
   * @returns {ModuleWithProviders}
   */
  static forRoot(nbThemeOptions = {
    name: "default"
  }, nbJSThemes, nbMediaBreakpoints, layoutDirection) {
    return {
      ngModule: _NbThemeModule,
      providers: [{
        provide: NB_THEME_OPTIONS,
        useValue: nbThemeOptions || {}
      }, {
        provide: NB_BUILT_IN_JS_THEMES,
        useValue: BUILT_IN_THEMES
      }, {
        provide: NB_JS_THEMES,
        useValue: nbJSThemes || []
      }, {
        provide: NB_MEDIA_BREAKPOINTS,
        useValue: nbMediaBreakpoints || DEFAULT_MEDIA_BREAKPOINTS
      }, {
        provide: NB_DOCUMENT,
        useExisting: DOCUMENT
      }, {
        provide: NB_WINDOW,
        useFactory: windowFactory,
        deps: [PLATFORM_ID]
      }, NbJSThemesRegistry, NbThemeService, NbMediaBreakpointsService, NbSpinnerService, {
        provide: NB_LAYOUT_DIRECTION,
        useValue: layoutDirection || NbLayoutDirection.LTR
      }, NbLayoutDirectionService, NbLayoutScrollService, NbLayoutRulerService, ...NbOverlayModule.forRoot().providers, NbStatusService]
    };
  }
};
_NbThemeModule.\u0275fac = function NbThemeModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbThemeModule)();
};
_NbThemeModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbThemeModule,
  imports: [CommonModule]
});
_NbThemeModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule]
});
var NbThemeModule = _NbThemeModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbThemeModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      exports: []
    }]
  }], null, null);
})();
var NbIconPackType;
(function(NbIconPackType2) {
  NbIconPackType2["SVG"] = "svg";
  NbIconPackType2["FONT"] = "font";
})(NbIconPackType || (NbIconPackType = {}));
var NbFontIcon = class {
  constructor(name, content, params = {}) {
    this.name = name;
    this.content = content;
    this.params = params;
  }
  getClasses(options) {
    const classes = [];
    if (this.params.packClass) {
      classes.push(this.params.packClass);
    }
    const name = this.params.iconClassPrefix ? `${this.params.iconClassPrefix}-${this.name}` : this.name;
    classes.push(name);
    return classes;
  }
  getContent(options) {
    return this.content;
  }
};
var NbSvgIcon = class {
  constructor(name, content, params = {}) {
    this.name = name;
    this.content = content;
    this.params = params;
  }
  getClasses(options) {
    const classes = [];
    if (this.params.packClass) {
      classes.push(this.params.packClass);
    }
    return classes;
  }
  getContent(options) {
    return this.content;
  }
};
function throwPackNotFoundError(name) {
  throw Error(`Icon Pack '${name}' is not registered`);
}
function throwNoDefaultPackError() {
  throw Error("Default pack is not registered.");
}
function throwWrongPackTypeError(name, type, desiredType) {
  throw Error(`Pack '${name}' is not an '${desiredType}' Pack and its type is '${type}'`);
}
var _NbIconLibraries = class _NbIconLibraries {
  constructor() {
    this.packs = /* @__PURE__ */ new Map();
  }
  /**
   * Registers new Svg icon pack
   * @param {string} name
   * @param {NbIcon} icons
   * @param {NbIconPackParams} params
   */
  registerSvgPack(name, icons2, params = {}) {
    this.packs.set(name, {
      name,
      icons: new Map(Object.entries(icons2)),
      params,
      type: NbIconPackType.SVG
    });
  }
  /**
   * Registers new font pack
   * @param {string} name
   * @param {NbIconPackParams} params
   */
  registerFontPack(name, params = {}) {
    this.packs.set(name, {
      name,
      params,
      icons: /* @__PURE__ */ new Map(),
      type: NbIconPackType.FONT
    });
  }
  /**
   * Returns pack by name
   * @param {string} name
   */
  getPack(name) {
    return this.packs.get(name);
  }
  /**
   * Sets pack as a default
   * @param {string} name
   */
  setDefaultPack(name) {
    if (!this.packs.has(name)) {
      throwPackNotFoundError(name);
    }
    this.defaultPack = this.packs.get(name);
  }
  /**
   * Returns Svg icon
   * @param {string} name
   * @param {string} pack
   *
   * @returns NbIconDefinition
   */
  getSvgIcon(name, pack) {
    const iconsPack = pack ? this.getPackOrThrow(pack) : this.getDefaultPackOrThrow();
    if (iconsPack.type !== NbIconPackType.SVG) {
      throwWrongPackTypeError(iconsPack.name, iconsPack.type, "SVG");
    }
    const icon = this.getIconFromPack(name, iconsPack);
    if (!icon) {
      return null;
    }
    return {
      name,
      pack: iconsPack.name,
      type: NbIconPackType.SVG,
      icon: this.createSvgIcon(name, icon, iconsPack.params)
    };
  }
  /**
   * Returns Font icon
   * @param {string} name
   * @param {string} pack
   *
   * @returns NbIconDefinition
   */
  getFontIcon(name, pack) {
    const iconsPack = pack ? this.getPackOrThrow(pack) : this.getDefaultPackOrThrow();
    if (iconsPack.type !== NbIconPackType.FONT) {
      throwWrongPackTypeError(iconsPack.name, iconsPack.type, "Font");
    }
    const icon = this.getIconFromPack(name, iconsPack) ?? "";
    const iconContent = iconsPack.params.ligature ? name : icon;
    return {
      name,
      pack: iconsPack.name,
      type: NbIconPackType.FONT,
      icon: this.createFontIcon(name, iconContent, iconsPack.params)
    };
  }
  /**
   * Returns an icon
   * @param {string} name
   * @param {string} pack
   *
   * @returns NbIconDefinition
   */
  getIcon(name, pack) {
    const iconsPack = pack ? this.getPackOrThrow(pack) : this.getDefaultPackOrThrow();
    if (iconsPack.type === NbIconPackType.SVG) {
      return this.getSvgIcon(name, pack);
    }
    return this.getFontIcon(name, pack);
  }
  createSvgIcon(name, content, params) {
    return content instanceof NbSvgIcon ? content : new NbSvgIcon(name, content, params);
  }
  createFontIcon(name, content, params) {
    return content instanceof NbFontIcon ? content : new NbFontIcon(name, content, params);
  }
  getPackOrThrow(name) {
    const pack = this.packs.get(name);
    if (!pack) {
      throwPackNotFoundError(name);
    }
    return pack;
  }
  getDefaultPackOrThrow() {
    if (!this.defaultPack) {
      throwNoDefaultPackError();
    }
    return this.defaultPack;
  }
  getIconFromPack(name, pack) {
    if (pack.icons.has(name)) {
      return pack.icons.get(name);
    }
    return null;
  }
};
_NbIconLibraries.\u0275fac = function NbIconLibraries_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbIconLibraries)();
};
_NbIconLibraries.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbIconLibraries,
  factory: _NbIconLibraries.\u0275fac,
  providedIn: "root"
});
var NbIconLibraries = _NbIconLibraries;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbIconLibraries, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _NbIconComponent = class _NbIconComponent {
  get primary() {
    return this.status === "primary";
  }
  get info() {
    return this.status === "info";
  }
  get success() {
    return this.status === "success";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  /**
   * Sets all icon configurable properties via config object.
   * If passed value is a string set icon name.
   * @docs-private
   */
  get config() {
    return this._config;
  }
  set config(value) {
    if (!value) {
      return;
    }
    this._config = value;
    if (typeof value === "string") {
      this.icon = value;
    } else {
      this.icon = value.icon;
      this.pack = value.pack;
      this.status = value.status;
      this.options = value.options;
    }
  }
  constructor(sanitizer, iconLibrary, el, renderer, statusService) {
    this.sanitizer = sanitizer;
    this.iconLibrary = iconLibrary;
    this.el = el;
    this.renderer = renderer;
    this.statusService = statusService;
    this.prevClasses = [];
    this.html = "";
  }
  ngOnInit() {
    this.iconDef = this.renderIcon(this.icon, this.pack, this.options);
  }
  ngOnChanges() {
    const iconDef = this.iconLibrary.getIcon(this.icon, this.pack);
    if (iconDef) {
      this.renderIcon(this.icon, this.pack, this.options);
    } else {
      this.clearIcon();
    }
  }
  renderIcon(name, pack, options) {
    const iconDefinition = this.iconLibrary.getIcon(name, pack);
    if (!iconDefinition) {
      return void 0;
    }
    const content = iconDefinition.icon.getContent(options);
    if (content) {
      this.html = this.sanitizer.bypassSecurityTrustHtml(content);
    }
    this.assignClasses(iconDefinition.icon.getClasses(options));
    return iconDefinition;
  }
  clearIcon() {
    this.html = "";
    this.assignClasses([]);
  }
  assignClasses(classes) {
    this.prevClasses.forEach((className) => {
      this.renderer.removeClass(this.el.nativeElement, className);
    });
    classes.forEach((className) => {
      this.renderer.addClass(this.el.nativeElement, className);
    });
    this.prevClasses = classes;
  }
};
_NbIconComponent.\u0275fac = function NbIconComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbIconComponent)(\u0275\u0275directiveInject(DomSanitizer), \u0275\u0275directiveInject(NbIconLibraries), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(NbStatusService));
};
_NbIconComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbIconComponent,
  selectors: [["nb-icon"]],
  hostVars: 17,
  hostBindings: function NbIconComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275domProperty("innerHTML", ctx.html, \u0275\u0275sanitizeHtml);
      \u0275\u0275classMap(ctx.additionalClasses);
      \u0275\u0275classProp("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control);
    }
  },
  inputs: {
    icon: "icon",
    pack: "pack",
    options: "options",
    status: "status",
    config: "config"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  decls: 0,
  vars: 0,
  template: function NbIconComponent_Template(rf, ctx) {
  },
  styles: ["[_nghost-%COMP%]{display:inline-block}"],
  changeDetection: 0
});
var NbIconComponent = _NbIconComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbIconComponent, [{
    type: Component,
    args: [{
      selector: "nb-icon",
      template: "",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      styles: [":host{display:inline-block}\n"]
    }]
  }], () => [{
    type: DomSanitizer
  }, {
    type: NbIconLibraries
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: NbStatusService
  }], {
    html: [{
      type: HostBinding,
      args: ["innerHtml"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    icon: [{
      type: Input
    }],
    pack: [{
      type: Input
    }],
    options: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    config: [{
      type: Input
    }]
  });
})();
var _NbIconModule = class _NbIconModule {
  constructor(iconsLibrary) {
    this.iconsLibrary = iconsLibrary;
    this.essentialsPackName = "nebular-essentials";
    if (this.iconsLibrary.getPack(this.essentialsPackName)) {
      return;
    }
    this.iconsLibrary.registerSvgPack(this.essentialsPackName, {
      "chevron-down-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="chevron-down"><rect width="24" height="24" opacity="0"/><path d="M12 15.5a1 1 0 0 1-.71-.29l-4-4a1 1 0 1 1 1.42-1.42L12 13.1l3.3-3.18a1 1 0 1 1 1.38 1.44l-4 3.86a1 1 0 0 1-.68.28z"/></g></g></svg>',
      "chevron-up-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="chevron-up"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M16 14.5a1 1 0 0 1-.71-.29L12 10.9l-3.3 3.18a1 1 0 0 1-1.41 0 1 1 0 0 1 0-1.42l4-3.86a1 1 0 0 1 1.4 0l4 4a1 1 0 0 1 0 1.42 1 1 0 0 1-.69.28z"/></g></g></svg>',
      "chevron-left-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="chevron-left"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M13.36 17a1 1 0 0 1-.72-.31l-3.86-4a1 1 0 0 1 0-1.4l4-4a1 1 0 1 1 1.42 1.42L10.9 12l3.18 3.3a1 1 0 0 1 0 1.41 1 1 0 0 1-.72.29z"/></g></g></svg>',
      "chevron-right-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="chevron-right"><rect width="24" height="24" transform="rotate(-90 12 12)" opacity="0"/><path d="M10.5 17a1 1 0 0 1-.71-.29 1 1 0 0 1 0-1.42L13.1 12 9.92 8.69a1 1 0 0 1 0-1.41 1 1 0 0 1 1.42 0l3.86 4a1 1 0 0 1 0 1.4l-4 4a1 1 0 0 1-.7.32z"/></g></g></svg>',
      "checkmark-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="checkmark"><rect width="24" height="24" opacity="0"/><path d="M9.86 18a1 1 0 0 1-.73-.32l-4.86-5.17a1 1 0 1 1 1.46-1.37l4.12 4.39 8.41-9.2a1 1 0 1 1 1.48 1.34l-9.14 10a1 1 0 0 1-.73.33z"/></g></g></svg>',
      "paper-plane-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="paper-plane"><rect width="24" height="24" opacity="0"/><path d="M21 4a1.31 1.31 0 0 0-.06-.27v-.09a1 1 0 0 0-.2-.3 1 1 0 0 0-.29-.19h-.09a.86.86 0 0 0-.31-.15H20a1 1 0 0 0-.3 0l-18 6a1 1 0 0 0 0 1.9l8.53 2.84 2.84 8.53a1 1 0 0 0 1.9 0l6-18A1 1 0 0 0 21 4zm-4.7 2.29l-5.57 5.57L5.16 10zM14 18.84l-1.86-5.57 5.57-5.57z"/></g></g></svg>',
      "file-text-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="file-text"><rect width="24" height="24" opacity="0"/><path d="M15 16H9a1 1 0 0 0 0 2h6a1 1 0 0 0 0-2z"/><path d="M9 14h3a1 1 0 0 0 0-2H9a1 1 0 0 0 0 2z"/><path d="M19.74 8.33l-5.44-6a1 1 0 0 0-.74-.33h-7A2.53 2.53 0 0 0 4 4.5v15A2.53 2.53 0 0 0 6.56 22h10.88A2.53 2.53 0 0 0 20 19.5V9a1 1 0 0 0-.26-.67zM14 5l2.74 3h-2a.79.79 0 0 1-.74-.85zm3.44 15H6.56a.53.53 0 0 1-.56-.5v-15a.53.53 0 0 1 .56-.5H12v3.15A2.79 2.79 0 0 0 14.71 10H18v9.5a.53.53 0 0 1-.56.5z"/></g></g></svg>',
      "alert-triangle-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="alert-triangle"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M22.56 16.3L14.89 3.58a3.43 3.43 0 0 0-5.78 0L1.44 16.3a3 3 0 0 0-.05 3A3.37 3.37 0 0 0 4.33 21h15.34a3.37 3.37 0 0 0 2.94-1.66 3 3 0 0 0-.05-3.04zm-1.7 2.05a1.31 1.31 0 0 1-1.19.65H4.33a1.31 1.31 0 0 1-1.19-.65 1 1 0 0 1 0-1l7.68-12.73a1.48 1.48 0 0 1 2.36 0l7.67 12.72a1 1 0 0 1 .01 1.01z"/><circle cx="12" cy="16" r="1"/><path d="M12 8a1 1 0 0 0-1 1v4a1 1 0 0 0 2 0V9a1 1 0 0 0-1-1z"/></g></g></svg>',
      "question-mark-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="question-mark"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M17 9A5 5 0 0 0 7 9a1 1 0 0 0 2 0 3 3 0 1 1 3 3 1 1 0 0 0-1 1v2a1 1 0 0 0 2 0v-1.1A5 5 0 0 0 17 9z"/><circle cx="12" cy="19" r="1"/></g></g></svg>',
      "email-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="email"><rect width="24" height="24" opacity="0"/><path d="M19 4H5a3 3 0 0 0-3 3v10a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3V7a3 3 0 0 0-3-3zm-.67 2L12 10.75 5.67 6zM19 18H5a1 1 0 0 1-1-1V7.25l7.4 5.55a1 1 0 0 0 .6.2 1 1 0 0 0 .6-.2L20 7.25V17a1 1 0 0 1-1 1z"/></g></g></svg>',
      "flash-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="flash"><rect width="24" height="24" opacity="0"/><path d="M11.11 23a1 1 0 0 1-.34-.06 1 1 0 0 1-.65-1.05l.77-7.09H5a1 1 0 0 1-.83-1.56l7.89-11.8a1 1 0 0 1 1.17-.38 1 1 0 0 1 .65 1l-.77 7.14H19a1 1 0 0 1 .83 1.56l-7.89 11.8a1 1 0 0 1-.83.44zM6.87 12.8H12a1 1 0 0 1 .74.33 1 1 0 0 1 .25.78l-.45 4.15 4.59-6.86H12a1 1 0 0 1-1-1.11l.45-4.15z"/></g></g></svg>',
      "search-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="search"><rect width="24" height="24" opacity="0"/><path d="M20.71 19.29l-3.4-3.39A7.92 7.92 0 0 0 19 11a8 8 0 1 0-8 8 7.92 7.92 0 0 0 4.9-1.69l3.39 3.4a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42zM5 11a6 6 0 1 1 6 6 6 6 0 0 1-6-6z"/></g></g></svg>',
      "close-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="close"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M13.41 12l4.3-4.29a1 1 0 1 0-1.42-1.42L12 10.59l-4.29-4.3a1 1 0 0 0-1.42 1.42l4.3 4.29-4.3 4.29a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0l4.29-4.3 4.29 4.3a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42z"/></g></g></svg>',
      "collapse-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="collapse"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M19 9h-2.58l3.29-3.29a1 1 0 1 0-1.42-1.42L15 7.57V5a1 1 0 0 0-1-1 1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h5a1 1 0 0 0 0-2z"/><path d="M10 13H5a1 1 0 0 0 0 2h2.57l-3.28 3.29a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0L9 16.42V19a1 1 0 0 0 1 1 1 1 0 0 0 1-1v-5a1 1 0 0 0-1-1z"/></g></g></svg>',
      "expand-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="expand"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M20 5a1 1 0 0 0-1-1h-5a1 1 0 0 0 0 2h2.57l-3.28 3.29a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0L18 7.42V10a1 1 0 0 0 1 1 1 1 0 0 0 1-1z"/><path d="M10.71 13.29a1 1 0 0 0-1.42 0L6 16.57V14a1 1 0 0 0-1-1 1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h5a1 1 0 0 0 0-2H7.42l3.29-3.29a1 1 0 0 0 0-1.42z"/></g></g></svg>',
      "minus-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="minus"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M19 13H5a1 1 0 0 1 0-2h14a1 1 0 0 1 0 2z"/></g></g></svg>',
      "minus-bold-outline": '<svg xmlns:xlink="http://www.w3.org/1999/xlink" fill="currentColor" viewBox="0 0 8 2" width="100%" height="100%"><defs><rect id="nb-mbo" y="3" width="8" height="2" rx="1"/></defs><use xlink:href="#nb-mbo" transform="translate(0 -3)" fill-rule="evenodd"/></svg>',
      "checkmark-bold-outline": '<svg xmlns:xlink="http://www.w3.org/1999/xlink" fill="currentColor" viewBox="0 0 8 7" width="100%" height="100%"><defs><path id="nb-cbo" d="M6.039 1.43a1.11 1.11 0 0 1 1.517-.228c.483.342.588.998.234 1.466L4.431 7.1a1 1 0 0 1-1.492.115L.317 4.677a1.023 1.023 0 0 1 .002-1.483 1.113 1.113 0 0 1 1.535.002l1.641 1.59L6.04 1.428z"/></defs><use xlink:href="#nb-cbo" transform="translate(0 -1)" fill-rule="evenodd"/></svg>',
      "arrow-back": '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="arrow-back"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M19 11H7.14l3.63-4.36a1 1 0 1 0-1.54-1.28l-5 6a1.19 1.19 0 0 0-.09.15c0 .05 0 .08-.07.13A1 1 0 0 0 4 12a1 1 0 0 0 .07.36c0 .05 0 .08.07.13a1.19 1.19 0 0 0 .09.15l5 6A1 1 0 0 0 10 19a1 1 0 0 0 .64-.23 1 1 0 0 0 .13-1.41L7.14 13H19a1 1 0 0 0 0-2z"/></g></g></svg>'
    });
  }
};
_NbIconModule.\u0275fac = function NbIconModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbIconModule)(\u0275\u0275inject(NbIconLibraries));
};
_NbIconModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbIconModule,
  declarations: [NbIconComponent],
  imports: [CommonModule],
  exports: [NbIconComponent]
});
_NbIconModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule]
});
var NbIconModule = _NbIconModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbIconModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [NbIconComponent],
      exports: [NbIconComponent]
    }]
  }], () => [{
    type: NbIconLibraries
  }], null);
})();
var _NbCardHeaderComponent = class _NbCardHeaderComponent {
};
_NbCardHeaderComponent.\u0275fac = function NbCardHeaderComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbCardHeaderComponent)();
};
_NbCardHeaderComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbCardHeaderComponent,
  selectors: [["nb-card-header"]],
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function NbCardHeaderComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275projection(0);
    }
  },
  encapsulation: 2
});
var NbCardHeaderComponent = _NbCardHeaderComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCardHeaderComponent, [{
    type: Component,
    args: [{
      selector: "nb-card-header",
      template: `<ng-content></ng-content>`,
      standalone: false
    }]
  }], null, null);
})();
var _NbCardBodyComponent = class _NbCardBodyComponent {
};
_NbCardBodyComponent.\u0275fac = function NbCardBodyComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbCardBodyComponent)();
};
_NbCardBodyComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbCardBodyComponent,
  selectors: [["nb-card-body"]],
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function NbCardBodyComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275projection(0);
    }
  },
  encapsulation: 2
});
var NbCardBodyComponent = _NbCardBodyComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCardBodyComponent, [{
    type: Component,
    args: [{
      selector: "nb-card-body",
      template: `<ng-content></ng-content>`,
      standalone: false
    }]
  }], null, null);
})();
var _NbCardFooterComponent = class _NbCardFooterComponent {
};
_NbCardFooterComponent.\u0275fac = function NbCardFooterComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbCardFooterComponent)();
};
_NbCardFooterComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbCardFooterComponent,
  selectors: [["nb-card-footer"]],
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function NbCardFooterComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275projection(0);
    }
  },
  encapsulation: 2
});
var NbCardFooterComponent = _NbCardFooterComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCardFooterComponent, [{
    type: Component,
    args: [{
      selector: "nb-card-footer",
      template: `<ng-content></ng-content>`,
      standalone: false
    }]
  }], null, null);
})();
var _NbCardComponent = class _NbCardComponent {
  /**
   * Card size, available sizes:
   * tiny, small, medium, large, giant
   */
  get size() {
    return this._size;
  }
  set size(value) {
    this._size = value;
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get primary() {
    return this.status === "primary";
  }
  get info() {
    return this.status === "info";
  }
  get success() {
    return this.status === "success";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get hasAccent() {
    return this.accent;
  }
  get primaryAccent() {
    return this.accent === "primary";
  }
  get infoAccent() {
    return this.accent === "info";
  }
  get successAccent() {
    return this.accent === "success";
  }
  get warningAccent() {
    return this.accent === "warning";
  }
  get dangerAccent() {
    return this.accent === "danger";
  }
  get basicAccent() {
    return this.accent === "basic";
  }
  get controlAccent() {
    return this.accent === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  constructor(statusService) {
    this.statusService = statusService;
    this._size = "";
    this.status = "";
    this.accent = "";
  }
};
_NbCardComponent.\u0275fac = function NbCardComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbCardComponent)(\u0275\u0275directiveInject(NbStatusService));
};
_NbCardComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbCardComponent,
  selectors: [["nb-card"]],
  hostVars: 42,
  hostBindings: function NbCardComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classMap(ctx.additionalClasses);
      \u0275\u0275classProp("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("accent", ctx.hasAccent)("accent-primary", ctx.primaryAccent)("accent-info", ctx.infoAccent)("accent-success", ctx.successAccent)("accent-warning", ctx.warningAccent)("accent-danger", ctx.dangerAccent)("accent-basic", ctx.basicAccent)("accent-control", ctx.controlAccent);
    }
  },
  inputs: {
    size: "size",
    status: "status",
    accent: "accent"
  },
  standalone: false,
  ngContentSelectors: _c2,
  decls: 4,
  vars: 0,
  template: function NbCardComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef(_c1);
      \u0275\u0275projection(0);
      \u0275\u0275projection(1, 1);
      \u0275\u0275projection(2, 2);
      \u0275\u0275projection(3, 3);
    }
  },
  styles: ["[_nghost-%COMP%]{display:flex;flex-direction:column}\n\n\n\n\n\n"]
});
var NbCardComponent = _NbCardComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCardComponent, [{
    type: Component,
    args: [{
      selector: "nb-card",
      template: `
    <ng-content select="nb-card-header"></ng-content>
    <ng-content select="nb-card-body"></ng-content>
    <ng-content></ng-content>
    <ng-content select="nb-card-footer"></ng-content>
  `,
      standalone: false,
      styles: [":host{display:flex;flex-direction:column}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: NbStatusService
  }], {
    size: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    accent: [{
      type: Input
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    hasAccent: [{
      type: HostBinding,
      args: ["class.accent"]
    }],
    primaryAccent: [{
      type: HostBinding,
      args: ["class.accent-primary"]
    }],
    infoAccent: [{
      type: HostBinding,
      args: ["class.accent-info"]
    }],
    successAccent: [{
      type: HostBinding,
      args: ["class.accent-success"]
    }],
    warningAccent: [{
      type: HostBinding,
      args: ["class.accent-warning"]
    }],
    dangerAccent: [{
      type: HostBinding,
      args: ["class.accent-danger"]
    }],
    basicAccent: [{
      type: HostBinding,
      args: ["class.accent-basic"]
    }],
    controlAccent: [{
      type: HostBinding,
      args: ["class.accent-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var _NbRevealCardComponent = class _NbRevealCardComponent {
  constructor() {
    this.revealed = false;
    this.showToggleButton = true;
  }
  toggle() {
    this.revealed = !this.revealed;
  }
};
_NbRevealCardComponent.\u0275fac = function NbRevealCardComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbRevealCardComponent)();
};
_NbRevealCardComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbRevealCardComponent,
  selectors: [["nb-reveal-card"]],
  hostVars: 2,
  hostBindings: function NbRevealCardComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("revealed", ctx.revealed);
    }
  },
  inputs: {
    revealed: "revealed",
    showToggleButton: "showToggleButton"
  },
  standalone: false,
  ngContentSelectors: _c4,
  decls: 4,
  vars: 1,
  consts: [[1, "second-card-container"], ["class", "reveal-button", 3, "click", 4, "ngIf"], [1, "reveal-button", 3, "click"], ["icon", "chevron-down-outline", "pack", "nebular-essentials", "aria-hidden", "true"]],
  template: function NbRevealCardComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef(_c3);
      \u0275\u0275projection(0);
      \u0275\u0275elementStart(1, "div", 0);
      \u0275\u0275projection(2, 1);
      \u0275\u0275elementEnd();
      \u0275\u0275template(3, NbRevealCardComponent_a_3_Template, 2, 0, "a", 1);
    }
    if (rf & 2) {
      \u0275\u0275advance(3);
      \u0275\u0275property("ngIf", ctx.showToggleButton);
    }
  },
  dependencies: [NgIf, NbIconComponent],
  styles: ["[_nghost-%COMP%]{display:block;position:relative;overflow:hidden}[_nghost-%COMP%]   .second-card-container[_ngcontent-%COMP%]{position:absolute;top:100%;right:0;left:0;overflow:hidden;transition:top 0s .5s}[_nghost-%COMP%]     nb-card-front nb-card, [_nghost-%COMP%]     nb-card-back nb-card{box-shadow:none;margin:0}[_nghost-%COMP%]     nb-card-front{display:block;height:100%}[_nghost-%COMP%]     nb-card-back{position:absolute;left:0;top:100%;width:100%;transition:top .5s}[_nghost-%COMP%]   .reveal-button[_ngcontent-%COMP%]{cursor:pointer;position:absolute;right:0;bottom:0;transform:rotate(180deg);transition:transform .3s}.revealed[_nghost-%COMP%]   .second-card-container[_ngcontent-%COMP%]{top:0;transition:none}.revealed[_nghost-%COMP%]   .second-card-container[_ngcontent-%COMP%]     nb-card-back{top:0}.revealed[_nghost-%COMP%]   .reveal-button[_ngcontent-%COMP%]{transform:none}"]
});
var NbRevealCardComponent = _NbRevealCardComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRevealCardComponent, [{
    type: Component,
    args: [{
      selector: "nb-reveal-card",
      template: `
    <ng-content select="nb-card-front"></ng-content>
    <div class="second-card-container">
      <ng-content select="nb-card-back"></ng-content>
    </div>
    <a *ngIf="showToggleButton" class="reveal-button" (click)="toggle()">
      <nb-icon icon="chevron-down-outline" pack="nebular-essentials" aria-hidden="true"></nb-icon>
    </a>
  `,
      standalone: false,
      styles: [":host{display:block;position:relative;overflow:hidden}:host .second-card-container{position:absolute;top:100%;right:0;left:0;overflow:hidden;transition:top 0s .5s}:host ::ng-deep nb-card-front nb-card,:host ::ng-deep nb-card-back nb-card{box-shadow:none;margin:0}:host ::ng-deep nb-card-front{display:block;height:100%}:host ::ng-deep nb-card-back{position:absolute;left:0;top:100%;width:100%;transition:top .5s}:host .reveal-button{cursor:pointer;position:absolute;right:0;bottom:0;transform:rotate(180deg);transition:transform .3s}:host(.revealed) .second-card-container{top:0;transition:none}:host(.revealed) .second-card-container ::ng-deep nb-card-back{top:0}:host(.revealed) .reveal-button{transform:none}\n"]
    }]
  }], null, {
    revealed: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.revealed"]
    }],
    showToggleButton: [{
      type: Input
    }]
  });
})();
var _NbFlipCardComponent = class _NbFlipCardComponent {
  constructor() {
    this.flipped = false;
    this.showToggleButton = true;
  }
  toggle() {
    this.flipped = !this.flipped;
  }
};
_NbFlipCardComponent.\u0275fac = function NbFlipCardComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbFlipCardComponent)();
};
_NbFlipCardComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbFlipCardComponent,
  selectors: [["nb-flip-card"]],
  hostVars: 2,
  hostBindings: function NbFlipCardComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("flipped", ctx.flipped);
    }
  },
  inputs: {
    flipped: "flipped",
    showToggleButton: "showToggleButton"
  },
  standalone: false,
  ngContentSelectors: _c4,
  decls: 7,
  vars: 2,
  consts: [[1, "flipcard-body"], [1, "front-container"], ["class", "flip-button", 3, "click", 4, "ngIf"], [1, "back-container"], [1, "flip-button", 3, "click"], ["icon", "chevron-left-outline", "pack", "nebular-essentials", "aria-hidden", "true"]],
  template: function NbFlipCardComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef(_c3);
      \u0275\u0275elementStart(0, "div", 0)(1, "div", 1);
      \u0275\u0275projection(2);
      \u0275\u0275template(3, NbFlipCardComponent_a_3_Template, 2, 0, "a", 2);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(4, "div", 3);
      \u0275\u0275projection(5, 1);
      \u0275\u0275template(6, NbFlipCardComponent_a_6_Template, 2, 0, "a", 2);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275advance(3);
      \u0275\u0275property("ngIf", ctx.showToggleButton);
      \u0275\u0275advance(3);
      \u0275\u0275property("ngIf", ctx.showToggleButton);
    }
  },
  dependencies: [NgIf, NbIconComponent],
  styles: ["[_nghost-%COMP%]{display:block;min-width:0;perspective:1200px;position:relative}.flipped[_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%], .flipped   [_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]{transform:rotateY(-180deg)}.flipped[_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%], .flipped   [_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%]{opacity:0;transition:opacity 0s .25s;backface-visibility:hidden;-webkit-backface-visibility:hidden}.flipped[_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%]   .flip-button[_ngcontent-%COMP%], .flipped   [_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%]   .flip-button[_ngcontent-%COMP%]{opacity:0;z-index:-1}.flipped[_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]   .back-container[_ngcontent-%COMP%], .flipped   [_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]   .back-container[_ngcontent-%COMP%]{backface-visibility:visible;-webkit-backface-visibility:visible}.flipcard-body[_ngcontent-%COMP%]{display:flex;transition:transform .5s;transform-style:preserve-3d}.flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%], .flipcard-body[_ngcontent-%COMP%]   .back-container[_ngcontent-%COMP%]{flex:1;height:fit-content;overflow:auto}.flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%]   .flip-button[_ngcontent-%COMP%], .flipcard-body[_ngcontent-%COMP%]   .back-container[_ngcontent-%COMP%]   .flip-button[_ngcontent-%COMP%]{cursor:pointer;position:absolute;right:0;bottom:0;opacity:1;transition:opacity 0s .15s}.flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%]{backface-visibility:visible;-webkit-backface-visibility:visible;transition:opacity 0s .2s}.flipcard-body[_ngcontent-%COMP%]   .back-container[_ngcontent-%COMP%]{backface-visibility:hidden;-webkit-backface-visibility:hidden;transform:rotateY(180deg)}\n\n\n\n\n\n"]
});
var NbFlipCardComponent = _NbFlipCardComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFlipCardComponent, [{
    type: Component,
    args: [{
      selector: "nb-flip-card",
      template: `
    <div class="flipcard-body">
      <div class="front-container">
        <ng-content select="nb-card-front"></ng-content>
        <a *ngIf="showToggleButton" class="flip-button" (click)="toggle()">
          <nb-icon icon="chevron-left-outline" pack="nebular-essentials" aria-hidden="true"></nb-icon>
        </a>
      </div>
      <div class="back-container">
        <ng-content select="nb-card-back"></ng-content>
        <a *ngIf="showToggleButton" class="flip-button" (click)="toggle()">
          <nb-icon icon="chevron-left-outline" pack="nebular-essentials" aria-hidden="true"></nb-icon>
        </a>
      </div>
    </div>
  `,
      standalone: false,
      styles: [":host{display:block;min-width:0;perspective:1200px;position:relative}:host-context(.flipped) .flipcard-body{transform:rotateY(-180deg)}:host-context(.flipped) .flipcard-body .front-container{opacity:0;transition:opacity 0s .25s;backface-visibility:hidden;-webkit-backface-visibility:hidden}:host-context(.flipped) .flipcard-body .front-container .flip-button{opacity:0;z-index:-1}:host-context(.flipped) .flipcard-body .back-container{backface-visibility:visible;-webkit-backface-visibility:visible}.flipcard-body{display:flex;transition:transform .5s;transform-style:preserve-3d}.flipcard-body .front-container,.flipcard-body .back-container{flex:1;height:fit-content;overflow:auto}.flipcard-body .front-container .flip-button,.flipcard-body .back-container .flip-button{cursor:pointer;position:absolute;right:0;bottom:0;opacity:1;transition:opacity 0s .15s}.flipcard-body .front-container{backface-visibility:visible;-webkit-backface-visibility:visible;transition:opacity 0s .2s}.flipcard-body .back-container{backface-visibility:hidden;-webkit-backface-visibility:hidden;transform:rotateY(180deg)}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], null, {
    flipped: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.flipped"]
    }],
    showToggleButton: [{
      type: Input
    }]
  });
})();
var _NbCardFrontComponent = class _NbCardFrontComponent {
};
_NbCardFrontComponent.\u0275fac = function NbCardFrontComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbCardFrontComponent)();
};
_NbCardFrontComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbCardFrontComponent,
  selectors: [["nb-card-front"]],
  standalone: false,
  ngContentSelectors: _c6,
  decls: 1,
  vars: 0,
  template: function NbCardFrontComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef(_c5);
      \u0275\u0275projection(0);
    }
  },
  encapsulation: 2
});
var NbCardFrontComponent = _NbCardFrontComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCardFrontComponent, [{
    type: Component,
    args: [{
      selector: "nb-card-front",
      template: '<ng-content select="nb-card"></ng-content>',
      standalone: false
    }]
  }], null, null);
})();
var _NbCardBackComponent = class _NbCardBackComponent {
};
_NbCardBackComponent.\u0275fac = function NbCardBackComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbCardBackComponent)();
};
_NbCardBackComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbCardBackComponent,
  selectors: [["nb-card-back"]],
  standalone: false,
  ngContentSelectors: _c6,
  decls: 1,
  vars: 0,
  template: function NbCardBackComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef(_c5);
      \u0275\u0275projection(0);
    }
  },
  encapsulation: 2
});
var NbCardBackComponent = _NbCardBackComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCardBackComponent, [{
    type: Component,
    args: [{
      selector: "nb-card-back",
      template: '<ng-content select="nb-card"></ng-content>',
      standalone: false
    }]
  }], null, null);
})();
var NB_CARD_COMPONENTS = [NbCardComponent, NbCardBodyComponent, NbCardFooterComponent, NbCardHeaderComponent, NbRevealCardComponent, NbFlipCardComponent, NbCardFrontComponent, NbCardBackComponent];
var _NbCardModule = class _NbCardModule {
};
_NbCardModule.\u0275fac = function NbCardModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbCardModule)();
};
_NbCardModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbCardModule,
  declarations: [NbCardComponent, NbCardBodyComponent, NbCardFooterComponent, NbCardHeaderComponent, NbRevealCardComponent, NbFlipCardComponent, NbCardFrontComponent, NbCardBackComponent],
  imports: [NbSharedModule, NbIconModule],
  exports: [NbCardComponent, NbCardBodyComponent, NbCardFooterComponent, NbCardHeaderComponent, NbRevealCardComponent, NbFlipCardComponent, NbCardFrontComponent, NbCardBackComponent]
});
_NbCardModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NbSharedModule, NbIconModule]
});
var NbCardModule = _NbCardModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCardModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbIconModule],
      declarations: [...NB_CARD_COMPONENTS],
      exports: [...NB_CARD_COMPONENTS]
    }]
  }], null, null);
})();
var NbCalendarViewMode;
(function(NbCalendarViewMode2) {
  NbCalendarViewMode2["YEAR"] = "year";
  NbCalendarViewMode2["MONTH"] = "month";
  NbCalendarViewMode2["DATE"] = "date";
})(NbCalendarViewMode || (NbCalendarViewMode = {}));
var NbCalendarSize;
(function(NbCalendarSize2) {
  NbCalendarSize2["MEDIUM"] = "medium";
  NbCalendarSize2["LARGE"] = "large";
})(NbCalendarSize || (NbCalendarSize = {}));
function convertToBoolProperty(val) {
  if (typeof val === "string") {
    val = val.toLowerCase().trim();
    return val === "true" || val === "";
  }
  return !!val;
}
var NbDateService = class {
  constructor() {
    this.DAYS_IN_WEEK = 7;
    this.HOURS_IN_DAY_PERIOD = 12;
  }
  setLocale(locale) {
    this.locale = locale;
  }
  /**
   * Checks if the date is between the start date and the end date.
   * */
  isBetween(date, start, end) {
    return this.compareDates(date, start) > 0 && this.compareDates(date, end) < 0;
  }
  /**
   * Checks is two dates have the same day.
   * */
  isSameDaySafe(date1, date2) {
    return date1 && date2 && this.isSameDay(date1, date2);
  }
  /**
   * Checks is two dates have the same month.
   * */
  isSameMonthSafe(date1, date2) {
    return date1 && date2 && this.isSameMonth(date1, date2);
  }
  /**
   * Checks is two dates have the same year.
   * */
  isSameYearSafe(date1, date2) {
    return date1 && date2 && this.isSameYear(date1, date2);
  }
  isSameHourAndMinute(date1, date2) {
    return this.isSameHour(date1, date2) && this.isSameMinute(date1, date2);
  }
  isSameHour(date1, date2) {
    return this.getHours(date1) === this.getHours(date2);
  }
  isSameMinute(date1, date2) {
    return this.getMinutes(date1) === this.getMinutes(date2);
  }
  getTwentyFourHoursFormat() {
    return "HH:mm";
  }
  getTwentyFourHoursFormatWithSeconds() {
    return "HH:mm:ss";
  }
  getTwelveHoursFormatWithSeconds() {
    return "hh:mm:ss a";
  }
  getDayPeriod(date) {
    const isFirstDayPeriod = this.getHours(date) < this.HOURS_IN_DAY_PERIOD;
    if (isFirstDayPeriod) {
      return "AM";
    } else {
      return "PM";
    }
  }
};
var batch = (target, batchSize, offset = 0) => {
  return target.reduce((res, item, index) => {
    const chunkIndex = Math.floor((index + offset) / batchSize);
    if (!res[chunkIndex]) {
      res[chunkIndex] = [];
    }
    res[chunkIndex].push(item);
    return res;
  }, []);
};
var rangeFromTo = (from2, to = 0, producer = (i) => i) => {
  const arr = [];
  for (let i = from2; i < to; i++) {
    arr.push(producer(i));
  }
  return arr;
};
var range = (bound, producer = (i) => i) => {
  return rangeFromTo(0, bound, producer);
};
var _NbCalendarYearModelService = class _NbCalendarYearModelService {
  constructor(dateService) {
    this.dateService = dateService;
    this.yearsInView = 12;
    this.yearsInRow = 4;
  }
  getYearsInView() {
    return this.yearsInView;
  }
  getYearsInRow() {
    return this.yearsInRow;
  }
  getViewYears(viewYear) {
    const year = this.dateService.getYear(viewYear);
    let viewStartYear;
    if (year >= 0) {
      viewStartYear = year - year % this.yearsInView;
    } else {
      viewStartYear = year - (year % this.yearsInView + this.yearsInView);
    }
    const years = range(this.yearsInView).map((i) => this.copyWithYear(viewStartYear + i, viewYear));
    return batch(years, this.yearsInRow);
  }
  copyWithYear(year, date) {
    return this.dateService.createDate(year, this.dateService.getMonth(date), this.dateService.getDate(date));
  }
};
_NbCalendarYearModelService.\u0275fac = function NbCalendarYearModelService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbCalendarYearModelService)(\u0275\u0275inject(NbDateService));
};
_NbCalendarYearModelService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbCalendarYearModelService,
  factory: _NbCalendarYearModelService.\u0275fac
});
var NbCalendarYearModelService = _NbCalendarYearModelService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarYearModelService, [{
    type: Injectable
  }], () => [{
    type: NbDateService
  }], null);
})();
var _NbButton = class _NbButton {
  /**
   * Sets `filled` appearance
   */
  get filled() {
    return this.appearance === "filled";
  }
  set filled(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "filled";
    }
  }
  /**
   * Sets `outline` appearance
   */
  get outline() {
    return this.appearance === "outline";
  }
  set outline(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "outline";
    }
  }
  /**
   * Sets `ghost` appearance
   */
  get ghost() {
    return this.appearance === "ghost";
  }
  set ghost(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "ghost";
    }
  }
  /**
   * If set element will fill its container
   */
  get fullWidth() {
    return this._fullWidth;
  }
  set fullWidth(value) {
    this._fullWidth = convertToBoolProperty(value);
  }
  /**
   * Disables the button
   */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    if (this.disabled !== convertToBoolProperty(value)) {
      this._disabled = !this.disabled;
      this.renderer.setProperty(this.hostElement.nativeElement, "disabled", this.disabled);
    }
  }
  // issue #794
  get tabbable() {
    if (this.disabled) {
      return "-1";
    }
    if (this.tabIndex == null) {
      return "0";
    }
    return this.tabIndex.toString();
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get rectangle() {
    return this.shape === "rectangle";
  }
  get round() {
    return this.shape === "round";
  }
  get semiRound() {
    return this.shape === "semi-round";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  constructor(renderer, hostElement, cd, zone, statusService) {
    this.renderer = renderer;
    this.hostElement = hostElement;
    this.cd = cd;
    this.zone = zone;
    this.statusService = statusService;
    this.size = "medium";
    this.status = "basic";
    this.shape = "rectangle";
    this.appearance = "filled";
    this._fullWidth = false;
    this._disabled = false;
    this.iconLeft = false;
    this.iconRight = false;
  }
  ngAfterContentChecked() {
    const firstNode = this.nodes[0];
    const lastNode = this.nodes[this.nodes.length - 1];
    this.iconLeft = this.isIconExist(firstNode);
    this.iconRight = this.isIconExist(lastNode);
  }
  ngAfterViewInit() {
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this.hostElement.nativeElement, "nb-transition");
    }));
  }
  /**
   * @docs-private
   **/
  updateProperties(config) {
    let isPropertyChanged = false;
    for (const key in config) {
      if (config.hasOwnProperty(key) && this[key] !== config[key]) {
        this[key] = config[key];
        isPropertyChanged = true;
      }
    }
    if (isPropertyChanged) {
      this.cd.markForCheck();
    }
  }
  get iconElement() {
    const el = this.hostElement.nativeElement;
    return el.querySelector("nb-icon");
  }
  get nodes() {
    return this.cd.rootNodes.filter((child) => child.nodeType !== Node.COMMENT_NODE);
  }
  isIconExist(node) {
    return this.icons.some((item) => item.nativeElement === node);
  }
};
_NbButton.\u0275fac = function NbButton_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbButton)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(NbStatusService));
};
_NbButton.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbButton,
  contentQueries: function NbButton_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, NbIconComponent, 4, ElementRef);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.icons = _t);
    }
  },
  hostVars: 34,
  hostBindings: function NbButton_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("aria-disabled", ctx.disabled)("tabindex", ctx.tabbable);
      \u0275\u0275classMap(ctx.additionalClasses);
      \u0275\u0275classProp("appearance-filled", ctx.filled)("appearance-outline", ctx.outline)("appearance-ghost", ctx.ghost)("full-width", ctx.fullWidth)("btn-disabled", ctx.disabled)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("shape-rectangle", ctx.rectangle)("shape-round", ctx.round)("shape-semi-round", ctx.semiRound)("icon-start", ctx.iconLeft)("icon-end", ctx.iconRight);
    }
  },
  inputs: {
    size: "size",
    status: "status",
    shape: "shape",
    appearance: "appearance",
    filled: "filled",
    outline: "outline",
    ghost: "ghost",
    fullWidth: "fullWidth",
    disabled: "disabled",
    tabIndex: "tabIndex"
  }
});
var NbButton = _NbButton;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbButton, [{
    type: Directive
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }], {
    size: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    shape: [{
      type: Input
    }],
    appearance: [{
      type: Input
    }],
    filled: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-filled"]
    }],
    outline: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-outline"]
    }],
    ghost: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-ghost"]
    }],
    fullWidth: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.full-width"]
    }],
    disabled: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }, {
      type: HostBinding,
      args: ["class.btn-disabled"]
    }],
    tabIndex: [{
      type: Input
    }],
    tabbable: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    rectangle: [{
      type: HostBinding,
      args: ["class.shape-rectangle"]
    }],
    round: [{
      type: HostBinding,
      args: ["class.shape-round"]
    }],
    semiRound: [{
      type: HostBinding,
      args: ["class.shape-semi-round"]
    }],
    iconLeft: [{
      type: HostBinding,
      args: ["class.icon-start"]
    }],
    iconRight: [{
      type: HostBinding,
      args: ["class.icon-end"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    icons: [{
      type: ContentChildren,
      args: [NbIconComponent, {
        read: ElementRef
      }]
    }]
  });
})();
var _NbButtonComponent = class _NbButtonComponent extends NbButton {
  /**
   * Sets `hero` appearance
   */
  get hero() {
    return this.appearance === "hero";
  }
  set hero(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "hero";
    }
  }
  get primary() {
    return this.status === "primary";
  }
  get info() {
    return this.status === "info";
  }
  get success() {
    return this.status === "success";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  /**
   * @private
   * Keep this handler to partially support anchor disabling.
   * Unlike button, anchor doesn't have 'disabled' DOM property,
   * so handler will be called anyway. We preventing navigation and bubbling.
   * Disabling is partial due to click handlers precedence. Consider example:
   * <a nbButton [disabled]="true" (click)="clickHandler()">...</a>
   * 'clickHandler' will be called before our host listener below. We can't prevent
   * such handlers call.
   */
  onClick(event) {
    if (this.disabled) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }
  }
  constructor(renderer, hostElement, cd, zone, statusService) {
    super(renderer, hostElement, cd, zone, statusService);
    this.renderer = renderer;
    this.hostElement = hostElement;
    this.cd = cd;
    this.zone = zone;
    this.statusService = statusService;
  }
};
_NbButtonComponent.\u0275fac = function NbButtonComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbButtonComponent)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(NbStatusService));
};
_NbButtonComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbButtonComponent,
  selectors: [["button", "nbButton", ""], ["a", "nbButton", ""], ["input", "type", "button", "nbButton", ""], ["input", "type", "submit", "nbButton", ""]],
  hostVars: 16,
  hostBindings: function NbButtonComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function NbButtonComponent_click_HostBindingHandler($event) {
        return ctx.onClick($event);
      });
    }
    if (rf & 2) {
      \u0275\u0275classProp("appearance-hero", ctx.hero)("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control);
    }
  },
  inputs: {
    hero: "hero"
  },
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NbButton,
    useExisting: _NbButtonComponent
  }]), \u0275\u0275InheritDefinitionFeature],
  attrs: _c7,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function NbButtonComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275projection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbButtonComponent = _NbButtonComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbButtonComponent, [{
    type: Component,
    args: [{
      selector: 'button[nbButton],a[nbButton],input[type="button"][nbButton],input[type="submit"][nbButton]',
      template: `
    <ng-content></ng-content>
  `,
      providers: [{
        provide: NbButton,
        useExisting: NbButtonComponent
      }],
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }], {
    hero: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-hero"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var _NbCalendarViewModeComponent = class _NbCalendarViewModeComponent {
  constructor(dateService, yearModelService) {
    this.dateService = dateService;
    this.yearModelService = yearModelService;
    this.viewMode = NbCalendarViewMode.DATE;
    this.changeMode = new EventEmitter(true);
  }
  getText() {
    if (!this.date) {
      return "";
    }
    switch (this.viewMode) {
      case NbCalendarViewMode.DATE: {
        const month = this.dateService.getMonthName(this.date, TranslationWidth.Wide);
        const year = this.dateService.getYear(this.date);
        return `${month} ${year}`;
      }
      case NbCalendarViewMode.MONTH:
        return `${this.dateService.getYear(this.date)}`;
      case NbCalendarViewMode.YEAR:
        return `${this.getFirstYear()} - ${this.getLastYear()}`;
    }
  }
  getIcon() {
    if (this.viewMode === NbCalendarViewMode.DATE) {
      return "chevron-down-outline";
    }
    return "chevron-up-outline";
  }
  getFirstYear() {
    const years = this.yearModelService.getViewYears(this.date);
    return this.dateService.getYear(years[0][0]).toString();
  }
  getLastYear() {
    const years = this.yearModelService.getViewYears(this.date);
    const lastRow = years[years.length - 1];
    const lastYear = lastRow[lastRow.length - 1];
    return this.dateService.getYear(lastYear).toString();
  }
};
_NbCalendarViewModeComponent.\u0275fac = function NbCalendarViewModeComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbCalendarViewModeComponent)(\u0275\u0275directiveInject(NbDateService), \u0275\u0275directiveInject(NbCalendarYearModelService));
};
_NbCalendarViewModeComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbCalendarViewModeComponent,
  selectors: [["nb-calendar-view-mode"]],
  inputs: {
    date: "date",
    viewMode: "viewMode"
  },
  outputs: {
    changeMode: "changeMode"
  },
  standalone: false,
  decls: 3,
  vars: 2,
  consts: [["nbButton", "", "ghost", "", "status", "basic", 3, "click"], ["pack", "nebular-essentials", 3, "icon"]],
  template: function NbCalendarViewModeComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "button", 0);
      \u0275\u0275listener("click", function NbCalendarViewModeComponent_Template_button_click_0_listener() {
        return ctx.changeMode.emit();
      });
      \u0275\u0275text(1);
      \u0275\u0275element(2, "nb-icon", 1);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance();
      \u0275\u0275textInterpolate1(" ", ctx.getText(), " ");
      \u0275\u0275advance();
      \u0275\u0275property("icon", ctx.getIcon());
    }
  },
  dependencies: [NbButtonComponent, NbIconComponent],
  encapsulation: 2,
  changeDetection: 0
});
var NbCalendarViewModeComponent = _NbCalendarViewModeComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarViewModeComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-view-mode",
      template: `
    <button nbButton (click)="changeMode.emit()" ghost status="basic">
      {{ getText() }}
      <nb-icon [icon]="getIcon()" pack="nebular-essentials"></nb-icon>
    </button>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], () => [{
    type: NbDateService
  }, {
    type: NbCalendarYearModelService
  }], {
    date: [{
      type: Input
    }],
    viewMode: [{
      type: Input
    }],
    changeMode: [{
      type: Output
    }]
  });
})();
var _NbCalendarPageableNavigationComponent = class _NbCalendarPageableNavigationComponent {
  constructor(directionService) {
    this.directionService = directionService;
    this.next = new EventEmitter();
    this.prev = new EventEmitter();
  }
  get isLtr() {
    return this.directionService.isLtr();
  }
};
_NbCalendarPageableNavigationComponent.\u0275fac = function NbCalendarPageableNavigationComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbCalendarPageableNavigationComponent)(\u0275\u0275directiveInject(NbLayoutDirectionService));
};
_NbCalendarPageableNavigationComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbCalendarPageableNavigationComponent,
  selectors: [["nb-calendar-pageable-navigation"]],
  outputs: {
    next: "next",
    prev: "prev"
  },
  standalone: false,
  decls: 4,
  vars: 2,
  consts: [["nbButton", "", "ghost", "", "status", "basic", 1, "prev-month", 3, "click"], ["pack", "nebular-essentials", 3, "icon"], ["nbButton", "", "ghost", "", "status", "basic", 1, "next-month", 3, "click"]],
  template: function NbCalendarPageableNavigationComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "button", 0);
      \u0275\u0275listener("click", function NbCalendarPageableNavigationComponent_Template_button_click_0_listener() {
        return ctx.prev.emit();
      });
      \u0275\u0275element(1, "nb-icon", 1);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(2, "button", 2);
      \u0275\u0275listener("click", function NbCalendarPageableNavigationComponent_Template_button_click_2_listener() {
        return ctx.next.emit();
      });
      \u0275\u0275element(3, "nb-icon", 1);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance();
      \u0275\u0275property("icon", ctx.isLtr ? "chevron-left-outline" : "chevron-right-outline");
      \u0275\u0275advance(2);
      \u0275\u0275property("icon", ctx.isLtr ? "chevron-right-outline" : "chevron-left-outline");
    }
  },
  dependencies: [NbButtonComponent, NbIconComponent],
  styles: ["[_nghost-%COMP%]{display:flex;align-items:center;justify-content:flex-start}\n\n\n\n\n\n"]
});
var NbCalendarPageableNavigationComponent = _NbCalendarPageableNavigationComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarPageableNavigationComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-pageable-navigation",
      template: `
    <button nbButton (click)="prev.emit()" ghost status="basic" class="prev-month">
      <nb-icon [icon]="isLtr ? 'chevron-left-outline' : 'chevron-right-outline'" pack="nebular-essentials"></nb-icon>
    </button>
    <button nbButton (click)="next.emit()" ghost status="basic" class="next-month">
      <nb-icon [icon]="isLtr ? 'chevron-right-outline' : 'chevron-left-outline'" pack="nebular-essentials"></nb-icon>
    </button>
  `,
      standalone: false,
      styles: [":host{display:flex;align-items:center;justify-content:flex-start}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: NbLayoutDirectionService
  }], {
    next: [{
      type: Output
    }],
    prev: [{
      type: Output
    }]
  });
})();
var _NbCalendarYearCellComponent = class _NbCalendarYearCellComponent {
  constructor(dateService) {
    this.dateService = dateService;
    this.size = NbCalendarSize.MEDIUM;
    this.select = new EventEmitter(true);
    this.yearCellClass = true;
  }
  get selected() {
    return this.dateService.isSameYearSafe(this.date, this.selectedValue);
  }
  get today() {
    return this.dateService.isSameYearSafe(this.date, this.dateService.today());
  }
  get disabled() {
    return this.smallerThanMin() || this.greaterThanMax();
  }
  get isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
  get year() {
    return this.dateService.getYear(this.date);
  }
  onClick() {
    if (this.disabled) {
      return;
    }
    this.select.emit(this.date);
  }
  smallerThanMin() {
    return this.date && this.min && this.dateService.compareDates(this.yearEnd(), this.min) < 0;
  }
  greaterThanMax() {
    return this.date && this.max && this.dateService.compareDates(this.yearStart(), this.max) > 0;
  }
  yearStart() {
    return this.dateService.getYearStart(this.date);
  }
  yearEnd() {
    return this.dateService.getYearEnd(this.date);
  }
};
_NbCalendarYearCellComponent.\u0275fac = function NbCalendarYearCellComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbCalendarYearCellComponent)(\u0275\u0275directiveInject(NbDateService));
};
_NbCalendarYearCellComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbCalendarYearCellComponent,
  selectors: [["nb-calendar-year-cell"]],
  hostVars: 10,
  hostBindings: function NbCalendarYearCellComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function NbCalendarYearCellComponent_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
    if (rf & 2) {
      \u0275\u0275classProp("selected", ctx.selected)("today", ctx.today)("disabled", ctx.disabled)("size-large", ctx.isLarge)("year-cell", ctx.yearCellClass);
    }
  },
  inputs: {
    date: "date",
    min: "min",
    max: "max",
    selectedValue: "selectedValue",
    size: "size"
  },
  outputs: {
    select: "select"
  },
  standalone: false,
  decls: 2,
  vars: 1,
  consts: [[1, "cell-content"]],
  template: function NbCalendarYearCellComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0);
      \u0275\u0275text(1);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance();
      \u0275\u0275textInterpolate1(" ", ctx.year, " ");
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbCalendarYearCellComponent = _NbCalendarYearCellComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarYearCellComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-year-cell",
      template: `
    <div class="cell-content">
      {{ year }}
    </div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], () => [{
    type: NbDateService
  }], {
    date: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    selectedValue: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    selected: [{
      type: HostBinding,
      args: ["class.selected"]
    }],
    today: [{
      type: HostBinding,
      args: ["class.today"]
    }],
    disabled: [{
      type: HostBinding,
      args: ["class.disabled"]
    }],
    isLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    yearCellClass: [{
      type: HostBinding,
      args: ["class.year-cell"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var _NbCalendarPickerRowComponent = class _NbCalendarPickerRowComponent {
  constructor() {
    this.size = NbCalendarSize.MEDIUM;
    this.select = new EventEmitter();
  }
  ngOnChanges() {
    this.containerRef.clear();
    this.row.forEach((date) => {
      const component = this.containerRef.createComponent(this.component, {
        index: this.containerRef.length
      });
      this.patchWithContext(component.instance, date);
      component.changeDetectorRef.detectChanges();
    });
  }
  patchWithContext(component, date) {
    component.visibleDate = this.visibleDate;
    component.selectedValue = this.selectedValue;
    component.date = date;
    component.min = this.min;
    component.max = this.max;
    component.filter = this.filter;
    component.size = this.size;
    component.select.subscribe(this.select.emit.bind(this.select));
  }
};
_NbCalendarPickerRowComponent.\u0275fac = function NbCalendarPickerRowComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbCalendarPickerRowComponent)();
};
_NbCalendarPickerRowComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbCalendarPickerRowComponent,
  selectors: [["nb-calendar-picker-row"]],
  viewQuery: function NbCalendarPickerRowComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(TemplateRef, 7, ViewContainerRef);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.containerRef = _t.first);
    }
  },
  inputs: {
    row: "row",
    selectedValue: "selectedValue",
    visibleDate: "visibleDate",
    component: "component",
    min: "min",
    max: "max",
    filter: "filter",
    size: "size"
  },
  outputs: {
    select: "select"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  decls: 1,
  vars: 0,
  template: function NbCalendarPickerRowComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NbCalendarPickerRowComponent_ng_template_0_Template, 0, 0, "ng-template");
    }
  },
  styles: ["[_nghost-%COMP%]{display:flex;justify-content:space-between}"],
  changeDetection: 0
});
var NbCalendarPickerRowComponent = _NbCalendarPickerRowComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarPickerRowComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-picker-row",
      template: "<ng-template></ng-template>",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      styles: [":host{display:flex;justify-content:space-between}\n"]
    }]
  }], null, {
    row: [{
      type: Input
    }],
    selectedValue: [{
      type: Input
    }],
    visibleDate: [{
      type: Input
    }],
    component: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    containerRef: [{
      type: ViewChild,
      args: [TemplateRef, {
        read: ViewContainerRef,
        static: true
      }]
    }]
  });
})();
var _NbCalendarPickerComponent = class _NbCalendarPickerComponent {
  constructor() {
    this.size = NbCalendarSize.MEDIUM;
    this.select = new EventEmitter();
  }
  get isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
};
_NbCalendarPickerComponent.\u0275fac = function NbCalendarPickerComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbCalendarPickerComponent)();
};
_NbCalendarPickerComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbCalendarPickerComponent,
  selectors: [["nb-calendar-picker"]],
  hostVars: 2,
  hostBindings: function NbCalendarPickerComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("size-large", ctx.isLarge);
    }
  },
  inputs: {
    data: "data",
    visibleDate: "visibleDate",
    selectedValue: "selectedValue",
    cellComponent: "cellComponent",
    min: "min",
    max: "max",
    filter: "filter",
    size: "size"
  },
  outputs: {
    select: "select"
  },
  standalone: false,
  decls: 1,
  vars: 1,
  consts: [[3, "row", "visibleDate", "selectedValue", "component", "min", "max", "filter", "size", "select", 4, "ngFor", "ngForOf"], [3, "select", "row", "visibleDate", "selectedValue", "component", "min", "max", "filter", "size"]],
  template: function NbCalendarPickerComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NbCalendarPickerComponent_nb_calendar_picker_row_0_Template, 1, 8, "nb-calendar-picker-row", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("ngForOf", ctx.data);
    }
  },
  dependencies: [NgForOf, NbCalendarPickerRowComponent],
  encapsulation: 2,
  changeDetection: 0
});
var NbCalendarPickerComponent = _NbCalendarPickerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarPickerComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-picker",
      template: `
    <nb-calendar-picker-row
      *ngFor="let row of data"
      [row]="row"
      [visibleDate]="visibleDate"
      [selectedValue]="selectedValue"
      [component]="cellComponent"
      [min]="min"
      [max]="max"
      [filter]="filter"
      [size]="size"
      (select)="select.emit($event)">
    </nb-calendar-picker-row>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], null, {
    data: [{
      type: Input
    }],
    visibleDate: [{
      type: Input
    }],
    selectedValue: [{
      type: Input
    }],
    cellComponent: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    isLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }]
  });
})();
var _NbCalendarYearPickerComponent = class _NbCalendarYearPickerComponent {
  set _cellComponent(cellComponent) {
    if (cellComponent) {
      this.cellComponent = cellComponent;
    }
  }
  get large() {
    return this.size === NbCalendarSize.LARGE;
  }
  constructor(dateService, yearModelService) {
    this.dateService = dateService;
    this.yearModelService = yearModelService;
    this.cellComponent = NbCalendarYearCellComponent;
    this.size = NbCalendarSize.MEDIUM;
    this.yearChange = new EventEmitter();
  }
  ngOnChanges() {
    this.years = this.yearModelService.getViewYears(this.year);
  }
  onSelect(year) {
    this.yearChange.emit(year);
  }
};
_NbCalendarYearPickerComponent.\u0275fac = function NbCalendarYearPickerComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbCalendarYearPickerComponent)(\u0275\u0275directiveInject(NbDateService), \u0275\u0275directiveInject(NbCalendarYearModelService));
};
_NbCalendarYearPickerComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbCalendarYearPickerComponent,
  selectors: [["nb-calendar-year-picker"]],
  hostVars: 2,
  hostBindings: function NbCalendarYearPickerComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("size-large", ctx.large);
    }
  },
  inputs: {
    date: "date",
    min: "min",
    max: "max",
    filter: "filter",
    _cellComponent: [0, "cellComponent", "_cellComponent"],
    size: "size",
    year: "year"
  },
  outputs: {
    yearChange: "yearChange"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  decls: 1,
  vars: 8,
  consts: [[3, "select", "data", "min", "max", "filter", "selectedValue", "visibleDate", "cellComponent", "size"]],
  template: function NbCalendarYearPickerComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "nb-calendar-picker", 0);
      \u0275\u0275listener("select", function NbCalendarYearPickerComponent_Template_nb_calendar_picker_select_0_listener($event) {
        return ctx.onSelect($event);
      });
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275property("data", ctx.years)("min", ctx.min)("max", ctx.max)("filter", ctx.filter)("selectedValue", ctx.date)("visibleDate", ctx.year)("cellComponent", ctx.cellComponent)("size", ctx.size);
    }
  },
  dependencies: [NbCalendarPickerComponent],
  encapsulation: 2,
  changeDetection: 0
});
var NbCalendarYearPickerComponent = _NbCalendarYearPickerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarYearPickerComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-year-picker",
      template: `
    <nb-calendar-picker
      [data]="years"
      [min]="min"
      [max]="max"
      [filter]="filter"
      [selectedValue]="date"
      [visibleDate]="year"
      [cellComponent]="cellComponent"
      [size]="size"
      (select)="onSelect($event)">
    </nb-calendar-picker>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], () => [{
    type: NbDateService
  }, {
    type: NbCalendarYearModelService
  }], {
    date: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    _cellComponent: [{
      type: Input,
      args: ["cellComponent"]
    }],
    size: [{
      type: Input
    }],
    year: [{
      type: Input
    }],
    yearChange: [{
      type: Output
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }]
  });
})();
var _NbCalendarMonthCellComponent = class _NbCalendarMonthCellComponent {
  constructor(dateService) {
    this.dateService = dateService;
    this.size = NbCalendarSize.MEDIUM;
    this.select = new EventEmitter(true);
    this.monthCellClass = true;
  }
  get selected() {
    return this.dateService.isSameMonthSafe(this.date, this.selectedValue);
  }
  get today() {
    return this.dateService.isSameMonthSafe(this.date, this.dateService.today());
  }
  get disabled() {
    return this.smallerThanMin() || this.greaterThanMax();
  }
  get isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
  get month() {
    return this.dateService.getMonthName(this.date);
  }
  onClick() {
    if (this.disabled) {
      return;
    }
    this.select.emit(this.date);
  }
  smallerThanMin() {
    return this.date && this.min && this.dateService.compareDates(this.monthEnd(), this.min) < 0;
  }
  greaterThanMax() {
    return this.date && this.max && this.dateService.compareDates(this.monthStart(), this.max) > 0;
  }
  monthStart() {
    return this.dateService.getMonthStart(this.date);
  }
  monthEnd() {
    return this.dateService.getMonthEnd(this.date);
  }
};
_NbCalendarMonthCellComponent.\u0275fac = function NbCalendarMonthCellComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbCalendarMonthCellComponent)(\u0275\u0275directiveInject(NbDateService));
};
_NbCalendarMonthCellComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbCalendarMonthCellComponent,
  selectors: [["nb-calendar-month-cell"]],
  hostVars: 10,
  hostBindings: function NbCalendarMonthCellComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function NbCalendarMonthCellComponent_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
    if (rf & 2) {
      \u0275\u0275classProp("selected", ctx.selected)("today", ctx.today)("disabled", ctx.disabled)("size-large", ctx.isLarge)("month-cell", ctx.monthCellClass);
    }
  },
  inputs: {
    date: "date",
    selectedValue: "selectedValue",
    min: "min",
    max: "max",
    size: "size"
  },
  outputs: {
    select: "select"
  },
  standalone: false,
  decls: 2,
  vars: 1,
  consts: [[1, "cell-content"]],
  template: function NbCalendarMonthCellComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0);
      \u0275\u0275text(1);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance();
      \u0275\u0275textInterpolate1(" ", ctx.month, " ");
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbCalendarMonthCellComponent = _NbCalendarMonthCellComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarMonthCellComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-month-cell",
      template: `
    <div class="cell-content">
      {{ month }}
    </div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], () => [{
    type: NbDateService
  }], {
    date: [{
      type: Input
    }],
    selectedValue: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    selected: [{
      type: HostBinding,
      args: ["class.selected"]
    }],
    today: [{
      type: HostBinding,
      args: ["class.today"]
    }],
    disabled: [{
      type: HostBinding,
      args: ["class.disabled"]
    }],
    isLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    monthCellClass: [{
      type: HostBinding,
      args: ["class.month-cell"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var MONTHS_IN_VIEW = 12;
var MONTHS_IN_COLUMN = 4;
var _NbCalendarMonthPickerComponent = class _NbCalendarMonthPickerComponent {
  constructor(dateService) {
    this.dateService = dateService;
    this.size = NbCalendarSize.MEDIUM;
    this.monthChange = new EventEmitter();
    this.cellComponent = NbCalendarMonthCellComponent;
  }
  set _cellComponent(cellComponent) {
    if (cellComponent) {
      this.cellComponent = cellComponent;
    }
  }
  get large() {
    return this.size === NbCalendarSize.LARGE;
  }
  ngOnChanges(changes) {
    if (changes.month) {
      this.initMonths();
    }
  }
  initMonths() {
    const date = this.dateService.getDate(this.month);
    const year = this.dateService.getYear(this.month);
    const firstMonth = this.dateService.createDate(year, 0, date);
    const months = [firstMonth];
    for (let monthIndex = 1; monthIndex < MONTHS_IN_VIEW; monthIndex++) {
      months.push(this.dateService.addMonth(firstMonth, monthIndex));
    }
    this.months = batch(months, MONTHS_IN_COLUMN);
  }
  onSelect(month) {
    this.monthChange.emit(month);
  }
};
_NbCalendarMonthPickerComponent.\u0275fac = function NbCalendarMonthPickerComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbCalendarMonthPickerComponent)(\u0275\u0275directiveInject(NbDateService));
};
_NbCalendarMonthPickerComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbCalendarMonthPickerComponent,
  selectors: [["nb-calendar-month-picker"]],
  hostVars: 2,
  hostBindings: function NbCalendarMonthPickerComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("size-large", ctx.large);
    }
  },
  inputs: {
    min: "min",
    max: "max",
    filter: "filter",
    size: "size",
    month: "month",
    date: "date",
    _cellComponent: [0, "cellComponent", "_cellComponent"]
  },
  outputs: {
    monthChange: "monthChange"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  decls: 1,
  vars: 8,
  consts: [[3, "select", "data", "min", "max", "filter", "selectedValue", "visibleDate", "cellComponent", "size"]],
  template: function NbCalendarMonthPickerComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "nb-calendar-picker", 0);
      \u0275\u0275listener("select", function NbCalendarMonthPickerComponent_Template_nb_calendar_picker_select_0_listener($event) {
        return ctx.onSelect($event);
      });
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275property("data", ctx.months)("min", ctx.min)("max", ctx.max)("filter", ctx.filter)("selectedValue", ctx.date)("visibleDate", ctx.month)("cellComponent", ctx.cellComponent)("size", ctx.size);
    }
  },
  dependencies: [NbCalendarPickerComponent],
  encapsulation: 2,
  changeDetection: 0
});
var NbCalendarMonthPickerComponent = _NbCalendarMonthPickerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarMonthPickerComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-month-picker",
      template: `
    <nb-calendar-picker
      [data]="months"
      [min]="min"
      [max]="max"
      [filter]="filter"
      [selectedValue]="date"
      [visibleDate]="month"
      [cellComponent]="cellComponent"
      [size]="size"
      (select)="onSelect($event)">
    </nb-calendar-picker>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], () => [{
    type: NbDateService
  }], {
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    month: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    monthChange: [{
      type: Output
    }],
    _cellComponent: [{
      type: Input,
      args: ["cellComponent"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }]
  });
})();
var _NbCalendarDayCellComponent = class _NbCalendarDayCellComponent {
  constructor(dateService) {
    this.dateService = dateService;
    this.size = NbCalendarSize.MEDIUM;
    this.select = new EventEmitter(true);
    this.dayCellClass = true;
  }
  get today() {
    return this.dateService.isSameDaySafe(this.date, this.dateService.today());
  }
  get boundingMonth() {
    return !this.dateService.isSameMonthSafe(this.date, this.visibleDate);
  }
  get selected() {
    return this.dateService.isSameDaySafe(this.date, this.selectedValue);
  }
  get empty() {
    return !this.date;
  }
  get disabled() {
    return this.smallerThanMin() || this.greaterThanMax() || this.dontFitFilter();
  }
  get isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
  get day() {
    return this.date && this.dateService.getDate(this.date);
  }
  onClick() {
    if (this.disabled || this.empty) {
      return;
    }
    this.select.emit(this.date);
  }
  smallerThanMin() {
    return this.date && this.min && this.dateService.compareDates(this.date, this.min) < 0;
  }
  greaterThanMax() {
    return this.date && this.max && this.dateService.compareDates(this.date, this.max) > 0;
  }
  dontFitFilter() {
    return this.date && this.filter && !this.filter(this.date);
  }
};
_NbCalendarDayCellComponent.\u0275fac = function NbCalendarDayCellComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbCalendarDayCellComponent)(\u0275\u0275directiveInject(NbDateService));
};
_NbCalendarDayCellComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbCalendarDayCellComponent,
  selectors: [["nb-calendar-day-cell"]],
  hostVars: 14,
  hostBindings: function NbCalendarDayCellComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function NbCalendarDayCellComponent_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
    if (rf & 2) {
      \u0275\u0275classProp("today", ctx.today)("bounding-month", ctx.boundingMonth)("selected", ctx.selected)("empty", ctx.empty)("disabled", ctx.disabled)("size-large", ctx.isLarge)("day-cell", ctx.dayCellClass);
    }
  },
  inputs: {
    date: "date",
    selectedValue: "selectedValue",
    visibleDate: "visibleDate",
    min: "min",
    max: "max",
    filter: "filter",
    size: "size"
  },
  outputs: {
    select: "select"
  },
  standalone: false,
  decls: 2,
  vars: 1,
  consts: [[1, "cell-content"]],
  template: function NbCalendarDayCellComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0);
      \u0275\u0275text(1);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance();
      \u0275\u0275textInterpolate1(" ", ctx.day, " ");
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbCalendarDayCellComponent = _NbCalendarDayCellComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarDayCellComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-day-cell",
      template: `
    <div class="cell-content">
      {{ day }}
    </div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], () => [{
    type: NbDateService
  }], {
    date: [{
      type: Input
    }],
    selectedValue: [{
      type: Input
    }],
    visibleDate: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    today: [{
      type: HostBinding,
      args: ["class.today"]
    }],
    boundingMonth: [{
      type: HostBinding,
      args: ["class.bounding-month"]
    }],
    selected: [{
      type: HostBinding,
      args: ["class.selected"]
    }],
    empty: [{
      type: HostBinding,
      args: ["class.empty"]
    }],
    disabled: [{
      type: HostBinding,
      args: ["class.disabled"]
    }],
    isLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    dayCellClass: [{
      type: HostBinding,
      args: ["class.day-cell"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var _NbCalendarMonthModelService = class _NbCalendarMonthModelService {
  constructor(dateService) {
    this.dateService = dateService;
  }
  createDaysGrid(activeMonth, boundingMonth = true, firstDayOfWeek) {
    const weeks = this.createDates(activeMonth, firstDayOfWeek);
    return this.withBoundingMonths(weeks, activeMonth, boundingMonth);
  }
  createDates(activeMonth, firstDayOfWeek) {
    const days = this.createDateRangeForMonth(activeMonth);
    const startOfWeekDayDiff = this.getStartOfWeekDayDiff(activeMonth, firstDayOfWeek);
    return batch(days, this.dateService.DAYS_IN_WEEK, startOfWeekDayDiff);
  }
  withBoundingMonths(weeks, activeMonth, boundingMonth) {
    let withBoundingMonths = weeks;
    if (this.isShouldAddPrevBoundingMonth(withBoundingMonths)) {
      withBoundingMonths = this.addPrevBoundingMonth(withBoundingMonths, activeMonth, boundingMonth);
    }
    if (this.isShouldAddNextBoundingMonth(withBoundingMonths)) {
      withBoundingMonths = this.addNextBoundingMonth(withBoundingMonths, activeMonth, boundingMonth);
    }
    return withBoundingMonths;
  }
  addPrevBoundingMonth(weeks, activeMonth, boundingMonth) {
    const firstWeek = weeks.shift();
    const requiredItems = this.dateService.DAYS_IN_WEEK - firstWeek.length;
    firstWeek.unshift(...this.createPrevBoundingDays(activeMonth, boundingMonth, requiredItems));
    return [firstWeek, ...weeks];
  }
  addNextBoundingMonth(weeks, activeMonth, boundingMonth) {
    const lastWeek = weeks.pop();
    const requiredItems = this.dateService.DAYS_IN_WEEK - lastWeek.length;
    lastWeek.push(...this.createNextBoundingDays(activeMonth, boundingMonth, requiredItems));
    return [...weeks, lastWeek];
  }
  createPrevBoundingDays(activeMonth, boundingMonth, requiredItems) {
    const month = this.dateService.addMonth(activeMonth, -1);
    const daysInMonth = this.dateService.getNumberOfDaysInMonth(month);
    return this.createDateRangeForMonth(month).slice(daysInMonth - requiredItems).map((date) => boundingMonth ? date : null);
  }
  createNextBoundingDays(activeMonth, boundingMonth, requiredItems) {
    const month = this.dateService.addMonth(activeMonth, 1);
    return this.createDateRangeForMonth(month).slice(0, requiredItems).map((date) => boundingMonth ? date : null);
  }
  getStartOfWeekDayDiff(date, firstDayOfWeek) {
    const startOfMonth = this.dateService.getMonthStart(date);
    return this.getWeekStartDiff(startOfMonth, firstDayOfWeek);
  }
  getWeekStartDiff(date, firstDayOfWeek) {
    const weekOfset = firstDayOfWeek ?? this.dateService.getFirstDayOfWeek();
    return (7 - weekOfset + this.dateService.getDayOfWeek(date)) % 7;
  }
  isShouldAddPrevBoundingMonth(weeks) {
    return weeks[0].length < this.dateService.DAYS_IN_WEEK;
  }
  isShouldAddNextBoundingMonth(weeks) {
    return weeks[weeks.length - 1].length < this.dateService.DAYS_IN_WEEK;
  }
  createDateRangeForMonth(date) {
    const daysInMonth = this.dateService.getNumberOfDaysInMonth(date);
    return range(daysInMonth, (i) => {
      const year = this.dateService.getYear(date);
      const month = this.dateService.getMonth(date);
      return this.dateService.createDate(year, month, i + 1);
    });
  }
};
_NbCalendarMonthModelService.\u0275fac = function NbCalendarMonthModelService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbCalendarMonthModelService)(\u0275\u0275inject(NbDateService));
};
_NbCalendarMonthModelService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbCalendarMonthModelService,
  factory: _NbCalendarMonthModelService.\u0275fac
});
var NbCalendarMonthModelService = _NbCalendarMonthModelService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarMonthModelService, [{
    type: Injectable
  }], () => [{
    type: NbDateService
  }], null);
})();
var _NbCalendarDaysNamesComponent = class _NbCalendarDaysNamesComponent {
  get isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
  constructor(dateService) {
    this.dateService = dateService;
  }
  ngOnInit() {
    const days = this.createDaysNames();
    this.days = this.shiftStartOfWeek(days);
  }
  ngOnChanges({
    firstDayOfWeek
  }) {
    if (firstDayOfWeek) {
      const days = this.createDaysNames();
      this.days = this.shiftStartOfWeek(days);
    }
  }
  createDaysNames() {
    return this.dateService.getDayOfWeekNames().map(this.markIfHoliday);
  }
  shiftStartOfWeek(days) {
    const firstDayOfWeek = this.firstDayOfWeek ?? this.dateService.getFirstDayOfWeek();
    for (let i = 0; i < firstDayOfWeek; i++) {
      days.push(days.shift());
    }
    return days;
  }
  markIfHoliday(name, i) {
    return {
      name,
      isHoliday: i % 6 === 0
    };
  }
};
_NbCalendarDaysNamesComponent.\u0275fac = function NbCalendarDaysNamesComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbCalendarDaysNamesComponent)(\u0275\u0275directiveInject(NbDateService));
};
_NbCalendarDaysNamesComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbCalendarDaysNamesComponent,
  selectors: [["nb-calendar-days-names"]],
  hostVars: 2,
  hostBindings: function NbCalendarDaysNamesComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("size-large", ctx.isLarge);
    }
  },
  inputs: {
    size: "size",
    firstDayOfWeek: "firstDayOfWeek"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  decls: 1,
  vars: 1,
  consts: [["class", "day", 3, "holiday", 4, "ngFor", "ngForOf"], [1, "day"]],
  template: function NbCalendarDaysNamesComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NbCalendarDaysNamesComponent_div_0_Template, 2, 3, "div", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("ngForOf", ctx.days);
    }
  },
  dependencies: [NgForOf],
  styles: ["[_nghost-%COMP%]{display:flex;justify-content:space-between}[_nghost-%COMP%]   .day[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center}\n\n\n\n\n\n"],
  changeDetection: 0
});
var NbCalendarDaysNamesComponent = _NbCalendarDaysNamesComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarDaysNamesComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-days-names",
      template: `
    <div class="day" *ngFor="let day of days" [class.holiday]="day.isHoliday">{{ day.name }}</div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      styles: [":host{display:flex;justify-content:space-between}:host .day{display:flex;align-items:center;justify-content:center}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: NbDateService
  }], {
    size: [{
      type: Input
    }],
    isLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    firstDayOfWeek: [{
      type: Input
    }]
  });
})();
var _NbCalendarWeekNumberComponent = class _NbCalendarWeekNumberComponent {
  get isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
  constructor(dateService) {
    this.dateService = dateService;
  }
  ngOnChanges(changes) {
    if (changes.weeks) {
      this.weekNumbers = this.getWeeks();
    }
  }
  getWeeks() {
    return this.weeks.map((week) => {
      const lastDay = [...week].reverse().find((day) => !!day);
      return this.dateService.getWeekNumber(lastDay);
    });
  }
};
_NbCalendarWeekNumberComponent.\u0275fac = function NbCalendarWeekNumberComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbCalendarWeekNumberComponent)(\u0275\u0275directiveInject(NbDateService));
};
_NbCalendarWeekNumberComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbCalendarWeekNumberComponent,
  selectors: [["nb-calendar-week-numbers"]],
  hostVars: 2,
  hostBindings: function NbCalendarWeekNumberComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("size-large", ctx.isLarge);
    }
  },
  inputs: {
    weeks: "weeks",
    size: "size",
    weekNumberSymbol: "weekNumberSymbol"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  decls: 4,
  vars: 2,
  consts: [[1, "sign-container"], [1, "sign"], ["class", "week-number", 4, "ngFor", "ngForOf"], [1, "week-number"]],
  template: function NbCalendarWeekNumberComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0)(1, "div", 1);
      \u0275\u0275text(2);
      \u0275\u0275elementEnd()();
      \u0275\u0275template(3, NbCalendarWeekNumberComponent_div_3_Template, 2, 1, "div", 2);
    }
    if (rf & 2) {
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate(ctx.weekNumberSymbol);
      \u0275\u0275advance();
      \u0275\u0275property("ngForOf", ctx.weekNumbers);
    }
  },
  dependencies: [NgForOf],
  styles: [_c8],
  changeDetection: 0
});
var NbCalendarWeekNumberComponent = _NbCalendarWeekNumberComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarWeekNumberComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-week-numbers",
      template: `
    <div class="sign-container">
      <div class="sign">{{ weekNumberSymbol }}</div>
    </div>
    <div class="week-number" *ngFor="let weekNumber of weekNumbers">{{ weekNumber }}</div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      styles: [":host{display:flex;flex-direction:column}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: NbDateService
  }], {
    weeks: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    weekNumberSymbol: [{
      type: Input
    }],
    isLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }]
  });
})();
var _NbCalendarDayPickerComponent = class _NbCalendarDayPickerComponent {
  /**
   * Custom day cell component. Have to implement `NbCalendarCell` interface.
   * */
  set setCellComponent(cellComponent) {
    if (cellComponent) {
      this.cellComponent = cellComponent;
    }
  }
  /**
   * Determines should we show week numbers column.
   * False by default.
   * */
  get showWeekNumber() {
    return this._showWeekNumber;
  }
  set showWeekNumber(value) {
    this._showWeekNumber = convertToBoolProperty(value);
  }
  get large() {
    return this.size === NbCalendarSize.LARGE;
  }
  constructor(monthModel) {
    this.monthModel = monthModel;
    this.boundingMonths = true;
    this.cellComponent = NbCalendarDayCellComponent;
    this.size = NbCalendarSize.MEDIUM;
    this._showWeekNumber = false;
    this.dateChange = new EventEmitter();
  }
  ngOnChanges({
    visibleDate,
    boundingMonths,
    firstDayOfWeek
  }) {
    if (visibleDate || boundingMonths || firstDayOfWeek) {
      this.weeks = this.monthModel.createDaysGrid(this.visibleDate, this.boundingMonths, this.firstDayOfWeek);
    }
  }
  onSelect(day) {
    this.dateChange.emit(day);
  }
};
_NbCalendarDayPickerComponent.\u0275fac = function NbCalendarDayPickerComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbCalendarDayPickerComponent)(\u0275\u0275directiveInject(NbCalendarMonthModelService));
};
_NbCalendarDayPickerComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbCalendarDayPickerComponent,
  selectors: [["nb-calendar-day-picker"]],
  hostVars: 2,
  hostBindings: function NbCalendarDayPickerComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("size-large", ctx.large);
    }
  },
  inputs: {
    visibleDate: "visibleDate",
    boundingMonths: "boundingMonths",
    min: "min",
    max: "max",
    filter: "filter",
    setCellComponent: [0, "cellComponent", "setCellComponent"],
    size: "size",
    date: "date",
    showWeekNumber: "showWeekNumber",
    weekNumberSymbol: "weekNumberSymbol",
    firstDayOfWeek: "firstDayOfWeek"
  },
  outputs: {
    dateChange: "dateChange"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  decls: 4,
  vars: 11,
  consts: [[3, "weeks", "size", "weekNumberSymbol", 4, "ngIf"], [1, "days-container"], [3, "size", "firstDayOfWeek"], [3, "select", "data", "visibleDate", "selectedValue", "cellComponent", "min", "max", "filter", "size"], [3, "weeks", "size", "weekNumberSymbol"]],
  template: function NbCalendarDayPickerComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NbCalendarDayPickerComponent_nb_calendar_week_numbers_0_Template, 1, 3, "nb-calendar-week-numbers", 0);
      \u0275\u0275elementStart(1, "div", 1);
      \u0275\u0275element(2, "nb-calendar-days-names", 2);
      \u0275\u0275elementStart(3, "nb-calendar-picker", 3);
      \u0275\u0275listener("select", function NbCalendarDayPickerComponent_Template_nb_calendar_picker_select_3_listener($event) {
        return ctx.onSelect($event);
      });
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.showWeekNumber);
      \u0275\u0275advance(2);
      \u0275\u0275property("size", ctx.size)("firstDayOfWeek", ctx.firstDayOfWeek);
      \u0275\u0275advance();
      \u0275\u0275property("data", ctx.weeks)("visibleDate", ctx.visibleDate)("selectedValue", ctx.date)("cellComponent", ctx.cellComponent)("min", ctx.min)("max", ctx.max)("filter", ctx.filter)("size", ctx.size);
    }
  },
  dependencies: [NgIf, NbCalendarDaysNamesComponent, NbCalendarPickerComponent, NbCalendarWeekNumberComponent],
  styles: ["[_nghost-%COMP%]{display:flex}.days-container[_ngcontent-%COMP%]{width:100%}"],
  changeDetection: 0
});
var NbCalendarDayPickerComponent = _NbCalendarDayPickerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarDayPickerComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-day-picker",
      template: `
    <nb-calendar-week-numbers *ngIf="showWeekNumber"
                              [weeks]="weeks"
                              [size]="size"
                              [weekNumberSymbol]="weekNumberSymbol">
    </nb-calendar-week-numbers>
    <div class="days-container">
      <nb-calendar-days-names [size]="size" [firstDayOfWeek]="firstDayOfWeek"></nb-calendar-days-names>
      <nb-calendar-picker
          [data]="weeks"
          [visibleDate]="visibleDate"
          [selectedValue]="date"
          [cellComponent]="cellComponent"
          [min]="min"
          [max]="max"
          [filter]="filter"
          [size]="size"
          (select)="onSelect($event)">
      </nb-calendar-picker>
    </div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      styles: [":host{display:flex}.days-container{width:100%}\n"]
    }]
  }], () => [{
    type: NbCalendarMonthModelService
  }], {
    visibleDate: [{
      type: Input
    }],
    boundingMonths: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    setCellComponent: [{
      type: Input,
      args: ["cellComponent"]
    }],
    size: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    showWeekNumber: [{
      type: Input
    }],
    weekNumberSymbol: [{
      type: Input
    }],
    firstDayOfWeek: [{
      type: Input
    }],
    dateChange: [{
      type: Output
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }]
  });
})();
var _NbBaseCalendarComponent = class _NbBaseCalendarComponent {
  /**
   * Determines should we show week numbers column.
   * False by default.
   * */
  get showWeekNumber() {
    return this._showWeekNumber;
  }
  set showWeekNumber(value) {
    this._showWeekNumber = convertToBoolProperty(value);
  }
  constructor(dateService, yearModelService) {
    this.dateService = dateService;
    this.yearModelService = yearModelService;
    this.boundingMonth = true;
    this.activeViewMode = NbCalendarViewMode.DATE;
    this.size = NbCalendarSize.MEDIUM;
    this.showNavigation = true;
    this._showWeekNumber = false;
    this.dateChange = new EventEmitter();
    this.ViewMode = NbCalendarViewMode;
  }
  ngOnInit() {
    if (!this.visibleDate) {
      this.visibleDate = this.dateService.today();
    }
  }
  get large() {
    return this.size === NbCalendarSize.LARGE;
  }
  setViewMode(viewMode) {
    this.activeViewMode = viewMode;
  }
  setVisibleDate(visibleDate) {
    this.visibleDate = visibleDate;
  }
  prevMonth() {
    this.changeVisibleMonth(-1);
  }
  nextMonth() {
    this.changeVisibleMonth(1);
  }
  prevYear() {
    this.changeVisibleYear(-1);
  }
  nextYear() {
    this.changeVisibleYear(1);
  }
  prevYears() {
    this.changeVisibleYears(-1);
  }
  nextYears() {
    this.changeVisibleYears(1);
  }
  navigatePrev() {
    switch (this.activeViewMode) {
      case NbCalendarViewMode.DATE:
        return this.prevMonth();
      case NbCalendarViewMode.MONTH:
        return this.prevYear();
      case NbCalendarViewMode.YEAR:
        return this.prevYears();
    }
  }
  navigateNext() {
    switch (this.activeViewMode) {
      case NbCalendarViewMode.DATE:
        return this.nextMonth();
      case NbCalendarViewMode.MONTH:
        return this.nextYear();
      case NbCalendarViewMode.YEAR:
        return this.nextYears();
    }
  }
  onChangeViewMode() {
    if (this.activeViewMode === NbCalendarViewMode.DATE) {
      return this.setViewMode(NbCalendarViewMode.YEAR);
    }
    this.setViewMode(NbCalendarViewMode.DATE);
  }
  changeVisibleMonth(direction) {
    this.visibleDate = this.dateService.addMonth(this.visibleDate, direction);
  }
  changeVisibleYear(direction) {
    this.visibleDate = this.dateService.addYear(this.visibleDate, direction);
  }
  changeVisibleYears(direction) {
    this.visibleDate = this.dateService.addYear(this.visibleDate, direction * this.yearModelService.getYearsInView());
  }
};
_NbBaseCalendarComponent.\u0275fac = function NbBaseCalendarComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbBaseCalendarComponent)(\u0275\u0275directiveInject(NbDateService), \u0275\u0275directiveInject(NbCalendarYearModelService));
};
_NbBaseCalendarComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbBaseCalendarComponent,
  selectors: [["nb-base-calendar"]],
  hostVars: 6,
  hostBindings: function NbBaseCalendarComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("has-navigation", ctx.showNavigation)("has-week-number", ctx.showWeekNumber)("size-large", ctx.large);
    }
  },
  inputs: {
    boundingMonth: "boundingMonth",
    activeViewMode: [0, "startView", "activeViewMode"],
    min: "min",
    max: "max",
    filter: "filter",
    dayCellComponent: "dayCellComponent",
    monthCellComponent: "monthCellComponent",
    yearCellComponent: "yearCellComponent",
    size: "size",
    visibleDate: "visibleDate",
    showNavigation: "showNavigation",
    date: "date",
    showWeekNumber: "showWeekNumber",
    weekNumberSymbol: "weekNumberSymbol",
    firstDayOfWeek: "firstDayOfWeek"
  },
  outputs: {
    dateChange: "dateChange"
  },
  standalone: false,
  decls: 6,
  vars: 5,
  consts: [["class", "calendar-navigation", 4, "ngIf"], [3, "ngSwitch"], [3, "boundingMonths", "cellComponent", "min", "max", "filter", "visibleDate", "size", "date", "showWeekNumber", "firstDayOfWeek", "weekNumberSymbol", "dateChange", 4, "ngSwitchCase"], [3, "cellComponent", "date", "min", "max", "filter", "size", "year", "yearChange", 4, "ngSwitchCase"], [3, "cellComponent", "min", "max", "filter", "size", "month", "date", "monthChange", 4, "ngSwitchCase"], [1, "calendar-navigation"], [3, "changeMode", "date", "viewMode"], [3, "prev", "next"], [3, "dateChange", "boundingMonths", "cellComponent", "min", "max", "filter", "visibleDate", "size", "date", "showWeekNumber", "firstDayOfWeek", "weekNumberSymbol"], [3, "yearChange", "cellComponent", "date", "min", "max", "filter", "size", "year"], [3, "monthChange", "cellComponent", "min", "max", "filter", "size", "month", "date"]],
  template: function NbBaseCalendarComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "nb-card");
      \u0275\u0275template(1, NbBaseCalendarComponent_nb_card_header_1_Template, 3, 2, "nb-card-header", 0);
      \u0275\u0275elementStart(2, "nb-card-body", 1);
      \u0275\u0275template(3, NbBaseCalendarComponent_nb_calendar_day_picker_3_Template, 1, 11, "nb-calendar-day-picker", 2)(4, NbBaseCalendarComponent_nb_calendar_year_picker_4_Template, 1, 7, "nb-calendar-year-picker", 3)(5, NbBaseCalendarComponent_nb_calendar_month_picker_5_Template, 1, 7, "nb-calendar-month-picker", 4);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.showNavigation);
      \u0275\u0275advance();
      \u0275\u0275property("ngSwitch", ctx.activeViewMode);
      \u0275\u0275advance();
      \u0275\u0275property("ngSwitchCase", ctx.ViewMode.DATE);
      \u0275\u0275advance();
      \u0275\u0275property("ngSwitchCase", ctx.ViewMode.YEAR);
      \u0275\u0275advance();
      \u0275\u0275property("ngSwitchCase", ctx.ViewMode.MONTH);
    }
  },
  dependencies: [NbCalendarViewModeComponent, NbCalendarPageableNavigationComponent, NbCalendarYearPickerComponent, NbCalendarMonthPickerComponent, NbCalendarDayPickerComponent, NgIf, NgSwitch, NgSwitchCase, NbCardComponent, NbCardBodyComponent, NbCardHeaderComponent],
  encapsulation: 2
});
var NbBaseCalendarComponent = _NbBaseCalendarComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbBaseCalendarComponent, [{
    type: Component,
    args: [{
      selector: "nb-base-calendar",
      standalone: false,
      template: '<nb-card>\n  <nb-card-header *ngIf="showNavigation" class="calendar-navigation">\n    <nb-calendar-view-mode [date]="visibleDate"\n                           [viewMode]="activeViewMode"\n                           (changeMode)="onChangeViewMode()">\n    </nb-calendar-view-mode>\n\n    <nb-calendar-pageable-navigation (prev)="navigatePrev()" (next)="navigateNext()">\n    </nb-calendar-pageable-navigation>\n  </nb-card-header>\n\n  <nb-card-body [ngSwitch]="activeViewMode">\n\n    <nb-calendar-day-picker *ngSwitchCase="ViewMode.DATE"\n                            [boundingMonths]="boundingMonth"\n                            [cellComponent]="dayCellComponent"\n                            [min]="min"\n                            [max]="max"\n                            [filter]="filter"\n                            [visibleDate]="visibleDate"\n                            [size]="size"\n                            [date]="date"\n                            [showWeekNumber]="showWeekNumber"\n                            [firstDayOfWeek]="firstDayOfWeek"\n                            (dateChange)="dateChange.emit($any($event))"\n                            [weekNumberSymbol]="weekNumberSymbol">\n    </nb-calendar-day-picker>\n\n    <nb-calendar-year-picker *ngSwitchCase="ViewMode.YEAR"\n                             [cellComponent]="yearCellComponent"\n                             [date]="$any(date)"\n                             [min]="min"\n                             [max]="max"\n                             [filter]="filter"\n                             [size]="size"\n                             [year]="visibleDate"\n                             (yearChange)="setVisibleDate($event); setViewMode(ViewMode.MONTH)">\n    </nb-calendar-year-picker>\n\n    <nb-calendar-month-picker *ngSwitchCase="ViewMode.MONTH"\n                              [cellComponent]="monthCellComponent"\n                              [min]="min"\n                              [max]="max"\n                              [filter]="filter"\n                              [size]="size"\n                              [month]="visibleDate"\n                              [date]="$any(date)"\n                              (monthChange)="setVisibleDate($event); setViewMode(ViewMode.DATE)">\n    </nb-calendar-month-picker>\n\n  </nb-card-body>\n\n</nb-card>\n'
    }]
  }], () => [{
    type: NbDateService
  }, {
    type: NbCalendarYearModelService
  }], {
    boundingMonth: [{
      type: Input
    }],
    activeViewMode: [{
      type: Input,
      args: ["startView"]
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    dayCellComponent: [{
      type: Input
    }],
    monthCellComponent: [{
      type: Input
    }],
    yearCellComponent: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    visibleDate: [{
      type: Input
    }],
    showNavigation: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.has-navigation"]
    }],
    date: [{
      type: Input
    }],
    showWeekNumber: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.has-week-number"]
    }],
    weekNumberSymbol: [{
      type: Input
    }],
    firstDayOfWeek: [{
      type: Input
    }],
    dateChange: [{
      type: Output
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }]
  });
})();
var _NbCalendarComponent = class _NbCalendarComponent {
  constructor() {
    this.boundingMonth = true;
    this.startView = NbCalendarViewMode.DATE;
    this.size = NbCalendarSize.MEDIUM;
    this.showNavigation = true;
    this._showWeekNumber = false;
    this.weekNumberSymbol = "#";
    this.dateChange = new EventEmitter();
  }
  /**
   * Determines should we show week numbers column.
   * False by default.
   * */
  get showWeekNumber() {
    return this._showWeekNumber;
  }
  set showWeekNumber(value) {
    this._showWeekNumber = convertToBoolProperty(value);
  }
};
_NbCalendarComponent.\u0275fac = function NbCalendarComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbCalendarComponent)();
};
_NbCalendarComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbCalendarComponent,
  selectors: [["nb-calendar"]],
  inputs: {
    boundingMonth: "boundingMonth",
    startView: "startView",
    min: "min",
    max: "max",
    filter: "filter",
    dayCellComponent: "dayCellComponent",
    monthCellComponent: "monthCellComponent",
    yearCellComponent: "yearCellComponent",
    size: "size",
    visibleDate: "visibleDate",
    showNavigation: "showNavigation",
    date: "date",
    showWeekNumber: "showWeekNumber",
    weekNumberSymbol: "weekNumberSymbol",
    firstDayOfWeek: "firstDayOfWeek"
  },
  outputs: {
    dateChange: "dateChange"
  },
  standalone: false,
  decls: 1,
  vars: 15,
  consts: [[3, "dateChange", "boundingMonth", "startView", "date", "min", "max", "filter", "dayCellComponent", "monthCellComponent", "yearCellComponent", "size", "visibleDate", "showNavigation", "showWeekNumber", "weekNumberSymbol", "firstDayOfWeek"]],
  template: function NbCalendarComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "nb-base-calendar", 0);
      \u0275\u0275listener("dateChange", function NbCalendarComponent_Template_nb_base_calendar_dateChange_0_listener($event) {
        return ctx.dateChange.emit($event);
      });
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275property("boundingMonth", ctx.boundingMonth)("startView", ctx.startView)("date", ctx.date)("min", ctx.min)("max", ctx.max)("filter", ctx.filter)("dayCellComponent", ctx.dayCellComponent)("monthCellComponent", ctx.monthCellComponent)("yearCellComponent", ctx.yearCellComponent)("size", ctx.size)("visibleDate", ctx.visibleDate)("showNavigation", ctx.showNavigation)("showWeekNumber", ctx.showWeekNumber)("weekNumberSymbol", ctx.weekNumberSymbol)("firstDayOfWeek", ctx.firstDayOfWeek);
    }
  },
  dependencies: [NbBaseCalendarComponent],
  encapsulation: 2
});
var NbCalendarComponent = _NbCalendarComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar",
      template: `
    <nb-base-calendar
      [boundingMonth]="boundingMonth"
      [startView]="startView"
      [date]="date"
      [min]="min"
      [max]="max"
      [filter]="filter"
      [dayCellComponent]="dayCellComponent"
      [monthCellComponent]="monthCellComponent"
      [yearCellComponent]="yearCellComponent"
      [size]="size"
      [visibleDate]="visibleDate"
      [showNavigation]="showNavigation"
      [showWeekNumber]="showWeekNumber"
      [weekNumberSymbol]="weekNumberSymbol"
      [firstDayOfWeek]="firstDayOfWeek"
      (dateChange)="dateChange.emit($event)"
    ></nb-base-calendar>
  `,
      standalone: false
    }]
  }], null, {
    boundingMonth: [{
      type: Input
    }],
    startView: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    dayCellComponent: [{
      type: Input
    }],
    monthCellComponent: [{
      type: Input
    }],
    yearCellComponent: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    visibleDate: [{
      type: Input
    }],
    showNavigation: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    showWeekNumber: [{
      type: Input
    }],
    weekNumberSymbol: [{
      type: Input
    }],
    firstDayOfWeek: [{
      type: Input
    }],
    dateChange: [{
      type: Output
    }]
  });
})();
var NB_BUTTON_COMPONENTS = [NbButtonComponent];
var _NbButtonModule = class _NbButtonModule {
};
_NbButtonModule.\u0275fac = function NbButtonModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbButtonModule)();
};
_NbButtonModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbButtonModule,
  declarations: [NbButtonComponent],
  imports: [NbSharedModule],
  exports: [NbButtonComponent]
});
_NbButtonModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NbSharedModule]
});
var NbButtonModule = _NbButtonModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbButtonModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule],
      declarations: [...NB_BUTTON_COMPONENTS],
      exports: [...NB_BUTTON_COMPONENTS]
    }]
  }], null, null);
})();
var _NbNativeDateService = class _NbNativeDateService extends NbDateService {
  constructor(locale) {
    super();
    this.setLocale(locale);
  }
  setLocale(locale) {
    super.setLocale(locale);
    this.datePipe = new DatePipe(locale);
  }
  setHours(date, hour) {
    const result = this.clone(date);
    result.setHours(hour);
    return result;
  }
  setMinutes(date, minute) {
    const result = this.clone(date);
    result.setMinutes(minute);
    return result;
  }
  setSeconds(date, second) {
    const result = this.clone(date);
    result.setSeconds(second);
    return result;
  }
  setMilliseconds(date, second) {
    const result = this.clone(date);
    result.setMilliseconds(second);
    return result;
  }
  isValidDateString(date, format) {
    return !isNaN(this.parse(date, format).getTime());
  }
  isValidTimeString(date, format) {
    return this.isValidDateString(date, format);
  }
  today() {
    return /* @__PURE__ */ new Date();
  }
  getLocaleTimeFormat() {
    return getLocaleTimeFormat(this.locale, FormatWidth.Short);
  }
  getDate(date) {
    return date.getDate();
  }
  getMonth(date) {
    return date.getMonth();
  }
  getYear(date) {
    return date.getFullYear();
  }
  getDayOfWeek(date) {
    return date.getDay();
  }
  /**
   * returns first day of the week, it can be 1 if week starts from monday
   * and 0 if from sunday and so on.
   * */
  getFirstDayOfWeek() {
    return getLocaleFirstDayOfWeek(this.locale);
  }
  getMonthName(date, style2 = TranslationWidth.Abbreviated) {
    const index = date.getMonth();
    return this.getMonthNameByIndex(index, style2);
  }
  getMonthNameByIndex(index, style2 = TranslationWidth.Abbreviated) {
    return getLocaleMonthNames(this.locale, FormStyle.Format, style2)[index];
  }
  getDayOfWeekNames() {
    return [...getLocaleDayNames(this.locale, FormStyle.Format, TranslationWidth.Short)];
  }
  format(date, format) {
    return this.datePipe.transform(date, format);
  }
  /**
   * We haven't got capability to parse date using formatting without third party libraries.
   * */
  parse(date, format) {
    return new Date(Date.parse(date));
  }
  addDay(date, num) {
    return this.createDate(date.getFullYear(), date.getMonth(), date.getDate() + num);
  }
  addMonth(date, num) {
    const month = this.createDate(date.getFullYear(), date.getMonth() + num, 1);
    month.setDate(Math.min(date.getDate(), this.getMonthEnd(month).getDate()));
    return month;
  }
  addMinutes(date, minute) {
    const result = new Date(date);
    result.setMinutes(date.getMinutes() + minute);
    return result;
  }
  addHours(date, hour) {
    const result = new Date(date);
    result.setHours(date.getHours() + hour);
    return result;
  }
  getHours(date) {
    return date.getHours();
  }
  getMinutes(date) {
    return date.getMinutes();
  }
  getSeconds(date) {
    return date.getSeconds();
  }
  getMilliseconds(date) {
    return date.getMilliseconds();
  }
  addYear(date, num) {
    return this.createDate(date.getFullYear() + num, date.getMonth(), date.getDate());
  }
  clone(date) {
    return new Date(date.getTime());
  }
  compareDates(date1, date2) {
    return date1.getTime() - date2.getTime();
  }
  createDate(year, month, date) {
    const result = new Date(year, month, date);
    if (year >= 0 && year < 100) {
      result.setFullYear(result.getFullYear() - 1900);
    }
    return result;
  }
  getMonthEnd(date) {
    return this.createDate(date.getFullYear(), date.getMonth() + 1, 0);
  }
  getMonthStart(date) {
    return this.createDate(date.getFullYear(), date.getMonth(), 1);
  }
  getNumberOfDaysInMonth(date) {
    return this.getMonthEnd(date).getDate();
  }
  getYearEnd(date) {
    return this.createDate(date.getFullYear(), 11, 31);
  }
  getYearStart(date) {
    return this.createDate(date.getFullYear(), 0, 1);
  }
  valueOf(date) {
    return date.valueOf();
  }
  isSameDay(date1, date2) {
    return this.isSameMonth(date1, date2) && date1.getDate() === date2.getDate();
  }
  isSameMonth(date1, date2) {
    return this.isSameYear(date1, date2) && date1.getMonth() === date2.getMonth();
  }
  isSameYear(date1, date2) {
    return date1.getFullYear() === date2.getFullYear();
  }
  getId() {
    return "native";
  }
  getWeekNumber(date) {
    return parseInt(this.datePipe.transform(date, "w"), 10);
  }
  getDateFormat() {
    return "yyyy-MM-dd";
  }
  getTwelveHoursFormat() {
    return "hh:mm a";
  }
};
_NbNativeDateService.\u0275fac = function NbNativeDateService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbNativeDateService)(\u0275\u0275inject(LOCALE_ID));
};
_NbNativeDateService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbNativeDateService,
  factory: _NbNativeDateService.\u0275fac
});
var NbNativeDateService = _NbNativeDateService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbNativeDateService, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [LOCALE_ID]
    }]
  }], null);
})();
var _NbCalendarTimeModelService = class _NbCalendarTimeModelService {
  constructor(dateService) {
    this.dateService = dateService;
    this.MINUTES_AND_SECONDS = 60;
  }
  getHoursRange(step = this.MINUTES_AND_SECONDS) {
    let date = this.getResetTime();
    const endDate = this.dateService.addDay(date, 1);
    const result = [];
    while (this.dateService.compareDates(date, endDate) < 0) {
      result.push(date);
      date = this.dateService.addMinutes(date, step);
    }
    return result;
  }
  getResetTime() {
    let today = this.dateService.today();
    today = this.dateService.setHours(today, 0);
    today = this.dateService.setMinutes(today, 0);
    today = this.dateService.setSeconds(today, 0);
    today = this.dateService.setMilliseconds(today, 0);
    return today;
  }
  paddToTwoSymbols(n) {
    if (n < 10) {
      return "0" + n;
    }
    return n.toString();
  }
  buildDateFormat(twelveHoursFormat, withSeconds = false) {
    if (twelveHoursFormat) {
      return `${this.dateService.getDateFormat()} ${this.dateService.getTwelveHoursFormat()}`;
    }
    if (withSeconds) {
      return `${this.dateService.getDateFormat()} ${this.dateService.getTwentyFourHoursFormatWithSeconds()}`;
    }
    return `${this.dateService.getDateFormat()} ${this.dateService.getTwentyFourHoursFormat()}`;
  }
};
_NbCalendarTimeModelService.\u0275fac = function NbCalendarTimeModelService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbCalendarTimeModelService)(\u0275\u0275inject(NbDateService));
};
_NbCalendarTimeModelService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbCalendarTimeModelService,
  factory: _NbCalendarTimeModelService.\u0275fac
});
var NbCalendarTimeModelService = _NbCalendarTimeModelService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarTimeModelService, [{
    type: Injectable
  }], () => [{
    type: NbDateService
  }], null);
})();
var _NbCalendarActionsComponent = class _NbCalendarActionsComponent {
  constructor() {
    this._applyButtonText = "ok";
    this._currentTimeButtonText = "now";
    this.setCurrentTime = new EventEmitter();
    this.saveValue = new EventEmitter();
  }
  set applyButtonText(value) {
    if (value) {
      this._applyButtonText = value;
    }
  }
  get applyText() {
    return this._applyButtonText;
  }
  set currentTimeButtonText(value) {
    if (value) {
      this._currentTimeButtonText = value;
    }
  }
  get currentTimeText() {
    return this._currentTimeButtonText;
  }
};
_NbCalendarActionsComponent.\u0275fac = function NbCalendarActionsComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbCalendarActionsComponent)();
};
_NbCalendarActionsComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbCalendarActionsComponent,
  selectors: [["nb-calendar-actions"]],
  inputs: {
    applyButtonText: "applyButtonText",
    currentTimeButtonText: "currentTimeButtonText",
    showCurrentTimeButton: "showCurrentTimeButton"
  },
  outputs: {
    setCurrentTime: "setCurrentTime",
    saveValue: "saveValue"
  },
  standalone: false,
  decls: 3,
  vars: 2,
  consts: [["nbButton", "", "ghost", "", "status", "primary", "size", "small", 3, "click", 4, "ngIf"], ["nbButton", "", "status", "primary", "size", "small", 1, "apply-text-button", 3, "click"], ["nbButton", "", "ghost", "", "status", "primary", "size", "small", 3, "click"]],
  template: function NbCalendarActionsComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NbCalendarActionsComponent_button_0_Template, 2, 1, "button", 0);
      \u0275\u0275elementStart(1, "button", 1);
      \u0275\u0275listener("click", function NbCalendarActionsComponent_Template_button_click_1_listener() {
        return ctx.saveValue.emit();
      });
      \u0275\u0275text(2);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.showCurrentTimeButton);
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate1(" ", ctx.applyText);
    }
  },
  dependencies: [NgIf, NbButtonComponent],
  styles: ["[_nghost-%COMP%]{display:flex;justify-content:space-between}[dir=ltr]   [_nghost-%COMP%]   .apply-text-button[_ngcontent-%COMP%]{margin-left:auto}[dir=rtl]   [_nghost-%COMP%]   .apply-text-button[_ngcontent-%COMP%]{margin-right:auto}\n\n\n\n\n\n"],
  changeDetection: 0
});
var NbCalendarActionsComponent = _NbCalendarActionsComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarActionsComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-actions",
      template: `
    <button
      *ngIf="showCurrentTimeButton"
      nbButton
      ghost
      status="primary"
      size="small"
      (click)="setCurrentTime.emit()">
      {{ currentTimeText }}</button>
    <button
      class="apply-text-button"
      nbButton
      status="primary"
      size="small"
      (click)="saveValue.emit()">
      {{ applyText }}</button>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      styles: [":host{display:flex;justify-content:space-between}[dir=ltr] :host .apply-text-button{margin-left:auto}[dir=rtl] :host .apply-text-button{margin-right:auto}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], null, {
    applyButtonText: [{
      type: Input
    }],
    currentTimeButtonText: [{
      type: Input
    }],
    showCurrentTimeButton: [{
      type: Input
    }],
    setCurrentTime: [{
      type: Output
    }],
    saveValue: [{
      type: Output
    }]
  });
})();
var SERVICES = [{
  provide: NbDateService,
  useClass: NbNativeDateService
}, DatePipe, NbCalendarMonthModelService, NbCalendarYearModelService, NbCalendarTimeModelService];
var COMPONENTS$3 = [NbCalendarViewModeComponent, NbCalendarPageableNavigationComponent, NbCalendarDaysNamesComponent, NbCalendarYearPickerComponent, NbCalendarMonthPickerComponent, NbCalendarDayPickerComponent, NbCalendarDayCellComponent, NbCalendarActionsComponent, NbCalendarMonthCellComponent, NbCalendarYearCellComponent, NbCalendarPickerRowComponent, NbCalendarPickerComponent, NbCalendarWeekNumberComponent];
var _NbCalendarKitModule = class _NbCalendarKitModule {
};
_NbCalendarKitModule.\u0275fac = function NbCalendarKitModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbCalendarKitModule)();
};
_NbCalendarKitModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbCalendarKitModule,
  declarations: [NbCalendarViewModeComponent, NbCalendarPageableNavigationComponent, NbCalendarDaysNamesComponent, NbCalendarYearPickerComponent, NbCalendarMonthPickerComponent, NbCalendarDayPickerComponent, NbCalendarDayCellComponent, NbCalendarActionsComponent, NbCalendarMonthCellComponent, NbCalendarYearCellComponent, NbCalendarPickerRowComponent, NbCalendarPickerComponent, NbCalendarWeekNumberComponent],
  imports: [NbSharedModule, NbButtonModule, NbIconModule],
  exports: [NbCalendarViewModeComponent, NbCalendarPageableNavigationComponent, NbCalendarDaysNamesComponent, NbCalendarYearPickerComponent, NbCalendarMonthPickerComponent, NbCalendarDayPickerComponent, NbCalendarDayCellComponent, NbCalendarActionsComponent, NbCalendarMonthCellComponent, NbCalendarYearCellComponent, NbCalendarPickerRowComponent, NbCalendarPickerComponent, NbCalendarWeekNumberComponent]
});
_NbCalendarKitModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [...SERVICES],
  imports: [NbSharedModule, NbButtonModule, NbIconModule]
});
var NbCalendarKitModule = _NbCalendarKitModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarKitModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbButtonModule, NbIconModule],
      exports: [...COMPONENTS$3],
      declarations: [...COMPONENTS$3],
      providers: [...SERVICES]
    }]
  }], null, null);
})();
var _NbBaseCalendarModule = class _NbBaseCalendarModule {
};
_NbBaseCalendarModule.\u0275fac = function NbBaseCalendarModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbBaseCalendarModule)();
};
_NbBaseCalendarModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbBaseCalendarModule,
  declarations: [NbBaseCalendarComponent],
  imports: [NbCalendarKitModule, NbSharedModule, NbCardModule],
  exports: [NbBaseCalendarComponent]
});
_NbBaseCalendarModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NbCalendarKitModule, NbSharedModule, NbCardModule]
});
var NbBaseCalendarModule = _NbBaseCalendarModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbBaseCalendarModule, [{
    type: NgModule,
    args: [{
      imports: [NbCalendarKitModule, NbSharedModule, NbCardModule],
      exports: [NbBaseCalendarComponent],
      declarations: [NbBaseCalendarComponent]
    }]
  }], null, null);
})();
var _NbCalendarModule = class _NbCalendarModule {
};
_NbCalendarModule.\u0275fac = function NbCalendarModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbCalendarModule)();
};
_NbCalendarModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbCalendarModule,
  declarations: [NbCalendarComponent],
  imports: [NbBaseCalendarModule],
  exports: [NbCalendarComponent]
});
_NbCalendarModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NbBaseCalendarModule]
});
var NbCalendarModule = _NbCalendarModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarModule, [{
    type: NgModule,
    args: [{
      imports: [NbBaseCalendarModule],
      exports: [NbCalendarComponent],
      declarations: [NbCalendarComponent]
    }]
  }], null, null);
})();
var NbBaseCalendarRangeCell = class {
  get hasRange() {
    return !!(this.selectedValue && this.selectedValue.start && this.selectedValue.end);
  }
};
var _NbCalendarRangeDayCellComponent = class _NbCalendarRangeDayCellComponent extends NbBaseCalendarRangeCell {
  constructor(dateService) {
    super();
    this.dateService = dateService;
    this.size = NbCalendarSize.MEDIUM;
    this.select = new EventEmitter(true);
    this.rangeCellClass = true;
    this.dayCellClass = true;
  }
  get inRange() {
    if (this.date && this.hasRange) {
      return this.isInRange(this.date, this.selectedValue);
    }
    return false;
  }
  get start() {
    return this.date && this.hasRange && this.dateService.isSameDay(this.date, this.selectedValue.start);
  }
  get end() {
    return this.date && this.hasRange && this.dateService.isSameDay(this.date, this.selectedValue.end);
  }
  get today() {
    return this.date && this.dateService.isSameDay(this.date, this.dateService.today());
  }
  get boundingMonth() {
    return !this.dateService.isSameMonthSafe(this.date, this.visibleDate);
  }
  get selected() {
    if (this.inRange) {
      return true;
    }
    if (this.selectedValue) {
      return this.dateService.isSameDaySafe(this.date, this.selectedValue.start);
    }
    return false;
  }
  get empty() {
    return !this.date;
  }
  get disabled() {
    return this.smallerThanMin() || this.greaterThanMax() || this.dontFitFilter();
  }
  get isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
  get day() {
    return this.date && this.dateService.getDate(this.date);
  }
  onClick() {
    if (this.disabled || this.empty) {
      return;
    }
    this.select.emit(this.date);
  }
  smallerThanMin() {
    return this.date && this.min && this.dateService.compareDates(this.date, this.min) < 0;
  }
  greaterThanMax() {
    return this.date && this.max && this.dateService.compareDates(this.date, this.max) > 0;
  }
  dontFitFilter() {
    return this.date && this.filter && !this.filter(this.date);
  }
  isInRange(date, {
    start,
    end
  }) {
    const isGreaterThanStart = this.dateService.compareDates(this.date, start) >= 0;
    const isLessThanEnd = this.dateService.compareDates(this.date, end) <= 0;
    return isGreaterThanStart && isLessThanEnd;
  }
};
_NbCalendarRangeDayCellComponent.\u0275fac = function NbCalendarRangeDayCellComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbCalendarRangeDayCellComponent)(\u0275\u0275directiveInject(NbDateService));
};
_NbCalendarRangeDayCellComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbCalendarRangeDayCellComponent,
  selectors: [["nb-calendar-range-day-cell"]],
  hostVars: 22,
  hostBindings: function NbCalendarRangeDayCellComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function NbCalendarRangeDayCellComponent_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
    if (rf & 2) {
      \u0275\u0275classProp("in-range", ctx.inRange)("start", ctx.start)("end", ctx.end)("range-cell", ctx.rangeCellClass)("day-cell", ctx.dayCellClass)("today", ctx.today)("bounding-month", ctx.boundingMonth)("selected", ctx.selected)("empty", ctx.empty)("disabled", ctx.disabled)("size-large", ctx.isLarge);
    }
  },
  inputs: {
    date: "date",
    selectedValue: "selectedValue",
    visibleDate: "visibleDate",
    min: "min",
    max: "max",
    filter: "filter",
    size: "size"
  },
  outputs: {
    select: "select"
  },
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 2,
  vars: 1,
  consts: [[1, "cell-content"]],
  template: function NbCalendarRangeDayCellComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0);
      \u0275\u0275text(1);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance();
      \u0275\u0275textInterpolate(ctx.day);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbCalendarRangeDayCellComponent = _NbCalendarRangeDayCellComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarRangeDayCellComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-range-day-cell",
      template: `
    <div class="cell-content">{{ day }}</div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], () => [{
    type: NbDateService
  }], {
    date: [{
      type: Input
    }],
    selectedValue: [{
      type: Input
    }],
    visibleDate: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    inRange: [{
      type: HostBinding,
      args: ["class.in-range"]
    }],
    start: [{
      type: HostBinding,
      args: ["class.start"]
    }],
    end: [{
      type: HostBinding,
      args: ["class.end"]
    }],
    rangeCellClass: [{
      type: HostBinding,
      args: ["class.range-cell"]
    }],
    dayCellClass: [{
      type: HostBinding,
      args: ["class.day-cell"]
    }],
    today: [{
      type: HostBinding,
      args: ["class.today"]
    }],
    boundingMonth: [{
      type: HostBinding,
      args: ["class.bounding-month"]
    }],
    selected: [{
      type: HostBinding,
      args: ["class.selected"]
    }],
    empty: [{
      type: HostBinding,
      args: ["class.empty"]
    }],
    disabled: [{
      type: HostBinding,
      args: ["class.disabled"]
    }],
    isLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var _NbCalendarRangeYearCellComponent = class _NbCalendarRangeYearCellComponent extends NbBaseCalendarRangeCell {
  constructor(dateService) {
    super();
    this.dateService = dateService;
    this.size = NbCalendarSize.MEDIUM;
    this.select = new EventEmitter(true);
    this.yearCellClass = true;
    this.rangeCellClass = true;
  }
  get inRange() {
    return this.hasRange && this.isInRange(this.date, this.selectedValue);
  }
  get rangeStart() {
    return this.hasRange && this.dateService.isSameYear(this.date, this.selectedValue.start);
  }
  get rangeEnd() {
    return this.hasRange && this.dateService.isSameYear(this.date, this.selectedValue.end);
  }
  get selected() {
    if (this.inRange) {
      return true;
    }
    if (this.selectedValue) {
      return this.dateService.isSameYearSafe(this.date, this.selectedValue.start);
    }
    return false;
  }
  get today() {
    return this.dateService.isSameYear(this.date, this.dateService.today());
  }
  get disabled() {
    return this.smallerThanMin() || this.greaterThanMax();
  }
  get isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
  get year() {
    return this.dateService.getYear(this.date);
  }
  onClick() {
    if (this.disabled) {
      return;
    }
    this.select.emit(this.date);
  }
  smallerThanMin() {
    return this.date && this.min && this.dateService.compareDates(this.yearEnd(), this.min) < 0;
  }
  greaterThanMax() {
    return this.date && this.max && this.dateService.compareDates(this.yearStart(), this.max) > 0;
  }
  yearStart() {
    return this.dateService.getYearStart(this.date);
  }
  yearEnd() {
    return this.dateService.getYearEnd(this.date);
  }
  isInRange(date, {
    start,
    end
  }) {
    if (start && end) {
      const cellYear = this.dateService.getYear(date);
      const startYear = this.dateService.getYear(start);
      const endYear = this.dateService.getYear(end);
      return cellYear >= startYear && cellYear <= endYear;
    }
    return this.dateService.isSameYear(date, start);
  }
};
_NbCalendarRangeYearCellComponent.\u0275fac = function NbCalendarRangeYearCellComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbCalendarRangeYearCellComponent)(\u0275\u0275directiveInject(NbDateService));
};
_NbCalendarRangeYearCellComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbCalendarRangeYearCellComponent,
  selectors: [["nb-calendar-range-year-cell"]],
  hostVars: 18,
  hostBindings: function NbCalendarRangeYearCellComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function NbCalendarRangeYearCellComponent_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
    if (rf & 2) {
      \u0275\u0275classProp("in-range", ctx.inRange)("start", ctx.rangeStart)("end", ctx.rangeEnd)("selected", ctx.selected)("today", ctx.today)("disabled", ctx.disabled)("size-large", ctx.isLarge)("year-cell", ctx.yearCellClass)("range-cell", ctx.rangeCellClass);
    }
  },
  inputs: {
    date: "date",
    min: "min",
    max: "max",
    selectedValue: "selectedValue",
    size: "size"
  },
  outputs: {
    select: "select"
  },
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 2,
  vars: 1,
  consts: [[1, "cell-content"]],
  template: function NbCalendarRangeYearCellComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0);
      \u0275\u0275text(1);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance();
      \u0275\u0275textInterpolate1(" ", ctx.year, " ");
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbCalendarRangeYearCellComponent = _NbCalendarRangeYearCellComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarRangeYearCellComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-range-year-cell",
      template: `
    <div class="cell-content">
      {{ year }}
    </div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], () => [{
    type: NbDateService
  }], {
    date: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    selectedValue: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    inRange: [{
      type: HostBinding,
      args: ["class.in-range"]
    }],
    rangeStart: [{
      type: HostBinding,
      args: ["class.start"]
    }],
    rangeEnd: [{
      type: HostBinding,
      args: ["class.end"]
    }],
    selected: [{
      type: HostBinding,
      args: ["class.selected"]
    }],
    today: [{
      type: HostBinding,
      args: ["class.today"]
    }],
    disabled: [{
      type: HostBinding,
      args: ["class.disabled"]
    }],
    isLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    yearCellClass: [{
      type: HostBinding,
      args: ["class.year-cell"]
    }],
    rangeCellClass: [{
      type: HostBinding,
      args: ["class.range-cell"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var _NbCalendarRangeMonthCellComponent = class _NbCalendarRangeMonthCellComponent extends NbBaseCalendarRangeCell {
  get month() {
    return this.dateService.getMonthName(this.date);
  }
  get selected() {
    if (this.inRange) {
      return true;
    }
    if (this.selectedValue) {
      return this.dateService.isSameMonthSafe(this.date, this.selectedValue.start);
    }
    return false;
  }
  get inRange() {
    if (this.hasRange) {
      return this.isInRage(this.date, this.selectedValue);
    }
    return false;
  }
  get rangeStart() {
    if (this.hasRange) {
      return this.dateService.isSameMonth(this.date, this.selectedValue.start);
    }
    return false;
  }
  get rangeEnd() {
    if (this.hasRange) {
      return this.dateService.isSameMonth(this.date, this.selectedValue.end);
    }
    return false;
  }
  get today() {
    return this.dateService.isSameMonthSafe(this.date, this.dateService.today());
  }
  get disabled() {
    return this.smallerThanMin() || this.greaterThanMax();
  }
  get isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
  onClick() {
    if (this.disabled) {
      return;
    }
    this.select.emit(this.date);
  }
  constructor(dateService) {
    super();
    this.dateService = dateService;
    this.size = NbCalendarSize.MEDIUM;
    this.select = new EventEmitter(true);
    this.monthCellClass = true;
    this.rangeCellClass = true;
  }
  smallerThanMin() {
    return this.date && this.min && this.dateService.compareDates(this.monthEnd(), this.min) < 0;
  }
  greaterThanMax() {
    return this.date && this.max && this.dateService.compareDates(this.monthStart(), this.max) > 0;
  }
  monthStart() {
    return this.dateService.getMonthStart(this.date);
  }
  monthEnd() {
    return this.dateService.getMonthEnd(this.date);
  }
  isInRage(date, range2) {
    if (range2.start && range2.end) {
      const cellDate = this.dateService.getMonthStart(date);
      const start = this.dateService.getMonthStart(range2.start);
      const end = this.dateService.getMonthStart(range2.end);
      const isGreaterThanStart = this.dateService.compareDates(cellDate, start) >= 0;
      const isLessThanEnd = this.dateService.compareDates(cellDate, end) <= 0;
      return isGreaterThanStart && isLessThanEnd;
    }
    return this.dateService.isSameMonth(date, range2.start);
  }
};
_NbCalendarRangeMonthCellComponent.\u0275fac = function NbCalendarRangeMonthCellComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbCalendarRangeMonthCellComponent)(\u0275\u0275directiveInject(NbDateService));
};
_NbCalendarRangeMonthCellComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbCalendarRangeMonthCellComponent,
  selectors: [["nb-calendar-range-month-cell"]],
  hostVars: 18,
  hostBindings: function NbCalendarRangeMonthCellComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function NbCalendarRangeMonthCellComponent_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
    if (rf & 2) {
      \u0275\u0275classProp("month-cell", ctx.monthCellClass)("range-cell", ctx.rangeCellClass)("selected", ctx.selected)("in-range", ctx.inRange)("start", ctx.rangeStart)("end", ctx.rangeEnd)("today", ctx.today)("disabled", ctx.disabled)("size-large", ctx.isLarge);
    }
  },
  inputs: {
    date: "date",
    visibleDate: "visibleDate",
    selectedValue: "selectedValue",
    min: "min",
    max: "max",
    size: "size"
  },
  outputs: {
    select: "select"
  },
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 2,
  vars: 1,
  consts: [[1, "cell-content"]],
  template: function NbCalendarRangeMonthCellComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0);
      \u0275\u0275text(1);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance();
      \u0275\u0275textInterpolate1(" ", ctx.month, " ");
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbCalendarRangeMonthCellComponent = _NbCalendarRangeMonthCellComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarRangeMonthCellComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-range-month-cell",
      template: `
    <div class="cell-content">
      {{ month }}
    </div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], () => [{
    type: NbDateService
  }], {
    date: [{
      type: Input
    }],
    visibleDate: [{
      type: Input
    }],
    selectedValue: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    monthCellClass: [{
      type: HostBinding,
      args: ["class.month-cell"]
    }],
    rangeCellClass: [{
      type: HostBinding,
      args: ["class.range-cell"]
    }],
    selected: [{
      type: HostBinding,
      args: ["class.selected"]
    }],
    inRange: [{
      type: HostBinding,
      args: ["class.in-range"]
    }],
    rangeStart: [{
      type: HostBinding,
      args: ["class.start"]
    }],
    rangeEnd: [{
      type: HostBinding,
      args: ["class.end"]
    }],
    today: [{
      type: HostBinding,
      args: ["class.today"]
    }],
    disabled: [{
      type: HostBinding,
      args: ["class.disabled"]
    }],
    isLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var _NbCalendarRangeComponent = class _NbCalendarRangeComponent {
  /**
   * Custom day cell component. Have to implement `NbCalendarCell` interface.
   * */
  set _cellComponent(cellComponent) {
    if (cellComponent) {
      this.dayCellComponent = cellComponent;
    }
  }
  /**
   * Custom month cell component. Have to implement `NbCalendarCell` interface.
   * */
  set _monthCellComponent(cellComponent) {
    if (cellComponent) {
      this.monthCellComponent = cellComponent;
    }
  }
  /**
   * Custom year cell component. Have to implement `NbCalendarCell` interface.
   * */
  set _yearCellComponent(cellComponent) {
    if (cellComponent) {
      this.yearCellComponent = cellComponent;
    }
  }
  /**
   * Determines should we show week numbers column.
   * False by default.
   * */
  get showWeekNumber() {
    return this._showWeekNumber;
  }
  set showWeekNumber(value) {
    this._showWeekNumber = convertToBoolProperty(value);
  }
  constructor(dateService) {
    this.dateService = dateService;
    this.boundingMonth = true;
    this.startView = NbCalendarViewMode.DATE;
    this.dayCellComponent = NbCalendarRangeDayCellComponent;
    this.monthCellComponent = NbCalendarRangeMonthCellComponent;
    this.yearCellComponent = NbCalendarRangeYearCellComponent;
    this.size = NbCalendarSize.MEDIUM;
    this.showNavigation = true;
    this._showWeekNumber = false;
    this.weekNumberSymbol = "#";
    this.rangeChange = new EventEmitter();
  }
  onChange(date) {
    this.initDateIfNull();
    this.handleSelected(date);
  }
  initDateIfNull() {
    if (!this.range) {
      this.range = {
        start: null,
        end: null
      };
    }
  }
  handleSelected(date) {
    if (this.selectionStarted()) {
      this.selectEnd(date);
    } else {
      this.selectStart(date);
    }
  }
  selectionStarted() {
    const {
      start,
      end
    } = this.range;
    return start && !end;
  }
  selectStart(start) {
    this.selectRange({
      start
    });
  }
  selectEnd(date) {
    const {
      start
    } = this.range;
    if (this.dateService.compareDates(date, start) > 0) {
      this.selectRange({
        start,
        end: date
      });
    } else {
      this.selectRange({
        start: date,
        end: start
      });
    }
  }
  selectRange(range2) {
    this.range = range2;
    this.rangeChange.emit(range2);
  }
};
_NbCalendarRangeComponent.\u0275fac = function NbCalendarRangeComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbCalendarRangeComponent)(\u0275\u0275directiveInject(NbDateService));
};
_NbCalendarRangeComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbCalendarRangeComponent,
  selectors: [["nb-calendar-range"]],
  inputs: {
    boundingMonth: "boundingMonth",
    startView: "startView",
    min: "min",
    max: "max",
    filter: "filter",
    _cellComponent: [0, "dayCellComponent", "_cellComponent"],
    _monthCellComponent: [0, "monthCellComponent", "_monthCellComponent"],
    monthCellComponent: "monthCellComponent",
    _yearCellComponent: [0, "yearCellComponent", "_yearCellComponent"],
    size: "size",
    visibleDate: "visibleDate",
    showNavigation: "showNavigation",
    range: "range",
    showWeekNumber: "showWeekNumber",
    weekNumberSymbol: "weekNumberSymbol",
    firstDayOfWeek: "firstDayOfWeek"
  },
  outputs: {
    rangeChange: "rangeChange"
  },
  standalone: false,
  decls: 1,
  vars: 15,
  consts: [[3, "dateChange", "date", "min", "max", "filter", "startView", "boundingMonth", "dayCellComponent", "monthCellComponent", "yearCellComponent", "visibleDate", "showNavigation", "size", "showWeekNumber", "weekNumberSymbol", "firstDayOfWeek"]],
  template: function NbCalendarRangeComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "nb-base-calendar", 0);
      \u0275\u0275listener("dateChange", function NbCalendarRangeComponent_Template_nb_base_calendar_dateChange_0_listener($event) {
        return ctx.onChange($event);
      });
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275property("date", ctx.range)("min", ctx.min)("max", ctx.max)("filter", ctx.filter)("startView", ctx.startView)("boundingMonth", ctx.boundingMonth)("dayCellComponent", ctx.dayCellComponent)("monthCellComponent", ctx.monthCellComponent)("yearCellComponent", ctx.yearCellComponent)("visibleDate", ctx.visibleDate)("showNavigation", ctx.showNavigation)("size", ctx.size)("showWeekNumber", ctx.showWeekNumber)("weekNumberSymbol", ctx.weekNumberSymbol)("firstDayOfWeek", ctx.firstDayOfWeek);
    }
  },
  dependencies: [NbBaseCalendarComponent],
  encapsulation: 2
});
var NbCalendarRangeComponent = _NbCalendarRangeComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarRangeComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-range",
      template: `
    <nb-base-calendar
      [date]="range"
      (dateChange)="onChange($any($event))"
      [min]="min"
      [max]="max"
      [filter]="filter"
      [startView]="startView"
      [boundingMonth]="boundingMonth"
      [dayCellComponent]="dayCellComponent"
      [monthCellComponent]="monthCellComponent"
      [yearCellComponent]="yearCellComponent"
      [visibleDate]="visibleDate"
      [showNavigation]="showNavigation"
      [size]="size"
      [showWeekNumber]="showWeekNumber"
      [weekNumberSymbol]="weekNumberSymbol"
      [firstDayOfWeek]="firstDayOfWeek"
    ></nb-base-calendar>
  `,
      standalone: false
    }]
  }], () => [{
    type: NbDateService
  }], {
    boundingMonth: [{
      type: Input
    }],
    startView: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    _cellComponent: [{
      type: Input,
      args: ["dayCellComponent"]
    }],
    _monthCellComponent: [{
      type: Input,
      args: ["monthCellComponent"]
    }],
    monthCellComponent: [{
      type: Input
    }],
    _yearCellComponent: [{
      type: Input,
      args: ["yearCellComponent"]
    }],
    size: [{
      type: Input
    }],
    visibleDate: [{
      type: Input
    }],
    showNavigation: [{
      type: Input
    }],
    range: [{
      type: Input
    }],
    showWeekNumber: [{
      type: Input
    }],
    weekNumberSymbol: [{
      type: Input
    }],
    firstDayOfWeek: [{
      type: Input
    }],
    rangeChange: [{
      type: Output
    }]
  });
})();
var _NbCalendarRangeModule = class _NbCalendarRangeModule {
};
_NbCalendarRangeModule.\u0275fac = function NbCalendarRangeModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbCalendarRangeModule)();
};
_NbCalendarRangeModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbCalendarRangeModule,
  declarations: [NbCalendarRangeComponent, NbCalendarRangeDayCellComponent, NbCalendarRangeYearCellComponent, NbCalendarRangeMonthCellComponent],
  imports: [NbBaseCalendarModule],
  exports: [NbCalendarRangeComponent]
});
_NbCalendarRangeModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NbBaseCalendarModule]
});
var NbCalendarRangeModule = _NbCalendarRangeModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarRangeModule, [{
    type: NgModule,
    args: [{
      imports: [NbBaseCalendarModule],
      exports: [NbCalendarRangeComponent],
      declarations: [NbCalendarRangeComponent, NbCalendarRangeDayCellComponent, NbCalendarRangeYearCellComponent, NbCalendarRangeMonthCellComponent]
    }]
  }], null, null);
})();
var NB_TIME_PICKER_CONFIG = new InjectionToken("NB_TIME_PICKER_CONFIG");
var NB_DEFAULT_TIMEPICKER_LOCALIZATION_CONFIG = {
  hoursText: "Hr",
  minutesText: "Min",
  secondsText: "Sec",
  ampmText: "Am/Pm"
};
var _NbListComponent = class _NbListComponent {
  constructor() {
    this.role = "list";
  }
};
_NbListComponent.\u0275fac = function NbListComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbListComponent)();
};
_NbListComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbListComponent,
  selectors: [["nb-list"]],
  hostVars: 1,
  hostBindings: function NbListComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("role", ctx.role);
    }
  },
  inputs: {
    role: "role"
  },
  standalone: false,
  ngContentSelectors: _c10,
  decls: 1,
  vars: 0,
  template: function NbListComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef(_c9);
      \u0275\u0275projection(0);
    }
  },
  styles: ["[_nghost-%COMP%]{display:flex;flex-direction:column;flex:1 1 auto;overflow:auto}"]
});
var NbListComponent = _NbListComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbListComponent, [{
    type: Component,
    args: [{
      selector: "nb-list",
      template: `<ng-content select="nb-list-item"></ng-content>`,
      standalone: false,
      styles: [":host{display:flex;flex-direction:column;flex:1 1 auto;overflow:auto}\n"]
    }]
  }], null, {
    role: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.role"]
    }]
  });
})();
var _NbListItemComponent = class _NbListItemComponent {
  constructor() {
    this.role = "listitem";
  }
};
_NbListItemComponent.\u0275fac = function NbListItemComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbListItemComponent)();
};
_NbListItemComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbListItemComponent,
  selectors: [["nb-list-item"]],
  hostVars: 1,
  hostBindings: function NbListItemComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("role", ctx.role);
    }
  },
  inputs: {
    role: "role"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function NbListItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275projection(0);
    }
  },
  styles: ["[_nghost-%COMP%]{display:flex;align-items:center;flex-shrink:0}"]
});
var NbListItemComponent = _NbListItemComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbListItemComponent, [{
    type: Component,
    args: [{
      selector: "nb-list-item",
      template: `<ng-content></ng-content>`,
      standalone: false,
      styles: [":host{display:flex;align-items:center;flex-shrink:0}\n"]
    }]
  }], null, {
    role: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.role"]
    }]
  });
})();
var _NbTimePickerCellComponent = class _NbTimePickerCellComponent {
  set selected(selected) {
    if (selected) {
      this._selected = selected;
      this.scrollToElement();
    }
    this.selectedChange$.next(selected);
  }
  get selected() {
    return this._selected;
  }
  constructor(ngZone, platformService) {
    this.ngZone = ngZone;
    this.platformService = platformService;
    this.selectedChange$ = new Subject();
    this.unselected$ = this.selectedChange$.pipe(filter((selected) => !selected));
    this.destroy$ = new Subject();
    this.select = new EventEmitter();
  }
  onClick() {
    this.select.emit({
      value: this.value
    });
  }
  ngAfterViewInit() {
    if (this.selected) {
      this.ngZone.onStable.pipe(take(1), takeUntil(merge(this.unselected$, this.destroy$))).subscribe(() => this.scrollToElement());
    }
  }
  scrollToElement() {
    if (this.valueContainerElement && this.platformService.isBrowser) {
      this.ngZone.runOutsideAngular(() => this.valueContainerElement.nativeElement.scrollIntoView({
        block: "center"
      }));
    }
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
};
_NbTimePickerCellComponent.\u0275fac = function NbTimePickerCellComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbTimePickerCellComponent)(\u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(NbPlatform));
};
_NbTimePickerCellComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbTimePickerCellComponent,
  selectors: [["nb-timepicker-cell"]],
  viewQuery: function NbTimePickerCellComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c11, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.valueContainerElement = _t.first);
    }
  },
  hostBindings: function NbTimePickerCellComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function NbTimePickerCellComponent_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
  },
  inputs: {
    selected: "selected",
    value: "value"
  },
  outputs: {
    select: "select"
  },
  standalone: false,
  decls: 3,
  vars: 1,
  consts: [["valueContainer", ""]],
  template: function NbTimePickerCellComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", null, 0);
      \u0275\u0275text(2);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate(ctx.value);
    }
  },
  styles: ["[_nghost-%COMP%]{width:100%;height:100%;display:flex;align-items:center;justify-content:center;-webkit-user-select:none;user-select:none}\n\n\n\n\n\n"],
  changeDetection: 0
});
var NbTimePickerCellComponent = _NbTimePickerCellComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTimePickerCellComponent, [{
    type: Component,
    args: [{
      selector: "nb-timepicker-cell",
      template: `
    <div #valueContainer>{{ value }}</div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      styles: [":host{width:100%;height:100%;display:flex;align-items:center;justify-content:center;-webkit-user-select:none;user-select:none}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: NgZone
  }, {
    type: NbPlatform
  }], {
    selected: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    valueContainerElement: [{
      type: ViewChild,
      args: ["valueContainer"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var _NbTimePickerComponent = class _NbTimePickerComponent {
  /**
   * Emits when timepicker looses focus.
   */
  get blur() {
    return this.blur$.asObservable();
  }
  /**
   * Defines time format string.
   * */
  get timeFormat() {
    return this._timeFormat;
  }
  set timeFormat(timeFormat) {
    this._timeFormat = timeFormat;
  }
  /**
   * Defines 12 hours format .
   * */
  get twelveHoursFormat() {
    return this._twelveHoursFormat;
  }
  set twelveHoursFormat(value) {
    this._twelveHoursFormat = convertToBoolProperty(value);
  }
  /**
   * Defines should show am/pm label if twelveHoursFormat enabled.
   * */
  get showAmPmLabel() {
    return this._showAmPmLabel;
  }
  set showAmPmLabel(value) {
    this._showAmPmLabel = convertToBoolProperty(value);
  }
  /**
   * Show seconds in timepicker.
   * Ignored when singleColumn is true
   * */
  get withSeconds() {
    return this._withSeconds;
  }
  set withSeconds(value) {
    this._withSeconds = convertToBoolProperty(value);
  }
  /**
   * Show timepicker values in one column with 60 minutes step by default.
   * */
  get singleColumn() {
    return this._singleColumn;
  }
  set singleColumn(value) {
    this._singleColumn = convertToBoolProperty(value);
  }
  /**
   * Defines minutes offset for options, when timepicker is in single column mode.
   * By default it’s 60 minutes: '12:00, 13:00: 14:00, 15:00...'
   * */
  set step(step) {
    this._step = step;
  }
  get step() {
    return this._step;
  }
  /**
   * Date which will be rendered as selected.
   * */
  set date(date) {
    this._date = date;
    this.isAM = this.dateService.getDayPeriod(this.date) === "AM";
    this.buildColumnOptions();
    this.cd.markForCheck();
  }
  get date() {
    return this._date;
  }
  constructor(config, platformService, locale, cd, calendarTimeModelService, dateService) {
    this.config = config;
    this.platformService = platformService;
    this.cd = cd;
    this.calendarTimeModelService = calendarTimeModelService;
    this.dateService = dateService;
    this.blur$ = new Subject();
    this.dayPeriodColumnOptions = [
      "AM",
      "PM"
      /* NbDayPeriod.PM */
    ];
    this.isAM = true;
    this.timepickerFormatChange$ = new Subject();
    this.computedTimeFormat = this.setupTimeFormat();
    this._showAmPmLabel = true;
    this.showFooter = true;
    this.onSelectTime = new EventEmitter();
    this.initFromConfig(this.config);
  }
  ngOnChanges({
    step,
    twelveHoursFormat,
    withSeconds,
    singleColumn
  }) {
    const nextTimeFormat = this.setupTimeFormat();
    if (nextTimeFormat !== this.computedTimeFormat) {
      this.computedTimeFormat = nextTimeFormat;
      this.timepickerFormatChange$.next();
    }
    const isConfigChanged = step || twelveHoursFormat || withSeconds || singleColumn;
    if (isConfigChanged || !this.fullTimeOptions) {
      this.buildColumnOptions();
    }
  }
  setHost(hostRef) {
    this.hostRef = hostRef;
  }
  attach(hostRef) {
    this.hostRef = hostRef;
  }
  setCurrentTime() {
    this.date = this.dateService.today();
    this.onSelectTime.emit({
      time: this.date,
      save: true
    });
  }
  setHour(value) {
    this.updateValue(this.dateService.setHours(this.date, value));
  }
  setMinute(value) {
    this.updateValue(this.dateService.setMinutes(this.date, value));
  }
  setSecond(value) {
    this.updateValue(this.dateService.setSeconds(this.date, value));
  }
  selectFullTime(value) {
    this.updateValue(value);
  }
  changeDayPeriod(dayPeriodToSet) {
    if (this.dateService.getDayPeriod(this.date) === dayPeriodToSet) {
      return;
    }
    const direction = dayPeriodToSet === "AM" ? -1 : 1;
    const increment = direction * this.dateService.HOURS_IN_DAY_PERIOD;
    this.updateValue(this.dateService.addHours(this.date, increment));
  }
  updateValue(date) {
    this.onSelectTime.emit({
      time: date
    });
  }
  saveValue() {
    this.onSelectTime.emit({
      time: this.date,
      save: true
    });
  }
  trackByTimeValues(index, item) {
    return item.value;
  }
  trackBySingleColumnValue(index, item) {
    return this.dateService.valueOf(item);
  }
  trackByDayPeriod(index, item) {
    return item;
  }
  showSeconds() {
    return this.withSeconds && !this.singleColumn;
  }
  isSelectedHour(val) {
    if (this.date) {
      return this.dateService.getHours(this.date) === val;
    }
    return false;
  }
  isSelectedMinute(val) {
    if (this.date) {
      return this.dateService.getMinutes(this.date) === val;
    }
    return false;
  }
  isSelectedSecond(val) {
    if (this.date) {
      return this.dateService.getSeconds(this.date) === val;
    }
    return false;
  }
  isSelectedDayPeriod(dayPeriod) {
    if (this.date) {
      return dayPeriod === this.dateService.getDayPeriod(this.date);
    }
    return false;
  }
  getFullTimeString(item) {
    return this.dateService.format(item, this.computedTimeFormat).toUpperCase();
  }
  isSelectedFullTimeValue(value) {
    if (this.date) {
      return this.dateService.isSameHourAndMinute(value, this.date);
    }
    return false;
  }
  buildColumnOptions() {
    this.fullTimeOptions = this.singleColumn ? this.calendarTimeModelService.getHoursRange(this.step) : [];
    this.hoursColumnOptions = this.generateHours();
    this.minutesColumnOptions = this.generateMinutesOrSeconds();
    this.secondsColumnOptions = this.showSeconds() ? this.generateMinutesOrSeconds() : [];
  }
  /**
   * @docs-private
   */
  isFirefox() {
    return this.platformService.FIREFOX;
  }
  generateHours() {
    if (!this.twelveHoursFormat) {
      return range(24, (v) => {
        return {
          value: v,
          text: this.calendarTimeModelService.paddToTwoSymbols(v)
        };
      });
    }
    if (this.isAM) {
      return range(12, (v) => {
        const text = v === 0 ? 12 : v;
        return {
          value: v,
          text: this.calendarTimeModelService.paddToTwoSymbols(text)
        };
      });
    }
    return rangeFromTo(12, 24, (v) => {
      const text = v === 12 ? 12 : v - 12;
      return {
        value: v,
        text: this.calendarTimeModelService.paddToTwoSymbols(text)
      };
    });
  }
  generateMinutesOrSeconds() {
    return range(60, (v) => {
      return {
        value: v,
        text: this.calendarTimeModelService.paddToTwoSymbols(v)
      };
    });
  }
  setupTimeFormat() {
    if (!this.timeFormat) {
      return this.config.format || this.buildTimeFormat();
    }
    return this.timeFormat;
  }
  /**
   * @docs-private
   */
  buildTimeFormat() {
    if (this.twelveHoursFormat) {
      return `${this.withSeconds && !this.singleColumn ? this.dateService.getTwelveHoursFormatWithSeconds() : this.dateService.getTwelveHoursFormat()}`;
    } else {
      return `${this.withSeconds && !this.singleColumn ? this.dateService.getTwentyFourHoursFormatWithSeconds() : this.dateService.getTwentyFourHoursFormat()}`;
    }
  }
  initFromConfig(config) {
    if (config) {
      this.twelveHoursFormat = config.twelveHoursFormat;
    } else {
      this.twelveHoursFormat = this.dateService.getLocaleTimeFormat().includes("h");
    }
    const localeConfig = __spreadValues(__spreadValues({}, NB_DEFAULT_TIMEPICKER_LOCALIZATION_CONFIG), config?.localization ?? {});
    this.hoursText = localeConfig.hoursText;
    this.minutesText = localeConfig.minutesText;
    this.secondsText = localeConfig.secondsText;
    this.ampmText = localeConfig.ampmText;
  }
};
_NbTimePickerComponent.\u0275fac = function NbTimePickerComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbTimePickerComponent)(\u0275\u0275directiveInject(NB_TIME_PICKER_CONFIG), \u0275\u0275directiveInject(NbPlatform), \u0275\u0275directiveInject(LOCALE_ID), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NbCalendarTimeModelService), \u0275\u0275directiveInject(NbDateService));
};
_NbTimePickerComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbTimePickerComponent,
  selectors: [["nb-timepicker"]],
  viewQuery: function NbTimePickerComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(NbPortalDirective, 7);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.portal = _t.first);
    }
  },
  inputs: {
    timeFormat: "timeFormat",
    twelveHoursFormat: "twelveHoursFormat",
    showAmPmLabel: "showAmPmLabel",
    withSeconds: "withSeconds",
    singleColumn: "singleColumn",
    step: "step",
    date: "date",
    showFooter: "showFooter",
    applyButtonText: "applyButtonText",
    hoursText: "hoursText",
    minutesText: "minutesText",
    secondsText: "secondsText",
    ampmText: "ampmText",
    currentTimeButtonText: "currentTimeButtonText"
  },
  outputs: {
    onSelectTime: "onSelectTime"
  },
  exportAs: ["nbTimepicker"],
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  decls: 1,
  vars: 0,
  consts: [["fullTimeHeadersBlock", ""], ["fullTimeColumnBlock", ""], ["class", "nb-timepicker-container", 3, "supports-scrollbar-theming", 4, "nbPortal"], [1, "nb-timepicker-container"], [1, "column-header"], [4, "ngIf", "ngIfElse"], [1, "picker-body"], ["class", "actions-footer", 4, "ngIf"], [1, "header-cell"], ["class", "header-cell", 4, "ngIf"], [3, "ngIf"], [1, "values-list"], ["class", "list-item", 3, "selected", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "list-item"], [3, "select", "value", "selected"], ["class", "values-list", 4, "ngIf"], ["class", "list-item am-pm-item", 3, "selected", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "list-item", "am-pm-item"], [1, "actions-footer"], [3, "setCurrentTime", "saveValue", "applyButtonText", "currentTimeButtonText"]],
  template: function NbTimePickerComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NbTimePickerComponent_nb_card_0_Template, 10, 7, "nb-card", 2);
    }
  },
  dependencies: [NgForOf, NgIf, NbPortalDirective, NbListComponent, NbListItemComponent, NbCardComponent, NbCardFooterComponent, NbCardHeaderComponent, NbCalendarActionsComponent, NbTimePickerCellComponent],
  styles: [".nb-timepicker-container[_ngcontent-%COMP%]{overflow:hidden;margin-bottom:0}.values-list[_ngcontent-%COMP%]{width:100%;overflow:hidden;scroll-snap-type:y proximity}.values-list[_ngcontent-%COMP%]:hover{overflow-y:auto}.list-item[_ngcontent-%COMP%]{border:0;padding:0;cursor:pointer}.picker-body[_ngcontent-%COMP%]{display:flex;width:100%;flex:1 0 0;overflow:hidden}.column-header[_ngcontent-%COMP%]{width:100%;display:flex;justify-content:space-between;padding:0}.header-cell[_ngcontent-%COMP%]{width:100%;display:flex;align-items:center;justify-content:center}.actions-footer[_ngcontent-%COMP%]{width:100%}nb-card-header[_ngcontent-%COMP%], nb-card-footer[_ngcontent-%COMP%]{flex:0 0 auto}\n\n\n\n\n\n"],
  changeDetection: 0
});
var NbTimePickerComponent = _NbTimePickerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTimePickerComponent, [{
    type: Component,
    args: [{
      selector: "nb-timepicker",
      exportAs: "nbTimepicker",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: '<nb-card *nbPortal [class.supports-scrollbar-theming]="!isFirefox()" class="nb-timepicker-container">\n  <nb-card-header class="column-header">\n    <ng-container *ngIf="singleColumn; else fullTimeHeadersBlock">\n      <div class="header-cell">Time</div>\n    </ng-container>\n    <ng-template #fullTimeHeadersBlock>\n      <div class="header-cell">{{ hoursText }}</div>\n      <div class="header-cell">{{ minutesText }}</div>\n      <div *ngIf="withSeconds" class="header-cell">{{ secondsText }}</div>\n      <div *ngIf="twelveHoursFormat" class="header-cell">\n        <ng-template [ngIf]="showAmPmLabel">{{ ampmText }}</ng-template>\n      </div>\n    </ng-template>\n  </nb-card-header>\n\n  <div class="picker-body">\n    <ng-container *ngIf="singleColumn; else fullTimeColumnBlock">\n      <nb-list class="values-list">\n        <nb-list-item\n          class="list-item"\n          [class.selected]="isSelectedFullTimeValue(item)"\n          *ngFor="let item of fullTimeOptions; trackBy: trackBySingleColumnValue.bind(this)"\n        >\n          <nb-timepicker-cell\n            [value]="getFullTimeString(item)"\n            [selected]="isSelectedFullTimeValue(item)"\n            (select)="selectFullTime(item)"\n          >\n          </nb-timepicker-cell>\n        </nb-list-item>\n      </nb-list>\n    </ng-container>\n\n    <ng-template #fullTimeColumnBlock>\n      <nb-list class="values-list">\n        <nb-list-item\n          class="list-item"\n          [class.selected]="isSelectedHour(item.value)"\n          *ngFor="let item of hoursColumnOptions; trackBy: trackByTimeValues"\n        >\n          <nb-timepicker-cell\n            [value]="item.text"\n            [selected]="isSelectedHour(item.value)"\n            (select)="setHour(item.value)"\n          >\n          </nb-timepicker-cell>\n        </nb-list-item>\n      </nb-list>\n      <nb-list class="values-list">\n        <nb-list-item\n          class="list-item"\n          [class.selected]="isSelectedMinute(item.value)"\n          *ngFor="let item of minutesColumnOptions; trackBy: trackByTimeValues"\n        >\n          <nb-timepicker-cell\n            [value]="item.text"\n            [selected]="isSelectedMinute(item.value)"\n            (select)="setMinute(item.value)"\n          >\n          </nb-timepicker-cell>\n        </nb-list-item>\n      </nb-list>\n      <nb-list *ngIf="showSeconds()" class="values-list">\n        <nb-list-item\n          class="list-item"\n          [class.selected]="isSelectedSecond(item.value)"\n          *ngFor="let item of secondsColumnOptions; trackBy: trackByTimeValues"\n        >\n          <nb-timepicker-cell\n            [value]="item.text"\n            [selected]="isSelectedSecond(item.value)"\n            (select)="setSecond(item.value)"\n          >\n          </nb-timepicker-cell>\n        </nb-list-item>\n      </nb-list>\n      <nb-list *ngIf="twelveHoursFormat" class="values-list">\n        <nb-list-item\n          class="list-item am-pm-item"\n          [class.selected]="isSelectedDayPeriod(dayPeriod)"\n          *ngFor="let dayPeriod of dayPeriodColumnOptions; trackBy: trackByDayPeriod"\n        >\n          <nb-timepicker-cell\n            [value]="dayPeriod"\n            [selected]="isSelectedDayPeriod(dayPeriod)"\n            (select)="changeDayPeriod(dayPeriod)"\n          >\n          </nb-timepicker-cell>\n        </nb-list-item>\n      </nb-list>\n    </ng-template>\n  </div>\n\n  <nb-card-footer *ngIf="showFooter" class="actions-footer">\n    <nb-calendar-actions\n      [applyButtonText]="applyButtonText"\n      [currentTimeButtonText]="currentTimeButtonText"\n      (setCurrentTime)="setCurrentTime()"\n      (saveValue)="saveValue()"\n    ></nb-calendar-actions>\n  </nb-card-footer>\n</nb-card>\n',
      styles: [".nb-timepicker-container{overflow:hidden;margin-bottom:0}.values-list{width:100%;overflow:hidden;scroll-snap-type:y proximity}.values-list:hover{overflow-y:auto}.list-item{border:0;padding:0;cursor:pointer}.picker-body{display:flex;width:100%;flex:1 0 0;overflow:hidden}.column-header{width:100%;display:flex;justify-content:space-between;padding:0}.header-cell{width:100%;display:flex;align-items:center;justify-content:center}.actions-footer{width:100%}nb-card-header,nb-card-footer{flex:0 0 auto}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_TIME_PICKER_CONFIG]
    }]
  }, {
    type: NbPlatform
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [LOCALE_ID]
    }]
  }, {
    type: ChangeDetectorRef
  }, {
    type: NbCalendarTimeModelService
  }, {
    type: NbDateService
  }], {
    timeFormat: [{
      type: Input
    }],
    twelveHoursFormat: [{
      type: Input
    }],
    showAmPmLabel: [{
      type: Input
    }],
    withSeconds: [{
      type: Input
    }],
    singleColumn: [{
      type: Input
    }],
    step: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    showFooter: [{
      type: Input
    }],
    applyButtonText: [{
      type: Input
    }],
    hoursText: [{
      type: Input
    }],
    minutesText: [{
      type: Input
    }],
    secondsText: [{
      type: Input
    }],
    ampmText: [{
      type: Input
    }],
    currentTimeButtonText: [{
      type: Input
    }],
    onSelectTime: [{
      type: Output
    }],
    portal: [{
      type: ViewChild,
      args: [NbPortalDirective, {
        static: true
      }]
    }]
  });
})();
var _NbCalendarWithTimeComponent = class _NbCalendarWithTimeComponent extends NbCalendarComponent {
  constructor(dateService, cd, calendarTimeModelService) {
    super();
    this.dateService = dateService;
    this.cd = cd;
    this.calendarTimeModelService = calendarTimeModelService;
  }
  ngOnInit() {
    if (!this.date) {
      this.date = this.calendarTimeModelService.getResetTime();
    }
  }
  ngAfterViewInit() {
    this.portalOutlet.attachTemplatePortal(this.timepicker.portal);
  }
  onDateValueChange(date) {
    const hours = this.dateService.getHours(this.date);
    const minutes = this.dateService.getMinutes(this.date);
    const seconds = this.dateService.getSeconds(this.date);
    const milliseconds = this.dateService.getMilliseconds(this.date);
    let newDate = this.dateService.setHours(date, hours);
    newDate = this.dateService.setMinutes(newDate, minutes);
    newDate = this.dateService.setMinutes(newDate, minutes);
    newDate = this.dateService.setSeconds(newDate, seconds);
    newDate = this.dateService.setMilliseconds(newDate, milliseconds);
    this.date = newDate;
  }
  onTimeChange(selectedTime) {
    let newDate = this.dateService.clone(this.date);
    newDate = this.dateService.setHours(newDate, this.dateService.getHours(selectedTime.time));
    newDate = this.dateService.setMinutes(newDate, this.dateService.getMinutes(selectedTime.time));
    newDate = this.dateService.setSeconds(newDate, this.dateService.getSeconds(selectedTime.time));
    newDate = this.dateService.setMilliseconds(newDate, this.dateService.getMilliseconds(selectedTime.time));
    this.date = newDate;
  }
  saveValue() {
    this.dateChange.emit(this.date);
  }
  saveCurrentTime() {
    this.dateChange.emit(this.dateService.today());
  }
  showSeconds() {
    return this.withSeconds && !this.singleColumn;
  }
  isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
};
_NbCalendarWithTimeComponent.\u0275fac = function NbCalendarWithTimeComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbCalendarWithTimeComponent)(\u0275\u0275directiveInject(NbDateService), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NbCalendarTimeModelService));
};
_NbCalendarWithTimeComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbCalendarWithTimeComponent,
  selectors: [["nb-calendar-with-time"]],
  viewQuery: function NbCalendarWithTimeComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(NbPortalOutletDirective, 5);
      \u0275\u0275viewQuery(NbTimePickerComponent, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.portalOutlet = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.timepicker = _t.first);
    }
  },
  inputs: {
    visibleDate: "visibleDate",
    twelveHoursFormat: "twelveHoursFormat",
    showAmPmLabel: "showAmPmLabel",
    withSeconds: "withSeconds",
    singleColumn: "singleColumn",
    step: "step",
    timeFormat: "timeFormat",
    title: "title",
    applyButtonText: "applyButtonText",
    currentTimeButtonText: "currentTimeButtonText",
    showCurrentTimeButton: "showCurrentTimeButton"
  },
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 10,
  vars: 32,
  consts: [[1, "calendar-with-time"], [1, "picker-body"], [3, "dateChange", "boundingMonth", "startView", "date", "min", "max", "filter", "dayCellComponent", "monthCellComponent", "yearCellComponent", "size", "visibleDate", "showNavigation", "showWeekNumber", "weekNumberSymbol", "firstDayOfWeek"], [1, "timepicker-section"], [1, "picker-title"], [3, "onSelectTime", "date", "twelveHoursFormat", "showAmPmLabel", "withSeconds", "showFooter", "singleColumn", "step"], ["nbPortalOutlet", ""], [1, "picker-footer"], [3, "setCurrentTime", "saveValue", "applyButtonText", "currentTimeButtonText", "showCurrentTimeButton"]],
  template: function NbCalendarWithTimeComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "nb-card", 0)(1, "nb-card-body", 1)(2, "nb-base-calendar", 2);
      \u0275\u0275listener("dateChange", function NbCalendarWithTimeComponent_Template_nb_base_calendar_dateChange_2_listener($event) {
        return ctx.onDateValueChange($event);
      });
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(3, "div", 3)(4, "div", 4);
      \u0275\u0275text(5);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(6, "nb-timepicker", 5);
      \u0275\u0275listener("onSelectTime", function NbCalendarWithTimeComponent_Template_nb_timepicker_onSelectTime_6_listener($event) {
        return ctx.onTimeChange($event);
      });
      \u0275\u0275elementEnd();
      \u0275\u0275elementContainer(7, 6);
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(8, "nb-card-footer", 7)(9, "nb-calendar-actions", 8);
      \u0275\u0275listener("setCurrentTime", function NbCalendarWithTimeComponent_Template_nb_calendar_actions_setCurrentTime_9_listener() {
        return ctx.saveCurrentTime();
      })("saveValue", function NbCalendarWithTimeComponent_Template_nb_calendar_actions_saveValue_9_listener() {
        return ctx.saveValue();
      });
      \u0275\u0275elementEnd()()();
    }
    if (rf & 2) {
      \u0275\u0275advance(2);
      \u0275\u0275property("boundingMonth", ctx.boundingMonth)("startView", ctx.startView)("date", ctx.date)("min", ctx.min)("max", ctx.max)("filter", ctx.filter)("dayCellComponent", ctx.dayCellComponent)("monthCellComponent", ctx.monthCellComponent)("yearCellComponent", ctx.yearCellComponent)("size", ctx.size)("visibleDate", ctx.visibleDate)("showNavigation", ctx.showNavigation)("showWeekNumber", ctx.showWeekNumber)("weekNumberSymbol", ctx.weekNumberSymbol)("firstDayOfWeek", ctx.firstDayOfWeek);
      \u0275\u0275advance();
      \u0275\u0275classProp("size-large", ctx.isLarge())("timepicker-single-column-width", ctx.singleColumn)("timepicker-multiple-column-width", !ctx.singleColumn);
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate(ctx.title);
      \u0275\u0275advance();
      \u0275\u0275property("date", ctx.date)("twelveHoursFormat", ctx.twelveHoursFormat)("showAmPmLabel", ctx.showAmPmLabel)("withSeconds", ctx.showSeconds())("showFooter", false)("singleColumn", ctx.singleColumn)("step", ctx.step);
      \u0275\u0275advance(3);
      \u0275\u0275property("applyButtonText", ctx.applyButtonText)("currentTimeButtonText", ctx.currentTimeButtonText)("showCurrentTimeButton", ctx.showCurrentTimeButton);
    }
  },
  dependencies: [NbPortalOutletDirective, NbCardComponent, NbCardBodyComponent, NbCardFooterComponent, NbBaseCalendarComponent, NbTimePickerComponent, NbCalendarActionsComponent],
  styles: ["[_nghost-%COMP%]     nb-card.nb-timepicker-container{flex:1 0 0;border-radius:0;width:auto;border-right:0;border-bottom:0}[dir=ltr]   [_nghost-%COMP%]   .picker-footer[_ngcontent-%COMP%]{padding-left:.625rem}[dir=rtl]   [_nghost-%COMP%]   .picker-footer[_ngcontent-%COMP%]{padding-right:.625rem}.picker-body[_ngcontent-%COMP%]{align-items:stretch;display:flex;padding:0}.picker-body[_ngcontent-%COMP%]   nb-base-calendar[_ngcontent-%COMP%]     nb-card{border-radius:0}.calendar-with-time[_ngcontent-%COMP%]{overflow:hidden}.timepicker-section[_ngcontent-%COMP%]{display:flex;flex-direction:column}\n\n\n\n\n\n\n\n\n\n\n\n"],
  changeDetection: 0
});
var NbCalendarWithTimeComponent = _NbCalendarWithTimeComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarWithTimeComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-with-time",
      template: `
    <nb-card class="calendar-with-time">
      <nb-card-body class="picker-body">
        <nb-base-calendar
          [boundingMonth]="boundingMonth"
          [startView]="startView"
          [date]="date"
          [min]="min"
          [max]="max"
          [filter]="filter"
          [dayCellComponent]="dayCellComponent"
          [monthCellComponent]="monthCellComponent"
          [yearCellComponent]="yearCellComponent"
          [size]="size"
          [visibleDate]="visibleDate"
          [showNavigation]="showNavigation"
          [showWeekNumber]="showWeekNumber"
          [weekNumberSymbol]="weekNumberSymbol"
          [firstDayOfWeek]="firstDayOfWeek"
          (dateChange)="onDateValueChange($event)"
        >
        </nb-base-calendar>
        <div
          class="timepicker-section"
          [class.size-large]="isLarge()"
          [class.timepicker-single-column-width]="singleColumn"
          [class.timepicker-multiple-column-width]="!singleColumn"
        >
          <div class="picker-title">{{ title }}</div>
          <nb-timepicker
            (onSelectTime)="onTimeChange($event)"
            [date]="date"
            [twelveHoursFormat]="twelveHoursFormat"
            [showAmPmLabel]="showAmPmLabel"
            [withSeconds]="showSeconds()"
            [showFooter]="false"
            [singleColumn]="singleColumn"
            [step]="step"
          >
          </nb-timepicker>
          <ng-container nbPortalOutlet></ng-container>
        </div>
      </nb-card-body>
      <nb-card-footer class="picker-footer">
        <nb-calendar-actions
          [applyButtonText]="applyButtonText"
          [currentTimeButtonText]="currentTimeButtonText"
          [showCurrentTimeButton]="showCurrentTimeButton"
          (setCurrentTime)="saveCurrentTime()"
          (saveValue)="saveValue()"
        ></nb-calendar-actions>
      </nb-card-footer>
    </nb-card>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      styles: [":host ::ng-deep nb-card.nb-timepicker-container{flex:1 0 0;border-radius:0;width:auto;border-right:0;border-bottom:0}[dir=ltr] :host .picker-footer{padding-left:.625rem}[dir=rtl] :host .picker-footer{padding-right:.625rem}.picker-body{align-items:stretch;display:flex;padding:0}.picker-body nb-base-calendar ::ng-deep nb-card{border-radius:0}.calendar-with-time{overflow:hidden}.timepicker-section{display:flex;flex-direction:column}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: NbDateService
  }, {
    type: ChangeDetectorRef
  }, {
    type: NbCalendarTimeModelService
  }], {
    visibleDate: [{
      type: Input
    }],
    twelveHoursFormat: [{
      type: Input
    }],
    showAmPmLabel: [{
      type: Input
    }],
    withSeconds: [{
      type: Input
    }],
    singleColumn: [{
      type: Input
    }],
    step: [{
      type: Input
    }],
    timeFormat: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    applyButtonText: [{
      type: Input
    }],
    currentTimeButtonText: [{
      type: Input
    }],
    showCurrentTimeButton: [{
      type: Input
    }],
    portalOutlet: [{
      type: ViewChild,
      args: [NbPortalOutletDirective]
    }],
    timepicker: [{
      type: ViewChild,
      args: [NbTimePickerComponent]
    }]
  });
})();
var _NbDatepickerContainerComponent = class _NbDatepickerContainerComponent extends NbPositionedContainerComponent {
  attach(portal) {
    return this.overlayContainer.attachComponentPortal(portal);
  }
};
_NbDatepickerContainerComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NbDatepickerContainerComponent_BaseFactory;
  return function NbDatepickerContainerComponent_Factory(__ngFactoryType__) {
    return (\u0275NbDatepickerContainerComponent_BaseFactory || (\u0275NbDatepickerContainerComponent_BaseFactory = \u0275\u0275getInheritedFactory(_NbDatepickerContainerComponent)))(__ngFactoryType__ || _NbDatepickerContainerComponent);
  };
})();
_NbDatepickerContainerComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbDatepickerContainerComponent,
  selectors: [["nb-datepicker-container"]],
  viewQuery: function NbDatepickerContainerComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(NbOverlayContainerComponent, 7);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.overlayContainer = _t.first);
    }
  },
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 1,
  vars: 0,
  template: function NbDatepickerContainerComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275element(0, "nb-overlay-container");
    }
  },
  dependencies: [NbOverlayContainerComponent],
  encapsulation: 2
});
var NbDatepickerContainerComponent = _NbDatepickerContainerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDatepickerContainerComponent, [{
    type: Component,
    args: [{
      selector: "nb-datepicker-container",
      template: `
    <nb-overlay-container></nb-overlay-container>
  `,
      standalone: false
    }]
  }], null, {
    overlayContainer: [{
      type: ViewChild,
      args: [NbOverlayContainerComponent, {
        static: true
      }]
    }]
  });
})();
var NbDatepickerAdapter = class {
};
var NbDatepicker = class {
};
var NB_DATE_ADAPTER = new InjectionToken("Datepicker Adapter");
var NB_DATE_SERVICE_OPTIONS = new InjectionToken("Date service options");
var _NbDatepickerDirective = class _NbDatepickerDirective {
  /**
   * Provides datepicker component.
   * */
  // eslint-disable-next-line @angular-eslint/no-input-rename
  set setPicker(picker) {
    this.picker = picker;
    this.setupPicker();
  }
  constructor(document2, datepickerAdapters, hostRef, dateService, changeDetector) {
    this.document = document2;
    this.datepickerAdapters = datepickerAdapters;
    this.hostRef = hostRef;
    this.dateService = dateService;
    this.changeDetector = changeDetector;
    this.destroy$ = new Subject();
    this.isDatepickerReady = false;
    this.onChange = () => {
    };
    this.onTouched = () => {
    };
    this.validator = Validators.compose([this.parseValidator, this.minValidator, this.maxValidator, this.filterValidator].map((fn) => fn.bind(this)));
    this.subscribeOnInputChange();
  }
  /**
   * Returns html input element.
   * */
  get input() {
    return this.hostRef.nativeElement;
  }
  /**
   * Returns host input value.
   * */
  get inputValue() {
    return this.input.value;
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  /**
   * Writes value in picker and html input element.
   * */
  writeValue(value) {
    if (this.isDatepickerReady) {
      this.writePicker(value);
      this.writeInput(value);
    } else {
      this.queue = value;
    }
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  setDisabledState(isDisabled) {
    this.input.disabled = isDisabled;
  }
  /**
   * Form control validation based on picker validator config.
   * */
  validate() {
    return this.validator(null);
  }
  /**
   * Hides picker, focuses the input
   */
  hidePicker() {
    this.input.focus();
    this.picker.hide();
  }
  /**
   * Validates that we can parse value correctly.
   * */
  parseValidator() {
    if (this.inputValue === "") {
      return null;
    }
    const isValid = this.datepickerAdapter.isValid(this.inputValue, this.picker.format);
    return isValid ? null : {
      nbDatepickerParse: {
        value: this.inputValue
      }
    };
  }
  /**
   * Validates passed value is greater than min.
   * */
  minValidator() {
    const config = this.picker.getValidatorConfig();
    const date = this.datepickerAdapter.parse(this.inputValue, this.picker.format);
    return !config.min || !date || this.dateService.compareDates(config.min, date) <= 0 ? null : {
      nbDatepickerMin: {
        min: config.min,
        actual: date
      }
    };
  }
  /**
   * Validates passed value is smaller than max.
   * */
  maxValidator() {
    const config = this.picker.getValidatorConfig();
    const date = this.datepickerAdapter.parse(this.inputValue, this.picker.format);
    return !config.max || !date || this.dateService.compareDates(config.max, date) >= 0 ? null : {
      nbDatepickerMax: {
        max: config.max,
        actual: date
      }
    };
  }
  /**
   * Validates passed value satisfy the filter.
   * */
  filterValidator() {
    const config = this.picker.getValidatorConfig();
    const date = this.datepickerAdapter.parse(this.inputValue, this.picker.format);
    return !config.filter || !date || config.filter(date) ? null : {
      nbDatepickerFilter: true
    };
  }
  /**
   * Chooses datepicker adapter based on passed picker component.
   * */
  chooseDatepickerAdapter() {
    this.datepickerAdapter = this.datepickerAdapters.find(({
      picker
    }) => this.picker instanceof picker);
    if (this.noDatepickerAdapterProvided()) {
      throw new Error("No datepickerAdapter provided for picker");
    }
  }
  /**
   * Attaches picker to the host input element and subscribes on value changes.
   * */
  setupPicker() {
    this.chooseDatepickerAdapter();
    this.picker.attach(this.hostRef);
    if (this.inputValue) {
      this.picker.value = this.datepickerAdapter.parse(this.inputValue, this.picker.format);
    }
    this.pickerInputsChangedSubscription?.unsubscribe();
    this.pickerInputsChangedSubscription = this.picker.formatChanged$.pipe(map(() => this.picker.format), startWith(this.picker.format), distinctUntilChanged(), pairwise(), takeUntil(this.destroy$)).subscribe(([prevFormat, nextFormat]) => {
      if (this.inputValue) {
        const date = this.datepickerAdapter.parse(this.inputValue, prevFormat);
        this.writeInput(date);
      }
    });
    if (!this.isDatepickerReady) {
      this.picker.init.pipe(take(1), tap(() => this.isDatepickerReady = true), filter(() => !!this.queue), takeUntil(this.destroy$)).subscribe(() => {
        this.writeValue(this.queue);
        this.changeDetector.detectChanges();
        this.queue = void 0;
      });
    }
    this.picker.valueChange.pipe(takeUntil(this.destroy$)).subscribe((value) => {
      this.writePicker(value);
      this.writeInput(value);
      this.onChange(value);
      if (this.picker.shouldHide()) {
        this.hidePicker();
      }
    });
    merge(this.picker.blur, fromEvent(this.input, "blur").pipe(filter(() => !this.picker.isShown && this.document.activeElement !== this.input))).pipe(takeUntil(this.destroy$)).subscribe(() => this.onTouched());
  }
  writePicker(value) {
    this.picker.value = value;
  }
  writeInput(value) {
    this.hostRef.nativeElement.value = this.datepickerAdapter.format(value, this.picker.format);
  }
  /**
   * Validates if no datepicker adapter provided.
   * */
  noDatepickerAdapterProvided() {
    return !this.datepickerAdapter || !(this.datepickerAdapter instanceof NbDatepickerAdapter);
  }
  subscribeOnInputChange() {
    fromEvent(this.input, "input").pipe(map(() => this.inputValue), takeUntil(this.destroy$)).subscribe((value) => this.handleInputChange(value));
  }
  /**
   * Parses input value and write if it isn't null.
   * */
  handleInputChange(value) {
    const date = this.parseInputValue(value);
    this.onChange(date);
    this.writePicker(date);
  }
  parseInputValue(value) {
    if (this.datepickerAdapter.isValid(value, this.picker.format)) {
      return this.datepickerAdapter.parse(value, this.picker.format);
    }
    return null;
  }
};
_NbDatepickerDirective.\u0275fac = function NbDatepickerDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbDatepickerDirective)(\u0275\u0275directiveInject(NB_DOCUMENT), \u0275\u0275directiveInject(NB_DATE_ADAPTER), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NbDateService), \u0275\u0275directiveInject(ChangeDetectorRef));
};
_NbDatepickerDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbDatepickerDirective,
  selectors: [["input", "nbDatepicker", ""]],
  inputs: {
    setPicker: [0, "nbDatepicker", "setPicker"]
  },
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => _NbDatepickerDirective),
    multi: true
  }, {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => _NbDatepickerDirective),
    multi: true
  }])]
});
var NbDatepickerDirective = _NbDatepickerDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDatepickerDirective, [{
    type: Directive,
    args: [{
      selector: "input[nbDatepicker]",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NbDatepickerDirective),
        multi: true
      }, {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => NbDatepickerDirective),
        multi: true
      }],
      standalone: false
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DATE_ADAPTER]
    }]
  }, {
    type: ElementRef
  }, {
    type: NbDateService
  }, {
    type: ChangeDetectorRef
  }], {
    setPicker: [{
      type: Input,
      args: ["nbDatepicker"]
    }]
  });
})();
var NbBasePicker = class extends NbDatepicker {
  constructor(overlay, positionBuilder, triggerStrategyBuilder, dateService, dateServiceOptions) {
    super();
    this.overlay = overlay;
    this.positionBuilder = positionBuilder;
    this.triggerStrategyBuilder = triggerStrategyBuilder;
    this.dateService = dateService;
    this.dateServiceOptions = dateServiceOptions;
    this.formatChanged$ = new Subject();
    this.init$ = new ReplaySubject();
    this.onChange$ = new Subject();
    this.overlayOffset = 8;
    this.adjustment = NbAdjustment.COUNTERCLOCKWISE;
    this.destroy$ = new Subject();
    this.blur$ = new Subject();
  }
  /**
   * Returns picker instance.
   * */
  get picker() {
    return this.pickerRef && this.pickerRef.instance;
  }
  /**
   * Stream of picker value changes.
   * */
  get valueChange() {
    return this.onChange$.asObservable();
  }
  get isShown() {
    return this.ref && this.ref.hasAttached();
  }
  get init() {
    return this.init$.asObservable();
  }
  /**
   * Emits when datepicker looses focus.
   */
  get blur() {
    return this.blur$.asObservable();
  }
  /**
   * Datepicker knows nothing about host html input element.
   * So, attach method attaches datepicker to the host input element.
   * */
  attach(hostRef) {
    this.hostRef = hostRef;
    this.subscribeOnTriggers();
  }
  getValidatorConfig() {
    return {
      min: this.min,
      max: this.max,
      filter: this.filter
    };
  }
  show() {
    if (!this.ref) {
      this.createOverlay();
    }
    this.openDatepicker();
  }
  shouldHide() {
    return this.hideOnSelect && !!this.value;
  }
  hide() {
    if (this.ref) {
      this.ref.detach();
    }
    if (this.picker) {
      this.queue = this.value;
      this.pickerRef.destroy();
      this.pickerRef = null;
      this.container = null;
    }
  }
  createOverlay() {
    this.positionStrategy = this.createPositionStrategy();
    this.ref = this.overlay.create({
      positionStrategy: this.positionStrategy,
      scrollStrategy: this.overlay.scrollStrategies.reposition()
    });
    this.subscribeOnPositionChange();
  }
  openDatepicker() {
    this.container = this.ref.attach(new NbComponentPortal(NbDatepickerContainerComponent, null, null));
    this.instantiatePicker();
    this.subscribeOnValueChange();
    this.writeQueue();
    this.patchWithInputs();
    this.pickerRef.changeDetectorRef.markForCheck();
  }
  createPositionStrategy() {
    return this.positionBuilder.connectedTo(this.hostRef).position(NbPosition.BOTTOM).offset(this.overlayOffset).adjustment(this.adjustment);
  }
  subscribeOnPositionChange() {
    this.positionStrategy.positionChange.pipe(takeUntil(this.destroy$)).subscribe((position) => patch(this.container, {
      position
    }));
  }
  createTriggerStrategy() {
    return this.triggerStrategyBuilder.trigger(NbTrigger.FOCUS).host(this.hostRef.nativeElement).container(() => this.container).build();
  }
  subscribeOnTriggers() {
    this.triggerStrategy = this.createTriggerStrategy();
    this.triggerStrategy.show$.subscribe(() => this.show());
    this.triggerStrategy.hide$.subscribe(() => {
      this.blur$.next();
      this.hide();
    });
  }
  instantiatePicker() {
    this.pickerRef = this.container.instance.attach(new NbComponentPortal(this.pickerClass, null, null));
  }
  /**
   * Subscribes on picker value changes and emit data through this.onChange$ subject.
   * */
  subscribeOnValueChange() {
    this.pickerValueChange.subscribe((date) => {
      this.onChange$.next(date);
    });
  }
  patchWithInputs() {
    this.picker.boundingMonth = this.boundingMonth;
    this.picker.startView = this.startView;
    this.picker.min = this.min;
    this.picker.max = this.max;
    this.picker.filter = this.filter;
    this.picker._cellComponent = this.dayCellComponent;
    this.picker._monthCellComponent = this.monthCellComponent;
    this.picker._yearCellComponent = this.yearCellComponent;
    this.picker.size = this.size;
    this.picker.showNavigation = this.showNavigation;
    this.picker.visibleDate = this.visibleDate;
    this.picker.showWeekNumber = this.showWeekNumber;
    this.picker.weekNumberSymbol = this.weekNumberSymbol;
    this.picker.firstDayOfWeek = this.firstDayOfWeek;
  }
  checkFormat() {
    if (this.dateService.getId() === "native" && this.format) {
      throw new Error(`Can't format native date. To use custom formatting you have to install @nebular/moment or @nebular/date-fns package and import NbMomentDateModule or NbDateFnsDateModule accordingly.More information at "Formatting issue" https://akveo.github.io/nebular/docs/components/datepicker/overview#nbdatepickercomponent`);
    }
    const isFormatSet = this.format || this.dateServiceOptions && this.dateServiceOptions.format;
    if (this.dateService.getId() === "date-fns" && !isFormatSet) {
      throw new Error("format is required when using NbDateFnsDateModule");
    }
  }
};
var _NbBasePickerComponent = class _NbBasePickerComponent extends NbBasePicker {
  /**
   * Determines should we show week numbers column.
   * False by default.
   * */
  get showWeekNumber() {
    return this._showWeekNumber;
  }
  set showWeekNumber(value) {
    this._showWeekNumber = convertToBoolProperty(value);
  }
  constructor(document2, positionBuilder, triggerStrategyBuilder, overlay, dateService, dateServiceOptions) {
    super(overlay, positionBuilder, triggerStrategyBuilder, dateService, dateServiceOptions);
    this.boundingMonth = true;
    this.startView = NbCalendarViewMode.DATE;
    this.size = NbCalendarSize.MEDIUM;
    this.hideOnSelect = true;
    this.showNavigation = true;
    this.weekNumberSymbol = "#";
    this._showWeekNumber = false;
    this.overlayOffset = 8;
    this.adjustment = NbAdjustment.COUNTERCLOCKWISE;
  }
  ngOnInit() {
    this.checkFormat();
    this.init$.next();
  }
  ngOnChanges(changes) {
    if (changes.format) {
      if (!changes.format.isFirstChange()) {
        this.checkFormat();
      }
      this.formatChanged$.next();
    }
    if (this.picker) {
      this.patchWithInputs();
    }
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
    this.hide();
    this.init$.complete();
    if (this.ref) {
      this.ref.dispose();
    }
    if (this.triggerStrategy) {
      this.triggerStrategy.destroy();
    }
  }
  get pickerValueChange() {
    return void 0;
  }
  get value() {
    return void 0;
  }
  set value(value) {
  }
  writeQueue() {
  }
};
_NbBasePickerComponent.\u0275fac = function NbBasePickerComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbBasePickerComponent)(\u0275\u0275directiveInject(NB_DOCUMENT), \u0275\u0275directiveInject(NbPositionBuilderService), \u0275\u0275directiveInject(NbTriggerStrategyBuilderService), \u0275\u0275directiveInject(NbOverlayService), \u0275\u0275directiveInject(NbDateService), \u0275\u0275directiveInject(NB_DATE_SERVICE_OPTIONS, 8));
};
_NbBasePickerComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbBasePickerComponent,
  selectors: [["ng-component"]],
  inputs: {
    format: "format",
    boundingMonth: "boundingMonth",
    startView: "startView",
    min: "min",
    max: "max",
    filter: "filter",
    dayCellComponent: "dayCellComponent",
    monthCellComponent: "monthCellComponent",
    yearCellComponent: "yearCellComponent",
    size: "size",
    visibleDate: "visibleDate",
    hideOnSelect: "hideOnSelect",
    showNavigation: "showNavigation",
    weekNumberSymbol: "weekNumberSymbol",
    showWeekNumber: "showWeekNumber",
    firstDayOfWeek: "firstDayOfWeek",
    overlayOffset: "overlayOffset",
    adjustment: "adjustment"
  },
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature],
  decls: 0,
  vars: 0,
  template: function NbBasePickerComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
var NbBasePickerComponent = _NbBasePickerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbBasePickerComponent, [{
    type: Component,
    args: [{
      template: "",
      standalone: false
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: NbPositionBuilderService
  }, {
    type: NbTriggerStrategyBuilderService
  }, {
    type: NbOverlayService
  }, {
    type: NbDateService
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NB_DATE_SERVICE_OPTIONS]
    }]
  }], {
    format: [{
      type: Input
    }],
    boundingMonth: [{
      type: Input
    }],
    startView: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    dayCellComponent: [{
      type: Input
    }],
    monthCellComponent: [{
      type: Input
    }],
    yearCellComponent: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    visibleDate: [{
      type: Input
    }],
    hideOnSelect: [{
      type: Input
    }],
    showNavigation: [{
      type: Input
    }],
    weekNumberSymbol: [{
      type: Input
    }],
    showWeekNumber: [{
      type: Input
    }],
    firstDayOfWeek: [{
      type: Input
    }],
    overlayOffset: [{
      type: Input
    }],
    adjustment: [{
      type: Input
    }]
  });
})();
var _NbDatepickerComponent = class _NbDatepickerComponent extends NbBasePickerComponent {
  constructor() {
    super(...arguments);
    this.pickerClass = NbCalendarComponent;
  }
  /**
   * Date which will be rendered as selected.
   * */
  set date(date) {
    this.value = date;
  }
  /**
   * Emits date when selected.
   * */
  get dateChange() {
    return this.valueChange;
  }
  get value() {
    return this.picker ? this.picker.date : void 0;
  }
  set value(date) {
    if (!this.picker) {
      this.queue = date;
      return;
    }
    if (date) {
      this.visibleDate = date;
      this.picker.visibleDate = date;
      this.picker.date = date;
    }
  }
  get pickerValueChange() {
    return this.picker.dateChange;
  }
  writeQueue() {
    if (this.queue) {
      const date = this.queue;
      this.queue = null;
      this.value = date;
    }
  }
};
_NbDatepickerComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NbDatepickerComponent_BaseFactory;
  return function NbDatepickerComponent_Factory(__ngFactoryType__) {
    return (\u0275NbDatepickerComponent_BaseFactory || (\u0275NbDatepickerComponent_BaseFactory = \u0275\u0275getInheritedFactory(_NbDatepickerComponent)))(__ngFactoryType__ || _NbDatepickerComponent);
  };
})();
_NbDatepickerComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbDatepickerComponent,
  selectors: [["nb-datepicker"]],
  inputs: {
    date: "date"
  },
  outputs: {
    dateChange: "dateChange"
  },
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NbDatepickerComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
var NbDatepickerComponent = _NbDatepickerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDatepickerComponent, [{
    type: Component,
    args: [{
      selector: "nb-datepicker",
      template: "",
      standalone: false
    }]
  }], null, {
    date: [{
      type: Input
    }],
    dateChange: [{
      type: Output
    }]
  });
})();
var _NbRangepickerComponent = class _NbRangepickerComponent extends NbBasePickerComponent {
  constructor() {
    super(...arguments);
    this.pickerClass = NbCalendarRangeComponent;
  }
  /**
   * Range which will be rendered as selected.
   * */
  set range(range2) {
    this.value = range2;
  }
  /**
   * Emits range when start selected and emits again when end selected.
   * */
  get rangeChange() {
    return this.valueChange;
  }
  get value() {
    return this.picker ? this.picker.range : void 0;
  }
  set value(range2) {
    if (!this.picker) {
      this.queue = range2;
      return;
    }
    if (range2) {
      const visibleDate = range2 && range2.start;
      this.visibleDate = visibleDate;
      this.picker.visibleDate = visibleDate;
      this.picker.range = range2;
    }
  }
  get pickerValueChange() {
    return this.picker.rangeChange;
  }
  shouldHide() {
    return super.shouldHide() && !!(this.value && this.value.start && this.value.end);
  }
  writeQueue() {
    if (this.queue) {
      const range2 = this.queue;
      this.queue = null;
      this.value = range2;
    }
  }
};
_NbRangepickerComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NbRangepickerComponent_BaseFactory;
  return function NbRangepickerComponent_Factory(__ngFactoryType__) {
    return (\u0275NbRangepickerComponent_BaseFactory || (\u0275NbRangepickerComponent_BaseFactory = \u0275\u0275getInheritedFactory(_NbRangepickerComponent)))(__ngFactoryType__ || _NbRangepickerComponent);
  };
})();
_NbRangepickerComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbRangepickerComponent,
  selectors: [["nb-rangepicker"]],
  inputs: {
    range: "range"
  },
  outputs: {
    rangeChange: "rangeChange"
  },
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NbRangepickerComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
var NbRangepickerComponent = _NbRangepickerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRangepickerComponent, [{
    type: Component,
    args: [{
      selector: "nb-rangepicker",
      template: "",
      standalone: false
    }]
  }], null, {
    range: [{
      type: Input
    }],
    rangeChange: [{
      type: Output
    }]
  });
})();
var _NbDateTimePickerComponent = class _NbDateTimePickerComponent extends NbBasePickerComponent {
  get value() {
    return this.picker ? this.picker.date : void 0;
  }
  set value(date) {
    if (!this.picker) {
      this.queue = date;
      return;
    }
    if (date) {
      this.visibleDate = date;
      this.picker.visibleDate = date;
      this.picker.date = date;
      this.picker.cd.markForCheck();
    }
  }
  /**
   * Defines 12 hours format like '07:00 PM'.
   * */
  get twelveHoursFormat() {
    return this._twelveHoursFormat;
  }
  set twelveHoursFormat(value) {
    this._twelveHoursFormat = convertToBoolProperty(value);
  }
  /**
   * Defines should show am/pm label if twelveHoursFormat enabled.
   * */
  get showAmPmLabel() {
    return this._showAmPmLabel;
  }
  set showAmPmLabel(value) {
    this._showAmPmLabel = convertToBoolProperty(value);
  }
  /**
   * Show seconds in timepicker.
   * Ignored when singleColumn is true.
   * */
  get withSeconds() {
    return this._withSeconds;
  }
  set withSeconds(value) {
    this._withSeconds = convertToBoolProperty(value);
  }
  /**
   * Show timepicker values in one column with 60 minutes step by default.
   * */
  get singleColumn() {
    return this._singleColumn;
  }
  set singleColumn(value) {
    this._singleColumn = convertToBoolProperty(value);
  }
  /**
   * Emits date with time when selected.
   * */
  get dateTimeChange() {
    return this.valueChange;
  }
  constructor(document2, positionBuilder, triggerStrategyBuilder, overlay, dateService, dateServiceOptions, calendarWithTimeModelService) {
    super(document2, positionBuilder, triggerStrategyBuilder, overlay, dateService, dateServiceOptions);
    this.calendarWithTimeModelService = calendarWithTimeModelService;
    this.pickerClass = NbCalendarWithTimeComponent;
    this.showCurrentTimeButton = true;
    this._showAmPmLabel = true;
  }
  ngOnInit() {
    this.format = this.format || this.buildTimeFormat();
    this.init$.next();
  }
  patchWithInputs() {
    this.picker.singleColumn = this.singleColumn;
    this.picker.twelveHoursFormat = this.twelveHoursFormat;
    this.picker.showAmPmLabel = this.showAmPmLabel;
    this.picker.withSeconds = this.withSeconds;
    this.picker.step = this.step;
    this.picker.title = this.title;
    this.picker.applyButtonText = this.applyButtonText;
    this.picker.currentTimeButtonText = this.currentTimeButtonText;
    this.picker.showCurrentTimeButton = this.showCurrentTimeButton;
    if (this.twelveHoursFormat) {
      this.picker.timeFormat = this.dateService.getTwelveHoursFormat();
    } else {
      this.picker.timeFormat = this.withSeconds && !this.singleColumn ? this.dateService.getTwentyFourHoursFormatWithSeconds() : this.dateService.getTwentyFourHoursFormat();
    }
    super.patchWithInputs();
    this.picker.cd.markForCheck();
  }
  get pickerValueChange() {
    return this.picker.dateChange;
  }
  writeQueue() {
    if (this.queue) {
      const date = this.queue;
      this.queue = null;
      this.value = date;
    }
  }
  buildTimeFormat() {
    if (this.singleColumn) {
      return this.calendarWithTimeModelService.buildDateFormat(this.twelveHoursFormat);
    } else {
      return this.calendarWithTimeModelService.buildDateFormat(this.twelveHoursFormat, this.withSeconds);
    }
  }
};
_NbDateTimePickerComponent.\u0275fac = function NbDateTimePickerComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbDateTimePickerComponent)(\u0275\u0275directiveInject(NB_DOCUMENT), \u0275\u0275directiveInject(NbPositionBuilderService), \u0275\u0275directiveInject(NbTriggerStrategyBuilderService), \u0275\u0275directiveInject(NbOverlayService), \u0275\u0275directiveInject(NbDateService), \u0275\u0275directiveInject(NB_DATE_SERVICE_OPTIONS, 8), \u0275\u0275directiveInject(NbCalendarTimeModelService));
};
_NbDateTimePickerComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbDateTimePickerComponent,
  selectors: [["nb-date-timepicker"]],
  inputs: {
    step: "step",
    title: "title",
    applyButtonText: "applyButtonText",
    currentTimeButtonText: "currentTimeButtonText",
    showCurrentTimeButton: "showCurrentTimeButton",
    twelveHoursFormat: "twelveHoursFormat",
    showAmPmLabel: "showAmPmLabel",
    withSeconds: "withSeconds",
    singleColumn: "singleColumn"
  },
  outputs: {
    dateTimeChange: "dateTimeChange"
  },
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NbDateTimePickerComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbDateTimePickerComponent = _NbDateTimePickerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDateTimePickerComponent, [{
    type: Component,
    args: [{
      selector: "nb-date-timepicker",
      template: "",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: NbPositionBuilderService
  }, {
    type: NbTriggerStrategyBuilderService
  }, {
    type: NbOverlayService
  }, {
    type: NbDateService
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NB_DATE_SERVICE_OPTIONS]
    }]
  }, {
    type: NbCalendarTimeModelService
  }], {
    step: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    applyButtonText: [{
      type: Input
    }],
    currentTimeButtonText: [{
      type: Input
    }],
    showCurrentTimeButton: [{
      type: Input
    }],
    twelveHoursFormat: [{
      type: Input
    }],
    showAmPmLabel: [{
      type: Input
    }],
    withSeconds: [{
      type: Input
    }],
    singleColumn: [{
      type: Input
    }],
    dateTimeChange: [{
      type: Output
    }]
  });
})();
function isUrlPathEqual(path, link) {
  const locationPath = getPathPartOfUrl(path);
  return link === locationPath;
}
function isUrlPathContain(path, link) {
  const locationPath = getPathPartOfUrl(path);
  const endOfUrlSegmentRegExp = /\/|^$/;
  return locationPath.startsWith(link) && locationPath.slice(link.length).charAt(0).search(endOfUrlSegmentRegExp) !== -1;
}
function getPathPartOfUrl(url) {
  return url.match(/.*?(?=[?;#]|$)/)[0];
}
function getFragmentPartOfUrl(url) {
  const matched = url.match(/#(.+)/);
  return matched ? matched[1] : "";
}
function isFragmentEqual(path, fragment) {
  return getFragmentPartOfUrl(path) === fragment;
}
function isFragmentContain(path, fragment) {
  return getFragmentPartOfUrl(path).includes(fragment);
}
var _NbRestoreScrollTopHelper = class _NbRestoreScrollTopHelper {
  constructor(router) {
    this.router = router;
  }
  shouldRestore() {
    return this.router.events.pipe(startWith(null), filter((event) => event === null || event instanceof NavigationEnd), pairwise(), map(([prev, current]) => this.pageChanged(prev, current)), filter((res) => !!res));
  }
  pageChanged(prev, current) {
    return !prev || getPathPartOfUrl(prev.url) !== getPathPartOfUrl(current.url);
  }
};
_NbRestoreScrollTopHelper.\u0275fac = function NbRestoreScrollTopHelper_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbRestoreScrollTopHelper)(\u0275\u0275inject(Router));
};
_NbRestoreScrollTopHelper.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbRestoreScrollTopHelper,
  factory: _NbRestoreScrollTopHelper.\u0275fac
});
var NbRestoreScrollTopHelper = _NbRestoreScrollTopHelper;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRestoreScrollTopHelper, [{
    type: Injectable
  }], () => [{
    type: Router
  }], null);
})();
var _NbLayoutComponent = class _NbLayoutComponent {
  /**
   * Defines whether the layout columns will be centered after some width
   * @param {boolean} val
   */
  set center(val) {
    this.centerValue = convertToBoolProperty(val);
  }
  /**
   * Defines whether the layout enters a 'window' mode, when the layout content (including sidebars and fixed header)
   * becomes centered by width with a margin from the top of the screen, like a floating window.
   * Automatically enables `withScroll` mode, as in the window mode scroll must be inside the layout and cannot be on
   * window. (TODO: check this)
   * @param {boolean} val
   */
  set windowMode(val) {
    this.windowModeValue = convertToBoolProperty(val);
    this.withScroll = this.windowModeValue;
  }
  /**
   * Defines whether to move the scrollbars to layout or leave it at the body level.
   * Automatically set to true when `windowMode` is enabled.
   * @param {boolean} val
   */
  set withScroll(val) {
    this.withScrollValue = convertToBoolProperty(val);
    const body = this.document.getElementsByTagName("body")[0];
    if (this.withScrollValue) {
      this.renderer.setStyle(body, "overflow", "hidden");
    } else {
      this.renderer.setStyle(body, "overflow", "initial");
    }
  }
  /**
   * Restores scroll to the top of the page after navigation
   * @param {boolean} val
   */
  set restoreScrollTop(val) {
    this.restoreScrollTopValue = convertToBoolProperty(val);
  }
  constructor(themeService, spinnerService, elementRef, renderer, window2, document2, platformId, layoutDirectionService, scrollService, rulerService, scrollTop, overlayContainer) {
    this.themeService = themeService;
    this.spinnerService = spinnerService;
    this.elementRef = elementRef;
    this.renderer = renderer;
    this.window = window2;
    this.document = document2;
    this.platformId = platformId;
    this.layoutDirectionService = layoutDirectionService;
    this.scrollService = scrollService;
    this.rulerService = rulerService;
    this.scrollTop = scrollTop;
    this.overlayContainer = overlayContainer;
    this.scrollBlockClass = "nb-global-scrollblock";
    this.isScrollBlocked = false;
    this.centerValue = false;
    this.restoreScrollTopValue = true;
    this.windowModeValue = false;
    this.withScrollValue = false;
    this.withSubheader = false;
    this.afterViewInit$ = new BehaviorSubject(null);
    this.destroy$ = new Subject();
    this.registerAsOverlayContainer();
    this.themeService.onThemeChange().pipe(takeUntil(this.destroy$)).subscribe((theme) => {
      const body = this.document.getElementsByTagName("body")[0];
      if (theme.previous) {
        this.renderer.removeClass(body, `nb-theme-${theme.previous}`);
      }
      this.renderer.addClass(body, `nb-theme-${theme.name}`);
    });
    this.themeService.onAppendLayoutClass().pipe(takeUntil(this.destroy$)).subscribe((className) => {
      this.renderer.addClass(this.elementRef.nativeElement, className);
    });
    this.themeService.onRemoveLayoutClass().pipe(takeUntil(this.destroy$)).subscribe((className) => {
      this.renderer.removeClass(this.elementRef.nativeElement, className);
    });
    this.spinnerService.registerLoader(new Promise((resolve) => {
      this.afterViewInit$.pipe(takeUntil(this.destroy$)).subscribe((_) => resolve());
    }));
    this.spinnerService.load();
    this.rulerService.onGetDimensions().pipe(takeUntil(this.destroy$)).subscribe(({
      listener
    }) => {
      listener.next(this.getDimensions());
      listener.complete();
    });
    this.scrollService.onGetPosition().pipe(takeUntil(this.destroy$)).subscribe(({
      listener
    }) => {
      listener.next(this.getScrollPosition());
      listener.complete();
    });
    this.scrollTop.shouldRestore().pipe(filter(() => this.restoreScrollTopValue), takeUntil(this.destroy$)).subscribe(() => {
      this.scroll(0, 0);
    });
    this.scrollService.onScrollableChange().pipe(filter(() => this.withScrollValue), takeUntil(this.destroy$)).subscribe((scrollable) => {
      if (scrollable) {
        this.enableScroll();
      } else {
        this.blockScroll();
      }
    });
    if (isPlatformBrowser(this.platformId)) {
      this.themeService.changeWindowWidth(this.window.innerWidth);
    }
  }
  ngAfterViewInit() {
    this.layoutDirectionService.onDirectionChange().pipe(takeUntil(this.destroy$)).subscribe((direction) => this.document.dir = direction);
    this.scrollService.onManualScroll().pipe(takeUntil(this.destroy$)).subscribe(({
      x,
      y
    }) => this.scroll(x, y));
    this.afterViewInit$.next(true);
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
    this.unregisterAsOverlayContainer();
  }
  onScroll($event) {
    this.scrollService.fireScrollChange($event);
  }
  onResize(event) {
    this.themeService.changeWindowWidth(event.target.innerWidth);
  }
  /**
   * Returns scroll and client height/width
   *
   * Depending on the current scroll mode (`withScroll=true`) returns sizes from the body element
   * or from the `.scrollable-container`
   * @returns {NbLayoutDimensions}
   */
  getDimensions() {
    let clientWidth, clientHeight, scrollWidth, scrollHeight = 0;
    if (this.withScrollValue) {
      const container = this.scrollableContainerRef.nativeElement;
      clientWidth = container.clientWidth;
      clientHeight = container.clientHeight;
      scrollWidth = container.scrollWidth;
      scrollHeight = container.scrollHeight;
    } else {
      const {
        documentElement: documentElement2,
        body
      } = this.document;
      clientWidth = documentElement2.clientWidth || body.clientWidth;
      clientHeight = documentElement2.clientHeight || body.clientHeight;
      scrollWidth = documentElement2.scrollWidth || body.scrollWidth;
      scrollHeight = documentElement2.scrollHeight || body.scrollHeight;
    }
    return {
      clientWidth,
      clientHeight,
      scrollWidth,
      scrollHeight
    };
  }
  /**
   * Returns scroll position of current scroll container.
   *
   * If `withScroll` = true, returns scroll position of the `.scrollable-container` element,
   * otherwise - of the scrollable element of the window (which may be different depending of a browser)
   *
   * @returns {NbScrollPosition}
   */
  getScrollPosition() {
    if (!isPlatformBrowser(this.platformId)) {
      return {
        x: 0,
        y: 0
      };
    }
    if (this.withScrollValue) {
      const container = this.scrollableContainerRef.nativeElement;
      return {
        x: container.scrollLeft,
        y: container.scrollTop
      };
    }
    const documentRect = this.document.documentElement.getBoundingClientRect();
    const x = -documentRect.left || this.document.body.scrollLeft || this.window.scrollX || this.document.documentElement.scrollLeft || 0;
    const y = -documentRect.top || this.document.body.scrollTop || this.window.scrollY || this.document.documentElement.scrollTop || 0;
    return {
      x,
      y
    };
  }
  registerAsOverlayContainer() {
    if (this.overlayContainer.setContainer) {
      this.overlayContainer.setContainer(this.elementRef.nativeElement);
    }
  }
  unregisterAsOverlayContainer() {
    if (this.overlayContainer.clearContainer) {
      this.overlayContainer.clearContainer();
    }
  }
  scroll(x = null, y = null) {
    const {
      x: currentX,
      y: currentY
    } = this.getScrollPosition();
    x = x == null ? currentX : x;
    y = y == null ? currentY : y;
    if (!isPlatformBrowser(this.platformId)) {
      return;
    }
    if (this.withScrollValue) {
      const scrollable = this.scrollableContainerRef.nativeElement;
      if (scrollable.scrollTo) {
        scrollable.scrollTo(x, y);
      } else {
        scrollable.scrollLeft = x;
        scrollable.scrollTop = y;
      }
    } else {
      this.window.scrollTo(x, y);
    }
  }
  // TODO: Extract into block scroll strategy
  blockScroll() {
    if (this.isScrollBlocked) {
      return;
    }
    this.isScrollBlocked = true;
    this.renderer.addClass(this.document.documentElement, this.scrollBlockClass);
    const scrollableContainerElement = this.scrollableContainerRef.nativeElement;
    const layoutElement = this.layoutContainerRef.nativeElement;
    const layoutWithScrollWidth = layoutElement.clientWidth;
    this.scrollableContainerOverflowOldValue = scrollableContainerElement.style.overflow;
    scrollableContainerElement.style.overflow = "hidden";
    const layoutWithoutScrollWidth = layoutElement.clientWidth;
    const scrollWidth = layoutWithoutScrollWidth - layoutWithScrollWidth;
    if (!scrollWidth) {
      return;
    }
    this.layoutPaddingOldValue = {
      left: layoutElement.style.paddingLeft,
      right: layoutElement.style.paddingRight
    };
    if (this.layoutDirectionService.isLtr()) {
      layoutElement.style.paddingRight = `${scrollWidth}px`;
    } else {
      layoutElement.style.paddingLeft = `${scrollWidth}px`;
    }
  }
  enableScroll() {
    if (this.isScrollBlocked) {
      this.isScrollBlocked = false;
      this.renderer.removeClass(this.document.documentElement, this.scrollBlockClass);
      this.scrollableContainerRef.nativeElement.style.overflow = this.scrollableContainerOverflowOldValue;
      if (this.layoutPaddingOldValue) {
        const layoutElement = this.layoutContainerRef.nativeElement;
        layoutElement.style.paddingLeft = this.layoutPaddingOldValue.left;
        layoutElement.style.paddingRight = this.layoutPaddingOldValue.right;
        this.layoutPaddingOldValue = null;
      }
    }
  }
};
_NbLayoutComponent.\u0275fac = function NbLayoutComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbLayoutComponent)(\u0275\u0275directiveInject(NbThemeService), \u0275\u0275directiveInject(NbSpinnerService), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(NB_WINDOW), \u0275\u0275directiveInject(NB_DOCUMENT), \u0275\u0275directiveInject(PLATFORM_ID), \u0275\u0275directiveInject(NbLayoutDirectionService), \u0275\u0275directiveInject(NbLayoutScrollService), \u0275\u0275directiveInject(NbLayoutRulerService), \u0275\u0275directiveInject(NbRestoreScrollTopHelper), \u0275\u0275directiveInject(NbOverlayContainerAdapter));
};
_NbLayoutComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbLayoutComponent,
  selectors: [["nb-layout"]],
  viewQuery: function NbLayoutComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c12, 5, ViewContainerRef);
      \u0275\u0275viewQuery(_c13, 7, ElementRef);
      \u0275\u0275viewQuery(_c14, 5, ElementRef);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.veryTopRef = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.scrollableContainerRef = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.layoutContainerRef = _t.first);
    }
  },
  hostVars: 6,
  hostBindings: function NbLayoutComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("scroll", function NbLayoutComponent_scroll_HostBindingHandler($event) {
        return ctx.onScroll($event);
      }, \u0275\u0275resolveWindow)("resize", function NbLayoutComponent_resize_HostBindingHandler($event) {
        return ctx.onResize($event);
      }, \u0275\u0275resolveWindow);
    }
    if (rf & 2) {
      \u0275\u0275classProp("window-mode", ctx.windowModeValue)("with-scroll", ctx.withScrollValue)("with-subheader", ctx.withSubheader);
    }
  },
  inputs: {
    center: "center",
    windowMode: "windowMode",
    withScroll: "withScroll",
    restoreScrollTop: "restoreScrollTop"
  },
  standalone: false,
  ngContentSelectors: _c16,
  decls: 12,
  vars: 2,
  consts: [["scrollableContainer", ""], ["layoutContainer", ""], [1, "scrollable-container", 3, "scroll"], [1, "layout"], [1, "layout-container"], [1, "content"], [1, "columns"]],
  template: function NbLayoutComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = \u0275\u0275getCurrentView();
      \u0275\u0275projectionDef(_c15);
      \u0275\u0275elementStart(0, "div", 2, 0);
      \u0275\u0275listener("scroll", function NbLayoutComponent_Template_div_scroll_0_listener($event) {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.onScroll($event));
      });
      \u0275\u0275elementStart(2, "div", 3, 1);
      \u0275\u0275projection(4);
      \u0275\u0275elementStart(5, "div", 4);
      \u0275\u0275projection(6, 1);
      \u0275\u0275elementStart(7, "div", 5);
      \u0275\u0275projection(8, 2);
      \u0275\u0275elementStart(9, "div", 6);
      \u0275\u0275projection(10, 3);
      \u0275\u0275elementEnd();
      \u0275\u0275projection(11, 4);
      \u0275\u0275elementEnd()()()();
    }
    if (rf & 2) {
      \u0275\u0275advance(7);
      \u0275\u0275classProp("center", ctx.centerValue);
    }
  },
  styles: ["[_nghost-%COMP%]{-webkit-font-smoothing:antialiased}[dir=ltr]   [_nghost-%COMP%]{text-align:left}[dir=rtl]   [_nghost-%COMP%]{text-align:right}[_nghost-%COMP%]   .layout[_ngcontent-%COMP%]{display:flex;flex-direction:column}[_nghost-%COMP%]     nb-layout-header{display:block}[_nghost-%COMP%]     nb-layout-header nav{align-items:center;justify-content:flex-start;display:flex}[_nghost-%COMP%]     nb-layout-header.fixed{position:fixed;top:0;left:0;right:0;z-index:1040}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]{display:flex;flex:1;-ms-flex:1 1 auto;flex-direction:row}[dir=ltr]   [_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]     nb-sidebar.left{order:0}[dir=rtl]   [_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]     nb-sidebar.left{order:2}[dir=ltr]   [_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]     nb-sidebar.right{order:2}[dir=rtl]   [_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]     nb-sidebar.right{order:0}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]     nb-sidebar.end{order:2}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]     nb-sidebar .fixed{position:fixed;width:100%;overflow-y:auto;height:100%}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]{display:flex;flex:1;-ms-flex:1 1 auto;flex-direction:column;min-width:0}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content.center[_ngcontent-%COMP%]{max-width:100%;position:relative;margin-left:auto;margin-right:auto}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .columns[_ngcontent-%COMP%]{display:flex;flex:1;-ms-flex:1 1 auto;flex-direction:row;width:100%}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .columns[_ngcontent-%COMP%]     nb-layout-column{order:1;flex:1 0;min-width:0}[dir=ltr]   [_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .columns[_ngcontent-%COMP%]     nb-layout-column.left{order:0}[dir=rtl]   [_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .columns[_ngcontent-%COMP%]     nb-layout-column.left{order:2}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .columns[_ngcontent-%COMP%]     nb-layout-column.start{order:0}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]     nb-layout-footer{display:block;margin-top:auto}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]     nb-layout-footer nav{justify-content:center;display:flex}\n\n\n\n\n\n"]
});
var NbLayoutComponent = _NbLayoutComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbLayoutComponent, [{
    type: Component,
    args: [{
      selector: "nb-layout",
      template: `
    <div class="scrollable-container" #scrollableContainer (scroll)="onScroll($event)">
      <div class="layout" #layoutContainer>
        <ng-content select="nb-layout-header:not([subheader])"></ng-content>
        <div class="layout-container">
          <ng-content select="nb-sidebar"></ng-content>
          <div class="content" [class.center]="centerValue">
            <ng-content select="nb-layout-header[subheader]"></ng-content>
            <div class="columns">
              <ng-content select="nb-layout-column"></ng-content>
            </div>
            <ng-content select="nb-layout-footer"></ng-content>
          </div>
        </div>
      </div>
    </div>
  `,
      standalone: false,
      styles: [":host{-webkit-font-smoothing:antialiased}[dir=ltr] :host{text-align:left}[dir=rtl] :host{text-align:right}:host .layout{display:flex;flex-direction:column}:host ::ng-deep nb-layout-header{display:block}:host ::ng-deep nb-layout-header nav{align-items:center;justify-content:flex-start;display:flex}:host ::ng-deep nb-layout-header.fixed{position:fixed;top:0;left:0;right:0;z-index:1040}:host .layout-container{display:flex;flex:1;-ms-flex:1 1 auto;flex-direction:row}[dir=ltr] :host .layout-container ::ng-deep nb-sidebar.left{order:0}[dir=rtl] :host .layout-container ::ng-deep nb-sidebar.left{order:2}[dir=ltr] :host .layout-container ::ng-deep nb-sidebar.right{order:2}[dir=rtl] :host .layout-container ::ng-deep nb-sidebar.right{order:0}:host .layout-container ::ng-deep nb-sidebar.end{order:2}:host .layout-container ::ng-deep nb-sidebar .fixed{position:fixed;width:100%;overflow-y:auto;height:100%}:host .layout-container .content{display:flex;flex:1;-ms-flex:1 1 auto;flex-direction:column;min-width:0}:host .layout-container .content.center{max-width:100%;position:relative;margin-left:auto;margin-right:auto}:host .layout-container .content .columns{display:flex;flex:1;-ms-flex:1 1 auto;flex-direction:row;width:100%}:host .layout-container .content .columns ::ng-deep nb-layout-column{order:1;flex:1 0;min-width:0}[dir=ltr] :host .layout-container .content .columns ::ng-deep nb-layout-column.left{order:0}[dir=rtl] :host .layout-container .content .columns ::ng-deep nb-layout-column.left{order:2}:host .layout-container .content .columns ::ng-deep nb-layout-column.start{order:0}:host .layout-container .content ::ng-deep nb-layout-footer{display:block;margin-top:auto}:host .layout-container .content ::ng-deep nb-layout-footer nav{justify-content:center;display:flex}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: NbThemeService
  }, {
    type: NbSpinnerService
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_WINDOW]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: Object,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }, {
    type: NbLayoutDirectionService
  }, {
    type: NbLayoutScrollService
  }, {
    type: NbLayoutRulerService
  }, {
    type: NbRestoreScrollTopHelper
  }, {
    type: NbOverlayContainerAdapter
  }], {
    windowModeValue: [{
      type: HostBinding,
      args: ["class.window-mode"]
    }],
    withScrollValue: [{
      type: HostBinding,
      args: ["class.with-scroll"]
    }],
    withSubheader: [{
      type: HostBinding,
      args: ["class.with-subheader"]
    }],
    center: [{
      type: Input
    }],
    windowMode: [{
      type: Input
    }],
    withScroll: [{
      type: Input
    }],
    restoreScrollTop: [{
      type: Input
    }],
    veryTopRef: [{
      type: ViewChild,
      args: ["layoutTopDynamicArea", {
        read: ViewContainerRef
      }]
    }],
    scrollableContainerRef: [{
      type: ViewChild,
      args: ["scrollableContainer", {
        read: ElementRef,
        static: true
      }]
    }],
    layoutContainerRef: [{
      type: ViewChild,
      args: ["layoutContainer", {
        read: ElementRef
      }]
    }],
    onScroll: [{
      type: HostListener,
      args: ["window:scroll", ["$event"]]
    }],
    onResize: [{
      type: HostListener,
      args: ["window:resize", ["$event"]]
    }]
  });
})();
var _NbLayoutColumnComponent = class _NbLayoutColumnComponent {
  /**
   * Move the column to the very left position in the layout.
   * @param {boolean} val
   */
  set left(val) {
    this.leftValue = convertToBoolProperty(val);
    this.startValue = false;
  }
  /**
   * Make column first in the layout.
   * @param {boolean} val
   */
  set start(val) {
    this.startValue = convertToBoolProperty(val);
    this.leftValue = false;
  }
};
_NbLayoutColumnComponent.\u0275fac = function NbLayoutColumnComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbLayoutColumnComponent)();
};
_NbLayoutColumnComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbLayoutColumnComponent,
  selectors: [["nb-layout-column"]],
  hostVars: 4,
  hostBindings: function NbLayoutColumnComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("left", ctx.leftValue)("start", ctx.startValue);
    }
  },
  inputs: {
    left: "left",
    start: "start"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function NbLayoutColumnComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275projection(0);
    }
  },
  encapsulation: 2
});
var NbLayoutColumnComponent = _NbLayoutColumnComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbLayoutColumnComponent, [{
    type: Component,
    args: [{
      selector: "nb-layout-column",
      template: `<ng-content></ng-content>`,
      standalone: false
    }]
  }], null, {
    leftValue: [{
      type: HostBinding,
      args: ["class.left"]
    }],
    startValue: [{
      type: HostBinding,
      args: ["class.start"]
    }],
    left: [{
      type: Input
    }],
    start: [{
      type: Input
    }]
  });
})();
var _NbLayoutHeaderComponent = class _NbLayoutHeaderComponent {
  constructor(layout) {
    this.layout = layout;
  }
  /**
   * Makes the header sticky to the top of the nb-layout.
   * @param {boolean} val
   */
  set fixed(val) {
    this.fixedValue = convertToBoolProperty(val);
  }
  /**
   * Places header on a side of the sidebar, and not above.
   * Disables fixed mode for this header and remove a shadow from the sidebar.
   * @param {boolean} val
   */
  set subheader(val) {
    this.subheaderValue = convertToBoolProperty(val);
    this.fixedValue = false;
    this.layout.withSubheader = this.subheaderValue;
  }
};
_NbLayoutHeaderComponent.\u0275fac = function NbLayoutHeaderComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbLayoutHeaderComponent)(\u0275\u0275directiveInject(NbLayoutComponent));
};
_NbLayoutHeaderComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbLayoutHeaderComponent,
  selectors: [["nb-layout-header"]],
  hostVars: 4,
  hostBindings: function NbLayoutHeaderComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("fixed", ctx.fixedValue)("subheader", ctx.subheaderValue);
    }
  },
  inputs: {
    fixed: "fixed",
    subheader: "subheader"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 2,
  vars: 2,
  template: function NbLayoutHeaderComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275elementStart(0, "nav");
      \u0275\u0275projection(1);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275classProp("fixed", ctx.fixedValue);
    }
  },
  encapsulation: 2
});
var NbLayoutHeaderComponent = _NbLayoutHeaderComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbLayoutHeaderComponent, [{
    type: Component,
    args: [{
      selector: "nb-layout-header",
      template: `
    <nav [class.fixed]="fixedValue">
      <ng-content></ng-content>
    </nav>
  `,
      standalone: false
    }]
  }], () => [{
    type: NbLayoutComponent
  }], {
    fixedValue: [{
      type: HostBinding,
      args: ["class.fixed"]
    }],
    subheaderValue: [{
      type: HostBinding,
      args: ["class.subheader"]
    }],
    fixed: [{
      type: Input
    }],
    subheader: [{
      type: Input
    }]
  });
})();
var _NbLayoutFooterComponent = class _NbLayoutFooterComponent {
  /**
   * Makes the footer sticky to the bottom of the window.
   * @param {boolean} val
   */
  set fixed(val) {
    this.fixedValue = convertToBoolProperty(val);
  }
};
_NbLayoutFooterComponent.\u0275fac = function NbLayoutFooterComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbLayoutFooterComponent)();
};
_NbLayoutFooterComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbLayoutFooterComponent,
  selectors: [["nb-layout-footer"]],
  hostVars: 2,
  hostBindings: function NbLayoutFooterComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("fixed", ctx.fixedValue);
    }
  },
  inputs: {
    fixed: "fixed"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 2,
  vars: 2,
  template: function NbLayoutFooterComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275elementStart(0, "nav");
      \u0275\u0275projection(1);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275classProp("fixed", ctx.fixedValue);
    }
  },
  encapsulation: 2
});
var NbLayoutFooterComponent = _NbLayoutFooterComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbLayoutFooterComponent, [{
    type: Component,
    args: [{
      selector: "nb-layout-footer",
      template: `
    <nav [class.fixed]="fixedValue">
      <ng-content></ng-content>
    </nav>
  `,
      standalone: false
    }]
  }], null, {
    fixedValue: [{
      type: HostBinding,
      args: ["class.fixed"]
    }],
    fixed: [{
      type: Input
    }]
  });
})();
var _NbBaseLayoutDirectionDirective = class _NbBaseLayoutDirectionDirective {
  constructor(templateRef, viewContainer, cd, directionService, directionToShow) {
    this.templateRef = templateRef;
    this.viewContainer = viewContainer;
    this.cd = cd;
    this.directionService = directionService;
    this.directionToShow = directionToShow;
    this.destroy$ = new Subject();
  }
  ngOnInit() {
    this.directionService.onDirectionChange().pipe(map((layoutDirection) => layoutDirection === this.directionToShow), distinctUntilChanged(), takeUntil(this.destroy$)).subscribe((shouldShow) => this.updateView(shouldShow));
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  updateView(shouldShow) {
    if (shouldShow && !this.viewContainer.length) {
      this.viewContainer.createEmbeddedView(this.templateRef);
      this.cd.markForCheck();
    } else if (!shouldShow && this.viewContainer.length) {
      this.viewContainer.clear();
    }
  }
};
_NbBaseLayoutDirectionDirective.\u0275fac = function NbBaseLayoutDirectionDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbBaseLayoutDirectionDirective)(\u0275\u0275directiveInject(TemplateRef), \u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NbLayoutDirectionService), \u0275\u0275directiveInject(NbLayoutDirection));
};
_NbBaseLayoutDirectionDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbBaseLayoutDirectionDirective
});
var NbBaseLayoutDirectionDirective = _NbBaseLayoutDirectionDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbBaseLayoutDirectionDirective, [{
    type: Directive
  }], () => [{
    type: TemplateRef
  }, {
    type: ViewContainerRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: NbLayoutDirectionService
  }, {
    type: NbLayoutDirection
  }], null);
})();
var _NbLtrDirective = class _NbLtrDirective extends NbBaseLayoutDirectionDirective {
  constructor(templateRef, viewContainer, cd, directionService) {
    super(templateRef, viewContainer, cd, directionService, NbLayoutDirection.LTR);
    this.templateRef = templateRef;
    this.viewContainer = viewContainer;
    this.cd = cd;
    this.directionService = directionService;
  }
};
_NbLtrDirective.\u0275fac = function NbLtrDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbLtrDirective)(\u0275\u0275directiveInject(TemplateRef), \u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NbLayoutDirectionService));
};
_NbLtrDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbLtrDirective,
  selectors: [["", "nbLtr", ""]],
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature]
});
var NbLtrDirective = _NbLtrDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbLtrDirective, [{
    type: Directive,
    args: [{
      selector: "[nbLtr]",
      standalone: false
    }]
  }], () => [{
    type: TemplateRef
  }, {
    type: ViewContainerRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: NbLayoutDirectionService
  }], null);
})();
var _NbRtlDirective = class _NbRtlDirective extends NbBaseLayoutDirectionDirective {
  constructor(templateRef, viewContainer, cd, directionService) {
    super(templateRef, viewContainer, cd, directionService, NbLayoutDirection.RTL);
    this.templateRef = templateRef;
    this.viewContainer = viewContainer;
    this.cd = cd;
    this.directionService = directionService;
  }
};
_NbRtlDirective.\u0275fac = function NbRtlDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbRtlDirective)(\u0275\u0275directiveInject(TemplateRef), \u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NbLayoutDirectionService));
};
_NbRtlDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbRtlDirective,
  selectors: [["", "nbRtl", ""]],
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature]
});
var NbRtlDirective = _NbRtlDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRtlDirective, [{
    type: Directive,
    args: [{
      selector: "[nbRtl]",
      standalone: false
    }]
  }], () => [{
    type: TemplateRef
  }, {
    type: ViewContainerRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: NbLayoutDirectionService
  }], null);
})();
var NB_LAYOUT_COMPONENTS = [NbLayoutComponent, NbLayoutColumnComponent, NbLayoutFooterComponent, NbLayoutHeaderComponent];
var NB_LAYOUT_DIRECTIVES = [NbLtrDirective, NbRtlDirective];
var _NbLayoutModule = class _NbLayoutModule {
};
_NbLayoutModule.\u0275fac = function NbLayoutModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbLayoutModule)();
};
_NbLayoutModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbLayoutModule,
  declarations: [NbLayoutComponent, NbLayoutColumnComponent, NbLayoutFooterComponent, NbLayoutHeaderComponent, NbLtrDirective, NbRtlDirective],
  imports: [NbSharedModule],
  exports: [NbLayoutComponent, NbLayoutColumnComponent, NbLayoutFooterComponent, NbLayoutHeaderComponent, NbLtrDirective, NbRtlDirective]
});
_NbLayoutModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [NbRestoreScrollTopHelper],
  imports: [NbSharedModule]
});
var NbLayoutModule = _NbLayoutModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbLayoutModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule],
      declarations: [...NB_LAYOUT_COMPONENTS, ...NB_LAYOUT_DIRECTIVES],
      providers: [NbRestoreScrollTopHelper],
      exports: [...NB_LAYOUT_COMPONENTS, ...NB_LAYOUT_DIRECTIVES]
    }]
  }], null, null);
})();
var itemClick$ = new Subject();
var addItems$ = new ReplaySubject(1);
var navigateHome$ = new ReplaySubject(1);
var getSelectedItem$ = new ReplaySubject(1);
var itemSelect$ = new ReplaySubject(1);
var itemHover$ = new ReplaySubject(1);
var submenuToggle$ = new ReplaySubject(1);
var collapseAll$ = new ReplaySubject(1);
var NbMenuItem = class {
  constructor() {
    this.pathMatch = "full";
  }
  /**
   * @returns item parents in top-down order
   */
  static getParents(item) {
    const parents = [];
    let parent = item.parent;
    while (parent) {
      parents.unshift(parent);
      parent = parent.parent;
    }
    return parents;
  }
  static isParent(item, possibleChild) {
    return possibleChild.parent ? possibleChild.parent === item || this.isParent(item, possibleChild.parent) : false;
  }
};
var _NbMenuService = class _NbMenuService {
  /**
   * Add items to the end of the menu items list
   * @param {List<NbMenuItem>} items
   * @param {string} tag
   */
  addItems(items, tag) {
    addItems$.next({
      tag,
      items
    });
  }
  /**
   * Collapses all menu items
   * @param {string} tag
   */
  collapseAll(tag) {
    collapseAll$.next({
      tag
    });
  }
  /**
   * Navigate to the home menu item
   * @param {string} tag
   */
  navigateHome(tag) {
    navigateHome$.next({
      tag
    });
  }
  /**
   * Returns currently selected item. Won't subscribe to the future events.
   * @param {string} tag
   * @returns {Observable<{tag: string; item: NbMenuItem}>}
   */
  getSelectedItem(tag) {
    const listener = new BehaviorSubject(null);
    getSelectedItem$.next({
      tag,
      listener
    });
    return listener.asObservable();
  }
  onItemClick() {
    return itemClick$.pipe(share());
  }
  onItemSelect() {
    return itemSelect$.pipe(share());
  }
  onItemHover() {
    return itemHover$.pipe(share());
  }
  onSubmenuToggle() {
    return submenuToggle$.pipe(share());
  }
};
_NbMenuService.\u0275fac = function NbMenuService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbMenuService)();
};
_NbMenuService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbMenuService,
  factory: _NbMenuService.\u0275fac
});
var NbMenuService = _NbMenuService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbMenuService, [{
    type: Injectable
  }], null, null);
})();
var _NbMenuInternalService = class _NbMenuInternalService {
  constructor(location) {
    this.location = location;
  }
  prepareItems(items) {
    const defaultItem = new NbMenuItem();
    items.forEach((i) => {
      this.applyDefaults(i, defaultItem);
      this.setParent(i);
    });
  }
  selectFromUrl(items, tag, collapseOther = false) {
    const selectedItem = this.findItemByUrl(items);
    if (selectedItem) {
      this.selectItem(selectedItem, items, collapseOther, tag);
    }
  }
  selectItem(item, items, collapseOther = false, tag) {
    const unselectedItems = this.resetSelection(items);
    const collapsedItems = collapseOther ? this.collapseItems(items) : [];
    for (const parent of NbMenuItem.getParents(item)) {
      parent.selected = true;
      if (!unselectedItems.includes(parent)) {
        this.itemSelect(parent, tag);
      }
      const wasNotExpanded = !parent.expanded;
      parent.expanded = true;
      const i = collapsedItems.indexOf(parent);
      if (i === -1 && wasNotExpanded) {
        this.submenuToggle(parent, tag);
      } else {
        collapsedItems.splice(i, 1);
      }
    }
    item.selected = true;
    if (!unselectedItems.includes(item)) {
      this.itemSelect(item, tag);
    }
    for (const collapsedItem of collapsedItems) {
      this.submenuToggle(collapsedItem, tag);
    }
  }
  collapseAll(items, tag, except) {
    const collapsedItems = this.collapseItems(items, except);
    for (const item of collapsedItems) {
      this.submenuToggle(item, tag);
    }
  }
  onAddItem() {
    return addItems$.pipe(share());
  }
  onNavigateHome() {
    return navigateHome$.pipe(share());
  }
  onCollapseAll() {
    return collapseAll$.pipe(share());
  }
  onGetSelectedItem() {
    return getSelectedItem$.pipe(share());
  }
  itemHover(item, tag) {
    itemHover$.next({
      tag,
      item
    });
  }
  submenuToggle(item, tag) {
    submenuToggle$.next({
      tag,
      item
    });
  }
  itemSelect(item, tag) {
    itemSelect$.next({
      tag,
      item
    });
  }
  itemClick(item, tag) {
    itemClick$.next({
      tag,
      item
    });
  }
  /**
   * Unselect all given items deeply.
   * @param items array of items to unselect.
   * @returns items which selected value was changed.
   */
  resetSelection(items) {
    const unselectedItems = [];
    for (const item of items) {
      if (item.selected) {
        unselectedItems.push(item);
      }
      item.selected = false;
      if (item.children) {
        unselectedItems.push(...this.resetSelection(item.children));
      }
    }
    return unselectedItems;
  }
  /**
   * Collapse all given items deeply.
   * @param items array of items to collapse.
   * @param except menu item which shouldn't be collapsed, also disables collapsing for parents of this item.
   * @returns items which expanded value was changed.
   */
  collapseItems(items, except) {
    const collapsedItems = [];
    for (const item of items) {
      if (except && (item === except || NbMenuItem.isParent(item, except))) {
        continue;
      }
      if (item.expanded) {
        collapsedItems.push(item);
      }
      item.expanded = false;
      if (item.children) {
        collapsedItems.push(...this.collapseItems(item.children));
      }
    }
    return collapsedItems;
  }
  applyDefaults(item, defaultItem) {
    const menuItem = __spreadValues({}, item);
    Object.assign(item, defaultItem, menuItem);
    item.children && item.children.forEach((child) => {
      this.applyDefaults(child, defaultItem);
    });
  }
  setParent(item) {
    item.children && item.children.forEach((child) => {
      child.parent = item;
      this.setParent(child);
    });
  }
  /**
   * Find deepest item which link matches current URL path.
   * @param items array of items to search in.
   * @returns found item of undefined.
   */
  findItemByUrl(items) {
    let selectedItem;
    items.some((item) => {
      if (item.children) {
        selectedItem = this.findItemByUrl(item.children);
      }
      if (!selectedItem && this.isSelectedInUrl(item)) {
        selectedItem = item;
      }
      return selectedItem;
    });
    return selectedItem;
  }
  isSelectedInUrl(item) {
    const exact = item.pathMatch === "full";
    const link = item.link;
    const isSelectedInPath = exact ? isUrlPathEqual(this.location.path(), link) : isUrlPathContain(this.location.path(), link);
    if (isSelectedInPath && item.fragment != null) {
      return exact ? isFragmentEqual(this.location.path(true), item.fragment) : isFragmentContain(this.location.path(true), item.fragment);
    }
    return isSelectedInPath;
  }
};
_NbMenuInternalService.\u0275fac = function NbMenuInternalService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbMenuInternalService)(\u0275\u0275inject(Location));
};
_NbMenuInternalService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbMenuInternalService,
  factory: _NbMenuInternalService.\u0275fac
});
var NbMenuInternalService = _NbMenuInternalService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbMenuInternalService, [{
    type: Injectable
  }], () => [{
    type: Location
  }], null);
})();
var _NbBadgeComponent = class _NbBadgeComponent {
  /**
   * Badge position
   *
   * Can be set to any class or to one of predefined positions:
   * 'top left', 'top right', 'bottom left', 'bottom right',
   * 'top start', 'top end', 'bottom start', 'bottom end'
   * @type string
   */
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value || this._defaultPosition;
  }
  /**
   * Shows badge as a dot. No text is shown.
   * @type boolean
   */
  get dotMode() {
    return this._dotMode;
  }
  set dotMode(value) {
    this._dotMode = convertToBoolProperty(value);
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  get primary() {
    return this.status === "primary";
  }
  get success() {
    return this.status === "success";
  }
  get info() {
    return this.status === "info";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get top() {
    return this.position.includes("top");
  }
  get right() {
    return this.position.includes("right");
  }
  get bottom() {
    return this.position.includes("bottom");
  }
  get left() {
    return this.position.includes("left");
  }
  get start() {
    return this.position.includes("start");
  }
  get end() {
    return this.position.includes("end");
  }
  get center() {
    return this.position.includes("center");
  }
  constructor(statusService) {
    this.statusService = statusService;
    this.text = "";
    this._defaultPosition = "top right";
    this._position = this._defaultPosition;
    this.status = "basic";
  }
};
_NbBadgeComponent.\u0275fac = function NbBadgeComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbBadgeComponent)(\u0275\u0275directiveInject(NbStatusService));
};
_NbBadgeComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbBadgeComponent,
  selectors: [["nb-badge"]],
  hostVars: 32,
  hostBindings: function NbBadgeComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classMap(ctx.additionalClasses);
      \u0275\u0275classProp("dot-mode", ctx.dotMode)("status-primary", ctx.primary)("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("position-top", ctx.top)("position-right", ctx.right)("position-bottom", ctx.bottom)("position-left", ctx.left)("position-start", ctx.start)("position-end", ctx.end)("position-center", ctx.center);
    }
  },
  inputs: {
    text: "text",
    position: "position",
    dotMode: "dotMode",
    status: "status"
  },
  standalone: false,
  decls: 1,
  vars: 1,
  template: function NbBadgeComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275text(0);
    }
    if (rf & 2) {
      \u0275\u0275textInterpolate(ctx.dotMode ? "" : ctx.text);
    }
  },
  styles: ["[_nghost-%COMP%]{position:absolute;text-align:center;white-space:nowrap;vertical-align:baseline}.position-top[_nghost-%COMP%]{top:0}.position-right[_nghost-%COMP%]{right:0}.position-bottom[_nghost-%COMP%]{bottom:0}.position-left[_nghost-%COMP%]{left:0}.position-center[_nghost-%COMP%]{top:50%;transform:translateY(-50%)}[dir=ltr]   .position-start[_nghost-%COMP%]{left:0}[dir=rtl]   .position-start[_nghost-%COMP%]{right:0}[dir=ltr]   .position-end[_nghost-%COMP%]{right:0}[dir=rtl]   .position-end[_nghost-%COMP%]{left:0}\n\n\n\n\n\n"]
});
var NbBadgeComponent = _NbBadgeComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbBadgeComponent, [{
    type: Component,
    args: [{
      selector: "nb-badge",
      template: `{{dotMode ? '' : text}}`,
      standalone: false,
      styles: [":host{position:absolute;text-align:center;white-space:nowrap;vertical-align:baseline}:host(.position-top){top:0}:host(.position-right){right:0}:host(.position-bottom){bottom:0}:host(.position-left){left:0}:host(.position-center){top:50%;transform:translateY(-50%)}[dir=ltr] :host(.position-start){left:0}[dir=rtl] :host(.position-start){right:0}[dir=ltr] :host(.position-end){right:0}[dir=rtl] :host(.position-end){left:0}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: NbStatusService
  }], {
    text: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    dotMode: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.dot-mode"]
    }],
    status: [{
      type: Input
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    top: [{
      type: HostBinding,
      args: ["class.position-top"]
    }],
    right: [{
      type: HostBinding,
      args: ["class.position-right"]
    }],
    bottom: [{
      type: HostBinding,
      args: ["class.position-bottom"]
    }],
    left: [{
      type: HostBinding,
      args: ["class.position-left"]
    }],
    start: [{
      type: HostBinding,
      args: ["class.position-start"]
    }],
    end: [{
      type: HostBinding,
      args: ["class.position-end"]
    }],
    center: [{
      type: HostBinding,
      args: ["class.position-center"]
    }]
  });
})();
var NbToggleStates;
(function(NbToggleStates2) {
  NbToggleStates2["Expanded"] = "expanded";
  NbToggleStates2["Collapsed"] = "collapsed";
})(NbToggleStates || (NbToggleStates = {}));
var _NbMenuItemComponent = class _NbMenuItemComponent {
  constructor(menuService, directionService) {
    this.menuService = menuService;
    this.directionService = directionService;
    this.menuItem = null;
    this.hoverItem = new EventEmitter();
    this.toggleSubMenu = new EventEmitter();
    this.selectItem = new EventEmitter();
    this.itemClick = new EventEmitter();
    this.destroy$ = new Subject();
  }
  ngDoCheck() {
    this.toggleState = this.menuItem.expanded ? NbToggleStates.Expanded : NbToggleStates.Collapsed;
  }
  ngAfterViewInit() {
    this.menuService.onSubmenuToggle().pipe(filter(({
      item
    }) => item === this.menuItem), map(({
      item
    }) => item.expanded), takeUntil(this.destroy$)).subscribe((isExpanded) => this.toggleState = isExpanded ? NbToggleStates.Expanded : NbToggleStates.Collapsed);
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  onToggleSubMenu(item) {
    this.toggleSubMenu.emit(item);
  }
  onHoverItem(item) {
    this.hoverItem.emit(item);
  }
  onSelectItem(item) {
    this.selectItem.emit(item);
  }
  onItemClick(item) {
    this.itemClick.emit(item);
  }
  getExpandStateIcon() {
    if (this.menuItem.expanded) {
      return "chevron-down-outline";
    }
    return this.directionService.isLtr() ? "chevron-left-outline" : "chevron-right-outline";
  }
};
_NbMenuItemComponent.\u0275fac = function NbMenuItemComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbMenuItemComponent)(\u0275\u0275directiveInject(NbMenuService), \u0275\u0275directiveInject(NbLayoutDirectionService));
};
_NbMenuItemComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbMenuItemComponent,
  selectors: [["", "nbMenuItem", ""]],
  inputs: {
    menuItem: "menuItem",
    badge: "badge"
  },
  outputs: {
    hoverItem: "hoverItem",
    toggleSubMenu: "toggleSubMenu",
    selectItem: "selectItem",
    itemClick: "itemClick"
  },
  standalone: false,
  attrs: _c17,
  decls: 8,
  vars: 6,
  consts: [["badgeTemplate", ""], [4, "ngIf"], [3, "routerLink", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "active", "mouseenter", "click", 4, "ngIf"], [3, "active", "mouseenter", "click", 4, "ngIf"], ["href", "#", 3, "active", "click", "mouseenter", 4, "ngIf"], ["class", "menu-items", 3, "collapsed", "expanded", 4, "ngIf"], ["class", "menu-icon", 3, "config", 4, "ngIf"], [1, "menu-icon", 3, "config"], [3, "mouseenter", "click", "routerLink", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange"], [1, "menu-title"], [3, "ngTemplateOutlet", 4, "ngIf"], [3, "ngTemplateOutlet"], [3, "mouseenter", "click"], ["href", "#", 3, "click", "mouseenter"], ["pack", "nebular-essentials", 1, "expand-state", 3, "icon"], [1, "menu-items"], [4, "ngFor", "ngForOf"], ["nbMenuItem", "", "class", "menu-item", 3, "menuItem", "badge", "menu-group", "hoverItem", "toggleSubMenu", "selectItem", "itemClick", 4, "ngIf"], ["nbMenuItem", "", 1, "menu-item", 3, "hoverItem", "toggleSubMenu", "selectItem", "itemClick", "menuItem", "badge"], [3, "text", "dotMode", "status"]],
  template: function NbMenuItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NbMenuItemComponent_span_0_Template, 3, 2, "span", 1)(1, NbMenuItemComponent_a_1_Template, 5, 14, "a", 2)(2, NbMenuItemComponent_a_2_Template, 5, 9, "a", 3)(3, NbMenuItemComponent_a_3_Template, 5, 8, "a", 3)(4, NbMenuItemComponent_a_4_Template, 6, 10, "a", 4)(5, NbMenuItemComponent_ul_5_Template, 2, 6, "ul", 5)(6, NbMenuItemComponent_ng_template_6_Template, 1, 3, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.menuItem.group);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.menuItem.link && !ctx.menuItem.url && !ctx.menuItem.children && !ctx.menuItem.group);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.menuItem.url && !ctx.menuItem.children && !ctx.menuItem.link && !ctx.menuItem.group);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", !ctx.menuItem.children && !ctx.menuItem.link && !ctx.menuItem.url && !ctx.menuItem.group);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.menuItem.children);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.menuItem.children);
    }
  },
  dependencies: [NgForOf, NgIf, NgTemplateOutlet, RouterLink, NbIconComponent, NbBadgeComponent, _NbMenuItemComponent],
  encapsulation: 2,
  data: {
    animation: [trigger("toggle", [state(NbToggleStates.Collapsed, style({
      height: "0",
      margin: "0"
    })), state(NbToggleStates.Expanded, style({
      height: "*"
    })), transition(`${NbToggleStates.Collapsed} <=> ${NbToggleStates.Expanded}`, animate(300))])]
  }
});
var NbMenuItemComponent = _NbMenuItemComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbMenuItemComponent, [{
    type: Component,
    args: [{
      selector: "[nbMenuItem]",
      animations: [trigger("toggle", [state(NbToggleStates.Collapsed, style({
        height: "0",
        margin: "0"
      })), state(NbToggleStates.Expanded, style({
        height: "*"
      })), transition(`${NbToggleStates.Collapsed} <=> ${NbToggleStates.Expanded}`, animate(300))])],
      standalone: false,
      template: '<span *ngIf="menuItem.group">\n  <nb-icon class="menu-icon" [config]="menuItem.icon" *ngIf="menuItem.icon"></nb-icon>\n  {{ menuItem.title }}\n</span>\n<a\n  *ngIf="menuItem.link && !menuItem.url && !menuItem.children && !menuItem.group"\n  [routerLink]="menuItem.link"\n  [queryParams]="menuItem.queryParams"\n  [fragment]="menuItem.fragment"\n  [queryParamsHandling]="menuItem.queryParamsHandling"\n  [preserveFragment]="menuItem.preserveFragment"\n  [skipLocationChange]="menuItem.skipLocationChange"\n  [attr.target]="menuItem.target"\n  [attr.title]="menuItem.title"\n  [attr.role]="menuItem.ariaRole"\n  [class.active]="menuItem.selected"\n  (mouseenter)="onHoverItem(menuItem)"\n  (click)="onItemClick(menuItem)"\n>\n  <nb-icon class="menu-icon" [config]="menuItem.icon" *ngIf="menuItem.icon"></nb-icon>\n  <span class="menu-title">{{ menuItem.title }}</span>\n  <ng-container *ngIf="badge" [ngTemplateOutlet]="badgeTemplate"></ng-container>\n</a>\n<a\n  *ngIf="menuItem.url && !menuItem.children && !menuItem.link && !menuItem.group"\n  [attr.href]="menuItem.url"\n  [attr.target]="menuItem.target"\n  [attr.title]="menuItem.title"\n  [attr.role]="menuItem.ariaRole"\n  [class.active]="menuItem.selected"\n  (mouseenter)="onHoverItem(menuItem)"\n  (click)="onSelectItem(menuItem)"\n>\n  <nb-icon class="menu-icon" [config]="menuItem.icon" *ngIf="menuItem.icon"></nb-icon>\n  <span class="menu-title">{{ menuItem.title }}</span>\n  <ng-container *ngIf="badge" [ngTemplateOutlet]="badgeTemplate"></ng-container>\n</a>\n<a\n  *ngIf="!menuItem.children && !menuItem.link && !menuItem.url && !menuItem.group"\n  [attr.target]="menuItem.target"\n  [attr.title]="menuItem.title"\n  [attr.role]="menuItem.ariaRole"\n  [class.active]="menuItem.selected"\n  (mouseenter)="onHoverItem(menuItem)"\n  (click)="$event.preventDefault(); onItemClick(menuItem)"\n>\n  <nb-icon class="menu-icon" [config]="menuItem.icon" *ngIf="menuItem.icon"></nb-icon>\n  <span class="menu-title">{{ menuItem.title }}</span>\n  <ng-container *ngIf="badge" [ngTemplateOutlet]="badgeTemplate"></ng-container>\n</a>\n<a\n  *ngIf="menuItem.children"\n  (click)="$event.preventDefault(); onToggleSubMenu(menuItem)"\n  [attr.target]="menuItem.target"\n  [attr.title]="menuItem.title"\n  [attr.aria-expanded]="menuItem.expanded ?? false"\n  [attr.role]="menuItem.ariaRole"\n  [class.active]="menuItem.selected"\n  (mouseenter)="onHoverItem(menuItem)"\n  href="#"\n>\n  <nb-icon class="menu-icon" [config]="menuItem.icon" *ngIf="menuItem.icon"></nb-icon>\n  <span class="menu-title">{{ menuItem.title }}</span>\n  <ng-container *ngIf="badge" [ngTemplateOutlet]="badgeTemplate"></ng-container>\n  <nb-icon class="expand-state" [icon]="getExpandStateIcon()" pack="nebular-essentials"></nb-icon>\n</a>\n<ul\n  *ngIf="menuItem.children"\n  [class.collapsed]="!(menuItem.children && menuItem.expanded)"\n  [class.expanded]="menuItem.expanded"\n  [@toggle]="toggleState"\n  class="menu-items"\n>\n  <ng-container *ngFor="let item of menuItem.children">\n    <li\n      nbMenuItem\n      *ngIf="!item.hidden"\n      [menuItem]="item"\n      [badge]="item.badge"\n      [class.menu-group]="item.group"\n      (hoverItem)="onHoverItem($event)"\n      (toggleSubMenu)="onToggleSubMenu($event)"\n      (selectItem)="onSelectItem($event)"\n      (itemClick)="onItemClick($event)"\n      class="menu-item"\n    ></li>\n  </ng-container>\n</ul>\n\n<ng-template #badgeTemplate>\n  <nb-badge [text]="badge.text" [dotMode]="badge.dotMode" [status]="badge.status"> </nb-badge>\n</ng-template>\n'
    }]
  }], () => [{
    type: NbMenuService
  }, {
    type: NbLayoutDirectionService
  }], {
    menuItem: [{
      type: Input
    }],
    badge: [{
      type: Input
    }],
    hoverItem: [{
      type: Output
    }],
    toggleSubMenu: [{
      type: Output
    }],
    selectItem: [{
      type: Output
    }],
    itemClick: [{
      type: Output
    }]
  });
})();
var _NbMenuComponent = class _NbMenuComponent {
  /**
   * Collapse all opened submenus on the toggle event
   * Default value is "false"
   * @type boolean
   */
  get autoCollapse() {
    return this._autoCollapse;
  }
  set autoCollapse(value) {
    this._autoCollapse = convertToBoolProperty(value);
  }
  constructor(window2, platformId, menuInternalService, router) {
    this.window = window2;
    this.platformId = platformId;
    this.menuInternalService = menuInternalService;
    this.router = router;
    this._autoCollapse = false;
    this.destroy$ = new Subject();
  }
  ngOnInit() {
    this.menuInternalService.prepareItems(this.items);
    this.menuInternalService.onAddItem().pipe(filter((data) => this.compareTag(data.tag)), takeUntil(this.destroy$)).subscribe((data) => this.onAddItem(data));
    this.menuInternalService.onNavigateHome().pipe(filter((data) => this.compareTag(data.tag)), takeUntil(this.destroy$)).subscribe(() => this.navigateHome());
    this.menuInternalService.onGetSelectedItem().pipe(filter((data) => this.compareTag(data.tag)), takeUntil(this.destroy$)).subscribe((data) => {
      data.listener.next({
        tag: this.tag,
        item: this.getSelectedItem(this.items)
      });
    });
    this.menuInternalService.onCollapseAll().pipe(filter((data) => this.compareTag(data.tag)), takeUntil(this.destroy$)).subscribe(() => this.collapseAll());
    this.router.events.pipe(filter((event) => event instanceof NavigationEnd), takeUntil(this.destroy$)).subscribe(() => {
      this.menuInternalService.selectFromUrl(this.items, this.tag, this.autoCollapse);
    });
  }
  ngAfterViewInit() {
    setTimeout(() => this.menuInternalService.selectFromUrl(this.items, this.tag, this.autoCollapse));
  }
  onAddItem(data) {
    this.items.push(...data.items);
    this.menuInternalService.prepareItems(this.items);
    this.menuInternalService.selectFromUrl(this.items, this.tag, this.autoCollapse);
  }
  onHoverItem(item) {
    this.menuInternalService.itemHover(item, this.tag);
  }
  onToggleSubMenu(item) {
    if (this.autoCollapse) {
      this.menuInternalService.collapseAll(this.items, this.tag, item);
    }
    item.expanded = !item.expanded;
    this.menuInternalService.submenuToggle(item, this.tag);
  }
  // TODO: is not fired on page reload
  onSelectItem(item) {
    this.menuInternalService.selectItem(item, this.items, this.autoCollapse, this.tag);
  }
  onItemClick(item) {
    this.menuInternalService.itemClick(item, this.tag);
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  navigateHome() {
    const homeItem = this.getHomeItem(this.items);
    if (homeItem) {
      if (homeItem.link) {
        const extras = {
          queryParams: homeItem.queryParams,
          queryParamsHandling: homeItem.queryParamsHandling,
          fragment: homeItem.fragment,
          preserveFragment: homeItem.preserveFragment
        };
        this.router.navigate([homeItem.link], extras);
      }
      if (homeItem.url && isPlatformBrowser(this.platformId)) {
        this.window.location.href = homeItem.url;
      }
    }
  }
  collapseAll() {
    this.menuInternalService.collapseAll(this.items, this.tag);
  }
  getHomeItem(items) {
    for (const item of items) {
      if (item.home) {
        return item;
      }
      const homeItem = item.children && this.getHomeItem(item.children);
      if (homeItem) {
        return homeItem;
      }
    }
    return void 0;
  }
  compareTag(tag) {
    return !tag || tag === this.tag;
  }
  getSelectedItem(items) {
    let selected = null;
    items.forEach((item) => {
      if (item.selected) {
        selected = item;
      }
      if (item.selected && item.children && item.children.length > 0) {
        selected = this.getSelectedItem(item.children);
      }
    });
    return selected;
  }
};
_NbMenuComponent.\u0275fac = function NbMenuComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbMenuComponent)(\u0275\u0275directiveInject(NB_WINDOW), \u0275\u0275directiveInject(PLATFORM_ID), \u0275\u0275directiveInject(NbMenuInternalService), \u0275\u0275directiveInject(Router));
};
_NbMenuComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbMenuComponent,
  selectors: [["nb-menu"]],
  inputs: {
    tag: "tag",
    items: "items",
    autoCollapse: "autoCollapse"
  },
  standalone: false,
  decls: 2,
  vars: 1,
  consts: [[1, "menu-items"], [4, "ngFor", "ngForOf"], ["nbMenuItem", "", "class", "menu-item", 3, "menuItem", "badge", "menu-group", "hoverItem", "toggleSubMenu", "selectItem", "itemClick", 4, "ngIf"], ["nbMenuItem", "", 1, "menu-item", 3, "hoverItem", "toggleSubMenu", "selectItem", "itemClick", "menuItem", "badge"]],
  template: function NbMenuComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "ul", 0);
      \u0275\u0275template(1, NbMenuComponent_ng_container_1_Template, 2, 1, "ng-container", 1);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance();
      \u0275\u0275property("ngForOf", ctx.items);
    }
  },
  dependencies: [NgForOf, NgIf, NbMenuItemComponent],
  styles: ["[_nghost-%COMP%]    {display:block}[_nghost-%COMP%]     .menu-items, [_nghost-%COMP%]     .menu-item>.menu-items{list-style-type:none;overflow:hidden}[_nghost-%COMP%]     .menu-item a{display:flex;text-decoration:none;align-items:center}[_nghost-%COMP%]     .menu-item a .menu-title{flex:1 0 auto;pointer-events:none}[dir=rtl]   [_nghost-%COMP%]     .menu-item a .menu-title{text-align:right}[_nghost-%COMP%]     .menu-item nb-badge{position:static}[_nghost-%COMP%]     .menu-group span{display:flex}\n\n\n\n\n\n"]
});
var NbMenuComponent = _NbMenuComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbMenuComponent, [{
    type: Component,
    args: [{
      selector: "nb-menu",
      template: `
    <ul class="menu-items">
      <ng-container *ngFor="let item of items">
        <li nbMenuItem *ngIf="!item.hidden"
            [menuItem]="item"
            [badge]="item.badge"
            [class.menu-group]="item.group"
            (hoverItem)="onHoverItem($event)"
            (toggleSubMenu)="onToggleSubMenu($event)"
            (selectItem)="onSelectItem($event)"
            (itemClick)="onItemClick($event)"
            class="menu-item">
        </li>
      </ng-container>
    </ul>
  `,
      standalone: false,
      styles: [":host ::ng-deep{display:block}:host ::ng-deep .menu-items,:host ::ng-deep .menu-item>.menu-items{list-style-type:none;overflow:hidden}:host ::ng-deep .menu-item a{display:flex;text-decoration:none;align-items:center}:host ::ng-deep .menu-item a .menu-title{flex:1 0 auto;pointer-events:none}[dir=rtl] :host ::ng-deep .menu-item a .menu-title{text-align:right}:host ::ng-deep .menu-item nb-badge{position:static}:host ::ng-deep .menu-group span{display:flex}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_WINDOW]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }, {
    type: NbMenuInternalService
  }, {
    type: Router
  }], {
    tag: [{
      type: Input
    }],
    items: [{
      type: Input
    }],
    autoCollapse: [{
      type: Input
    }]
  });
})();
var _NbBadgeModule = class _NbBadgeModule {
};
_NbBadgeModule.\u0275fac = function NbBadgeModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbBadgeModule)();
};
_NbBadgeModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbBadgeModule,
  declarations: [NbBadgeComponent],
  exports: [NbBadgeComponent]
});
_NbBadgeModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var NbBadgeModule = _NbBadgeModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbBadgeModule, [{
    type: NgModule,
    args: [{
      exports: [NbBadgeComponent],
      declarations: [NbBadgeComponent]
    }]
  }], null, null);
})();
var nbMenuComponents = [NbMenuComponent, NbMenuItemComponent];
var NB_MENU_PROVIDERS = [NbMenuService, NbMenuInternalService];
var _NbMenuModule = class _NbMenuModule {
  static forRoot() {
    return {
      ngModule: _NbMenuModule,
      providers: [...NB_MENU_PROVIDERS]
    };
  }
};
_NbMenuModule.\u0275fac = function NbMenuModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbMenuModule)();
};
_NbMenuModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbMenuModule,
  declarations: [NbMenuComponent, NbMenuItemComponent],
  imports: [NbSharedModule, NbIconModule, NbBadgeModule],
  exports: [NbMenuComponent, NbMenuItemComponent]
});
_NbMenuModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NbSharedModule, NbIconModule, NbBadgeModule]
});
var NbMenuModule = _NbMenuModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbMenuModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbIconModule, NbBadgeModule],
      declarations: [...nbMenuComponents],
      exports: [...nbMenuComponents]
    }]
  }], null, null);
})();
var _NbMergeConfigsPipe = class _NbMergeConfigsPipe {
  transform(...configs) {
    return Object.assign({}, ...configs);
  }
};
_NbMergeConfigsPipe.\u0275fac = function NbMergeConfigsPipe_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbMergeConfigsPipe)();
};
_NbMergeConfigsPipe.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
  name: "nbMergeConfigs",
  type: _NbMergeConfigsPipe,
  pure: true,
  standalone: false
});
var NbMergeConfigsPipe = _NbMergeConfigsPipe;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbMergeConfigsPipe, [{
    type: Pipe,
    args: [{
      name: "nbMergeConfigs",
      standalone: false
    }]
  }], null, null);
})();
var _NbRouteTabsetComponent = class _NbRouteTabsetComponent {
  constructor() {
    this.fullWidthValue = false;
    this.activeLinkOptions = {
      exact: true
    };
    this.changeTab = new EventEmitter();
  }
  /**
   * Take full width of a parent
   * @param {boolean} val
   */
  set fullWidth(val) {
    this.fullWidthValue = convertToBoolProperty(val);
  }
  selectTab(tab) {
    this.changeTab.emit(tab);
  }
};
_NbRouteTabsetComponent.\u0275fac = function NbRouteTabsetComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbRouteTabsetComponent)();
};
_NbRouteTabsetComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbRouteTabsetComponent,
  selectors: [["nb-route-tabset"]],
  hostVars: 2,
  hostBindings: function NbRouteTabsetComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("full-width", ctx.fullWidthValue);
    }
  },
  inputs: {
    tabs: "tabs",
    activeLinkOptions: "activeLinkOptions",
    fullWidth: "fullWidth"
  },
  outputs: {
    changeTab: "changeTab"
  },
  standalone: false,
  decls: 3,
  vars: 1,
  consts: [["enabled", ""], [1, "route-tabset"], [4, "ngFor", "ngForOf"], ["class", "route-tab disabled", "tabindex", "-1", 3, "responsive", 4, "ngIf", "ngIfElse"], ["tabindex", "-1", 1, "route-tab", "disabled"], ["tabindex", "-1", 1, "tab-link"], [3, "config", 4, "ngIf"], ["class", "tab-text", 4, "ngIf"], [3, "config"], [1, "tab-text"], ["routerLinkActive", "active", 1, "route-tab", 3, "routerLinkActiveOptions"], [1, "tab-link", 3, "click", "routerLink", "queryParams", "queryParamsHandling", "fragment", "preserveFragment", "skipLocationChange", "replaceUrl", "state"]],
  template: function NbRouteTabsetComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "ul", 1);
      \u0275\u0275template(1, NbRouteTabsetComponent_ng_container_1_Template, 4, 2, "ng-container", 2);
      \u0275\u0275elementEnd();
      \u0275\u0275element(2, "router-outlet");
    }
    if (rf & 2) {
      \u0275\u0275advance();
      \u0275\u0275property("ngForOf", ctx.tabs);
    }
  },
  dependencies: [NgForOf, NgIf, RouterOutlet, RouterLink, RouterLinkActive, NbIconComponent, NbMergeConfigsPipe],
  styles: ['.route-tabset[_ngcontent-%COMP%]{display:flex;flex-direction:row;list-style-type:none;margin:0;padding:0}.route-tabset[_ngcontent-%COMP%]   .route-tab[_ngcontent-%COMP%]{margin-bottom:-1px;text-align:center;padding:0}.route-tabset[_ngcontent-%COMP%]   .route-tab.active[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]:before{display:block}.route-tabset[_ngcontent-%COMP%]   .route-tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{position:relative;text-decoration:none;display:inline-block}.route-tabset[_ngcontent-%COMP%]   .route-tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]:before{position:absolute;content:"";width:100%;border-radius:3px;bottom:-2px;left:0}.route-tabset[_ngcontent-%COMP%]   .route-tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{vertical-align:middle}[dir=ltr]   [_nghost-%COMP%]   .tab-link[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%] + span[_ngcontent-%COMP%]{margin-left:.5rem}[dir=rtl]   [_nghost-%COMP%]   .tab-link[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%] + span[_ngcontent-%COMP%]{margin-right:.5rem}.full-width[_nghost-%COMP%]   .route-tabset[_ngcontent-%COMP%]{justify-content:space-around}\n\n\n\n\n\n']
});
var NbRouteTabsetComponent = _NbRouteTabsetComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRouteTabsetComponent, [{
    type: Component,
    args: [{
      selector: "nb-route-tabset",
      template: `
    <ul class="route-tabset">
      <ng-container *ngFor="let tab of tabs">
        <li
          *ngIf="tab.disabled; else enabled"
          [class.responsive]="tab.responsive"
          class="route-tab disabled"
          tabindex="-1"
        >
          <a tabindex="-1" class="tab-link">
            <nb-icon *ngIf="tab.icon" [config]="tab.icon"></nb-icon>
            <span *ngIf="tab.title" class="tab-text">{{ tab.title }}</span>
          </a>
        </li>

        <ng-template #enabled>
          <li
            routerLinkActive="active"
            [routerLinkActiveOptions]="activeLinkOptions | nbMergeConfigs: tab.activeLinkOptions"
            class="route-tab"
          >
            <a
              (click)="selectTab(tab)"
              [routerLink]="tab.route"
              [class.responsive]="tab.responsive"
              [queryParams]="tab.queryParams"
              [queryParamsHandling]="tab.queryParamsHandling"
              [fragment]="tab.fragment"
              [preserveFragment]="tab.preserveFragment"
              [skipLocationChange]="tab.skipLocationChange"
              [replaceUrl]="tab.replaceUrl"
              [state]="tab.state"
              class="tab-link"
            >
              <nb-icon *ngIf="tab.icon" [config]="tab.icon"></nb-icon>
              <span *ngIf="tab.title" class="tab-text">{{ tab.title }}</span>
            </a>
          </li>
        </ng-template>
      </ng-container>
    </ul>
    <router-outlet></router-outlet>
  `,
      standalone: false,
      styles: ['.route-tabset{display:flex;flex-direction:row;list-style-type:none;margin:0;padding:0}.route-tabset .route-tab{margin-bottom:-1px;text-align:center;padding:0}.route-tabset .route-tab.active a:before{display:block}.route-tabset .route-tab a{position:relative;text-decoration:none;display:inline-block}.route-tabset .route-tab a:before{position:absolute;content:"";width:100%;border-radius:3px;bottom:-2px;left:0}.route-tabset .route-tab a nb-icon{vertical-align:middle}[dir=ltr] :host .tab-link nb-icon+span{margin-left:.5rem}[dir=rtl] :host .tab-link nb-icon+span{margin-right:.5rem}:host(.full-width) .route-tabset{justify-content:space-around}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n']
    }]
  }], null, {
    fullWidthValue: [{
      type: HostBinding,
      args: ["class.full-width"]
    }],
    tabs: [{
      type: Input
    }],
    activeLinkOptions: [{
      type: Input
    }],
    fullWidth: [{
      type: Input
    }],
    changeTab: [{
      type: Output
    }]
  });
})();
var _NbRouteTabsetModule = class _NbRouteTabsetModule {
};
_NbRouteTabsetModule.\u0275fac = function NbRouteTabsetModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbRouteTabsetModule)();
};
_NbRouteTabsetModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbRouteTabsetModule,
  declarations: [NbRouteTabsetComponent, NbMergeConfigsPipe],
  imports: [NbSharedModule, NbIconModule],
  exports: [NbRouteTabsetComponent]
});
_NbRouteTabsetModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NbSharedModule, NbIconModule]
});
var NbRouteTabsetModule = _NbRouteTabsetModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRouteTabsetModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbIconModule],
      declarations: [NbRouteTabsetComponent, NbMergeConfigsPipe],
      exports: [NbRouteTabsetComponent]
    }]
  }], null, null);
})();
var getSidebarState$ = new Subject();
var getSidebarResponsiveState$ = new Subject();
var _NbSidebarService = class _NbSidebarService {
  constructor() {
    this.toggle$ = new Subject();
    this.expand$ = new Subject();
    this.collapse$ = new Subject();
    this.compact$ = new Subject();
  }
  /**
   * Subscribe to toggle events
   *
   * @returns Observable<{ compact: boolean, tag: string }>
   */
  onToggle() {
    return this.toggle$.pipe(share());
  }
  /**
   * Subscribe to expand events
   * @returns Observable<{ tag: string }>
   */
  onExpand() {
    return this.expand$.pipe(share());
  }
  /**
   * Subscribe to collapse evens
   * @returns Observable<{ tag: string }>
   */
  onCollapse() {
    return this.collapse$.pipe(share());
  }
  /**
   * Subscribe to compact evens
   * @returns Observable<{ tag: string }>
   */
  onCompact() {
    return this.compact$.pipe(share());
  }
  /**
   * Toggle a sidebar
   * @param {boolean} compact
   * @param {string} tag If you have multiple sidebars on the page, mark them with `tag` input property and pass it here
   * to specify which sidebar you want to control
   */
  toggle(compact = false, tag) {
    this.toggle$.next({
      compact,
      tag
    });
  }
  /**
   * Expands a sidebar
   * @param {string} tag If you have multiple sidebars on the page, mark them with `tag` input property and pass it here
   * to specify which sidebar you want to control
   */
  expand(tag) {
    this.expand$.next({
      tag
    });
  }
  /**
   * Collapses a sidebar
   * @param {string} tag If you have multiple sidebars on the page, mark them with `tag` input property and pass it here
   * to specify which sidebar you want to control
   */
  collapse(tag) {
    this.collapse$.next({
      tag
    });
  }
  /**
   * Makes sidebar compact
   * @param {string} tag If you have multiple sidebars on the page, mark them with `tag` input property and pass it here
   * to specify which sidebar you want to control
   */
  compact(tag) {
    this.compact$.next({
      tag
    });
  }
  /**
   * Returns sidebar state observable which emits once
   * @param {string} tag If you have multiple sidebars on the page, mark them with `tag` input property and pass it here
   * to specify which sidebar state you need
   */
  getSidebarState(tag) {
    const observer = new ReplaySubject(1);
    getSidebarState$.next({
      observer,
      tag
    });
    return observer.pipe(publish(), refCount());
  }
  /**
   * Returns sidebar state observable which emits once
   * @param {string} tag If you have multiple sidebars on the page, mark them with `tag` input property and pass it here
   * to specify which sidebar responsive state you need
   */
  getSidebarResponsiveState(tag) {
    const observer = new ReplaySubject();
    getSidebarResponsiveState$.next({
      observer,
      tag
    });
    return observer.pipe(publish(), refCount());
  }
};
_NbSidebarService.\u0275fac = function NbSidebarService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbSidebarService)();
};
_NbSidebarService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbSidebarService,
  factory: _NbSidebarService.\u0275fac
});
var NbSidebarService = _NbSidebarService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSidebarService, [{
    type: Injectable
  }], null, null);
})();
var _NbSidebarHeaderComponent = class _NbSidebarHeaderComponent {
};
_NbSidebarHeaderComponent.\u0275fac = function NbSidebarHeaderComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbSidebarHeaderComponent)();
};
_NbSidebarHeaderComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbSidebarHeaderComponent,
  selectors: [["nb-sidebar-header"]],
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function NbSidebarHeaderComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275projection(0);
    }
  },
  encapsulation: 2
});
var NbSidebarHeaderComponent = _NbSidebarHeaderComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSidebarHeaderComponent, [{
    type: Component,
    args: [{
      selector: "nb-sidebar-header",
      template: ` <ng-content></ng-content> `,
      standalone: false
    }]
  }], null, null);
})();
var _NbSidebarFooterComponent = class _NbSidebarFooterComponent {
};
_NbSidebarFooterComponent.\u0275fac = function NbSidebarFooterComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbSidebarFooterComponent)();
};
_NbSidebarFooterComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbSidebarFooterComponent,
  selectors: [["nb-sidebar-footer"]],
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function NbSidebarFooterComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275projection(0);
    }
  },
  encapsulation: 2
});
var NbSidebarFooterComponent = _NbSidebarFooterComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSidebarFooterComponent, [{
    type: Component,
    args: [{
      selector: "nb-sidebar-footer",
      template: ` <ng-content></ng-content> `,
      standalone: false
    }]
  }], null, null);
})();
var _NbSidebarComponent = class _NbSidebarComponent {
  get expanded() {
    return this.state === "expanded";
  }
  get collapsed() {
    return this.state === "collapsed";
  }
  get compacted() {
    return this.state === "compacted";
  }
  /**
   * Places sidebar on the right side
   * @type {boolean}
   */
  set right(val) {
    this.rightValue = convertToBoolProperty(val);
    this.leftValue = !this.rightValue;
    this.startValue = false;
    this.endValue = false;
  }
  /**
   * Places sidebar on the left side
   * @type {boolean}
   */
  set left(val) {
    this.leftValue = convertToBoolProperty(val);
    this.rightValue = !this.leftValue;
    this.startValue = false;
    this.endValue = false;
  }
  /**
   * Places sidebar on the start edge of layout
   * @type {boolean}
   */
  set start(val) {
    this.startValue = convertToBoolProperty(val);
    this.endValue = !this.startValue;
    this.leftValue = false;
    this.rightValue = false;
  }
  /**
   * Places sidebar on the end edge of layout
   * @type {boolean}
   */
  set end(val) {
    this.endValue = convertToBoolProperty(val);
    this.startValue = !this.endValue;
    this.leftValue = false;
    this.rightValue = false;
  }
  /**
   * Makes sidebar fixed (shown above the layout content)
   * @type {boolean}
   */
  set fixed(val) {
    this.fixedValue = convertToBoolProperty(val);
  }
  /**
   * Makes sidebar container fixed
   * @type {boolean}
   */
  set containerFixed(val) {
    this.containerFixedValue = convertToBoolProperty(val);
  }
  /**
   * Initial sidebar state, `expanded`|`collapsed`|`compacted`
   * @type {string}
   */
  get state() {
    return this._state;
  }
  set state(value) {
    this._state = value;
  }
  /**
   * Makes sidebar listen to media query events and change its behaviour
   * @type {boolean}
   */
  get responsive() {
    return this._responsive;
  }
  set responsive(value) {
    if (this.responsive !== convertToBoolProperty(value)) {
      this._responsive = !this.responsive;
      this.responsiveValueChange$.next(this.responsive);
    }
  }
  constructor(sidebarService, themeService, element, cd) {
    this.sidebarService = sidebarService;
    this.themeService = themeService;
    this.element = element;
    this.cd = cd;
    this.responsiveValueChange$ = new Subject();
    this.responsiveState = "pc";
    this.destroy$ = new Subject();
    this.containerFixedValue = true;
    this.fixedValue = false;
    this.rightValue = false;
    this.leftValue = true;
    this.startValue = false;
    this.endValue = false;
    this._state = "expanded";
    this._responsive = false;
    this.compactedBreakpoints = ["xs", "is", "sm", "md", "lg"];
    this.collapsedBreakpoints = ["xs", "is"];
    this.stateChange = new EventEmitter();
    this.responsiveStateChange = new EventEmitter();
  }
  ngOnInit() {
    this.sidebarService.onToggle().pipe(filter(({
      tag
    }) => !this.tag || this.tag === tag), takeUntil(this.destroy$)).subscribe(({
      compact
    }) => this.toggle(compact));
    this.sidebarService.onExpand().pipe(filter(({
      tag
    }) => !this.tag || this.tag === tag), takeUntil(this.destroy$)).subscribe(() => this.expand());
    this.sidebarService.onCollapse().pipe(filter(({
      tag
    }) => !this.tag || this.tag === tag), takeUntil(this.destroy$)).subscribe(() => this.collapse());
    this.sidebarService.onCompact().pipe(filter(({
      tag
    }) => !this.tag || this.tag === tag), takeUntil(this.destroy$)).subscribe(() => this.compact());
    getSidebarState$.pipe(filter(({
      tag
    }) => !this.tag || this.tag === tag), takeUntil(this.destroy$)).subscribe(({
      observer
    }) => observer.next(this.state));
    getSidebarResponsiveState$.pipe(filter(({
      tag
    }) => !this.tag || this.tag === tag), takeUntil(this.destroy$)).subscribe(({
      observer
    }) => observer.next(this.responsiveState));
    this.responsiveValueChange$.pipe(filter((responsive) => !responsive), takeUntil(this.destroy$)).subscribe(() => this.expand());
    this.subscribeToMediaQueryChange();
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  // TODO: this is more of a workaround, should be a better way to make components communicate to each other
  onClick(event) {
    const menu = this.element.nativeElement.querySelector("nb-menu");
    if (menu && menu.contains(event.target)) {
      const link = this.getMenuLink(event.target);
      if (link && link.nextElementSibling && link.nextElementSibling.classList.contains("menu-items")) {
        this.sidebarService.expand(this.tag);
      }
    }
  }
  /**
   * Collapses the sidebar
   */
  collapse() {
    this.updateState("collapsed");
  }
  /**
   * Expands the sidebar
   */
  expand() {
    this.updateState("expanded");
  }
  /**
   * Compacts the sidebar (minimizes)
   */
  compact() {
    this.updateState("compacted");
  }
  /**
   * Toggles sidebar state (expanded|collapsed|compacted)
   * @param {boolean} compact If true, then sidebar state will be changed between expanded & compacted,
   * otherwise - between expanded & collapsed. False by default.
   *
   * Toggle sidebar state
   *
   * ```ts
   * this.sidebar.toggle(true);
   * ```
   */
  toggle(compact = false) {
    if (this.responsive) {
      if (this.responsiveState === "mobile") {
        compact = false;
      }
    }
    if (this.state === "compacted" || this.state === "collapsed") {
      this.updateState("expanded");
    } else {
      this.updateState(compact ? "compacted" : "collapsed");
    }
  }
  subscribeToMediaQueryChange() {
    combineLatest([this.responsiveValueChange$.pipe(startWith(this.responsive)), this.themeService.onMediaQueryChange()]).pipe(filter(([responsive]) => responsive), map(([, breakpoints]) => breakpoints), takeUntil(this.destroy$)).subscribe(([prev, current]) => {
      const isCollapsed = this.collapsedBreakpoints.includes(current.name);
      const isCompacted = this.compactedBreakpoints.includes(current.name);
      let newResponsiveState;
      if (isCompacted) {
        this.fixed = this.containerFixedValue;
        this.compact();
        newResponsiveState = "tablet";
      }
      if (isCollapsed) {
        this.fixed = true;
        this.collapse();
        newResponsiveState = "mobile";
      }
      if (!isCollapsed && !isCompacted && (!prev.width || prev.width < current.width)) {
        this.expand();
        this.fixed = false;
        newResponsiveState = "pc";
      }
      if (newResponsiveState && newResponsiveState !== this.responsiveState) {
        this.responsiveState = newResponsiveState;
        this.responsiveStateChange.emit(this.responsiveState);
        this.cd.markForCheck();
      }
    });
  }
  getMenuLink(element) {
    if (!element || element.tagName.toLowerCase() === "nb-menu") {
      return void 0;
    }
    if (element.tagName.toLowerCase() === "a") {
      return element;
    }
    return this.getMenuLink(element.parentElement);
  }
  updateState(state2) {
    if (this.state !== state2) {
      this.state = state2;
      this.stateChange.emit(this.state);
      this.cd.markForCheck();
    }
  }
};
_NbSidebarComponent.\u0275fac = function NbSidebarComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbSidebarComponent)(\u0275\u0275directiveInject(NbSidebarService), \u0275\u0275directiveInject(NbThemeService), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(ChangeDetectorRef));
};
_NbSidebarComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbSidebarComponent,
  selectors: [["nb-sidebar"]],
  hostVars: 16,
  hostBindings: function NbSidebarComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("fixed", ctx.fixedValue)("right", ctx.rightValue)("left", ctx.leftValue)("start", ctx.startValue)("end", ctx.endValue)("expanded", ctx.expanded)("collapsed", ctx.collapsed)("compacted", ctx.compacted);
    }
  },
  inputs: {
    right: "right",
    left: "left",
    start: "start",
    end: "end",
    fixed: "fixed",
    containerFixed: "containerFixed",
    state: "state",
    responsive: "responsive",
    tag: "tag",
    compactedBreakpoints: "compactedBreakpoints",
    collapsedBreakpoints: "collapsedBreakpoints"
  },
  outputs: {
    stateChange: "stateChange",
    responsiveStateChange: "responsiveStateChange"
  },
  standalone: false,
  ngContentSelectors: _c19,
  decls: 5,
  vars: 2,
  consts: [[1, "main-container"], [1, "scrollable", 3, "click"]],
  template: function NbSidebarComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef(_c18);
      \u0275\u0275elementStart(0, "div", 0);
      \u0275\u0275projection(1);
      \u0275\u0275elementStart(2, "div", 1);
      \u0275\u0275listener("click", function NbSidebarComponent_Template_div_click_2_listener($event) {
        return ctx.onClick($event);
      });
      \u0275\u0275projection(3, 1);
      \u0275\u0275elementEnd();
      \u0275\u0275projection(4, 2);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275classProp("main-container-fixed", ctx.containerFixedValue);
    }
  },
  styles: ["[_nghost-%COMP%]{display:flex;flex-direction:column;overflow:hidden;z-index:auto;order:0}[_nghost-%COMP%]   .scrollable[_ngcontent-%COMP%]{overflow-y:auto;overflow-x:hidden;flex:1}[_nghost-%COMP%]   .main-container[_ngcontent-%COMP%]{transform:translateZ(0);display:flex;flex-direction:column}[_nghost-%COMP%]   .main-container-fixed[_ngcontent-%COMP%]{position:fixed}.right[_nghost-%COMP%]{margin-right:0;margin-left:auto}[dir=ltr]   .right[_nghost-%COMP%]{order:4}[dir=rtl]   .right[_nghost-%COMP%]{order:0}.end[_nghost-%COMP%]{order:4}[dir=ltr]   .end[_nghost-%COMP%]{margin-right:0;margin-left:auto}[dir=rtl]   .end[_nghost-%COMP%]{margin-left:0;margin-right:auto}.fixed[_nghost-%COMP%]{position:fixed;height:100%;z-index:999;top:0;bottom:0;left:0}.fixed.right[_nghost-%COMP%]{right:0}[dir=ltr]   .fixed.start[_nghost-%COMP%]{left:0}[dir=rtl]   .fixed.start[_nghost-%COMP%]{right:0}[dir=ltr]   .fixed.end[_nghost-%COMP%]{right:0}[dir=rtl]   .fixed.end[_nghost-%COMP%]{left:0}[_nghost-%COMP%]     nb-sidebar-footer{margin-top:auto;display:block}[_nghost-%COMP%]     nb-sidebar-header{display:block}\n\n\n\n\n\n"],
  changeDetection: 0
});
var NbSidebarComponent = _NbSidebarComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSidebarComponent, [{
    type: Component,
    args: [{
      selector: "nb-sidebar",
      template: `
    <div class="main-container" [class.main-container-fixed]="containerFixedValue">
      <ng-content select="nb-sidebar-header"></ng-content>
      <div class="scrollable" (click)="onClick($event)">
        <ng-content></ng-content>
      </div>
      <ng-content select="nb-sidebar-footer"></ng-content>
    </div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      styles: [":host{display:flex;flex-direction:column;overflow:hidden;z-index:auto;order:0}:host .scrollable{overflow-y:auto;overflow-x:hidden;flex:1}:host .main-container{transform:translateZ(0);display:flex;flex-direction:column}:host .main-container-fixed{position:fixed}:host.right{margin-right:0;margin-left:auto}[dir=ltr] :host.right{order:4}[dir=rtl] :host.right{order:0}:host.end{order:4}[dir=ltr] :host.end{margin-right:0;margin-left:auto}[dir=rtl] :host.end{margin-left:0;margin-right:auto}:host.fixed{position:fixed;height:100%;z-index:999;top:0;bottom:0;left:0}:host.fixed.right{right:0}[dir=ltr] :host.fixed.start{left:0}[dir=rtl] :host.fixed.start{right:0}[dir=ltr] :host.fixed.end{right:0}[dir=rtl] :host.fixed.end{left:0}:host ::ng-deep nb-sidebar-footer{margin-top:auto;display:block}:host ::ng-deep nb-sidebar-header{display:block}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: NbSidebarService
  }, {
    type: NbThemeService
  }, {
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }], {
    fixedValue: [{
      type: HostBinding,
      args: ["class.fixed"]
    }],
    rightValue: [{
      type: HostBinding,
      args: ["class.right"]
    }],
    leftValue: [{
      type: HostBinding,
      args: ["class.left"]
    }],
    startValue: [{
      type: HostBinding,
      args: ["class.start"]
    }],
    endValue: [{
      type: HostBinding,
      args: ["class.end"]
    }],
    expanded: [{
      type: HostBinding,
      args: ["class.expanded"]
    }],
    collapsed: [{
      type: HostBinding,
      args: ["class.collapsed"]
    }],
    compacted: [{
      type: HostBinding,
      args: ["class.compacted"]
    }],
    right: [{
      type: Input
    }],
    left: [{
      type: Input
    }],
    start: [{
      type: Input
    }],
    end: [{
      type: Input
    }],
    fixed: [{
      type: Input
    }],
    containerFixed: [{
      type: Input
    }],
    state: [{
      type: Input
    }],
    responsive: [{
      type: Input
    }],
    tag: [{
      type: Input
    }],
    compactedBreakpoints: [{
      type: Input
    }],
    collapsedBreakpoints: [{
      type: Input
    }],
    stateChange: [{
      type: Output
    }],
    responsiveStateChange: [{
      type: Output
    }]
  });
})();
var NB_SIDEBAR_COMPONENTS = [NbSidebarComponent, NbSidebarFooterComponent, NbSidebarHeaderComponent];
var NB_SIDEBAR_PROVIDERS = [NbSidebarService];
var _NbSidebarModule = class _NbSidebarModule {
  static forRoot() {
    return {
      ngModule: _NbSidebarModule,
      providers: [...NB_SIDEBAR_PROVIDERS]
    };
  }
};
_NbSidebarModule.\u0275fac = function NbSidebarModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbSidebarModule)();
};
_NbSidebarModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbSidebarModule,
  declarations: [NbSidebarComponent, NbSidebarFooterComponent, NbSidebarHeaderComponent],
  imports: [NbSharedModule],
  exports: [NbSidebarComponent, NbSidebarFooterComponent, NbSidebarHeaderComponent]
});
_NbSidebarModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NbSharedModule]
});
var NbSidebarModule = _NbSidebarModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSidebarModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule],
      declarations: [...NB_SIDEBAR_COMPONENTS],
      exports: [...NB_SIDEBAR_COMPONENTS]
    }]
  }], null, null);
})();
var _NbTabContentDirective = class _NbTabContentDirective {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
};
_NbTabContentDirective.\u0275fac = function NbTabContentDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbTabContentDirective)(\u0275\u0275directiveInject(TemplateRef));
};
_NbTabContentDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbTabContentDirective,
  selectors: [["", "nbTabContent", ""]],
  standalone: false
});
var NbTabContentDirective = _NbTabContentDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTabContentDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTabContent]",
      standalone: false
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var _NbTabTitleDirective = class _NbTabTitleDirective {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
};
_NbTabTitleDirective.\u0275fac = function NbTabTitleDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbTabTitleDirective)(\u0275\u0275directiveInject(TemplateRef));
};
_NbTabTitleDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbTabTitleDirective,
  selectors: [["", "nbTabTitle", ""]],
  standalone: false
});
var NbTabTitleDirective = _NbTabTitleDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTabTitleDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTabTitle]",
      standalone: false
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var _NbTabComponent = class _NbTabComponent {
  constructor() {
    this.activeValue = false;
    this.responsiveValue = false;
    this.disabledValue = false;
    this.badgeStatus = "basic";
    this.init = false;
  }
  /**
   * Use badge dot mode
   * @type {boolean}
   */
  get badgeDot() {
    return this._badgeDot;
  }
  set badgeDot(val) {
    this._badgeDot = convertToBoolProperty(val);
  }
  /**
   * Item is disabled and cannot be opened.
   * @type {boolean}
   */
  get disabled() {
    return this.disabledValue;
  }
  set disabled(val) {
    this.disabledValue = convertToBoolProperty(val);
  }
  /**
   * Show only icons when width is smaller than `tabs-icon-only-max-width`
   * @type {boolean}
   */
  set responsive(val) {
    this.responsiveValue = convertToBoolProperty(val);
  }
  get responsive() {
    return this.responsiveValue;
  }
  /**
   * Specifies active tab
   * @returns {boolean}
   */
  get active() {
    return this.activeValue;
  }
  set active(val) {
    this.activeValue = convertToBoolProperty(val);
    if (this.activeValue) {
      this.init = true;
    }
  }
  /**
   * Lazy load content before tab selection
   * @docs-private
   * @deprecated This setting never worked. Wrap content into a `nbTabContent` to make it lazy.
   * @breaking-change Remove 12.0.0
   */
  set lazyLoad(val) {
    this.init = convertToBoolProperty(val);
  }
};
_NbTabComponent.\u0275fac = function NbTabComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbTabComponent)();
};
_NbTabComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbTabComponent,
  selectors: [["nb-tab"]],
  contentQueries: function NbTabComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, NbTabContentDirective, 5);
      \u0275\u0275contentQuery(dirIndex, NbTabTitleDirective, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tabContentDirective = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tabTitleDirective = _t.first);
    }
  },
  hostVars: 4,
  hostBindings: function NbTabComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("disabled", ctx.disabled)("content-active", ctx.activeValue);
    }
  },
  inputs: {
    tabTitle: "tabTitle",
    tabId: "tabId",
    badgeDot: "badgeDot",
    tabIcon: "tabIcon",
    disabled: "disabled",
    responsive: "responsive",
    route: "route",
    active: "active",
    lazyLoad: "lazyLoad",
    badgeText: "badgeText",
    badgeStatus: "badgeStatus",
    badgePosition: "badgePosition"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 3,
  vars: 2,
  consts: [["projectedContent", ""], [3, "ngTemplateOutlet", 4, "ngIf", "ngIfElse"], [3, "ngTemplateOutlet"]],
  template: function NbTabComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275template(0, NbTabComponent_ng_container_0_Template, 1, 1, "ng-container", 1)(1, NbTabComponent_ng_template_1_Template, 1, 0, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
    }
    if (rf & 2) {
      const projectedContent_r2 = \u0275\u0275reference(2);
      \u0275\u0275property("ngIf", ctx.tabContentDirective)("ngIfElse", projectedContent_r2);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet],
  encapsulation: 2
});
var NbTabComponent = _NbTabComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTabComponent, [{
    type: Component,
    args: [{
      selector: "nb-tab",
      template: `
    <ng-container
      *ngIf="tabContentDirective; else projectedContent"
      [ngTemplateOutlet]="tabContentDirective.templateRef"
    ></ng-container>

    <ng-template #projectedContent>
      <ng-content></ng-content>
    </ng-template>
  `,
      standalone: false
    }]
  }], null, {
    tabContentDirective: [{
      type: ContentChild,
      args: [NbTabContentDirective]
    }],
    tabTitleDirective: [{
      type: ContentChild,
      args: [NbTabTitleDirective]
    }],
    tabTitle: [{
      type: Input
    }],
    tabId: [{
      type: Input
    }],
    badgeDot: [{
      type: Input
    }],
    tabIcon: [{
      type: Input
    }],
    disabled: [{
      type: Input,
      args: ["disabled"]
    }, {
      type: HostBinding,
      args: ["class.disabled"]
    }],
    responsive: [{
      type: Input
    }],
    route: [{
      type: Input
    }],
    activeValue: [{
      type: HostBinding,
      args: ["class.content-active"]
    }],
    active: [{
      type: Input
    }],
    lazyLoad: [{
      type: Input
    }],
    badgeText: [{
      type: Input
    }],
    badgeStatus: [{
      type: Input
    }],
    badgePosition: [{
      type: Input
    }]
  });
})();
var _NbTabsetComponent = class _NbTabsetComponent {
  /**
   * Take full width of a parent
   * @param {boolean} val
   */
  set fullWidth(val) {
    this.fullWidthValue = convertToBoolProperty(val);
  }
  constructor(route, changeDetectorRef) {
    this.route = route;
    this.changeDetectorRef = changeDetectorRef;
    this.fullWidthValue = false;
    this.changeTab = new EventEmitter();
    this.destroy$ = new Subject();
  }
  // TODO: refactoring this component, avoid change detection loop
  ngAfterContentInit() {
    this.route.params.pipe(map((params) => this.tabs.find((tab) => this.routeParam ? tab.route === params[this.routeParam] : tab.active)), delay(0), map((tab) => tab || this.tabs.first), filter((tab) => !!tab), takeUntil(this.destroy$)).subscribe((tabToSelect) => {
      this.selectTab(tabToSelect);
      this.changeDetectorRef.markForCheck();
    });
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  // TODO: navigate to routeParam
  selectTab(selectedTab) {
    if (!selectedTab.disabled) {
      this.tabs.forEach((tab) => tab.active = tab === selectedTab);
      this.changeTab.emit(selectedTab);
    }
  }
};
_NbTabsetComponent.\u0275fac = function NbTabsetComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbTabsetComponent)(\u0275\u0275directiveInject(ActivatedRoute), \u0275\u0275directiveInject(ChangeDetectorRef));
};
_NbTabsetComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbTabsetComponent,
  selectors: [["nb-tabset"]],
  contentQueries: function NbTabsetComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, NbTabComponent, 4);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tabs = _t);
    }
  },
  hostVars: 2,
  hostBindings: function NbTabsetComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("full-width", ctx.fullWidthValue);
    }
  },
  inputs: {
    fullWidth: "fullWidth",
    routeParam: "routeParam"
  },
  outputs: {
    changeTab: "changeTab"
  },
  standalone: false,
  ngContentSelectors: _c21,
  decls: 3,
  vars: 1,
  consts: [["textTitleTemplate", ""], [1, "tabset"], ["class", "tab", 3, "responsive", "active", "disabled", "click", "keyup.space", "keyup.enter", 4, "ngFor", "ngForOf"], [1, "tab", 3, "click", "keyup.space", "keyup.enter"], ["href", "", "tabindex", "-1", 1, "tab-link", 3, "click"], [3, "config", 4, "ngIf"], [3, "ngTemplateOutlet", 4, "ngIf", "ngIfElse"], [3, "text", "dotMode", "status", "position", 4, "ngIf"], [3, "config"], [3, "ngTemplateOutlet"], [1, "tab-text"], [3, "text", "dotMode", "status", "position"]],
  template: function NbTabsetComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef(_c20);
      \u0275\u0275elementStart(0, "ul", 1);
      \u0275\u0275template(1, NbTabsetComponent_li_1_Template, 7, 12, "li", 2);
      \u0275\u0275elementEnd();
      \u0275\u0275projection(2);
    }
    if (rf & 2) {
      \u0275\u0275advance();
      \u0275\u0275property("ngForOf", ctx.tabs);
    }
  },
  dependencies: [NgForOf, NgIf, NgTemplateOutlet, NbBadgeComponent, NbIconComponent],
  styles: ['[_nghost-%COMP%]{display:block}.full-width[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]{justify-content:space-around}[_nghost-%COMP%]     nb-tab{flex:1;-ms-flex:1 1 auto;overflow:auto;display:none}[_nghost-%COMP%]     nb-tab.content-active{display:block}[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]{display:flex;flex-direction:row;list-style-type:none;margin:0;padding:0}[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab[_ngcontent-%COMP%]{margin-bottom:-1px;text-align:center;position:relative}[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab.active[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]:before{display:block}[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{display:flex;position:relative;text-decoration:none}[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]:before{position:absolute;content:"";width:100%;border-radius:3px;bottom:-2px;left:0}[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{vertical-align:middle}[dir=ltr]   [_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%] + span[_ngcontent-%COMP%]{margin-left:.5rem}[dir=rtl]   [_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%] + span[_ngcontent-%COMP%]{margin-right:.5rem}\n\n\n\n\n\n']
});
var NbTabsetComponent = _NbTabsetComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTabsetComponent, [{
    type: Component,
    args: [{
      selector: "nb-tabset",
      template: `
    <ul class="tabset">
      <li
        *ngFor="let tab of tabs"
        (click)="selectTab(tab)"
        (keyup.space)="selectTab(tab)"
        (keyup.enter)="selectTab(tab)"
        [class.responsive]="tab.responsive"
        [class.active]="tab.active"
        [class.disabled]="tab.disabled"
        [attr.tabindex]="tab.disabled ? -1 : 0"
        [attr.data-tab-id]="tab.tabId"
        class="tab"
      >
        <a href (click)="$event.preventDefault()" tabindex="-1" class="tab-link">
          <nb-icon *ngIf="tab.tabIcon" [config]="tab.tabIcon"></nb-icon>
          <ng-container
            *ngIf="tab.tabTitleDirective; else textTitleTemplate"
            [ngTemplateOutlet]="tab.tabTitleDirective.templateRef"
          ></ng-container>
          <ng-template #textTitleTemplate>
            <span class="tab-text">{{ tab.tabTitle }}</span>
          </ng-template>
        </a>
        <nb-badge
          *ngIf="tab.badgeText || tab.badgeDot"
          [text]="tab.badgeText"
          [dotMode]="tab.badgeDot"
          [status]="tab.badgeStatus"
          [position]="tab.badgePosition"
        >
        </nb-badge>
      </li>
    </ul>
    <ng-content select="nb-tab"></ng-content>
  `,
      standalone: false,
      styles: [':host{display:block}:host.full-width .tabset{justify-content:space-around}:host ::ng-deep nb-tab{flex:1;-ms-flex:1 1 auto;overflow:auto;display:none}:host ::ng-deep nb-tab.content-active{display:block}:host .tabset{display:flex;flex-direction:row;list-style-type:none;margin:0;padding:0}:host .tabset .tab{margin-bottom:-1px;text-align:center;position:relative}:host .tabset .tab.active a:before{display:block}:host .tabset .tab a{display:flex;position:relative;text-decoration:none}:host .tabset .tab a:before{position:absolute;content:"";width:100%;border-radius:3px;bottom:-2px;left:0}:host .tabset .tab a nb-icon{vertical-align:middle}[dir=ltr] :host .tabset .tab a nb-icon+span{margin-left:.5rem}[dir=rtl] :host .tabset .tab a nb-icon+span{margin-right:.5rem}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n']
    }]
  }], () => [{
    type: ActivatedRoute
  }, {
    type: ChangeDetectorRef
  }], {
    tabs: [{
      type: ContentChildren,
      args: [NbTabComponent]
    }],
    fullWidthValue: [{
      type: HostBinding,
      args: ["class.full-width"]
    }],
    fullWidth: [{
      type: Input
    }],
    routeParam: [{
      type: Input
    }],
    changeTab: [{
      type: Output
    }]
  });
})();
var NB_TABSET_COMPONENTS = [NbTabsetComponent, NbTabComponent];
var NB_TABSET_DIRECTIVES = [NbTabContentDirective, NbTabTitleDirective];
var _NbTabsetModule = class _NbTabsetModule {
};
_NbTabsetModule.\u0275fac = function NbTabsetModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbTabsetModule)();
};
_NbTabsetModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbTabsetModule,
  declarations: [NbTabsetComponent, NbTabComponent, NbTabContentDirective, NbTabTitleDirective],
  imports: [NbSharedModule, NbBadgeModule, NbIconModule],
  exports: [NbTabsetComponent, NbTabComponent, NbTabContentDirective, NbTabTitleDirective]
});
_NbTabsetModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NbSharedModule, NbBadgeModule, NbIconModule]
});
var NbTabsetModule = _NbTabsetModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTabsetModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbBadgeModule, NbIconModule],
      declarations: [...NB_TABSET_COMPONENTS, ...NB_TABSET_DIRECTIVES],
      exports: [...NB_TABSET_COMPONENTS, ...NB_TABSET_DIRECTIVES]
    }]
  }], null, null);
})();
var _NbUserComponent = class _NbUserComponent {
  /**
   * Absolute path to a user picture or base64 image.
   * User name initials will be shown if no picture specified (JD for John Doe).
   * @type string
   */
  set picture(value) {
    this.imageBackgroundStyle = value ? this.domSanitizer.bypassSecurityTrustStyle(`url(${value})`) : null;
  }
  /**
   * Whether to show a user name or not
   */
  get showName() {
    return this._showName;
  }
  set showName(val) {
    this._showName = convertToBoolProperty(val);
  }
  /**
   * Whether to show a user title or not
   * @type boolean
   */
  get showTitle() {
    return this._showTitle;
  }
  set showTitle(val) {
    this._showTitle = convertToBoolProperty(val);
  }
  /**
   * Whether to show a user initials (if no picture specified) or not
   * @type boolean
   */
  get showInitials() {
    return this._showInitials;
  }
  set showInitials(val) {
    this._showInitials = convertToBoolProperty(val);
  }
  /**
   * Whether to show only a picture or also show the name and title
   * @type boolean
   */
  get onlyPicture() {
    return !this.showName && !this.showTitle;
  }
  set onlyPicture(val) {
    this.showName = this.showTitle = !convertToBoolProperty(val);
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get rectangle() {
    return this.shape === "rectangle";
  }
  get semiRound() {
    return this.shape === "semi-round";
  }
  get round() {
    return this.shape === "round";
  }
  constructor(domSanitizer) {
    this.domSanitizer = domSanitizer;
    this.name = "Anonymous";
    this.size = "medium";
    this.shape = "round";
    this._showName = true;
    this._showTitle = true;
    this._showInitials = true;
    this.badgeStatus = "basic";
  }
  getInitials() {
    if (this.name) {
      const names = this.name.split(" ");
      return names.map((n) => n.charAt(0)).splice(0, 2).join("").toUpperCase();
    }
    return "";
  }
};
_NbUserComponent.\u0275fac = function NbUserComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbUserComponent)(\u0275\u0275directiveInject(DomSanitizer));
};
_NbUserComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbUserComponent,
  selectors: [["nb-user"]],
  hostVars: 16,
  hostBindings: function NbUserComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("shape-rectangle", ctx.rectangle)("shape-semi-round", ctx.semiRound)("shape-round", ctx.round);
    }
  },
  inputs: {
    name: "name",
    title: "title",
    picture: "picture",
    color: "color",
    size: "size",
    shape: "shape",
    showName: "showName",
    showTitle: "showTitle",
    showInitials: "showInitials",
    onlyPicture: "onlyPicture",
    badgeText: "badgeText",
    badgeStatus: "badgeStatus",
    badgePosition: "badgePosition"
  },
  standalone: false,
  decls: 6,
  vars: 4,
  consts: [[1, "user-container"], ["class", "user-picture image", 3, "background-image", 4, "ngIf"], ["class", "user-picture initials", 3, "background-color", 4, "ngIf"], [1, "info-container"], ["class", "user-name", 4, "ngIf"], ["class", "user-title", 4, "ngIf"], [1, "user-picture", "image"], [3, "text", "status", "position", 4, "ngIf"], [3, "text", "status", "position"], [1, "user-picture", "initials"], [4, "ngIf"], [1, "user-name"], [1, "user-title"]],
  template: function NbUserComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0);
      \u0275\u0275template(1, NbUserComponent_div_1_Template, 2, 3, "div", 1)(2, NbUserComponent_div_2_Template, 3, 4, "div", 2);
      \u0275\u0275elementStart(3, "div", 3);
      \u0275\u0275template(4, NbUserComponent_div_4_Template, 2, 1, "div", 4)(5, NbUserComponent_div_5_Template, 2, 1, "div", 5);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.imageBackgroundStyle);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", !ctx.imageBackgroundStyle);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", ctx.showName && ctx.name);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.showTitle && ctx.title);
    }
  },
  dependencies: [NgIf, NbBadgeComponent],
  styles: ["[_nghost-%COMP%]{display:flex}[_nghost-%COMP%]   .user-container[_ngcontent-%COMP%]{position:relative;display:flex;align-items:center}[_nghost-%COMP%]   .user-picture[_ngcontent-%COMP%]{position:relative;flex-shrink:0}[_nghost-%COMP%]   .user-picture.image[_ngcontent-%COMP%]{background-size:cover;background-repeat:no-repeat}[_nghost-%COMP%]   .user-picture.initials[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center}[dir=rtl]   [_nghost-%COMP%]   .user-name[_ngcontent-%COMP%], [dir=rtl]   [_nghost-%COMP%]   .user-title[_ngcontent-%COMP%]{text-align:right}[dir=ltr]   [_nghost-%COMP%]   .info-container[_ngcontent-%COMP%]{margin-left:.5rem}[dir=rtl]   [_nghost-%COMP%]   .info-container[_ngcontent-%COMP%]{margin-right:.5rem}\n\n\n\n\n\n"]
});
var NbUserComponent = _NbUserComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbUserComponent, [{
    type: Component,
    args: [{
      selector: "nb-user",
      standalone: false,
      template: '<div class="user-container">\n  <div *ngIf="imageBackgroundStyle" class="user-picture image" [style.background-image]="imageBackgroundStyle">\n    <nb-badge *ngIf="badgeText" [text]="badgeText" [status]="badgeStatus" [position]="badgePosition"></nb-badge>\n  </div>\n  <div *ngIf="!imageBackgroundStyle" class="user-picture initials" [style.background-color]="color">\n    <ng-container *ngIf="showInitials">\n      {{ getInitials() }}\n    </ng-container>\n    <nb-badge *ngIf="badgeText" [text]="badgeText" [status]="badgeStatus" [position]="badgePosition"></nb-badge>\n  </div>\n\n  <div class="info-container">\n    <div *ngIf="showName && name" class="user-name">{{ name }}</div>\n    <div *ngIf="showTitle && title" class="user-title">{{ title }}</div>\n  </div>\n</div>\n',
      styles: [":host{display:flex}:host .user-container{position:relative;display:flex;align-items:center}:host .user-picture{position:relative;flex-shrink:0}:host .user-picture.image{background-size:cover;background-repeat:no-repeat}:host .user-picture.initials{display:flex;align-items:center;justify-content:center}[dir=rtl] :host .user-name,[dir=rtl] :host .user-title{text-align:right}[dir=ltr] :host .info-container{margin-left:.5rem}[dir=rtl] :host .info-container{margin-right:.5rem}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: DomSanitizer
  }], {
    name: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    picture: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    shape: [{
      type: Input
    }],
    showName: [{
      type: Input
    }],
    showTitle: [{
      type: Input
    }],
    showInitials: [{
      type: Input
    }],
    onlyPicture: [{
      type: Input
    }],
    badgeText: [{
      type: Input
    }],
    badgeStatus: [{
      type: Input
    }],
    badgePosition: [{
      type: Input
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    rectangle: [{
      type: HostBinding,
      args: ["class.shape-rectangle"]
    }],
    semiRound: [{
      type: HostBinding,
      args: ["class.shape-semi-round"]
    }],
    round: [{
      type: HostBinding,
      args: ["class.shape-round"]
    }]
  });
})();
var NB_USER_COMPONENTS = [NbUserComponent];
var _NbUserModule = class _NbUserModule {
};
_NbUserModule.\u0275fac = function NbUserModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbUserModule)();
};
_NbUserModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbUserModule,
  declarations: [NbUserComponent],
  imports: [NbSharedModule, NbBadgeModule],
  exports: [NbUserComponent]
});
_NbUserModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NbSharedModule, NbBadgeModule]
});
var NbUserModule = _NbUserModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbUserModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbBadgeModule],
      declarations: [...NB_USER_COMPONENTS],
      exports: [...NB_USER_COMPONENTS]
    }]
  }], null, null);
})();
var _NbActionComponent = class _NbActionComponent {
  constructor() {
    this.title = "";
    this._disabled = false;
    this.badgeStatus = "basic";
  }
  /**
   * Visually disables the item
   * @type boolean
   */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = convertToBoolProperty(value);
  }
  /**
   * Use badge dot mode
   * @type boolean
   */
  get badgeDot() {
    return this._badgeDot;
  }
  set badgeDot(value) {
    this._badgeDot = convertToBoolProperty(value);
  }
};
_NbActionComponent.\u0275fac = function NbActionComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbActionComponent)();
};
_NbActionComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbActionComponent,
  selectors: [["nb-action"]],
  hostVars: 2,
  hostBindings: function NbActionComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("disabled", ctx.disabled);
    }
  },
  inputs: {
    link: "link",
    href: "href",
    title: "title",
    icon: "icon",
    disabled: "disabled",
    badgeDot: "badgeDot",
    badgeText: "badgeText",
    badgeStatus: "badgeStatus",
    badgePosition: "badgePosition"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 5,
  vars: 2,
  consts: [["projectedContent", ""], ["badgeTemplate", ""], [4, "ngIf", "ngIfElse"], ["class", "icon-container", 3, "routerLink", "title", 4, "ngIf"], ["class", "icon-container", 3, "href", "title", 4, "ngIf"], ["class", "icon-container", "href", "#", 3, "title", "click", 4, "ngIf"], [1, "icon-container", 3, "routerLink", "title"], [3, "config"], [3, "ngTemplateOutlet"], [1, "icon-container", 3, "href", "title"], ["href", "#", 1, "icon-container", 3, "click", "title"], [3, "text", "dotMode", "status", "position", 4, "ngIf"], [3, "text", "dotMode", "status", "position"]],
  template: function NbActionComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275template(0, NbActionComponent_ng_container_0_Template, 4, 3, "ng-container", 2)(1, NbActionComponent_ng_template_1_Template, 2, 1, "ng-template", null, 0, \u0275\u0275templateRefExtractor)(3, NbActionComponent_ng_template_3_Template, 1, 1, "ng-template", null, 1, \u0275\u0275templateRefExtractor);
    }
    if (rf & 2) {
      const projectedContent_r4 = \u0275\u0275reference(2);
      \u0275\u0275property("ngIf", ctx.icon)("ngIfElse", projectedContent_r4);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, RouterLink, NbBadgeComponent, NbIconComponent],
  styles: ["[_nghost-%COMP%]{background:transparent;display:flex;align-items:center;position:relative}.disabled[_nghost-%COMP%]{cursor:not-allowed}.disabled[_nghost-%COMP%]   a[_ngcontent-%COMP%], .disabled[_nghost-%COMP%]   nb-icon[_ngcontent-%COMP%]{cursor:not-allowed}nb-actions.full-width[_nghost-%COMP%], nb-actions.full-width   [_nghost-%COMP%]{justify-content:center;width:100%}a.icon-container[_ngcontent-%COMP%]{position:relative}a.icon-container[_ngcontent-%COMP%]:hover, a.icon-container[_ngcontent-%COMP%]:focus{text-decoration:none}nb-icon[_ngcontent-%COMP%]:hover{cursor:pointer}\n\n\n\n\n\n"]
});
var NbActionComponent = _NbActionComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbActionComponent, [{
    type: Component,
    args: [{
      selector: "nb-action",
      template: `
    <ng-container *ngIf="icon; else projectedContent">
      <a class="icon-container"
         [routerLink]="link"
         [title]="title"
         *ngIf="link">
        <nb-icon [config]="icon"></nb-icon>
        <ng-container [ngTemplateOutlet]="badgeTemplate"></ng-container>
      </a>
      <a class="icon-container"
         [href]="href"
         [title]="title"
         *ngIf="href && !link">
        <nb-icon [config]="icon"></nb-icon>
        <ng-container [ngTemplateOutlet]="badgeTemplate"></ng-container>
      </a>
      <a class="icon-container"
         href="#"
         [title]="title"
         *ngIf="!href && !link"
         (click)="$event.preventDefault()">
        <nb-icon [config]="icon"></nb-icon>
        <ng-container [ngTemplateOutlet]="badgeTemplate"></ng-container>
      </a>
    </ng-container>

    <ng-template #projectedContent>
      <ng-content></ng-content>
      <ng-container [ngTemplateOutlet]="badgeTemplate"></ng-container>
    </ng-template>
    <ng-template #badgeTemplate>
      <nb-badge *ngIf="badgeText || badgeDot"
                [text]="badgeText"
                [dotMode]="badgeDot"
                [status]="badgeStatus"
                [position]="badgePosition">
      </nb-badge>
    </ng-template>
  `,
      standalone: false,
      styles: [":host{background:transparent;display:flex;align-items:center;position:relative}:host(.disabled){cursor:not-allowed}:host(.disabled) a,:host(.disabled) nb-icon{cursor:not-allowed}:host-context(nb-actions.full-width){justify-content:center;width:100%}a.icon-container{position:relative}a.icon-container:hover,a.icon-container:focus{text-decoration:none}nb-icon:hover{cursor:pointer}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], null, {
    link: [{
      type: Input
    }],
    href: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    icon: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.disabled"]
    }],
    badgeDot: [{
      type: Input
    }],
    badgeText: [{
      type: Input
    }],
    badgeStatus: [{
      type: Input
    }],
    badgePosition: [{
      type: Input
    }]
  });
})();
var _NbActionsComponent = class _NbActionsComponent {
  constructor() {
    this._size = "small";
    this._fullWidth = false;
  }
  /**
   * Size of the component: 'tiny', 'small' (default), 'medium', 'large', 'giant'
   */
  get size() {
    return this._size;
  }
  set size(value) {
    this._size = value;
  }
  /**
   * Component will fill full width of the container
   */
  get fullWidth() {
    return this._fullWidth;
  }
  set fullWidth(value) {
    this._fullWidth = convertToBoolProperty(value);
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
};
_NbActionsComponent.\u0275fac = function NbActionsComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbActionsComponent)();
};
_NbActionsComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbActionsComponent,
  selectors: [["nb-actions"]],
  hostVars: 12,
  hostBindings: function NbActionsComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("full-width", ctx.fullWidth)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant);
    }
  },
  inputs: {
    size: "size",
    fullWidth: "fullWidth"
  },
  standalone: false,
  ngContentSelectors: _c23,
  decls: 1,
  vars: 0,
  template: function NbActionsComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef(_c22);
      \u0275\u0275projection(0);
    }
  },
  styles: ["[_nghost-%COMP%]{display:flex;align-items:center}\n\n\n\n\n\n"]
});
var NbActionsComponent = _NbActionsComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbActionsComponent, [{
    type: Component,
    args: [{
      selector: "nb-actions",
      template: `
    <ng-content select="nb-action"></ng-content>
  `,
      standalone: false,
      styles: [":host{display:flex;align-items:center}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], null, {
    size: [{
      type: Input
    }],
    fullWidth: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.full-width"]
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }]
  });
})();
var NB_ACTIONS_COMPONENTS = [NbActionComponent, NbActionsComponent];
var _NbActionsModule = class _NbActionsModule {
};
_NbActionsModule.\u0275fac = function NbActionsModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbActionsModule)();
};
_NbActionsModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbActionsModule,
  declarations: [NbActionComponent, NbActionsComponent],
  imports: [NbSharedModule, NbBadgeModule, NbIconModule],
  exports: [NbActionComponent, NbActionsComponent]
});
_NbActionsModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NbSharedModule, NbBadgeModule, NbIconModule]
});
var NbActionsModule = _NbActionsModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbActionsModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbBadgeModule, NbIconModule],
      declarations: [...NB_ACTIONS_COMPONENTS],
      exports: [...NB_ACTIONS_COMPONENTS]
    }]
  }], null, null);
})();
var _NbSearchService = class _NbSearchService {
  constructor() {
    this.searchSubmittings$ = new Subject();
    this.searchActivations$ = new Subject();
    this.searchDeactivations$ = new Subject();
    this.searchInput$ = new Subject();
  }
  /***
   * Activate (open) search component
   * @param {string} searchType
   * @param {string} tag
   */
  activateSearch(searchType, tag) {
    this.searchActivations$.next({
      searchType,
      tag
    });
  }
  /**
   * Deactibate (close) search component
   * @param {string} searchType
   * @param {string} tag
   */
  deactivateSearch(searchType, tag) {
    this.searchDeactivations$.next({
      searchType,
      tag
    });
  }
  /**
   * Trigger search submit
   * @param {string} term
   * @param {string} tag
   */
  submitSearch(term, tag) {
    this.searchSubmittings$.next({
      term,
      tag
    });
  }
  /**
   * Trigger search submit by input event
   * @param {string} term
   * @param {string} tag
   */
  searchInput(term, tag) {
    this.searchInput$.next({
      term,
      tag
    });
  }
  /**
   * Subscribe to 'activate' event
   * @returns Observable<{searchType: string; tag?: string}>
   */
  onSearchActivate() {
    return this.searchActivations$.pipe(share());
  }
  /**
   * Subscribe to 'deactivate' event
   * @returns Observable<{searchType: string; tag?: string}>
   */
  onSearchDeactivate() {
    return this.searchDeactivations$.pipe(share());
  }
  /**
   * Subscribe to 'submit' event (when submit button clicked)
   * @returns Observable<{term: string; tag?: string}>
   */
  onSearchSubmit() {
    return this.searchSubmittings$.pipe(share());
  }
  /**
   * Subscribe to input event
   * @returns Observable<{term: string; tag?: string}>
   */
  onSearchInput() {
    return this.searchInput$.pipe(share());
  }
};
_NbSearchService.\u0275fac = function NbSearchService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbSearchService)();
};
_NbSearchService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbSearchService,
  factory: _NbSearchService.\u0275fac
});
var NbSearchService = _NbSearchService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSearchService, [{
    type: Injectable
  }], null, null);
})();
var _NbSearchFieldComponent = class _NbSearchFieldComponent {
  constructor() {
    this.show = false;
    this.close = new EventEmitter();
    this.search = new EventEmitter();
    this.searchInput = new EventEmitter();
  }
  get showClass() {
    return this.show;
  }
  get modalZoomin() {
    return this.type === _NbSearchFieldComponent.TYPE_MODAL_ZOOMIN;
  }
  get rotateLayout() {
    return this.type === _NbSearchFieldComponent.TYPE_ROTATE_LAYOUT;
  }
  get modalMove() {
    return this.type === _NbSearchFieldComponent.TYPE_MODAL_MOVE;
  }
  get curtain() {
    return this.type === _NbSearchFieldComponent.TYPE_CURTAIN;
  }
  get columnCurtain() {
    return this.type === _NbSearchFieldComponent.TYPE_COLUMN_CURTAIN;
  }
  get modalDrop() {
    return this.type === _NbSearchFieldComponent.TYPE_MODAL_DROP;
  }
  get modalHalf() {
    return this.type === _NbSearchFieldComponent.TYPE_MODAL_HALF;
  }
  ngOnChanges({
    show
  }) {
    const becameHidden = !show.isFirstChange() && show.currentValue === false;
    if (becameHidden && this.inputElement) {
      this.inputElement.nativeElement.value = "";
    }
    this.focusInput();
  }
  ngAfterViewInit() {
    this.focusInput();
  }
  emitClose() {
    this.close.emit();
  }
  submitSearch(term) {
    if (term) {
      this.search.emit(term);
    }
  }
  emitSearchInput(term) {
    this.searchInput.emit(term);
  }
  focusInput() {
    if (this.show && this.inputElement) {
      this.inputElement.nativeElement.focus();
    }
  }
};
_NbSearchFieldComponent.TYPE_MODAL_ZOOMIN = "modal-zoomin";
_NbSearchFieldComponent.TYPE_ROTATE_LAYOUT = "rotate-layout";
_NbSearchFieldComponent.TYPE_MODAL_MOVE = "modal-move";
_NbSearchFieldComponent.TYPE_CURTAIN = "curtain";
_NbSearchFieldComponent.TYPE_COLUMN_CURTAIN = "column-curtain";
_NbSearchFieldComponent.TYPE_MODAL_DROP = "modal-drop";
_NbSearchFieldComponent.TYPE_MODAL_HALF = "modal-half";
_NbSearchFieldComponent.\u0275fac = function NbSearchFieldComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbSearchFieldComponent)();
};
_NbSearchFieldComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbSearchFieldComponent,
  selectors: [["nb-search-field"]],
  viewQuery: function NbSearchFieldComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c24, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.inputElement = _t.first);
    }
  },
  hostVars: 16,
  hostBindings: function NbSearchFieldComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("show", ctx.showClass)("modal-zoomin", ctx.modalZoomin)("rotate-layout", ctx.rotateLayout)("modal-move", ctx.modalMove)("curtain", ctx.curtain)("column-curtain", ctx.columnCurtain)("modal-drop", ctx.modalDrop)("modal-half", ctx.modalHalf);
    }
  },
  inputs: {
    type: "type",
    placeholder: "placeholder",
    hint: "hint",
    show: "show"
  },
  outputs: {
    close: "close",
    search: "search",
    searchInput: "searchInput"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  decls: 10,
  vars: 2,
  consts: [["searchInput", ""], [1, "search", 3, "keyup.esc"], ["nbButton", "", "ghost", "", 1, "close-button", 3, "click"], ["icon", "close-outline", "pack", "nebular-essentials"], [1, "form-wrapper"], [1, "form", 3, "keyup.enter"], [1, "form-content"], ["autocomplete", "off", "tabindex", "-1", 1, "search-input", 3, "input", "blur"], [1, "info"]],
  template: function NbSearchFieldComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = \u0275\u0275getCurrentView();
      \u0275\u0275elementStart(0, "div", 1);
      \u0275\u0275listener("keyup.esc", function NbSearchFieldComponent_Template_div_keyup_esc_0_listener() {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.emitClose());
      });
      \u0275\u0275elementStart(1, "button", 2);
      \u0275\u0275listener("click", function NbSearchFieldComponent_Template_button_click_1_listener() {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.emitClose());
      });
      \u0275\u0275element(2, "nb-icon", 3);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(3, "div", 4)(4, "form", 5);
      \u0275\u0275listener("keyup.enter", function NbSearchFieldComponent_Template_form_keyup_enter_4_listener() {
        \u0275\u0275restoreView(_r1);
        const searchInput_r2 = \u0275\u0275reference(7);
        return \u0275\u0275resetView(ctx.submitSearch(searchInput_r2.value));
      });
      \u0275\u0275elementStart(5, "div", 6)(6, "input", 7, 0);
      \u0275\u0275listener("input", function NbSearchFieldComponent_Template_input_input_6_listener() {
        \u0275\u0275restoreView(_r1);
        const searchInput_r2 = \u0275\u0275reference(7);
        return \u0275\u0275resetView(ctx.emitSearchInput(searchInput_r2.value));
      })("blur", function NbSearchFieldComponent_Template_input_blur_6_listener() {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.focusInput());
      });
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(8, "span", 8);
      \u0275\u0275text(9);
      \u0275\u0275elementEnd()()()();
    }
    if (rf & 2) {
      \u0275\u0275advance(6);
      \u0275\u0275attribute("placeholder", ctx.placeholder);
      \u0275\u0275advance(3);
      \u0275\u0275textInterpolate(ctx.hint);
    }
  },
  dependencies: [\u0275NgNoValidate, NgControlStatusGroup, NgForm, NbIconComponent, NbButtonComponent],
  styles: ['[_nghost-%COMP%]   button[_ngcontent-%COMP%]{margin:0;padding:0;cursor:pointer;border:none;background:none}[_nghost-%COMP%]   button[_ngcontent-%COMP%]:focus{box-shadow:none;outline:none}[_nghost-%COMP%]   input[_ngcontent-%COMP%]{border-top:0;border-right:0;border-left:0;background:transparent;border-radius:0;line-height:1;display:inline-block;box-sizing:border-box;padding:.05rem 0;-webkit-appearance:none}[_nghost-%COMP%]   input[_ngcontent-%COMP%]:focus{outline:none}[_nghost-%COMP%]   input[_ngcontent-%COMP%]::placeholder{opacity:.3}[_nghost-%COMP%]   span[_ngcontent-%COMP%]{font-size:90%;font-weight:700;display:block;width:75%;margin:0 auto;padding:.85rem 0;text-align:right}.modal-zoomin[_nghost-%COMP%]{display:block}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;position:fixed;z-index:1050;top:0;left:0;width:100%;height:100vh;pointer-events:none;opacity:0;transition:opacity .5s}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:before, .modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:after{content:"";position:absolute;width:calc(100% + 15px);height:calc(100% + 15px);pointer-events:none}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:before{top:0;left:0;border-right-width:0;border-bottom-width:0;transform:translate3d(-15px,-15px,0)}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:after{right:0;bottom:0;border-top-width:0;border-left-width:0;transform:translate3d(15px,15px,0)}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{position:absolute;top:3rem;font-size:2.5rem}[dir=ltr]   .modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:3rem}[dir=rtl]   .modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:3rem}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{font-size:10vw;width:75%}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s}.modal-zoomin.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{pointer-events:auto;opacity:1}.modal-zoomin.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:before, .modal-zoomin.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:after{transform:translateZ(0);transition:transform .5s}.modal-zoomin.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1;transform:scaleZ(1)}.modal-zoomin.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{opacity:1;transform:scaleZ(1)}@media screen and (max-width: 40rem){.modal-zoomin[_nghost-%COMP%]   form[_ngcontent-%COMP%]{margin:5rem 0 1rem}.modal-zoomin[_nghost-%COMP%]   span[_ngcontent-%COMP%]{text-align:left}}\n\n\n\n\n\n\n\n\n\n\n\n', "nb-layout.rotate-layout{position:fixed;overflow:hidden;width:100%}  nb-layout.rotate-layout .scrollable-container{position:relative;z-index:10001;transition:transform .5s cubic-bezier(.2,1,.3,1)}  nb-layout.rotate-layout.with-search .scrollable-container{transition:transform .5s cubic-bezier(.2,1,.3,1);transform-origin:50vw 50vh;transform:perspective(1000px) translate3d(0,50vh,0) rotateX(30deg);pointer-events:none}.rotate-layout[_nghost-%COMP%]{position:absolute;display:block;width:100vw;height:100vh;pointer-events:none;opacity:0;transition-property:opacity;transition-delay:.4s}.rotate-layout[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;z-index:1050;position:fixed;top:0;left:0;width:100%;height:50vh;pointer-events:none;opacity:0;transition:opacity .5s;transition-timing-function:cubic-bezier(.2,1,.3,1)}.rotate-layout[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{position:absolute;top:3rem;font-size:2.5rem;opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s;transition-timing-function:cubic-bezier(.2,1,.3,1)}[dir=ltr]   .rotate-layout[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:3rem}[dir=rtl]   .rotate-layout[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:3rem}.rotate-layout[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{margin:5rem 0;opacity:0;transform:scale3d(.7,.7,1);transition:opacity .5s,transform .5s;transition-timing-function:cubic-bezier(.2,1,.3,1)}.rotate-layout[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{font-size:7vw;width:75%}.rotate-layout.show[_nghost-%COMP%]{opacity:1;transition-delay:0s}.rotate-layout.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{pointer-events:auto;opacity:1}.rotate-layout.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1;transform:scaleZ(1)}.rotate-layout.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{opacity:1;transform:scaleZ(1)}\n\n\n\n\n\n", "nb-layout.modal-move .layout{transition:transform .5s}  nb-layout.modal-move.with-search .layout{transform:scale3d(.8,.8,1);pointer-events:none}.modal-move[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;position:fixed;z-index:1050;top:0;left:0;width:100%;height:100vh;pointer-events:none;opacity:0;transition:opacity .5s}.modal-move[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{position:absolute;top:3rem;font-size:2.5rem;opacity:0;transition:opacity .5s}[dir=ltr]   .modal-move[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:3rem}[dir=rtl]   .modal-move[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:3rem}.modal-move[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{margin:5rem 0;opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s}.modal-move[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{font-size:10vw;width:75%;transform:scale3d(0,1,1);transform-origin:0 50%;transition:transform .3s}.modal-move.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{pointer-events:auto;opacity:1}.modal-move.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1}.modal-move.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{opacity:1;transform:scaleZ(1)}.modal-move.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{transform:scaleZ(1);transition-duration:.5s}@media screen and (max-width: 40rem){.modal-move[_nghost-%COMP%]   span[_ngcontent-%COMP%]{text-align:left}}\n\n\n\n\n\n", '.curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{position:fixed;z-index:1050;top:0;left:100%;overflow:hidden;height:100vh;width:100%;padding:3rem;pointer-events:none;transition:transform .3s;transition-delay:.4s;transition-timing-function:ease-out}.curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:after{content:"";position:absolute;top:0;left:0;width:100%;height:100%;transition:transform .3s;transition-timing-function:ease-out}.curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{font-size:2.5rem;position:absolute;top:3rem;transition:opacity .1s;transition-delay:.3s}[dir=ltr]   .curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:3rem}[dir=rtl]   .curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:3rem}.curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{width:50%;opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s}.curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{width:100%;font-size:6vw}.curtain.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{width:100%;pointer-events:auto;transform:translate3d(-100%,0,0);transition-delay:0s}.curtain.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:after{transform:translate3d(100%,0,0);transition-delay:.4s}.curtain.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1;transform:scaleZ(1)}.curtain.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{opacity:1;transform:scaleZ(1)}@media screen and (max-width: 40em){.curtain[_nghost-%COMP%]   span[_ngcontent-%COMP%]{width:90%}.curtain[_nghost-%COMP%]   input[_ngcontent-%COMP%]{font-size:2em;width:90%}}  nb-layout.curtain .scrollable-container{position:relative;z-index:0}\n\n\n\n\n\n\n\n\n\n\n\n', 'nb-layout.column-curtain.with-search .layout{pointer-events:none}.column-curtain[_nghost-%COMP%]{display:block;position:fixed;z-index:1050;top:0;left:50%;overflow:hidden;width:50%;height:100vh;pointer-events:none}.column-curtain[_nghost-%COMP%]:before{content:"";position:absolute;top:0;left:0;width:100%;height:100%;transform:scale3d(0,1,1);transform-origin:0 50%;transition:transform .3s;transition-timing-function:cubic-bezier(.86,0,.07,1)}.column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{position:relative;padding:2.5rem 1.5rem 0;background:transparent}.column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{position:absolute;top:2rem;font-size:2.5rem;opacity:0;transition:opacity .5s}[dir=ltr]   .column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:2rem}[dir=rtl]   .column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:2rem}.column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{width:85%;transform:translate3d(-150%,0,0);transition:transform .3s}.column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{font-size:2.5rem;width:100%}.column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{font-size:85%}.column-curtain.show[_nghost-%COMP%]{pointer-events:auto}.column-curtain.show[_nghost-%COMP%]:before{transform:scaleZ(1)}.column-curtain.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{transform:translateZ(0);transition-delay:.15s;transition-timing-function:cubic-bezier(.86,0,.07,1)}.column-curtain.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1;z-index:100}@media screen and (max-width: 40rem){.column-curtain[_nghost-%COMP%]   span[_ngcontent-%COMP%]{width:90%}.column-curtain[_nghost-%COMP%]   input[_ngcontent-%COMP%]{font-size:2rem;width:90%}}\n\n\n\n\n\n\n\n\n\n\n\n', 'nb-layout.modal-drop .layout{position:relative;transition:transform .4s,opacity .4s;transition-timing-function:cubic-bezier(.4,0,.2,1)}  nb-layout.modal-drop.with-search .layout{opacity:0;transform:scale3d(.9,.9,1);pointer-events:none}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;z-index:1050;position:fixed;top:0;left:0;width:100%;height:100vh;background:none;pointer-events:none}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:before{content:"";position:absolute;top:0;right:0;width:100%;height:100%;opacity:0;transition:opacity .4s}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{font-size:2.5rem;position:absolute;top:3rem;display:block;opacity:0;transition:opacity .4s}[dir=ltr]   .modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:3rem}[dir=rtl]   .modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:3rem}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{position:relative;margin:5rem 0 2rem}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{font-size:6vw;width:60%;padding:.25rem;text-align:center;opacity:0;transition:opacity .4s}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{position:relative;z-index:9;display:block;width:60%;padding:.85rem 0;opacity:0;transform:translate3d(0,-50px,0);transition:opacity .4s,transform .4s}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   .form-content[_ngcontent-%COMP%]{position:relative;z-index:10;overflow:hidden;transform:translate3d(0,-50px,0);transition:transform .4s}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   .form-content[_ngcontent-%COMP%]:after{content:"";position:absolute;top:0;left:20%;width:60%;height:105%;opacity:0;transform-origin:50% 0}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{pointer-events:auto}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:before{opacity:1}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   .form-content[_ngcontent-%COMP%]{transform:translateZ(0);transition:none}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   .form-content[_ngcontent-%COMP%]:after{animation:_ngcontent-%COMP%_scaleUpDown .8s cubic-bezier(.4,0,.2,1) forwards}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{opacity:1;transition:opacity 0s .4s}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{opacity:1;transform:translateZ(0);transition-delay:.4s;transition-timing-function:ease-out}@keyframes _ngcontent-%COMP%_scaleUpDown{0%{opacity:1;transform:scale3d(1,0,1)}50%{transform:scaleZ(1);transform-origin:50% 0;transition-timing-function:ease-out}50.1%{transform-origin:50% 100%;transition-timing-function:ease-out}to{opacity:1;transform:scale3d(1,0,1);transform-origin:50% 100%;transition-timing-function:ease-out}}@media screen and (max-width: 40rem){.modal-drop[_nghost-%COMP%]   form[_ngcontent-%COMP%]{margin:2rem 0}.modal-drop[_nghost-%COMP%]   input[_ngcontent-%COMP%]{width:100%;left:0}}\n\n\n\n\n\n', 'nb-layout.modal-half .layout{transition:transform .6s,opacity .6s;transition-timing-function:cubic-bezier(.2,1,.3,1)}  nb-layout.modal-half.with-search .layout{transform:scale3d(.8,.8,1);pointer-events:none}.modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{text-align:center;position:fixed;z-index:1050;top:0;left:0;overflow:hidden;width:100%;height:100vh;background:none;pointer-events:none}.modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:before{content:"";position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;opacity:0;transition:opacity .6s;transition-timing-function:cubic-bezier(.2,1,.3,1)}.modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{font-size:2.5rem;position:absolute;top:3rem;display:block;z-index:100;opacity:0;transform:scale3d(.8,.8,1);transition:opacity .6s,transform .6s;transition-timing-function:cubic-bezier(.2,1,.3,1)}[dir=ltr]   .modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:3rem}[dir=rtl]   .modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:3rem}.modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   .form-wrapper[_ngcontent-%COMP%]{position:absolute;display:flex;justify-content:center;align-items:center;width:100%;height:50%;transition:transform .6s;transition-timing-function:cubic-bezier(.2,1,.3,1);transform:translate3d(0,-100%,0)}.modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{width:75%;margin:0 auto}.modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{font-size:7vw;width:100%}.modal-half.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{pointer-events:auto}.modal-half.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:before{opacity:1}.modal-half.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1;transform:scaleZ(1)}.modal-half.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   .form-wrapper[_ngcontent-%COMP%]{transform:translateZ(0)}\n\n\n\n\n\n'],
  changeDetection: 0
});
var NbSearchFieldComponent = _NbSearchFieldComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSearchFieldComponent, [{
    type: Component,
    args: [{
      selector: "nb-search-field",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <div class="search" (keyup.esc)="emitClose()">
      <button (click)="emitClose()" nbButton ghost class="close-button">
        <nb-icon icon="close-outline" pack="nebular-essentials"></nb-icon>
      </button>
      <div class="form-wrapper">
        <form class="form" (keyup.enter)="submitSearch(searchInput.value)">
          <div class="form-content">
            <input class="search-input"
                   #searchInput
                   (input)="emitSearchInput(searchInput.value)"
                   autocomplete="off"
                   [attr.placeholder]="placeholder"
                   tabindex="-1"
                   (blur)="focusInput()"/>
          </div>
          <span class="info">{{ hint }}</span>
        </form>
      </div>
    </div>
  `,
      standalone: false,
      styles: [':host button{margin:0;padding:0;cursor:pointer;border:none;background:none}:host button:focus{box-shadow:none;outline:none}:host input{border-top:0;border-right:0;border-left:0;background:transparent;border-radius:0;line-height:1;display:inline-block;box-sizing:border-box;padding:.05rem 0;-webkit-appearance:none}:host input:focus{outline:none}:host input::placeholder{opacity:.3}:host span{font-size:90%;font-weight:700;display:block;width:75%;margin:0 auto;padding:.85rem 0;text-align:right}:host.modal-zoomin{display:block}:host.modal-zoomin .search{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;position:fixed;z-index:1050;top:0;left:0;width:100%;height:100vh;pointer-events:none;opacity:0;transition:opacity .5s}:host.modal-zoomin .search:before,:host.modal-zoomin .search:after{content:"";position:absolute;width:calc(100% + 15px);height:calc(100% + 15px);pointer-events:none}:host.modal-zoomin .search:before{top:0;left:0;border-right-width:0;border-bottom-width:0;transform:translate3d(-15px,-15px,0)}:host.modal-zoomin .search:after{right:0;bottom:0;border-top-width:0;border-left-width:0;transform:translate3d(15px,15px,0)}:host.modal-zoomin .search button{position:absolute;top:3rem;font-size:2.5rem}[dir=ltr] :host.modal-zoomin .search button{right:3rem}[dir=rtl] :host.modal-zoomin .search button{left:3rem}:host.modal-zoomin .search input{font-size:10vw;width:75%}:host.modal-zoomin .search button{opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s}:host.modal-zoomin .search form{opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s}:host.modal-zoomin.show .search{pointer-events:auto;opacity:1}:host.modal-zoomin.show .search:before,:host.modal-zoomin.show .search:after{transform:translateZ(0);transition:transform .5s}:host.modal-zoomin.show .search button{opacity:1;transform:scaleZ(1)}:host.modal-zoomin.show .search form{opacity:1;transform:scaleZ(1)}@media screen and (max-width: 40rem){:host.modal-zoomin form{margin:5rem 0 1rem}:host.modal-zoomin span{text-align:left}}\n/**\n* @license\n* Copyright Akveo. All Rights Reserved.\n* Licensed under the MIT License. See License.txt in the project root for license information.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n', "::ng-deep nb-layout.rotate-layout{position:fixed;overflow:hidden;width:100%}::ng-deep nb-layout.rotate-layout .scrollable-container{position:relative;z-index:10001;transition:transform .5s cubic-bezier(.2,1,.3,1)}::ng-deep nb-layout.rotate-layout.with-search .scrollable-container{transition:transform .5s cubic-bezier(.2,1,.3,1);transform-origin:50vw 50vh;transform:perspective(1000px) translate3d(0,50vh,0) rotateX(30deg);pointer-events:none}:host.rotate-layout{position:absolute;display:block;width:100vw;height:100vh;pointer-events:none;opacity:0;transition-property:opacity;transition-delay:.4s}:host.rotate-layout .search{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;z-index:1050;position:fixed;top:0;left:0;width:100%;height:50vh;pointer-events:none;opacity:0;transition:opacity .5s;transition-timing-function:cubic-bezier(.2,1,.3,1)}:host.rotate-layout .search button{position:absolute;top:3rem;font-size:2.5rem;opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s;transition-timing-function:cubic-bezier(.2,1,.3,1)}[dir=ltr] :host.rotate-layout .search button{right:3rem}[dir=rtl] :host.rotate-layout .search button{left:3rem}:host.rotate-layout .search form{margin:5rem 0;opacity:0;transform:scale3d(.7,.7,1);transition:opacity .5s,transform .5s;transition-timing-function:cubic-bezier(.2,1,.3,1)}:host.rotate-layout .search input{font-size:7vw;width:75%}:host.rotate-layout.show{opacity:1;transition-delay:0s}:host.rotate-layout.show .search{pointer-events:auto;opacity:1}:host.rotate-layout.show .search button{opacity:1;transform:scaleZ(1)}:host.rotate-layout.show .search form{opacity:1;transform:scaleZ(1)}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n", "::ng-deep nb-layout.modal-move .layout{transition:transform .5s}::ng-deep nb-layout.modal-move.with-search .layout{transform:scale3d(.8,.8,1);pointer-events:none}:host.modal-move .search{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;position:fixed;z-index:1050;top:0;left:0;width:100%;height:100vh;pointer-events:none;opacity:0;transition:opacity .5s}:host.modal-move .search button{position:absolute;top:3rem;font-size:2.5rem;opacity:0;transition:opacity .5s}[dir=ltr] :host.modal-move .search button{right:3rem}[dir=rtl] :host.modal-move .search button{left:3rem}:host.modal-move .search form{margin:5rem 0;opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s}:host.modal-move .search input{font-size:10vw;width:75%;transform:scale3d(0,1,1);transform-origin:0 50%;transition:transform .3s}:host.modal-move.show .search{pointer-events:auto;opacity:1}:host.modal-move.show .search button{opacity:1}:host.modal-move.show .search form{opacity:1;transform:scaleZ(1)}:host.modal-move.show .search input{transform:scaleZ(1);transition-duration:.5s}@media screen and (max-width: 40rem){:host.modal-move span{text-align:left}}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n", ':host.curtain .search{position:fixed;z-index:1050;top:0;left:100%;overflow:hidden;height:100vh;width:100%;padding:3rem;pointer-events:none;transition:transform .3s;transition-delay:.4s;transition-timing-function:ease-out}:host.curtain .search:after{content:"";position:absolute;top:0;left:0;width:100%;height:100%;transition:transform .3s;transition-timing-function:ease-out}:host.curtain .search button{font-size:2.5rem;position:absolute;top:3rem;transition:opacity .1s;transition-delay:.3s}[dir=ltr] :host.curtain .search button{right:3rem}[dir=rtl] :host.curtain .search button{left:3rem}:host.curtain .search form{width:50%;opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s}:host.curtain .search input{width:100%;font-size:6vw}:host.curtain.show .search{width:100%;pointer-events:auto;transform:translate3d(-100%,0,0);transition-delay:0s}:host.curtain.show .search:after{transform:translate3d(100%,0,0);transition-delay:.4s}:host.curtain.show .search button{opacity:1;transform:scaleZ(1)}:host.curtain.show .search form{opacity:1;transform:scaleZ(1)}@media screen and (max-width: 40em){:host.curtain span{width:90%}:host.curtain input{font-size:2em;width:90%}}::ng-deep nb-layout.curtain .scrollable-container{position:relative;z-index:0}\n/**\n* @license\n* Copyright Akveo. All Rights Reserved.\n* Licensed under the MIT License. See License.txt in the project root for license information.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n', '::ng-deep nb-layout.column-curtain.with-search .layout{pointer-events:none}:host.column-curtain{display:block;position:fixed;z-index:1050;top:0;left:50%;overflow:hidden;width:50%;height:100vh;pointer-events:none}:host.column-curtain:before{content:"";position:absolute;top:0;left:0;width:100%;height:100%;transform:scale3d(0,1,1);transform-origin:0 50%;transition:transform .3s;transition-timing-function:cubic-bezier(.86,0,.07,1)}:host.column-curtain .search{position:relative;padding:2.5rem 1.5rem 0;background:transparent}:host.column-curtain .search button{position:absolute;top:2rem;font-size:2.5rem;opacity:0;transition:opacity .5s}[dir=ltr] :host.column-curtain .search button{right:2rem}[dir=rtl] :host.column-curtain .search button{left:2rem}:host.column-curtain .search form{width:85%;transform:translate3d(-150%,0,0);transition:transform .3s}:host.column-curtain .search input{font-size:2.5rem;width:100%}:host.column-curtain .search span{font-size:85%}:host.column-curtain.show{pointer-events:auto}:host.column-curtain.show:before{transform:scaleZ(1)}:host.column-curtain.show .search form{transform:translateZ(0);transition-delay:.15s;transition-timing-function:cubic-bezier(.86,0,.07,1)}:host.column-curtain.show .search button{opacity:1;z-index:100}@media screen and (max-width: 40rem){:host.column-curtain span{width:90%}:host.column-curtain input{font-size:2rem;width:90%}}\n/**\n* @license\n* Copyright Akveo. All Rights Reserved.\n* Licensed under the MIT License. See License.txt in the project root for license information.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n', '::ng-deep nb-layout.modal-drop .layout{position:relative;transition:transform .4s,opacity .4s;transition-timing-function:cubic-bezier(.4,0,.2,1)}::ng-deep nb-layout.modal-drop.with-search .layout{opacity:0;transform:scale3d(.9,.9,1);pointer-events:none}:host.modal-drop .search{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;z-index:1050;position:fixed;top:0;left:0;width:100%;height:100vh;background:none;pointer-events:none}:host.modal-drop .search:before{content:"";position:absolute;top:0;right:0;width:100%;height:100%;opacity:0;transition:opacity .4s}:host.modal-drop .search button{font-size:2.5rem;position:absolute;top:3rem;display:block;opacity:0;transition:opacity .4s}[dir=ltr] :host.modal-drop .search button{right:3rem}[dir=rtl] :host.modal-drop .search button{left:3rem}:host.modal-drop .search form{position:relative;margin:5rem 0 2rem}:host.modal-drop .search input{font-size:6vw;width:60%;padding:.25rem;text-align:center;opacity:0;transition:opacity .4s}:host.modal-drop .search span{position:relative;z-index:9;display:block;width:60%;padding:.85rem 0;opacity:0;transform:translate3d(0,-50px,0);transition:opacity .4s,transform .4s}:host.modal-drop .search .form-content{position:relative;z-index:10;overflow:hidden;transform:translate3d(0,-50px,0);transition:transform .4s}:host.modal-drop .search .form-content:after{content:"";position:absolute;top:0;left:20%;width:60%;height:105%;opacity:0;transform-origin:50% 0}:host.modal-drop.show .search{pointer-events:auto}:host.modal-drop.show .search:before{opacity:1}:host.modal-drop.show .search button{opacity:1}:host.modal-drop.show .search .form-content{transform:translateZ(0);transition:none}:host.modal-drop.show .search .form-content:after{animation:scaleUpDown .8s cubic-bezier(.4,0,.2,1) forwards}:host.modal-drop.show .search input{opacity:1;transition:opacity 0s .4s}:host.modal-drop.show .search span{opacity:1;transform:translateZ(0);transition-delay:.4s;transition-timing-function:ease-out}@keyframes scaleUpDown{0%{opacity:1;transform:scale3d(1,0,1)}50%{transform:scaleZ(1);transform-origin:50% 0;transition-timing-function:ease-out}50.1%{transform-origin:50% 100%;transition-timing-function:ease-out}to{opacity:1;transform:scale3d(1,0,1);transform-origin:50% 100%;transition-timing-function:ease-out}}@media screen and (max-width: 40rem){:host.modal-drop form{margin:2rem 0}:host.modal-drop input{width:100%;left:0}}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n', '::ng-deep nb-layout.modal-half .layout{transition:transform .6s,opacity .6s;transition-timing-function:cubic-bezier(.2,1,.3,1)}::ng-deep nb-layout.modal-half.with-search .layout{transform:scale3d(.8,.8,1);pointer-events:none}:host.modal-half .search{text-align:center;position:fixed;z-index:1050;top:0;left:0;overflow:hidden;width:100%;height:100vh;background:none;pointer-events:none}:host.modal-half .search:before{content:"";position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;opacity:0;transition:opacity .6s;transition-timing-function:cubic-bezier(.2,1,.3,1)}:host.modal-half .search button{font-size:2.5rem;position:absolute;top:3rem;display:block;z-index:100;opacity:0;transform:scale3d(.8,.8,1);transition:opacity .6s,transform .6s;transition-timing-function:cubic-bezier(.2,1,.3,1)}[dir=ltr] :host.modal-half .search button{right:3rem}[dir=rtl] :host.modal-half .search button{left:3rem}:host.modal-half .search .form-wrapper{position:absolute;display:flex;justify-content:center;align-items:center;width:100%;height:50%;transition:transform .6s;transition-timing-function:cubic-bezier(.2,1,.3,1);transform:translate3d(0,-100%,0)}:host.modal-half .search form{width:75%;margin:0 auto}:host.modal-half .search input{font-size:7vw;width:100%}:host.modal-half.show .search{pointer-events:auto}:host.modal-half.show .search:before{opacity:1}:host.modal-half.show .search button{opacity:1;transform:scaleZ(1)}:host.modal-half.show .search .form-wrapper{transform:translateZ(0)}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n']
    }]
  }], null, {
    type: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    hint: [{
      type: Input
    }],
    show: [{
      type: Input
    }],
    close: [{
      type: Output
    }],
    search: [{
      type: Output
    }],
    searchInput: [{
      type: Output
    }],
    inputElement: [{
      type: ViewChild,
      args: ["searchInput"]
    }],
    showClass: [{
      type: HostBinding,
      args: ["class.show"]
    }],
    modalZoomin: [{
      type: HostBinding,
      args: ["class.modal-zoomin"]
    }],
    rotateLayout: [{
      type: HostBinding,
      args: ["class.rotate-layout"]
    }],
    modalMove: [{
      type: HostBinding,
      args: ["class.modal-move"]
    }],
    curtain: [{
      type: HostBinding,
      args: ["class.curtain"]
    }],
    columnCurtain: [{
      type: HostBinding,
      args: ["class.column-curtain"]
    }],
    modalDrop: [{
      type: HostBinding,
      args: ["class.modal-drop"]
    }],
    modalHalf: [{
      type: HostBinding,
      args: ["class.modal-half"]
    }]
  });
})();
var _NbSearchComponent = class _NbSearchComponent {
  constructor(searchService, themeService, router, overlayService, changeDetector) {
    this.searchService = searchService;
    this.themeService = themeService;
    this.router = router;
    this.overlayService = overlayService;
    this.changeDetector = changeDetector;
    this.destroy$ = new Subject();
    this.showSearchField = false;
    this.placeholder = "Search...";
    this.hint = "Hit enter to search";
  }
  ngOnInit() {
    this.router.events.pipe(filter((event) => event instanceof NavigationEnd), takeUntil(this.destroy$)).subscribe(() => this.hideSearch());
    this.searchService.onSearchActivate().pipe(filter((data) => !this.tag || data.tag === this.tag), takeUntil(this.destroy$)).subscribe(() => this.openSearch());
    this.searchService.onSearchDeactivate().pipe(filter((data) => !this.tag || data.tag === this.tag), takeUntil(this.destroy$)).subscribe(() => this.hideSearch());
  }
  ngOnDestroy() {
    if (this.overlayRef && this.overlayRef.hasAttached()) {
      this.removeLayoutClasses();
      this.overlayRef.detach();
    }
    this.destroy$.next();
    this.destroy$.complete();
  }
  openSearch() {
    if (!this.overlayRef) {
      this.overlayRef = this.overlayService.create();
      this.overlayRef.attach(this.searchFieldPortal);
    }
    this.themeService.appendLayoutClass(this.type);
    of(null).pipe(delay(0)).subscribe(() => {
      this.themeService.appendLayoutClass("with-search");
      this.showSearchField = true;
      this.changeDetector.detectChanges();
    });
  }
  hideSearch() {
    this.removeLayoutClasses();
    this.showSearchField = false;
    this.changeDetector.detectChanges();
    this.searchButton.nativeElement.focus();
  }
  search(term) {
    this.searchService.submitSearch(term, this.tag);
    this.hideSearch();
  }
  emitInput(term) {
    this.searchService.searchInput(term, this.tag);
  }
  emitActivate() {
    this.searchService.activateSearch(this.type, this.tag);
  }
  emitDeactivate() {
    this.searchService.deactivateSearch(this.type, this.tag);
  }
  removeLayoutClasses() {
    this.themeService.removeLayoutClass("with-search");
    of(null).pipe(delay(500)).subscribe(() => {
      this.themeService.removeLayoutClass(this.type);
    });
  }
};
_NbSearchComponent.\u0275fac = function NbSearchComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbSearchComponent)(\u0275\u0275directiveInject(NbSearchService), \u0275\u0275directiveInject(NbThemeService), \u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(NbOverlayService), \u0275\u0275directiveInject(ChangeDetectorRef));
};
_NbSearchComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbSearchComponent,
  selectors: [["nb-search"]],
  viewQuery: function NbSearchComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(NbPortalDirective, 5);
      \u0275\u0275viewQuery(_c25, 5, ElementRef);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.searchFieldPortal = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.searchButton = _t.first);
    }
  },
  inputs: {
    tag: "tag",
    placeholder: "placeholder",
    hint: "hint",
    type: "type"
  },
  standalone: false,
  decls: 4,
  vars: 0,
  consts: [["searchButton", ""], ["nbButton", "", "ghost", "", 1, "start-search", 3, "click"], ["icon", "search-outline", "pack", "nebular-essentials"], [3, "show", "type", "placeholder", "hint", "search", "searchInput", "close", 4, "nbPortal"], [3, "search", "searchInput", "close", "show", "type", "placeholder", "hint"]],
  template: function NbSearchComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = \u0275\u0275getCurrentView();
      \u0275\u0275elementStart(0, "button", 1, 0);
      \u0275\u0275listener("click", function NbSearchComponent_Template_button_click_0_listener() {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.emitActivate());
      });
      \u0275\u0275element(2, "nb-icon", 2);
      \u0275\u0275elementEnd();
      \u0275\u0275template(3, NbSearchComponent_nb_search_field_3_Template, 1, 4, "nb-search-field", 3);
    }
  },
  dependencies: [NbPortalDirective, NbIconComponent, NbButtonComponent, NbSearchFieldComponent],
  styles: ["[_nghost-%COMP%]   button[_ngcontent-%COMP%]{font-size:2rem;margin:0 auto;padding:0;cursor:pointer;border:none;background:none}[_nghost-%COMP%]   button[_ngcontent-%COMP%]:focus{box-shadow:none;outline:none}  nb-layout.with-search .scrollable-container{position:relative;z-index:0}\n\n\n\n\n\n"],
  changeDetection: 0
});
var NbSearchComponent = _NbSearchComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSearchComponent, [{
    type: Component,
    args: [{
      selector: "nb-search",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <button #searchButton class="start-search" (click)="emitActivate()" nbButton ghost>
      <nb-icon icon="search-outline" pack="nebular-essentials"></nb-icon>
    </button>
    <nb-search-field
      *nbPortal
      [show]="showSearchField"
      [type]="type"
      [placeholder]="placeholder"
      [hint]="hint"
      (search)="search($event)"
      (searchInput)="emitInput($event)"
      (close)="emitDeactivate()">
    </nb-search-field>
  `,
      standalone: false,
      styles: [":host button{font-size:2rem;margin:0 auto;padding:0;cursor:pointer;border:none;background:none}:host button:focus{box-shadow:none;outline:none}::ng-deep nb-layout.with-search .scrollable-container{position:relative;z-index:0}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: NbSearchService
  }, {
    type: NbThemeService
  }, {
    type: Router
  }, {
    type: NbOverlayService
  }, {
    type: ChangeDetectorRef
  }], {
    tag: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    hint: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    searchFieldPortal: [{
      type: ViewChild,
      args: [NbPortalDirective]
    }],
    searchButton: [{
      type: ViewChild,
      args: ["searchButton", {
        read: ElementRef
      }]
    }]
  });
})();
var _NbSearchModule = class _NbSearchModule {
};
_NbSearchModule.\u0275fac = function NbSearchModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbSearchModule)();
};
_NbSearchModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbSearchModule,
  declarations: [NbSearchComponent, NbSearchFieldComponent],
  imports: [NbSharedModule, NbOverlayModule, NbIconModule, NbButtonModule],
  exports: [NbSearchComponent, NbSearchFieldComponent]
});
_NbSearchModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [NbSearchService],
  imports: [NbSharedModule, NbOverlayModule, NbIconModule, NbButtonModule]
});
var NbSearchModule = _NbSearchModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSearchModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbOverlayModule, NbIconModule, NbButtonModule],
      declarations: [NbSearchComponent, NbSearchFieldComponent],
      exports: [NbSearchComponent, NbSearchFieldComponent],
      providers: [NbSearchService]
    }]
  }], null, null);
})();
var _NbCheckboxComponent = class _NbCheckboxComponent {
  get checked() {
    return this._checked;
  }
  set checked(value) {
    this._checked = convertToBoolProperty(value);
  }
  /**
   * Controls input disabled state
   */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = convertToBoolProperty(value);
  }
  /**
   * Controls checkbox indeterminate state
   */
  get indeterminate() {
    return this._indeterminate;
  }
  set indeterminate(value) {
    this._indeterminate = convertToBoolProperty(value);
  }
  get primary() {
    return this.status === "primary";
  }
  get success() {
    return this.status === "success";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get info() {
    return this.status === "info";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  constructor(changeDetector, renderer, hostElement, zone, statusService) {
    this.changeDetector = changeDetector;
    this.renderer = renderer;
    this.hostElement = hostElement;
    this.zone = zone;
    this.statusService = statusService;
    this.onChange = () => {
    };
    this.onTouched = () => {
    };
    this._checked = false;
    this._disabled = false;
    this.status = "basic";
    this._indeterminate = false;
    this.checkedChange = new EventEmitter();
  }
  ngAfterViewInit() {
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this.hostElement.nativeElement, "nb-transition");
    }));
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  writeValue(val) {
    this._checked = val;
    this.changeDetector.markForCheck();
  }
  setDisabledState(val) {
    this.disabled = convertToBoolProperty(val);
    this.changeDetector.markForCheck();
  }
  setTouched() {
    this.onTouched();
  }
  updateValueAndIndeterminate(event) {
    const input2 = event.target;
    this.checked = input2.checked;
    this.checkedChange.emit(this.checked);
    this.onChange(this.checked);
    this.indeterminate = input2.indeterminate;
  }
};
_NbCheckboxComponent.\u0275fac = function NbCheckboxComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbCheckboxComponent)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(NbStatusService));
};
_NbCheckboxComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbCheckboxComponent,
  selectors: [["nb-checkbox"]],
  hostVars: 16,
  hostBindings: function NbCheckboxComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classMap(ctx.additionalClasses);
      \u0275\u0275classProp("status-primary", ctx.primary)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-info", ctx.info)("status-basic", ctx.basic)("status-control", ctx.control);
    }
  },
  inputs: {
    checked: "checked",
    disabled: "disabled",
    status: "status",
    indeterminate: "indeterminate"
  },
  outputs: {
    checkedChange: "checkedChange"
  },
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => _NbCheckboxComponent),
    multi: true
  }])],
  ngContentSelectors: _c0,
  decls: 7,
  vars: 9,
  consts: [[1, "label"], ["type", "checkbox", 1, "native-input", "visually-hidden", 3, "change", "blur", "click", "disabled", "checked", "indeterminate"], [1, "custom-checkbox"], ["icon", "minus-bold-outline", "pack", "nebular-essentials", "class", "custom-checkbox-icon", 4, "ngIf"], ["icon", "checkmark-bold-outline", "pack", "nebular-essentials", "class", "custom-checkbox-icon", 4, "ngIf"], [1, "text"], ["icon", "minus-bold-outline", "pack", "nebular-essentials", 1, "custom-checkbox-icon"], ["icon", "checkmark-bold-outline", "pack", "nebular-essentials", 1, "custom-checkbox-icon"]],
  template: function NbCheckboxComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275elementStart(0, "label", 0)(1, "input", 1);
      \u0275\u0275listener("change", function NbCheckboxComponent_Template_input_change_1_listener($event) {
        return ctx.updateValueAndIndeterminate($event);
      })("blur", function NbCheckboxComponent_Template_input_blur_1_listener() {
        return ctx.setTouched();
      })("click", function NbCheckboxComponent_Template_input_click_1_listener($event) {
        return $event.stopPropagation();
      });
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(2, "span", 2);
      \u0275\u0275template(3, NbCheckboxComponent_nb_icon_3_Template, 1, 0, "nb-icon", 3)(4, NbCheckboxComponent_nb_icon_4_Template, 1, 0, "nb-icon", 4);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(5, "span", 5);
      \u0275\u0275projection(6);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275advance();
      \u0275\u0275property("disabled", ctx.disabled)("checked", ctx.checked)("indeterminate", ctx.indeterminate);
      \u0275\u0275advance();
      \u0275\u0275classProp("indeterminate", ctx.indeterminate)("checked", ctx.checked);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.indeterminate);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.checked && !ctx.indeterminate);
    }
  },
  dependencies: [NgIf, NbIconComponent],
  styles: ["[_nghost-%COMP%]   .label[_ngcontent-%COMP%]{position:relative;display:inline-flex;align-items:center;margin:0;min-height:inherit}[_nghost-%COMP%]   .custom-checkbox[_ngcontent-%COMP%]{flex-shrink:0}.nb-transition[_nghost-%COMP%]   .custom-checkbox[_ngcontent-%COMP%]{transition-duration:.15s;transition-property:background-color,border,box-shadow;transition-timing-function:ease-in}.nb-transition[_nghost-%COMP%]   .text[_ngcontent-%COMP%]{transition-duration:.15s;transition-property:color;transition-timing-function:ease-in}\n\n\n\n\n\n"],
  changeDetection: 0
});
var NbCheckboxComponent = _NbCheckboxComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCheckboxComponent, [{
    type: Component,
    args: [{
      selector: "nb-checkbox",
      template: `
    <label class="label">
      <input type="checkbox" class="native-input visually-hidden"
             [disabled]="disabled"
             [checked]="checked"
             (change)="updateValueAndIndeterminate($event)"
             (blur)="setTouched()"
             (click)="$event.stopPropagation()"
             [indeterminate]="indeterminate">
      <span [class.indeterminate]="indeterminate" [class.checked]="checked" class="custom-checkbox">
        <nb-icon *ngIf="indeterminate" icon="minus-bold-outline" pack="nebular-essentials" class="custom-checkbox-icon"></nb-icon>
        <nb-icon *ngIf="checked && !indeterminate" icon="checkmark-bold-outline" pack="nebular-essentials" class="custom-checkbox-icon"></nb-icon>
      </span>
      <span class="text">
        <ng-content></ng-content>
      </span>
    </label>
  `,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NbCheckboxComponent),
        multi: true
      }],
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      styles: [":host .label{position:relative;display:inline-flex;align-items:center;margin:0;min-height:inherit}:host .custom-checkbox{flex-shrink:0}:host(.nb-transition) .custom-checkbox{transition-duration:.15s;transition-property:background-color,border,box-shadow;transition-timing-function:ease-in}:host(.nb-transition) .text{transition-duration:.15s;transition-property:color;transition-timing-function:ease-in}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }], {
    checked: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    indeterminate: [{
      type: Input
    }],
    checkedChange: [{
      type: Output
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var _NbCheckboxModule = class _NbCheckboxModule {
};
_NbCheckboxModule.\u0275fac = function NbCheckboxModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbCheckboxModule)();
};
_NbCheckboxModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbCheckboxModule,
  declarations: [NbCheckboxComponent],
  imports: [NbSharedModule, NbIconModule],
  exports: [NbCheckboxComponent]
});
_NbCheckboxModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NbSharedModule, NbIconModule]
});
var NbCheckboxModule = _NbCheckboxModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCheckboxModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbIconModule],
      declarations: [NbCheckboxComponent],
      exports: [NbCheckboxComponent]
    }]
  }], null, null);
})();
var _NbDynamicOverlay = class _NbDynamicOverlay {
  get isAttached() {
    return this.ref && this.ref.hasAttached();
  }
  get isShown() {
    return this.isShown$.pipe(distinctUntilChanged());
  }
  constructor(overlay, zone, overlayContainer) {
    this.overlay = overlay;
    this.zone = zone;
    this.overlayContainer = overlayContainer;
    this.context = {};
    this.overlayConfig = {};
    this.disabled = false;
    this.positionStrategyChange$ = new Subject();
    this.isShown$ = new BehaviorSubject(false);
    this.destroy$ = new Subject();
    this.overlayDestroy$ = new Subject();
  }
  create(componentType, content, context, positionStrategy, overlayConfig = {}, disabled = false) {
    this.setContentAndContext(content, context);
    this.setComponent(componentType);
    this.setPositionStrategy(positionStrategy);
    this.setOverlayConfig(overlayConfig);
    this.setDisabled(disabled);
    return this;
  }
  setContent(content) {
    this.content = content;
    if (this.container) {
      this.updateContext();
    }
    this.updatePosition();
  }
  setContext(context) {
    this.context = context;
    if (this.container) {
      this.updateContext();
    }
    this.updatePosition();
  }
  setContentAndContext(content, context) {
    this.content = content;
    this.context = context;
    if (this.container) {
      this.updateContext();
    }
    this.updatePosition();
  }
  setComponent(componentType) {
    this.componentType = componentType;
    const wasAttached = this.isAttached;
    this.disposeOverlayRef();
    if (wasAttached) {
      this.show();
    }
  }
  setPositionStrategy(positionStrategy) {
    this.positionStrategyChange$.next();
    this.positionStrategy = positionStrategy;
    this.positionStrategy.positionChange.pipe(filter(() => !!this.container), takeUntil(merge(this.positionStrategyChange$, this.destroy$))).subscribe((position) => {
      this.lastAppliedPosition = position;
      patch(this.container, {
        position
      });
    });
    if (this.ref) {
      this.ref.updatePositionStrategy(this.positionStrategy);
    }
  }
  setOverlayConfig(overlayConfig) {
    this.overlayConfig = overlayConfig;
    const wasAttached = this.isAttached;
    this.disposeOverlayRef();
    if (wasAttached) {
      this.show();
    }
  }
  setDisabled(disabled) {
    if (disabled && this.isShown$.value) {
      this.hide();
    }
    this.disabled = disabled;
  }
  show() {
    if (this.disabled) {
      return;
    }
    if (!this.ref) {
      this.createOverlay();
    }
    this.renderContainer();
    if (!this.hasOverlayInContainer()) {
      this.disposeOverlayRef();
      return this.show();
    }
    this.isShown$.next(true);
  }
  hide() {
    if (!this.ref) {
      return;
    }
    this.ref.detach();
    this.container = null;
    this.isShown$.next(false);
  }
  toggle() {
    if (this.isAttached) {
      this.hide();
    } else {
      this.show();
    }
  }
  dispose() {
    this.destroy$.next();
    this.destroy$.complete();
    this.hide();
    this.disposeOverlayRef();
    this.isShown$.complete();
    this.positionStrategyChange$.complete();
    this.overlayDestroy$.complete();
  }
  getContainer() {
    return this.container;
  }
  createOverlay() {
    this.ref = this.overlay.create(__spreadValues({
      positionStrategy: this.positionStrategy,
      scrollStrategy: this.overlay.scrollStrategies.reposition()
    }, this.overlayConfig));
    this.updatePositionWhenStable(this.ref);
  }
  renderContainer() {
    const containerContext = this.createContainerContext();
    if (!this.container) {
      this.container = createContainer(this.ref, this.componentType, containerContext);
    }
    this.container.instance.renderContent();
  }
  updateContext() {
    const containerContext = this.createContainerContext();
    Object.assign(this.container.instance, containerContext);
    this.container.instance.renderContent();
    this.container.changeDetectorRef.detectChanges();
  }
  createContainerContext() {
    return {
      content: this.content,
      context: this.context,
      position: this.lastAppliedPosition
    };
  }
  /**
   * Dimensions of the container may change after content update. So we listen to zone.stable event to
   * reposition the container.
   */
  updatePositionWhenStable(overlay) {
    const overlayDestroy$ = this.overlayDestroy$.pipe(filter((destroyedOverlay) => destroyedOverlay === overlay));
    this.zone.onStable.pipe(take(1), takeUntil(merge(this.destroy$, overlayDestroy$))).subscribe(() => this.updatePosition());
  }
  updatePosition() {
    if (this.ref) {
      this.ref.updatePosition();
    }
  }
  hasOverlayInContainer() {
    return this.overlayContainer.getContainerElement().contains(this.ref.hostElement);
  }
  disposeOverlayRef() {
    if (this.ref) {
      this.ref.dispose();
      this.overlayDestroy$.next(this.ref);
      this.ref = null;
      this.container = null;
    }
  }
};
_NbDynamicOverlay.\u0275fac = function NbDynamicOverlay_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbDynamicOverlay)(\u0275\u0275inject(NbOverlayService), \u0275\u0275inject(NgZone), \u0275\u0275inject(NbOverlayContainer));
};
_NbDynamicOverlay.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbDynamicOverlay,
  factory: _NbDynamicOverlay.\u0275fac
});
var NbDynamicOverlay = _NbDynamicOverlay;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDynamicOverlay, [{
    type: Injectable
  }], () => [{
    type: NbOverlayService
  }, {
    type: NgZone
  }, {
    type: NbOverlayContainer
  }], null);
})();
var NbDynamicOverlayChange = class extends SimpleChange {
  constructor(previousValue, currentValue, firstChange = false) {
    super(previousValue, currentValue, firstChange);
  }
  isChanged() {
    return this.currentValue !== this.previousValue;
  }
};
var _NbDynamicOverlayHandler = class _NbDynamicOverlayHandler {
  constructor(positionBuilder, triggerStrategyBuilder, dynamicOverlayService, directionService) {
    this.positionBuilder = positionBuilder;
    this.triggerStrategyBuilder = triggerStrategyBuilder;
    this.dynamicOverlayService = dynamicOverlayService;
    this.directionService = directionService;
    this._context = {};
    this._trigger = NbTrigger.NOOP;
    this._disabled = false;
    this._position = NbPosition.TOP;
    this._adjustment = NbAdjustment.NOOP;
    this._offset = 15;
    this._overlayConfig = {};
    this.changes = {};
    this.destroy$ = new Subject();
  }
  host(host) {
    this.changes.host = new NbDynamicOverlayChange(this._host, host);
    this._host = host;
    return this;
  }
  trigger(trigger2) {
    this.changes.trigger = new NbDynamicOverlayChange(this._trigger, trigger2);
    this._trigger = trigger2;
    return this;
  }
  disabled(disabled) {
    this.changes.disabled = new NbDynamicOverlayChange(this._disabled, disabled);
    this._disabled = disabled;
    return this;
  }
  position(position) {
    this.changes.position = new NbDynamicOverlayChange(this._position, position);
    this._position = position;
    return this;
  }
  adjustment(adjustment) {
    this.changes.adjustment = new NbDynamicOverlayChange(this._adjustment, adjustment);
    this._adjustment = adjustment;
    return this;
  }
  componentType(componentType) {
    this.changes.componentType = new NbDynamicOverlayChange(this._componentType, componentType);
    this._componentType = componentType;
    return this;
  }
  content(content) {
    this.changes.content = new NbDynamicOverlayChange(this._content, content);
    this._content = content;
    return this;
  }
  context(context) {
    this.changes.context = new NbDynamicOverlayChange(this._context, context);
    this._context = context;
    return this;
  }
  offset(offset) {
    this.changes.offset = new NbDynamicOverlayChange(this._offset, offset);
    this._offset = offset;
    return this;
  }
  overlayConfig(overlayConfig) {
    this.changes.overlayConfig = new NbDynamicOverlayChange(this._overlayConfig, overlayConfig);
    this._overlayConfig = overlayConfig;
    return this;
  }
  build() {
    if (!this._componentType || !this._host) {
      throw Error(`NbDynamicOverlayHandler: at least 'componentType' and 'host' should be
      passed before building a dynamic overlay.`);
    }
    this.dynamicOverlay = this.dynamicOverlayService.create(this._componentType, this._content, this._context, this.createPositionStrategy(), this._overlayConfig, this._disabled);
    this.connect();
    this.clearChanges();
    return this.dynamicOverlay;
  }
  rebuild() {
    if (!this.dynamicOverlay) {
      return void 0;
    }
    if (this.isPositionStrategyUpdateRequired()) {
      this.dynamicOverlay.setPositionStrategy(this.createPositionStrategy());
    }
    if (this.isTriggerStrategyUpdateRequired()) {
      this.connect();
    }
    if (this.isContainerRerenderRequired()) {
      this.dynamicOverlay.setContentAndContext(this._content, this._context);
    }
    if (this.isComponentTypeUpdateRequired()) {
      this.dynamicOverlay.setComponent(this._componentType);
    }
    if (this.isOverlayConfigUpdateRequired()) {
      this.dynamicOverlay.setOverlayConfig(this._overlayConfig);
    }
    if (this.isDisabledUpdated()) {
      this.dynamicOverlay.setDisabled(this._disabled);
    }
    this.clearChanges();
    return this.dynamicOverlay;
  }
  connect() {
    if (!this.dynamicOverlay) {
      throw new Error(`NbDynamicOverlayHandler: cannot connect to DynamicOverlay
      as it is not created yet. Call build() first`);
    }
    this.disconnect();
    this.subscribeOnTriggers(this.dynamicOverlay);
    this.subscribeOnDirectionChange();
  }
  disconnect() {
    if (this.triggerStrategy) {
      this.triggerStrategy.destroy();
    }
  }
  destroy() {
    this.destroy$.next();
    this.destroy$.complete();
    this.disconnect();
    this.clearChanges();
    if (this.dynamicOverlay) {
      this.dynamicOverlay.dispose();
    }
  }
  createPositionStrategy() {
    return this.positionBuilder.connectedTo(this._host).position(this._position).adjustment(this._adjustment).offset(this._offset).direction(this.directionService.getDirection());
  }
  subscribeOnTriggers(dynamicOverlay) {
    this.triggerStrategy = this.triggerStrategyBuilder.trigger(this._trigger).host(this._host.nativeElement).container(() => dynamicOverlay.getContainer()).build();
    this.triggerStrategy.show$.subscribe(() => dynamicOverlay.show());
    this.triggerStrategy.hide$.subscribe(() => dynamicOverlay.hide());
  }
  subscribeOnDirectionChange() {
    this.directionService.onDirectionChange().pipe(skip(1), takeUntil(this.destroy$)).subscribe(() => {
      this.dynamicOverlay.setPositionStrategy(this.createPositionStrategy());
    });
  }
  isContainerRerenderRequired() {
    return this.isContentUpdated() || this.isContextUpdated() || this.isPositionStrategyUpdateRequired();
  }
  isPositionStrategyUpdateRequired() {
    return this.isAdjustmentUpdated() || this.isPositionUpdated() || this.isOffsetUpdated() || this.isHostUpdated();
  }
  isTriggerStrategyUpdateRequired() {
    return this.isTriggerUpdated() || this.isHostUpdated();
  }
  isComponentTypeUpdateRequired() {
    return this.isComponentTypeUpdated();
  }
  isOverlayConfigUpdateRequired() {
    return this.isOverlayConfigUpdated();
  }
  isComponentTypeUpdated() {
    return this.changes.componentType && this.changes.componentType.isChanged();
  }
  isContentUpdated() {
    return this.changes.content && this.changes.content.isChanged();
  }
  isContextUpdated() {
    return this.changes.context && this.changes.context.isChanged();
  }
  isAdjustmentUpdated() {
    return this.changes.adjustment && this.changes.adjustment.isChanged();
  }
  isPositionUpdated() {
    return this.changes.position && this.changes.position.isChanged();
  }
  isHostUpdated() {
    return this.changes.host && this.changes.host.isChanged();
  }
  isTriggerUpdated() {
    return this.changes.trigger && this.changes.trigger.isChanged();
  }
  isOffsetUpdated() {
    return this.changes.offset && this.changes.offset.isChanged();
  }
  isOverlayConfigUpdated() {
    return this.changes.overlayConfig && this.changes.overlayConfig.isChanged();
  }
  isDisabledUpdated() {
    return this.changes.disabled && this.changes.disabled.isChanged();
  }
  clearChanges() {
    this.changes = {};
  }
};
_NbDynamicOverlayHandler.\u0275fac = function NbDynamicOverlayHandler_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbDynamicOverlayHandler)(\u0275\u0275inject(NbPositionBuilderService), \u0275\u0275inject(NbTriggerStrategyBuilderService), \u0275\u0275inject(NbDynamicOverlay), \u0275\u0275inject(NbLayoutDirectionService));
};
_NbDynamicOverlayHandler.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbDynamicOverlayHandler,
  factory: _NbDynamicOverlayHandler.\u0275fac
});
var NbDynamicOverlayHandler = _NbDynamicOverlayHandler;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDynamicOverlayHandler, [{
    type: Injectable
  }], () => [{
    type: NbPositionBuilderService
  }, {
    type: NbTriggerStrategyBuilderService
  }, {
    type: NbDynamicOverlay
  }, {
    type: NbLayoutDirectionService
  }], null);
})();
var _NbPopoverComponent = class _NbPopoverComponent extends NbPositionedContainerComponent {
  renderContent() {
    this.detachContent();
    this.attachContent();
  }
  detachContent() {
    this.overlayContainer.detach();
  }
  attachContent() {
    if (this.content instanceof TemplateRef) {
      this.attachTemplate();
    } else if (this.content instanceof Type) {
      this.attachComponent();
    } else {
      this.attachString();
    }
  }
  attachTemplate() {
    this.overlayContainer.attachTemplatePortal(new NbTemplatePortal(this.content, null, {
      $implicit: this.context
    }));
  }
  attachComponent() {
    const portal = new NbComponentPortal(this.content, null, null);
    const ref = this.overlayContainer.attachComponentPortal(portal, this.context);
    ref.changeDetectorRef.detectChanges();
  }
  attachString() {
    this.overlayContainer.attachStringContent(this.content);
  }
};
_NbPopoverComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NbPopoverComponent_BaseFactory;
  return function NbPopoverComponent_Factory(__ngFactoryType__) {
    return (\u0275NbPopoverComponent_BaseFactory || (\u0275NbPopoverComponent_BaseFactory = \u0275\u0275getInheritedFactory(_NbPopoverComponent)))(__ngFactoryType__ || _NbPopoverComponent);
  };
})();
_NbPopoverComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbPopoverComponent,
  selectors: [["nb-popover"]],
  viewQuery: function NbPopoverComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(NbOverlayContainerComponent, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.overlayContainer = _t.first);
    }
  },
  inputs: {
    content: "content",
    context: "context"
  },
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 2,
  vars: 0,
  consts: [[1, "arrow"]],
  template: function NbPopoverComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275element(0, "span", 0)(1, "nb-overlay-container");
    }
  },
  dependencies: [NbOverlayContainerComponent],
  styles: ["[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{position:absolute;width:0;height:0}\n\n\n\n\n\n"]
});
var NbPopoverComponent = _NbPopoverComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPopoverComponent, [{
    type: Component,
    args: [{
      selector: "nb-popover",
      template: `
    <span class="arrow"></span>
    <nb-overlay-container></nb-overlay-container>
  `,
      standalone: false,
      styles: [":host .arrow{position:absolute;width:0;height:0}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], null, {
    overlayContainer: [{
      type: ViewChild,
      args: [NbOverlayContainerComponent]
    }],
    content: [{
      type: Input
    }],
    context: [{
      type: Input
    }]
  });
})();
var _NbPopoverDirective = class _NbPopoverDirective {
  /**
   * Container position will be changes automatically based on this strategy if container can't fit view port.
   * Set this property to `noop` value if you want to disable automatically adjustment.
   * Available values: `clockwise` (default), `counterclockwise`, `vertical`, `horizontal`, `noop`.
   * */
  get adjustment() {
    return this._adjustment;
  }
  set adjustment(value) {
    this._adjustment = value;
  }
  get popoverClass() {
    return this._popoverClass;
  }
  set popoverClass(value) {
    if (value !== this.popoverClass) {
      this._popoverClass = value;
      this.overlayConfig = {
        panelClass: this.popoverClass
      };
    }
  }
  get isShown() {
    return !!(this.dynamicOverlay && this.dynamicOverlay.isAttached);
  }
  constructor(hostRef, dynamicOverlayHandler) {
    this.hostRef = hostRef;
    this.dynamicOverlayHandler = dynamicOverlayHandler;
    this.popoverComponent = NbPopoverComponent;
    this.destroy$ = new Subject();
    this.context = {};
    this.position = NbPosition.TOP;
    this._adjustment = NbAdjustment.CLOCKWISE;
    this.trigger = NbTrigger.CLICK;
    this.offset = 15;
    this.disabled = false;
    this._popoverClass = "";
    this.nbPopoverShowStateChange = new EventEmitter();
    this.overlayConfig = {
      panelClass: this.popoverClass
    };
  }
  ngOnInit() {
    this.dynamicOverlayHandler.host(this.hostRef).componentType(this.popoverComponent);
  }
  ngOnChanges() {
    this.rebuild();
  }
  ngAfterViewInit() {
    this.dynamicOverlay = this.configureDynamicOverlay().build();
    this.dynamicOverlay.isShown.pipe(skip(1), takeUntil(this.destroy$)).subscribe((isShown) => this.nbPopoverShowStateChange.emit({
      isShown
    }));
  }
  rebuild() {
    this.dynamicOverlay = this.configureDynamicOverlay().rebuild();
  }
  show() {
    this.dynamicOverlay.show();
  }
  hide() {
    this.dynamicOverlay.hide();
  }
  toggle() {
    this.dynamicOverlay.toggle();
  }
  ngOnDestroy() {
    this.dynamicOverlayHandler.destroy();
    this.destroy$.next();
    this.destroy$.complete();
  }
  configureDynamicOverlay() {
    return this.dynamicOverlayHandler.position(this.position).trigger(this.trigger).disabled(this.disabled).offset(this.offset).adjustment(this.adjustment).content(this.content).context(this.context).overlayConfig(this.overlayConfig);
  }
};
_NbPopoverDirective.\u0275fac = function NbPopoverDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbPopoverDirective)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NbDynamicOverlayHandler));
};
_NbPopoverDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbPopoverDirective,
  selectors: [["", "nbPopover", ""]],
  inputs: {
    content: [0, "nbPopover", "content"],
    context: [0, "nbPopoverContext", "context"],
    position: [0, "nbPopoverPlacement", "position"],
    adjustment: [0, "nbPopoverAdjustment", "adjustment"],
    trigger: [0, "nbPopoverTrigger", "trigger"],
    offset: [0, "nbPopoverOffset", "offset"],
    disabled: [0, "nbTooltipDisabled", "disabled"],
    popoverClass: [0, "nbPopoverClass", "popoverClass"]
  },
  outputs: {
    nbPopoverShowStateChange: "nbPopoverShowStateChange"
  },
  exportAs: ["nbPopover"],
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([NbDynamicOverlayHandler, NbDynamicOverlay]), \u0275\u0275NgOnChangesFeature]
});
var NbPopoverDirective = _NbPopoverDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPopoverDirective, [{
    type: Directive,
    args: [{
      selector: "[nbPopover]",
      exportAs: "nbPopover",
      providers: [NbDynamicOverlayHandler, NbDynamicOverlay],
      standalone: false
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NbDynamicOverlayHandler
  }], {
    content: [{
      type: Input,
      args: ["nbPopover"]
    }],
    context: [{
      type: Input,
      args: ["nbPopoverContext"]
    }],
    position: [{
      type: Input,
      args: ["nbPopoverPlacement"]
    }],
    adjustment: [{
      type: Input,
      args: ["nbPopoverAdjustment"]
    }],
    trigger: [{
      type: Input,
      args: ["nbPopoverTrigger"]
    }],
    offset: [{
      type: Input,
      args: ["nbPopoverOffset"]
    }],
    disabled: [{
      type: Input,
      args: ["nbTooltipDisabled"]
    }],
    popoverClass: [{
      type: Input,
      args: ["nbPopoverClass"]
    }],
    nbPopoverShowStateChange: [{
      type: Output
    }]
  });
})();
var _NbPopoverModule = class _NbPopoverModule {
};
_NbPopoverModule.\u0275fac = function NbPopoverModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbPopoverModule)();
};
_NbPopoverModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbPopoverModule,
  declarations: [NbPopoverDirective, NbPopoverComponent],
  imports: [NbOverlayModule],
  exports: [NbPopoverDirective]
});
_NbPopoverModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NbOverlayModule]
});
var NbPopoverModule = _NbPopoverModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPopoverModule, [{
    type: NgModule,
    args: [{
      imports: [NbOverlayModule],
      declarations: [NbPopoverDirective, NbPopoverComponent],
      exports: [NbPopoverDirective]
    }]
  }], null, null);
})();
var _NbContextMenuComponent = class _NbContextMenuComponent extends NbPositionedContainerComponent {
  constructor() {
    super(...arguments);
    this.items = [];
    this.context = {
      items: []
    };
  }
  /**
   * The method is empty since we don't need to do anything additionally
   * render is handled by change detection
   */
  renderContent() {
  }
};
_NbContextMenuComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NbContextMenuComponent_BaseFactory;
  return function NbContextMenuComponent_Factory(__ngFactoryType__) {
    return (\u0275NbContextMenuComponent_BaseFactory || (\u0275NbContextMenuComponent_BaseFactory = \u0275\u0275getInheritedFactory(_NbContextMenuComponent)))(__ngFactoryType__ || _NbContextMenuComponent);
  };
})();
_NbContextMenuComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbContextMenuComponent,
  selectors: [["nb-context-menu"]],
  inputs: {
    items: "items",
    tag: "tag",
    context: "context"
  },
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 1,
  vars: 2,
  consts: [[1, "context-menu", 3, "items", "tag"]],
  template: function NbContextMenuComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275element(0, "nb-menu", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("items", ctx.context.items)("tag", ctx.context.tag);
    }
  },
  dependencies: [NbMenuComponent],
  encapsulation: 2
});
var NbContextMenuComponent = _NbContextMenuComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbContextMenuComponent, [{
    type: Component,
    args: [{
      selector: "nb-context-menu",
      template: `
    <nb-menu class="context-menu" [items]="context.items" [tag]="context.tag"></nb-menu>
  `,
      standalone: false
    }]
  }], null, {
    items: [{
      type: Input
    }],
    tag: [{
      type: Input
    }],
    context: [{
      type: Input
    }]
  });
})();
var _NbContextMenuDirective = class _NbContextMenuDirective {
  /**
   * Position will be calculated relatively host element based on the position.
   * Can be top, right, bottom and left.
   * */
  get position() {
    return this._position;
  }
  set position(value) {
    if (value !== this.position) {
      this._position = value;
      this.updateOverlayContext();
    }
  }
  /**
   * Set NbMenu tag, which helps identify menu when working with NbMenuService.
   * */
  get tag() {
    return this._tag;
  }
  set tag(value) {
    if (value !== this.tag) {
      this._tag = value;
      this.updateOverlayContext();
    }
  }
  /**
   * Basic menu items, will be passed to the internal NbMenuComponent.
   * */
  get items() {
    return this._items;
  }
  set items(items) {
    this.validateItems(items);
    this._items = items;
    this.updateOverlayContext();
  }
  get contextMenuClass() {
    return this._contextMenuClass;
  }
  set contextMenuClass(value) {
    if (value !== this.contextMenuClass) {
      this._contextMenuClass = value;
      this.overlayConfig = {
        panelClass: this.contextMenuClass
      };
    }
  }
  constructor(hostRef, menuService, dynamicOverlayHandler) {
    this.hostRef = hostRef;
    this.menuService = menuService;
    this.dynamicOverlayHandler = dynamicOverlayHandler;
    this.contextMenuHost = true;
    this._position = NbPosition.BOTTOM;
    this.adjustment = NbAdjustment.CLOCKWISE;
    this.trigger = NbTrigger.CLICK;
    this._contextMenuClass = "";
    this.overlayConfig = {
      panelClass: this.contextMenuClass
    };
    this.overlayContext = {
      items: this.items,
      tag: this.tag,
      position: this.position
    };
    this.destroy$ = new Subject();
    this._items = [];
  }
  ngOnInit() {
    this.dynamicOverlayHandler.host(this.hostRef).componentType(NbContextMenuComponent);
  }
  ngOnChanges() {
    this.rebuild();
  }
  ngAfterViewInit() {
    this.dynamicOverlay = this.configureDynamicOverlay().build();
    this.subscribeOnItemClick();
  }
  rebuild() {
    this.dynamicOverlay = this.configureDynamicOverlay().rebuild();
  }
  show() {
    this.dynamicOverlay.show();
  }
  hide() {
    this.dynamicOverlay.hide();
  }
  toggle() {
    this.dynamicOverlay.toggle();
  }
  ngOnDestroy() {
    this.dynamicOverlayHandler.destroy();
    this.destroy$.next();
    this.destroy$.complete();
  }
  configureDynamicOverlay() {
    return this.dynamicOverlayHandler.position(this.position).trigger(this.trigger).adjustment(this.adjustment).context(this.overlayContext).overlayConfig(this.overlayConfig);
  }
  /*
   * NbMenuComponent will crash if don't pass menu items to it.
   * So, we just validating them and throw custom obvious error.
   * */
  validateItems(items) {
    if (!items || !items.length) {
      throw Error(`List of menu items expected, but given: ${items}`);
    }
  }
  subscribeOnItemClick() {
    this.menuService.onItemClick().pipe(filter(({
      tag
    }) => tag === this.tag && this.trigger !== NbTrigger.NOOP), takeUntil(this.destroy$)).subscribe(() => this.hide());
  }
  updateOverlayContext() {
    this.overlayContext = {
      items: this.items,
      position: this.position,
      tag: this.tag
    };
  }
};
_NbContextMenuDirective.\u0275fac = function NbContextMenuDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbContextMenuDirective)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NbMenuService), \u0275\u0275directiveInject(NbDynamicOverlayHandler));
};
_NbContextMenuDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbContextMenuDirective,
  selectors: [["", "nbContextMenu", ""]],
  hostVars: 2,
  hostBindings: function NbContextMenuDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("context-menu-host", ctx.contextMenuHost);
    }
  },
  inputs: {
    position: [0, "nbContextMenuPlacement", "position"],
    adjustment: [0, "nbContextMenuAdjustment", "adjustment"],
    tag: [0, "nbContextMenuTag", "tag"],
    items: [0, "nbContextMenu", "items"],
    trigger: [0, "nbContextMenuTrigger", "trigger"],
    contextMenuClass: [0, "nbContextMenuClass", "contextMenuClass"]
  },
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([NbDynamicOverlayHandler, NbDynamicOverlay]), \u0275\u0275NgOnChangesFeature]
});
var NbContextMenuDirective = _NbContextMenuDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbContextMenuDirective, [{
    type: Directive,
    args: [{
      selector: "[nbContextMenu]",
      providers: [NbDynamicOverlayHandler, NbDynamicOverlay],
      standalone: false
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NbMenuService
  }, {
    type: NbDynamicOverlayHandler
  }], {
    contextMenuHost: [{
      type: HostBinding,
      args: ["class.context-menu-host"]
    }],
    position: [{
      type: Input,
      args: ["nbContextMenuPlacement"]
    }],
    adjustment: [{
      type: Input,
      args: ["nbContextMenuAdjustment"]
    }],
    tag: [{
      type: Input,
      args: ["nbContextMenuTag"]
    }],
    items: [{
      type: Input,
      args: ["nbContextMenu"]
    }],
    trigger: [{
      type: Input,
      args: ["nbContextMenuTrigger"]
    }],
    contextMenuClass: [{
      type: Input,
      args: ["nbContextMenuClass"]
    }]
  });
})();
var _NbContextMenuModule = class _NbContextMenuModule {
};
_NbContextMenuModule.\u0275fac = function NbContextMenuModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbContextMenuModule)();
};
_NbContextMenuModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbContextMenuModule,
  declarations: [NbContextMenuDirective, NbContextMenuComponent],
  imports: [CommonModule, NbOverlayModule, NbMenuModule],
  exports: [NbContextMenuDirective]
});
_NbContextMenuModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, NbOverlayModule, NbMenuModule]
});
var NbContextMenuModule = _NbContextMenuModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbContextMenuModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NbOverlayModule, NbMenuModule],
      exports: [NbContextMenuDirective],
      declarations: [NbContextMenuDirective, NbContextMenuComponent]
    }]
  }], null, null);
})();
var _NbProgressBarComponent = class _NbProgressBarComponent {
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get primary() {
    return this.status === "primary";
  }
  get success() {
    return this.status === "success";
  }
  get info() {
    return this.status === "info";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  constructor(statusService) {
    this.statusService = statusService;
    this.value = 0;
    this.status = "basic";
    this.size = "medium";
    this.displayValue = false;
  }
};
_NbProgressBarComponent.\u0275fac = function NbProgressBarComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbProgressBarComponent)(\u0275\u0275directiveInject(NbStatusService));
};
_NbProgressBarComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbProgressBarComponent,
  selectors: [["nb-progress-bar"]],
  hostVars: 26,
  hostBindings: function NbProgressBarComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classMap(ctx.additionalClasses);
      \u0275\u0275classProp("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control);
    }
  },
  inputs: {
    value: "value",
    status: "status",
    size: "size",
    displayValue: "displayValue"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 4,
  vars: 3,
  consts: [[1, "progress-container"], [1, "progress-value"], [4, "ngIf"]],
  template: function NbProgressBarComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275elementStart(0, "div", 0)(1, "div", 1);
      \u0275\u0275template(2, NbProgressBarComponent_span_2_Template, 2, 1, "span", 2);
      \u0275\u0275projection(3);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275advance();
      \u0275\u0275styleProp("width", ctx.value, "%");
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.displayValue);
    }
  },
  dependencies: [NgIf],
  styles: ["[_nghost-%COMP%]{display:block}.progress-container[_ngcontent-%COMP%]{overflow:hidden}.progress-value[_ngcontent-%COMP%]{height:100%;text-align:center;overflow:hidden}\n\n\n\n\n\n"]
});
var NbProgressBarComponent = _NbProgressBarComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbProgressBarComponent, [{
    type: Component,
    args: [{
      selector: "nb-progress-bar",
      template: `
    <div class="progress-container">
      <div class="progress-value" [style.width.%]="value">
        <span *ngIf="displayValue">{{ value }}%</span>
        <ng-content></ng-content>
      </div>
    </div>
  `,
      standalone: false,
      styles: [":host{display:block}.progress-container{overflow:hidden}.progress-value{height:100%;text-align:center;overflow:hidden}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: NbStatusService
  }], {
    value: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    displayValue: [{
      type: Input
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var _NbProgressBarModule = class _NbProgressBarModule {
};
_NbProgressBarModule.\u0275fac = function NbProgressBarModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbProgressBarModule)();
};
_NbProgressBarModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbProgressBarModule,
  declarations: [NbProgressBarComponent],
  imports: [NbSharedModule],
  exports: [NbProgressBarComponent]
});
_NbProgressBarModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NbSharedModule]
});
var NbProgressBarModule = _NbProgressBarModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbProgressBarModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule],
      declarations: [NbProgressBarComponent],
      exports: [NbProgressBarComponent]
    }]
  }], null, null);
})();
var _NbAlertComponent = class _NbAlertComponent {
  /**
   * Shows `close` icon
   */
  get closable() {
    return this._closable;
  }
  set closable(value) {
    this._closable = convertToBoolProperty(value);
  }
  constructor(statusService) {
    this.statusService = statusService;
    this.size = "";
    this.status = "basic";
    this.accent = "";
    this.outline = "";
    this._closable = false;
    this.close = new EventEmitter();
  }
  /**
   * Emits the removed chip event
   */
  onClose() {
    this.close.emit();
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get primary() {
    return this.status === "primary";
  }
  get success() {
    return this.status === "success";
  }
  get info() {
    return this.status === "info";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get primaryAccent() {
    return this.accent === "primary";
  }
  get successAccent() {
    return this.accent === "success";
  }
  get infoAccent() {
    return this.accent === "info";
  }
  get warningAccent() {
    return this.accent === "warning";
  }
  get dangerAccent() {
    return this.accent === "danger";
  }
  get basicAccent() {
    return this.accent === "basic";
  }
  get controlAccent() {
    return this.accent === "control";
  }
  get primaryOutline() {
    return this.outline === "primary";
  }
  get successOutline() {
    return this.outline === "success";
  }
  get infoOutline() {
    return this.outline === "info";
  }
  get warningOutline() {
    return this.outline === "warning";
  }
  get dangerOutline() {
    return this.outline === "danger";
  }
  get basicOutline() {
    return this.outline === "basic";
  }
  get controlOutline() {
    return this.outline === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
};
_NbAlertComponent.\u0275fac = function NbAlertComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbAlertComponent)(\u0275\u0275directiveInject(NbStatusService));
};
_NbAlertComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbAlertComponent,
  selectors: [["nb-alert"]],
  hostVars: 56,
  hostBindings: function NbAlertComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classMap(ctx.additionalClasses);
      \u0275\u0275classProp("closable", ctx.closable)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("accent-primary", ctx.primaryAccent)("accent-success", ctx.successAccent)("accent-info", ctx.infoAccent)("accent-warning", ctx.warningAccent)("accent-danger", ctx.dangerAccent)("accent-basic", ctx.basicAccent)("accent-control", ctx.controlAccent)("outline-primary", ctx.primaryOutline)("outline-success", ctx.successOutline)("outline-info", ctx.infoOutline)("outline-warning", ctx.warningOutline)("outline-danger", ctx.dangerOutline)("outline-basic", ctx.basicOutline)("outline-control", ctx.controlOutline);
    }
  },
  inputs: {
    size: "size",
    status: "status",
    accent: "accent",
    outline: "outline",
    closable: "closable"
  },
  outputs: {
    close: "close"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 2,
  vars: 1,
  consts: [["type", "button", "class", "close", "aria-label", "Close", 3, "click", 4, "ngIf"], ["type", "button", "aria-label", "Close", 1, "close", 3, "click"], ["aria-hidden", "true"]],
  template: function NbAlertComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275template(0, NbAlertComponent_button_0_Template, 3, 0, "button", 0);
      \u0275\u0275projection(1);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.closable);
    }
  },
  dependencies: [NgIf],
  styles: ["[_nghost-%COMP%]{display:flex;flex-direction:column;position:relative}[dir=ltr]   [_nghost-%COMP%]   .close[_ngcontent-%COMP%]{right:0}[dir=rtl]   [_nghost-%COMP%]   .close[_ngcontent-%COMP%]{left:0}.close[_ngcontent-%COMP%]{position:absolute;top:0;color:inherit;background-color:transparent;border:0;appearance:none}\n\n\n\n\n\n"]
});
var NbAlertComponent = _NbAlertComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAlertComponent, [{
    type: Component,
    args: [{
      selector: "nb-alert",
      template: `
    <button *ngIf="closable" type="button" class="close" aria-label="Close" (click)="onClose()">
      <span aria-hidden="true">&times;</span>
    </button>
    <ng-content></ng-content>
  `,
      standalone: false,
      styles: [":host{display:flex;flex-direction:column;position:relative}[dir=ltr] :host .close{right:0}[dir=rtl] :host .close{left:0}.close{position:absolute;top:0;color:inherit;background-color:transparent;border:0;appearance:none}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: NbStatusService
  }], {
    size: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    accent: [{
      type: Input
    }],
    outline: [{
      type: Input
    }],
    closable: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.closable"]
    }],
    close: [{
      type: Output
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    primaryAccent: [{
      type: HostBinding,
      args: ["class.accent-primary"]
    }],
    successAccent: [{
      type: HostBinding,
      args: ["class.accent-success"]
    }],
    infoAccent: [{
      type: HostBinding,
      args: ["class.accent-info"]
    }],
    warningAccent: [{
      type: HostBinding,
      args: ["class.accent-warning"]
    }],
    dangerAccent: [{
      type: HostBinding,
      args: ["class.accent-danger"]
    }],
    basicAccent: [{
      type: HostBinding,
      args: ["class.accent-basic"]
    }],
    controlAccent: [{
      type: HostBinding,
      args: ["class.accent-control"]
    }],
    primaryOutline: [{
      type: HostBinding,
      args: ["class.outline-primary"]
    }],
    successOutline: [{
      type: HostBinding,
      args: ["class.outline-success"]
    }],
    infoOutline: [{
      type: HostBinding,
      args: ["class.outline-info"]
    }],
    warningOutline: [{
      type: HostBinding,
      args: ["class.outline-warning"]
    }],
    dangerOutline: [{
      type: HostBinding,
      args: ["class.outline-danger"]
    }],
    basicOutline: [{
      type: HostBinding,
      args: ["class.outline-basic"]
    }],
    controlOutline: [{
      type: HostBinding,
      args: ["class.outline-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var _NbAlertModule = class _NbAlertModule {
};
_NbAlertModule.\u0275fac = function NbAlertModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbAlertModule)();
};
_NbAlertModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbAlertModule,
  declarations: [NbAlertComponent],
  imports: [NbSharedModule],
  exports: [NbAlertComponent]
});
_NbAlertModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NbSharedModule]
});
var NbAlertModule = _NbAlertModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAlertModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule],
      declarations: [NbAlertComponent],
      exports: [NbAlertComponent]
    }]
  }], null, null);
})();
var _NbFormFieldControl = class _NbFormFieldControl {
};
_NbFormFieldControl.\u0275fac = function NbFormFieldControl_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbFormFieldControl)();
};
_NbFormFieldControl.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbFormFieldControl,
  factory: _NbFormFieldControl.\u0275fac
});
var NbFormFieldControl = _NbFormFieldControl;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFormFieldControl, [{
    type: Injectable
  }], null, null);
})();
var _NbFormFieldControlConfig = class _NbFormFieldControlConfig {
  constructor() {
    this.supportsPrefix = true;
    this.supportsSuffix = true;
  }
};
_NbFormFieldControlConfig.\u0275fac = function NbFormFieldControlConfig_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbFormFieldControlConfig)();
};
_NbFormFieldControlConfig.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbFormFieldControlConfig,
  factory: _NbFormFieldControlConfig.\u0275fac
});
var NbFormFieldControlConfig = _NbFormFieldControlConfig;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFormFieldControlConfig, [{
    type: Injectable
  }], null, null);
})();
var _NbInputDirective = class _NbInputDirective {
  /**
   * If set element will fill container. `false` by default.
   */
  get fullWidth() {
    return this._fullWidth;
  }
  set fullWidth(value) {
    this._fullWidth = convertToBoolProperty(value);
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  constructor(elementRef, focusMonitor, renderer, zone, statusService) {
    this.elementRef = elementRef;
    this.focusMonitor = focusMonitor;
    this.renderer = renderer;
    this.zone = zone;
    this.statusService = statusService;
    this.destroy$ = new Subject();
    this.fieldSize = "medium";
    this.status = "basic";
    this.shape = "rectangle";
    this._fullWidth = false;
    this.status$ = new BehaviorSubject(this.status);
    this.size$ = new BehaviorSubject(this.fieldSize);
    this.focused$ = new BehaviorSubject(false);
    this.disabled$ = new BehaviorSubject(false);
    this.fullWidth$ = new BehaviorSubject(this.fullWidth);
  }
  ngDoCheck() {
    const isDisabled = this.elementRef.nativeElement.disabled;
    if (isDisabled !== this.disabled$.value) {
      this.disabled$.next(isDisabled);
    }
  }
  ngOnChanges({
    status,
    fieldSize,
    fullWidth
  }) {
    if (status) {
      this.status$.next(this.status);
    }
    if (fieldSize) {
      this.size$.next(this.fieldSize);
    }
    if (fullWidth) {
      this.fullWidth$.next(this.fullWidth);
    }
  }
  ngOnInit() {
    this.focusMonitor.monitor(this.elementRef).pipe(map((origin) => !!origin), finalize(() => this.focusMonitor.stopMonitoring(this.elementRef)), takeUntil(this.destroy$)).subscribe(this.focused$);
  }
  ngAfterViewInit() {
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this.elementRef.nativeElement, "nb-transition");
    }));
  }
  ngOnDestroy() {
    this.destroy$.next();
  }
  get tiny() {
    return this.fieldSize === "tiny";
  }
  get small() {
    return this.fieldSize === "small";
  }
  get medium() {
    return this.fieldSize === "medium";
  }
  get large() {
    return this.fieldSize === "large";
  }
  get giant() {
    return this.fieldSize === "giant";
  }
  get primary() {
    return this.status === "primary";
  }
  get info() {
    return this.status === "info";
  }
  get success() {
    return this.status === "success";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get rectangle() {
    return this.shape === "rectangle";
  }
  get semiRound() {
    return this.shape === "semi-round";
  }
  get round() {
    return this.shape === "round";
  }
};
_NbInputDirective.\u0275fac = function NbInputDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbInputDirective)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NbFocusMonitor), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(NbStatusService));
};
_NbInputDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbInputDirective,
  selectors: [["input", "nbInput", ""], ["textarea", "nbInput", ""]],
  hostVars: 34,
  hostBindings: function NbInputDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classMap(ctx.additionalClasses);
      \u0275\u0275classProp("input-full-width", ctx.fullWidth)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("shape-rectangle", ctx.rectangle)("shape-semi-round", ctx.semiRound)("shape-round", ctx.round);
    }
  },
  inputs: {
    fieldSize: "fieldSize",
    status: "status",
    shape: "shape",
    fullWidth: "fullWidth"
  },
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NbFormFieldControl,
    useExisting: _NbInputDirective
  }]), \u0275\u0275NgOnChangesFeature]
});
var NbInputDirective = _NbInputDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbInputDirective, [{
    type: Directive,
    args: [{
      selector: "input[nbInput],textarea[nbInput]",
      providers: [{
        provide: NbFormFieldControl,
        useExisting: NbInputDirective
      }],
      standalone: false
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NbFocusMonitor
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }], {
    fieldSize: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    shape: [{
      type: Input
    }],
    fullWidth: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.input-full-width"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    rectangle: [{
      type: HostBinding,
      args: ["class.shape-rectangle"]
    }],
    semiRound: [{
      type: HostBinding,
      args: ["class.shape-semi-round"]
    }],
    round: [{
      type: HostBinding,
      args: ["class.shape-round"]
    }]
  });
})();
var _NbChatFormComponent = class _NbChatFormComponent {
  constructor(cd, domSanitizer) {
    this.cd = cd;
    this.domSanitizer = domSanitizer;
    this.status = "basic";
    this.inputFocus = false;
    this.inputHover = false;
    this.droppedFiles = [];
    this.imgDropTypes = ["image/png", "image/jpeg", "image/gif"];
    this.message = "";
    this.messagePlaceholder = "Type a message";
    this.buttonTitle = "";
    this.buttonIcon = "paper-plane-outline";
    this.showButton = true;
    this.dropFiles = false;
    this.dropFilePlaceholder = "Drop file to send";
    this.send = new EventEmitter();
    this.onInputChange = new EventEmitter();
    this.fileOver = false;
  }
  onDrop(event) {
    if (this.dropFiles) {
      event.preventDefault();
      event.stopPropagation();
      this.fileOver = false;
      if (event.dataTransfer && event.dataTransfer.files) {
        for (const file of event.dataTransfer.files) {
          const res = file;
          if (this.imgDropTypes.includes(file.type)) {
            const fr = new FileReader();
            fr.onload = (e) => {
              res.src = e.target.result;
              res.urlStyle = this.domSanitizer.bypassSecurityTrustStyle(`url(${res.src})`);
              this.cd.detectChanges();
            };
            fr.readAsDataURL(file);
          }
          this.droppedFiles.push(res);
        }
      }
    }
  }
  removeFile(file) {
    const index = this.droppedFiles.indexOf(file);
    if (index >= 0) {
      this.droppedFiles.splice(index, 1);
    }
  }
  onDragOver(event) {
    event.preventDefault();
    event.stopPropagation();
    if (this.dropFiles) {
      this.fileOver = true;
    }
  }
  onDragLeave(event) {
    event.preventDefault();
    event.stopPropagation();
    if (this.dropFiles) {
      this.fileOver = false;
    }
  }
  sendMessage() {
    if (this.droppedFiles.length || String(this.message).trim().length) {
      this.send.emit({
        message: this.message,
        files: this.droppedFiles
      });
      this.message = "";
      this.droppedFiles = [];
    }
  }
  setStatus(status) {
    if (this.status !== status) {
      this.status = status;
      this.cd.detectChanges();
    }
  }
  getInputStatus() {
    if (this.fileOver) {
      return this.getHighlightStatus();
    }
    if (this.inputFocus || this.inputHover) {
      return this.status;
    }
    return "basic";
  }
  getButtonStatus() {
    return this.getHighlightStatus();
  }
  getHighlightStatus() {
    if (this.status === "basic" || this.status === "control") {
      return "primary";
    }
    return this.status;
  }
  onModelChange(value) {
    this.onInputChange.emit(value);
  }
};
_NbChatFormComponent.\u0275fac = function NbChatFormComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbChatFormComponent)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(DomSanitizer));
};
_NbChatFormComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbChatFormComponent,
  selectors: [["nb-chat-form"]],
  hostVars: 2,
  hostBindings: function NbChatFormComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("drop", function NbChatFormComponent_drop_HostBindingHandler($event) {
        return ctx.onDrop($event);
      })("dragover", function NbChatFormComponent_dragover_HostBindingHandler($event) {
        return ctx.onDragOver($event);
      })("dragleave", function NbChatFormComponent_dragleave_HostBindingHandler($event) {
        return ctx.onDragLeave($event);
      });
    }
    if (rf & 2) {
      \u0275\u0275classProp("file-over", ctx.fileOver);
    }
  },
  inputs: {
    message: "message",
    messagePlaceholder: "messagePlaceholder",
    buttonTitle: "buttonTitle",
    buttonIcon: "buttonIcon",
    showButton: "showButton",
    dropFiles: "dropFiles",
    dropFilePlaceholder: "dropFilePlaceholder"
  },
  outputs: {
    send: "send",
    onInputChange: "onInputChange"
  },
  standalone: false,
  decls: 4,
  vars: 8,
  consts: [["title", ""], ["class", "dropped-files", 4, "ngIf"], [1, "message-row"], ["nbInput", "", "fullWidth", "", "type", "text", 3, "focus", "blur", "mouseenter", "mouseleave", "ngModelChange", "keyup.enter", "status", "ngModel", "placeholder"], ["nbButton", "", "class", "send-button", 3, "status", "with-icon", "click", 4, "ngIf"], [1, "dropped-files"], [4, "ngFor", "ngForOf"], [3, "background-image", 4, "ngIf"], [4, "ngIf"], [1, "remove", 3, "click"], ["icon", "file-text-outline", "pack", "nebular-essentials"], ["nbButton", "", 1, "send-button", 3, "click", "status"], ["pack", "nebular-essentials", 3, "icon", 4, "ngIf", "ngIfElse"], ["pack", "nebular-essentials", 3, "icon"]],
  template: function NbChatFormComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NbChatFormComponent_div_0_Template, 2, 1, "div", 1);
      \u0275\u0275elementStart(1, "div", 2)(2, "input", 3);
      \u0275\u0275listener("focus", function NbChatFormComponent_Template_input_focus_2_listener() {
        return ctx.inputFocus = true;
      })("blur", function NbChatFormComponent_Template_input_blur_2_listener() {
        return ctx.inputFocus = false;
      })("mouseenter", function NbChatFormComponent_Template_input_mouseenter_2_listener() {
        return ctx.inputHover = true;
      })("mouseleave", function NbChatFormComponent_Template_input_mouseleave_2_listener() {
        return ctx.inputHover = false;
      });
      \u0275\u0275twoWayListener("ngModelChange", function NbChatFormComponent_Template_input_ngModelChange_2_listener($event) {
        \u0275\u0275twoWayBindingSet(ctx.message, $event) || (ctx.message = $event);
        return $event;
      });
      \u0275\u0275listener("ngModelChange", function NbChatFormComponent_Template_input_ngModelChange_2_listener($event) {
        return ctx.onModelChange($event);
      })("keyup.enter", function NbChatFormComponent_Template_input_keyup_enter_2_listener() {
        return ctx.sendMessage();
      });
      \u0275\u0275elementEnd();
      \u0275\u0275template(3, NbChatFormComponent_button_3_Template, 4, 5, "button", 4);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.droppedFiles == null ? null : ctx.droppedFiles.length);
      \u0275\u0275advance(2);
      \u0275\u0275classProp("with-button", ctx.showButton);
      \u0275\u0275property("placeholder", \u0275\u0275interpolate(ctx.fileOver ? ctx.dropFilePlaceholder : ctx.messagePlaceholder))("status", ctx.getInputStatus());
      \u0275\u0275twoWayProperty("ngModel", ctx.message);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.showButton);
    }
  },
  dependencies: [NgForOf, NgIf, DefaultValueAccessor, NgControlStatus, NgModel, NbIconComponent, NbInputDirective, NbButtonComponent],
  encapsulation: 2,
  changeDetection: 0
});
var NbChatFormComponent = _NbChatFormComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatFormComponent, [{
    type: Component,
    args: [{
      selector: "nb-chat-form",
      template: `
    <div class="dropped-files" *ngIf="droppedFiles?.length">
      <ng-container *ngFor="let file of droppedFiles">
        <div *ngIf="file.urlStyle" [style.background-image]="file.urlStyle">
          <span class="remove" (click)="removeFile(file)">&times;</span>
        </div>

        <div *ngIf="!file.urlStyle">
          <nb-icon icon="file-text-outline" pack="nebular-essentials"></nb-icon>
          <span class="remove" (click)="removeFile(file)">&times;</span>
        </div>
      </ng-container>
    </div>
    <div class="message-row">
      <input
        nbInput
        fullWidth
        [status]="getInputStatus()"
        (focus)="inputFocus = true"
        (blur)="inputFocus = false"
        (mouseenter)="inputHover = true"
        (mouseleave)="inputHover = false"
        [(ngModel)]="message"
        (ngModelChange)="onModelChange($event)"
        [class.with-button]="showButton"
        type="text"
        placeholder="{{ fileOver ? dropFilePlaceholder : messagePlaceholder }}"
        (keyup.enter)="sendMessage()"
      />
      <button
        nbButton
        [status]="getButtonStatus()"
        *ngIf="showButton"
        [class.with-icon]="!buttonTitle"
        (click)="sendMessage()"
        class="send-button"
      >
        <nb-icon *ngIf="!buttonTitle; else title" [icon]="buttonIcon" pack="nebular-essentials"></nb-icon>
        <ng-template #title>{{ buttonTitle }}</ng-template>
      </button>
    </div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: DomSanitizer
  }], {
    message: [{
      type: Input
    }],
    messagePlaceholder: [{
      type: Input
    }],
    buttonTitle: [{
      type: Input
    }],
    buttonIcon: [{
      type: Input
    }],
    showButton: [{
      type: Input
    }],
    dropFiles: [{
      type: Input
    }],
    dropFilePlaceholder: [{
      type: Input
    }],
    send: [{
      type: Output
    }],
    onInputChange: [{
      type: Output
    }],
    fileOver: [{
      type: HostBinding,
      args: ["class.file-over"]
    }],
    onDrop: [{
      type: HostListener,
      args: ["drop", ["$event"]]
    }],
    onDragOver: [{
      type: HostListener,
      args: ["dragover", ["$event"]]
    }],
    onDragLeave: [{
      type: HostListener,
      args: ["dragleave", ["$event"]]
    }]
  });
})();
var _NbChatCustomMessageService = class _NbChatCustomMessageService {
  constructor() {
    this.customMessages = /* @__PURE__ */ new Map();
  }
  register(type, instance) {
    this.customMessages.set(type, instance);
  }
  unregister(type) {
    return this.customMessages.delete(type);
  }
  getInstance(type) {
    return this.customMessages.get(type);
  }
};
_NbChatCustomMessageService.\u0275fac = function NbChatCustomMessageService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbChatCustomMessageService)();
};
_NbChatCustomMessageService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbChatCustomMessageService,
  factory: _NbChatCustomMessageService.\u0275fac
});
var NbChatCustomMessageService = _NbChatCustomMessageService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatCustomMessageService, [{
    type: Injectable
  }], null, null);
})();
var _NbChatMessageTextComponent = class _NbChatMessageTextComponent {
  constructor() {
    this.dateFormat = "shortTime";
  }
};
_NbChatMessageTextComponent.\u0275fac = function NbChatMessageTextComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbChatMessageTextComponent)();
};
_NbChatMessageTextComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbChatMessageTextComponent,
  selectors: [["nb-chat-message-text"]],
  inputs: {
    sender: "sender",
    message: "message",
    date: "date",
    dateFormat: "dateFormat"
  },
  standalone: false,
  decls: 2,
  vars: 2,
  consts: [["class", "sender", 4, "ngIf"], ["class", "text", 4, "ngIf"], [1, "sender"], [1, "text"]],
  template: function NbChatMessageTextComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NbChatMessageTextComponent_p_0_Template, 5, 5, "p", 0)(1, NbChatMessageTextComponent_p_1_Template, 2, 1, "p", 1);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.sender || ctx.date);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.message);
    }
  },
  dependencies: [NgIf, DatePipe],
  encapsulation: 2,
  changeDetection: 0
});
var NbChatMessageTextComponent = _NbChatMessageTextComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatMessageTextComponent, [{
    type: Component,
    args: [{
      selector: "nb-chat-message-text",
      template: `
    <p class="sender" *ngIf="sender || date">{{ sender }} <time>{{ date  | date: dateFormat }}</time></p>
    <p class="text" *ngIf="message">{{ message }}</p>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], null, {
    sender: [{
      type: Input
    }],
    message: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    dateFormat: [{
      type: Input
    }]
  });
})();
var _NbChatMessageFileComponent = class _NbChatMessageFileComponent {
  /**
   * Message file path
   * @type {Date}
   */
  set files(files) {
    this.readyFiles = (files || []).map((file) => {
      const isImage = this.isImage(file);
      return __spreadProps(__spreadValues({}, file), {
        urlStyle: isImage && this.domSanitizer.bypassSecurityTrustStyle(`url(${file.url})`),
        isImage
      });
    });
    this.cd.detectChanges();
  }
  constructor(cd, domSanitizer) {
    this.cd = cd;
    this.domSanitizer = domSanitizer;
    this.dateFormat = "shortTime";
  }
  isImage(file) {
    const type = file.type;
    if (type) {
      return ["image/png", "image/jpeg", "image/gif"].includes(type);
    }
    return false;
  }
};
_NbChatMessageFileComponent.\u0275fac = function NbChatMessageFileComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbChatMessageFileComponent)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(DomSanitizer));
};
_NbChatMessageFileComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbChatMessageFileComponent,
  selectors: [["nb-chat-message-file"]],
  inputs: {
    message: "message",
    sender: "sender",
    date: "date",
    dateFormat: "dateFormat",
    files: "files"
  },
  standalone: false,
  decls: 4,
  vars: 7,
  consts: [[3, "sender", "date", "dateFormat", "message"], [4, "ngIf"], [1, "message-content-group"], ["target", "_blank", 3, "href", 4, "ngFor", "ngForOf"], ["target", "_blank", 3, "href"], [3, "icon", 4, "ngIf"], [3, "background-image", 4, "ngIf"], [3, "icon"]],
  template: function NbChatMessageFileComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "nb-chat-message-text", 0);
      \u0275\u0275text(1);
      \u0275\u0275elementEnd();
      \u0275\u0275template(2, NbChatMessageFileComponent_ng_container_2_Template, 3, 1, "ng-container", 1)(3, NbChatMessageFileComponent_ng_container_3_Template, 4, 3, "ng-container", 1);
    }
    if (rf & 2) {
      \u0275\u0275property("sender", ctx.sender)("date", ctx.date)("dateFormat", ctx.dateFormat)("message", ctx.message);
      \u0275\u0275advance();
      \u0275\u0275textInterpolate1(" ", ctx.message, " ");
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", (ctx.readyFiles == null ? null : ctx.readyFiles.length) > 1);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", (ctx.readyFiles == null ? null : ctx.readyFiles.length) === 1);
    }
  },
  dependencies: [NgForOf, NgIf, NbIconComponent, NbChatMessageTextComponent],
  encapsulation: 2,
  changeDetection: 0
});
var NbChatMessageFileComponent = _NbChatMessageFileComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatMessageFileComponent, [{
    type: Component,
    args: [{
      selector: "nb-chat-message-file",
      template: `
    <nb-chat-message-text [sender]="sender" [date]="date" [dateFormat]="dateFormat" [message]="message">
      {{ message }}
    </nb-chat-message-text>

    <ng-container *ngIf="readyFiles?.length > 1">
      <div class="message-content-group">
        <a *ngFor="let file of readyFiles" [href]="file.url" target="_blank">
          <nb-icon [icon]="file.icon" *ngIf="!file.urlStyle && file.icon"></nb-icon>
          <div *ngIf="file.urlStyle" [style.background-image]="file.urlStyle"></div>
        </a>
      </div>
    </ng-container>

    <ng-container *ngIf="readyFiles?.length === 1">
      <a [href]="readyFiles[0].url" target="_blank">
        <nb-icon [icon]="readyFiles[0].icon" *ngIf="!readyFiles[0].urlStyle && readyFiles[0].icon"></nb-icon>
        <div *ngIf="readyFiles[0].urlStyle" [style.background-image]="readyFiles[0].urlStyle"></div>
      </a>
    </ng-container>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: DomSanitizer
  }], {
    message: [{
      type: Input
    }],
    sender: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    dateFormat: [{
      type: Input
    }],
    files: [{
      type: Input
    }]
  });
})();
var _NbChatMessageQuoteComponent = class _NbChatMessageQuoteComponent {
  constructor() {
    this.dateFormat = "shortTime";
  }
};
_NbChatMessageQuoteComponent.\u0275fac = function NbChatMessageQuoteComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbChatMessageQuoteComponent)();
};
_NbChatMessageQuoteComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbChatMessageQuoteComponent,
  selectors: [["nb-chat-message-quote"]],
  inputs: {
    message: "message",
    sender: "sender",
    date: "date",
    dateFormat: "dateFormat",
    quote: "quote"
  },
  standalone: false,
  decls: 5,
  vars: 4,
  consts: [["class", "sender", 4, "ngIf"], [1, "quote"], [3, "message"], [1, "sender"]],
  template: function NbChatMessageQuoteComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NbChatMessageQuoteComponent_p_0_Template, 5, 5, "p", 0);
      \u0275\u0275elementStart(1, "p", 1);
      \u0275\u0275text(2);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(3, "nb-chat-message-text", 2);
      \u0275\u0275text(4);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.sender || ctx.date);
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate1(" ", ctx.quote, " ");
      \u0275\u0275advance();
      \u0275\u0275property("message", ctx.message);
      \u0275\u0275advance();
      \u0275\u0275textInterpolate1(" ", ctx.message, " ");
    }
  },
  dependencies: [NgIf, NbChatMessageTextComponent, DatePipe],
  encapsulation: 2,
  changeDetection: 0
});
var NbChatMessageQuoteComponent = _NbChatMessageQuoteComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatMessageQuoteComponent, [{
    type: Component,
    args: [{
      selector: "nb-chat-message-quote",
      template: `
    <p class="sender" *ngIf="sender || date">{{ sender }} <time>{{ date | date: dateFormat }}</time></p>
    <p class="quote">
      {{ quote }}
    </p>
    <nb-chat-message-text [message]="message">
      {{ message }}
    </nb-chat-message-text>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], null, {
    message: [{
      type: Input
    }],
    sender: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    dateFormat: [{
      type: Input
    }],
    quote: [{
      type: Input
    }]
  });
})();
var NbChatOptions = class {
};
var _NbChatMessageMapComponent = class _NbChatMessageMapComponent {
  get file() {
    return {
      // eslint-disable-next-line max-len
      url: `https://maps.googleapis.com/maps/api/staticmap?center=${this.latitude},${this.longitude}&zoom=12&size=400x400&key=${this.mapKey}`,
      type: "image/png",
      icon: "location"
    };
  }
  constructor(options) {
    this.dateFormat = "shortTime";
    this.mapKey = options.messageGoogleMapKey;
  }
};
_NbChatMessageMapComponent.\u0275fac = function NbChatMessageMapComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbChatMessageMapComponent)(\u0275\u0275directiveInject(NbChatOptions));
};
_NbChatMessageMapComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbChatMessageMapComponent,
  selectors: [["nb-chat-message-map"]],
  inputs: {
    message: "message",
    sender: "sender",
    date: "date",
    dateFormat: "dateFormat",
    latitude: "latitude",
    longitude: "longitude"
  },
  standalone: false,
  decls: 1,
  vars: 7,
  consts: [[3, "files", "message", "sender", "date", "dateFormat"]],
  template: function NbChatMessageMapComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275element(0, "nb-chat-message-file", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("files", \u0275\u0275pureFunction1(5, _c26, ctx.file))("message", ctx.message)("sender", ctx.sender)("date", ctx.date)("dateFormat", ctx.dateFormat);
    }
  },
  dependencies: [NbChatMessageFileComponent],
  encapsulation: 2,
  changeDetection: 0
});
var NbChatMessageMapComponent = _NbChatMessageMapComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatMessageMapComponent, [{
    type: Component,
    args: [{
      selector: "nb-chat-message-map",
      template: `
    <nb-chat-message-file [files]="[file]" [message]="message" [sender]="sender" [date]="date"
     [dateFormat]="dateFormat"></nb-chat-message-file>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], () => [{
    type: NbChatOptions
  }], {
    message: [{
      type: Input
    }],
    sender: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    dateFormat: [{
      type: Input
    }],
    latitude: [{
      type: Input
    }],
    longitude: [{
      type: Input
    }]
  });
})();
var _NbChatAvatarComponent = class _NbChatAvatarComponent {
  constructor() {
    this.avatarClass = true;
  }
};
_NbChatAvatarComponent.\u0275fac = function NbChatAvatarComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbChatAvatarComponent)();
};
_NbChatAvatarComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbChatAvatarComponent,
  selectors: [["nb-chat-avatar"]],
  hostVars: 4,
  hostBindings: function NbChatAvatarComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275styleProp("background-image", ctx.avatarStyle);
      \u0275\u0275classProp("avatar", ctx.avatarClass);
    }
  },
  inputs: {
    initials: "initials",
    avatarStyle: "avatarStyle"
  },
  standalone: false,
  decls: 1,
  vars: 1,
  consts: [[4, "ngIf"]],
  template: function NbChatAvatarComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NbChatAvatarComponent_ng_container_0_Template, 2, 1, "ng-container", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", !ctx.avatarStyle);
    }
  },
  dependencies: [NgIf],
  encapsulation: 2,
  changeDetection: 0
});
var NbChatAvatarComponent = _NbChatAvatarComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatAvatarComponent, [{
    type: Component,
    args: [{
      selector: "nb-chat-avatar",
      template: `
    <ng-container *ngIf="!avatarStyle">
      {{ initials }}
    </ng-container>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], null, {
    initials: [{
      type: Input
    }],
    avatarStyle: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["style.background-image"]
    }],
    avatarClass: [{
      type: HostBinding,
      args: ["class.avatar"]
    }]
  });
})();
var _NbChatMessageComponent = class _NbChatMessageComponent {
  get _addReplyClass() {
    return this._areDefaultStylesEnabled() && this.reply;
  }
  get _addNotReplyClass() {
    return this._areDefaultStylesEnabled() && this.notReply;
  }
  get _addNoSpaceClass() {
    return this._areDefaultStylesEnabled() && !this.message;
  }
  get flyInOut() {
    return true;
  }
  get notReply() {
    return !this.reply;
  }
  /**
   * Determines if a message is a reply
   */
  get reply() {
    return this._reply;
  }
  set reply(value) {
    this._reply = convertToBoolProperty(value);
  }
  /**
   * Message send avatar
   * @type {string}
   */
  set avatar(value) {
    this.avatarStyle = value ? this.domSanitizer.bypassSecurityTrustStyle(`url(${value})`) : null;
  }
  constructor(domSanitizer, customMessageService) {
    this.domSanitizer = domSanitizer;
    this.customMessageService = customMessageService;
    this.builtInMessageTypes = ["text", "file", "map", "quote"];
    this._reply = false;
  }
  getInitials() {
    if (this.sender) {
      const names = this.sender.split(" ");
      return names.map((n) => n.charAt(0)).splice(0, 2).join("").toUpperCase();
    }
    return "";
  }
  _isBuiltInMessageType() {
    return this.type == null || this.builtInMessageTypes.includes(this.type);
  }
  _getTemplate() {
    const customMessage = this.getCustomMessage(this.type);
    return customMessage.templateRef;
  }
  _getTemplateContext() {
    return {
      $implicit: this.customMessageData,
      isReply: this.reply
    };
  }
  _areDefaultStylesEnabled() {
    const customMessageDirective = this.getCustomMessage(this.type);
    return !customMessageDirective.noStyles;
  }
  getCustomMessage(type) {
    const customMessageDirective = this.customMessageService.getInstance(type);
    if (!customMessageDirective) {
      throw new Error(`nb-chat: Can't find template for custom type '${type}'. Make sure you provide it in the chat component with *nbCustomMessage='${type}'.`);
    }
    return customMessageDirective;
  }
};
_NbChatMessageComponent.\u0275fac = function NbChatMessageComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbChatMessageComponent)(\u0275\u0275directiveInject(DomSanitizer), \u0275\u0275directiveInject(NbChatCustomMessageService));
};
_NbChatMessageComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbChatMessageComponent,
  selectors: [["nb-chat-message"]],
  hostVars: 5,
  hostBindings: function NbChatMessageComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275syntheticHostProperty("@flyInOut", ctx.flyInOut);
      \u0275\u0275classProp("not-reply", ctx.notReply)("reply", ctx.reply);
    }
  },
  inputs: {
    reply: "reply",
    message: "message",
    sender: "sender",
    date: "date",
    dateFormat: "dateFormat",
    files: "files",
    quote: "quote",
    latitude: "latitude",
    longitude: "longitude",
    avatar: "avatar",
    type: "type",
    customMessageData: "customMessageData"
  },
  standalone: false,
  decls: 5,
  vars: 3,
  consts: [["customTemplate", ""], [3, "initials", "avatarStyle", 4, "ngIf"], [1, "message"], [3, "ngSwitch", 4, "ngIf", "ngIfElse"], [3, "initials", "avatarStyle"], [3, "ngSwitch"], [3, "sender", "date", "dateFormat", "message", "files", 4, "ngSwitchCase"], [3, "sender", "date", "dateFormat", "message", "quote", 4, "ngSwitchCase"], [3, "sender", "date", "message", "latitude", "longitude", 4, "ngSwitchCase"], [3, "sender", "date", "dateFormat", "message", 4, "ngSwitchDefault"], [3, "sender", "date", "dateFormat", "message", "files"], [3, "sender", "date", "dateFormat", "message", "quote"], [3, "sender", "date", "message", "latitude", "longitude"], [3, "sender", "date", "dateFormat", "message"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
  template: function NbChatMessageComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NbChatMessageComponent_nb_chat_avatar_0_Template, 1, 2, "nb-chat-avatar", 1);
      \u0275\u0275elementStart(1, "div", 2);
      \u0275\u0275template(2, NbChatMessageComponent_ng_container_2_Template, 5, 4, "ng-container", 3);
      \u0275\u0275elementEnd();
      \u0275\u0275template(3, NbChatMessageComponent_ng_template_3_Template, 3, 16, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
    }
    if (rf & 2) {
      const customTemplate_r2 = \u0275\u0275reference(4);
      \u0275\u0275property("ngIf", ctx.notReply);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", ctx._isBuiltInMessageType())("ngIfElse", customTemplate_r2);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, NgSwitch, NgSwitchCase, NgSwitchDefault, NbChatMessageTextComponent, NbChatMessageFileComponent, NbChatMessageQuoteComponent, NbChatMessageMapComponent, NbChatAvatarComponent],
  encapsulation: 2,
  data: {
    animation: [trigger("flyInOut", [state("in", style({
      transform: "translateX(0)"
    })), transition("void => *", [style({
      transform: "translateX(-100%)"
    }), animate(80)]), transition("* => void", [animate(80, style({
      transform: "translateX(100%)"
    }))])])]
  },
  changeDetection: 0
});
var NbChatMessageComponent = _NbChatMessageComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatMessageComponent, [{
    type: Component,
    args: [{
      selector: "nb-chat-message",
      template: `
    <nb-chat-avatar *ngIf="notReply" [initials]="getInitials()" [avatarStyle]="avatarStyle"> </nb-chat-avatar>

    <div class="message">
      <ng-container [ngSwitch]="type" *ngIf="_isBuiltInMessageType(); else customTemplate">
        <nb-chat-message-file
          *ngSwitchCase="'file'"
          [sender]="sender"
          [date]="date"
          [dateFormat]="dateFormat"
          [message]="message"
          [files]="files"
        >
        </nb-chat-message-file>

        <nb-chat-message-quote
          *ngSwitchCase="'quote'"
          [sender]="sender"
          [date]="date"
          [dateFormat]="dateFormat"
          [message]="message"
          [quote]="quote"
        >
        </nb-chat-message-quote>

        <nb-chat-message-map
          *ngSwitchCase="'map'"
          [sender]="sender"
          [date]="date"
          [message]="message"
          [latitude]="latitude"
          [longitude]="longitude"
        >
        </nb-chat-message-map>

        <nb-chat-message-text
          *ngSwitchDefault
          [sender]="sender"
          [date]="date"
          [dateFormat]="dateFormat"
          [message]="message"
        >
        </nb-chat-message-text>
      </ng-container>
    </div>

    <ng-template #customTemplate>
      <nb-chat-message-text [sender]="sender" [date]="date" [dateFormat]="dateFormat" [message]="message">
      </nb-chat-message-text>
      <div
        [class.nb-custom-message]="_areDefaultStylesEnabled()"
        [class.nb-custom-message-no-space]="_addNoSpaceClass"
        [class.nb-custom-message-reply]="_addReplyClass"
        [class.nb-custom-message-not-reply]="_addNotReplyClass"
        [class.nb-custom-message-full-width]="!_areDefaultStylesEnabled()"
      >
        <ng-container [ngTemplateOutlet]="_getTemplate()" [ngTemplateOutletContext]="_getTemplateContext()">
        </ng-container>
      </div>
    </ng-template>
  `,
      animations: [trigger("flyInOut", [state("in", style({
        transform: "translateX(0)"
      })), transition("void => *", [style({
        transform: "translateX(-100%)"
      }), animate(80)]), transition("* => void", [animate(80, style({
        transform: "translateX(100%)"
      }))])])],
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], () => [{
    type: DomSanitizer
  }, {
    type: NbChatCustomMessageService
  }], {
    flyInOut: [{
      type: HostBinding,
      args: ["@flyInOut"]
    }],
    notReply: [{
      type: HostBinding,
      args: ["class.not-reply"]
    }],
    reply: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.reply"]
    }],
    message: [{
      type: Input
    }],
    sender: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    dateFormat: [{
      type: Input
    }],
    files: [{
      type: Input
    }],
    quote: [{
      type: Input
    }],
    latitude: [{
      type: Input
    }],
    longitude: [{
      type: Input
    }],
    avatar: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    customMessageData: [{
      type: Input
    }]
  });
})();
var _NbChatTitleDirective = class _NbChatTitleDirective {
  constructor(templateRef) {
    this.templateRef = templateRef;
    this.context = {};
  }
};
_NbChatTitleDirective.\u0275fac = function NbChatTitleDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbChatTitleDirective)(\u0275\u0275directiveInject(TemplateRef));
};
_NbChatTitleDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbChatTitleDirective,
  selectors: [["", "nbChatTitle", ""]],
  inputs: {
    context: "context"
  },
  standalone: false
});
var NbChatTitleDirective = _NbChatTitleDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatTitleDirective, [{
    type: Directive,
    args: [{
      selector: `[nbChatTitle]`,
      standalone: false
    }]
  }], () => [{
    type: TemplateRef
  }], {
    context: [{
      type: Input
    }]
  });
})();
var _NbChatComponent = class _NbChatComponent {
  /**
   * Scroll chat to the bottom of the list when a new message arrives
   */
  get scrollBottom() {
    return this._scrollBottom;
  }
  set scrollBottom(value) {
    this._scrollBottom = convertToBoolProperty(value);
  }
  constructor(statusService) {
    this.statusService = statusService;
    this.status = "basic";
    this.noMessagesPlaceholder = "No messages yet.";
    this._scrollBottom = true;
  }
  ngOnChanges(changes) {
    if ("status" in changes) {
      this.updateFormStatus();
    }
  }
  ngAfterContentInit() {
    this.updateFormStatus();
  }
  ngAfterViewInit() {
    this.messages.changes.subscribe((messages) => {
      this.messages = messages;
      this.updateView();
    });
    this.updateView();
  }
  updateView() {
    if (this.scrollBottom) {
      this.scrollListBottom();
    }
  }
  scrollListBottom() {
    this.scrollable.nativeElement.scrollTop = this.scrollable.nativeElement.scrollHeight;
  }
  updateFormStatus() {
    if (this.chatForm) {
      this.chatForm.setStatus(this.status);
    }
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get primary() {
    return this.status === "primary";
  }
  get success() {
    return this.status === "success";
  }
  get info() {
    return this.status === "info";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
};
_NbChatComponent.\u0275fac = function NbChatComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbChatComponent)(\u0275\u0275directiveInject(NbStatusService));
};
_NbChatComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbChatComponent,
  selectors: [["nb-chat"]],
  contentQueries: function NbChatComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, NbChatFormComponent, 5);
      \u0275\u0275contentQuery(dirIndex, NbChatTitleDirective, 5);
      \u0275\u0275contentQuery(dirIndex, NbChatMessageComponent, 4);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.chatForm = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.titleTemplate = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.messages = _t);
    }
  },
  viewQuery: function NbChatComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c27, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.scrollable = _t.first);
    }
  },
  hostVars: 26,
  hostBindings: function NbChatComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classMap(ctx.additionalClasses);
      \u0275\u0275classProp("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control);
    }
  },
  inputs: {
    title: "title",
    size: "size",
    status: "status",
    noMessagesPlaceholder: "noMessagesPlaceholder",
    scrollBottom: "scrollBottom"
  },
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([NbChatCustomMessageService]), \u0275\u0275NgOnChangesFeature],
  ngContentSelectors: _c29,
  decls: 11,
  vars: 3,
  consts: [["textTitleTemplate", ""], ["scrollable", ""], [1, "header"], [3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngIf", "ngIfElse"], [1, "scrollable"], [1, "messages"], ["class", "no-messages", 4, "ngIf"], [1, "form"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "no-messages"]],
  template: function NbChatComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef(_c28);
      \u0275\u0275elementStart(0, "div", 2);
      \u0275\u0275template(1, NbChatComponent_ng_container_1_Template, 1, 4, "ng-container", 3)(2, NbChatComponent_ng_template_2_Template, 1, 1, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(4, "div", 4, 1)(6, "div", 5);
      \u0275\u0275projection(7);
      \u0275\u0275template(8, NbChatComponent_p_8_Template, 2, 1, "p", 6);
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(9, "div", 7);
      \u0275\u0275projection(10, 1);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      const textTitleTemplate_r2 = \u0275\u0275reference(3);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.titleTemplate)("ngIfElse", textTitleTemplate_r2);
      \u0275\u0275advance(7);
      \u0275\u0275property("ngIf", !(ctx.messages == null ? null : ctx.messages.length));
    }
  },
  dependencies: [NgIf, NgTemplateOutlet],
  styles: ["[_nghost-%COMP%]{display:flex;flex-direction:column;position:relative;height:100%}\n\n\n\n\n\n"]
});
var NbChatComponent = _NbChatComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatComponent, [{
    type: Component,
    args: [{
      selector: "nb-chat",
      template: `
    <div class="header">
      <ng-container
        *ngIf="titleTemplate; else textTitleTemplate"
        [ngTemplateOutlet]="titleTemplate.templateRef"
        [ngTemplateOutletContext]="{ $implicit: titleTemplate.context }"
      >
      </ng-container>
      <ng-template #textTitleTemplate>
        {{ title }}
      </ng-template>
    </div>

    <div class="scrollable" #scrollable>
      <div class="messages">
        <ng-content select="nb-chat-message"></ng-content>
        <p class="no-messages" *ngIf="!messages?.length">{{ noMessagesPlaceholder }}</p>
      </div>
    </div>
    <div class="form">
      <ng-content select="nb-chat-form"></ng-content>
    </div>
  `,
      providers: [NbChatCustomMessageService],
      standalone: false,
      styles: [":host{display:flex;flex-direction:column;position:relative;height:100%}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: NbStatusService
  }], {
    title: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    noMessagesPlaceholder: [{
      type: Input
    }],
    scrollBottom: [{
      type: Input
    }],
    scrollable: [{
      type: ViewChild,
      args: ["scrollable"]
    }],
    messages: [{
      type: ContentChildren,
      args: [NbChatMessageComponent]
    }],
    chatForm: [{
      type: ContentChild,
      args: [NbChatFormComponent]
    }],
    titleTemplate: [{
      type: ContentChild,
      args: [NbChatTitleDirective]
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var NB_INPUT_COMPONENTS = [NbInputDirective];
var _NbInputModule = class _NbInputModule {
};
_NbInputModule.\u0275fac = function NbInputModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbInputModule)();
};
_NbInputModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbInputModule,
  declarations: [NbInputDirective],
  imports: [NbSharedModule],
  exports: [NbInputDirective]
});
_NbInputModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NbSharedModule]
});
var NbInputModule = _NbInputModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbInputModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule],
      declarations: NB_INPUT_COMPONENTS,
      exports: NB_INPUT_COMPONENTS
    }]
  }], null, null);
})();
function throwCustomMessageTypeIsRequired() {
  throw new Error("[nbCustomMessage]: custom message type is required.");
}
var _NbChatCustomMessageDirective = class _NbChatCustomMessageDirective {
  /**
   * Defines a message type which should rendered with the custom message template.
   * @type {string}
   */
  get nbCustomMessage() {
    return this._type;
  }
  set nbCustomMessage(value) {
    this._type = value;
  }
  get type() {
    return this._type;
  }
  /**
   * Disables generic message styles, such as round corners, text color, background, etc.,
   * so a custom message could be styled from the ground up.
   *
   * @type {boolean}
   */
  set nbCustomMessageNoStyles(value) {
    this._noStyles = convertToBoolProperty(value);
  }
  get nbCustomMessageNoStyles() {
    return this._noStyles;
  }
  get noStyles() {
    return this.nbCustomMessageNoStyles;
  }
  constructor(templateRef, customMessageService) {
    this.templateRef = templateRef;
    this.customMessageService = customMessageService;
    this._noStyles = false;
  }
  ngOnInit() {
    if (!this._type) {
      throwCustomMessageTypeIsRequired();
    }
    this.customMessageService.register(this.type, this);
  }
  ngOnDestroy() {
    this.customMessageService.unregister(this.type);
  }
};
_NbChatCustomMessageDirective.\u0275fac = function NbChatCustomMessageDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbChatCustomMessageDirective)(\u0275\u0275directiveInject(TemplateRef), \u0275\u0275directiveInject(NbChatCustomMessageService));
};
_NbChatCustomMessageDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbChatCustomMessageDirective,
  selectors: [["", "nbCustomMessage", ""]],
  inputs: {
    nbCustomMessage: "nbCustomMessage",
    nbCustomMessageNoStyles: "nbCustomMessageNoStyles"
  },
  standalone: false
});
var NbChatCustomMessageDirective = _NbChatCustomMessageDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatCustomMessageDirective, [{
    type: Directive,
    args: [{
      selector: `[nbCustomMessage]`,
      standalone: false
    }]
  }], () => [{
    type: TemplateRef
  }, {
    type: NbChatCustomMessageService
  }], {
    nbCustomMessage: [{
      type: Input
    }],
    nbCustomMessageNoStyles: [{
      type: Input
    }]
  });
})();
var NB_CHAT_COMPONENTS = [NbChatComponent, NbChatMessageComponent, NbChatFormComponent, NbChatMessageTextComponent, NbChatMessageFileComponent, NbChatMessageQuoteComponent, NbChatMessageMapComponent, NbChatAvatarComponent];
var NB_CHAT_DIRECTIVES = [NbChatCustomMessageDirective, NbChatTitleDirective];
var _NbChatModule = class _NbChatModule {
  static forRoot(options) {
    return {
      ngModule: _NbChatModule,
      providers: [{
        provide: NbChatOptions,
        useValue: options || {}
      }]
    };
  }
  static forChild(options) {
    return {
      ngModule: _NbChatModule,
      providers: [{
        provide: NbChatOptions,
        useValue: options || {}
      }]
    };
  }
};
_NbChatModule.\u0275fac = function NbChatModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbChatModule)();
};
_NbChatModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbChatModule,
  declarations: [NbChatComponent, NbChatMessageComponent, NbChatFormComponent, NbChatMessageTextComponent, NbChatMessageFileComponent, NbChatMessageQuoteComponent, NbChatMessageMapComponent, NbChatAvatarComponent, NbChatCustomMessageDirective, NbChatTitleDirective],
  imports: [NbSharedModule, NbIconModule, NbInputModule, NbButtonModule],
  exports: [NbChatComponent, NbChatMessageComponent, NbChatFormComponent, NbChatMessageTextComponent, NbChatMessageFileComponent, NbChatMessageQuoteComponent, NbChatMessageMapComponent, NbChatAvatarComponent, NbChatCustomMessageDirective, NbChatTitleDirective]
});
_NbChatModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NbSharedModule, NbIconModule, NbInputModule, NbButtonModule]
});
var NbChatModule = _NbChatModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbIconModule, NbInputModule, NbButtonModule],
      declarations: [...NB_CHAT_COMPONENTS, ...NB_CHAT_DIRECTIVES],
      exports: [...NB_CHAT_COMPONENTS, ...NB_CHAT_DIRECTIVES]
    }]
  }], null, null);
})();
var _NbSpinnerComponent = class _NbSpinnerComponent {
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get primary() {
    return this.status === "primary";
  }
  get info() {
    return this.status === "info";
  }
  get success() {
    return this.status === "success";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  constructor(statusService) {
    this.statusService = statusService;
    this.message = "Loading...";
    this.size = "medium";
    this.status = "basic";
  }
};
_NbSpinnerComponent.\u0275fac = function NbSpinnerComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbSpinnerComponent)(\u0275\u0275directiveInject(NbStatusService));
};
_NbSpinnerComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbSpinnerComponent,
  selectors: [["nb-spinner"]],
  hostVars: 26,
  hostBindings: function NbSpinnerComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classMap(ctx.additionalClasses);
      \u0275\u0275classProp("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control);
    }
  },
  inputs: {
    message: "message",
    size: "size",
    status: "status"
  },
  standalone: false,
  decls: 2,
  vars: 1,
  consts: [[1, "spin-circle"], ["class", "message", 4, "ngIf"], [1, "message"]],
  template: function NbSpinnerComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275element(0, "span", 0);
      \u0275\u0275template(1, NbSpinnerComponent_span_1_Template, 2, 1, "span", 1);
    }
    if (rf & 2) {
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.message);
    }
  },
  dependencies: [NgIf],
  styles: ["[_nghost-%COMP%]{opacity:1;position:absolute;border-radius:inherit;inset:0;overflow:hidden;z-index:9999;display:flex;justify-content:center;align-items:center;visibility:visible}[_nghost-%COMP%]   .spin-circle[_ngcontent-%COMP%]{animation:spin .8s infinite linear;border-radius:50%;border-style:solid;border-width:.125em;width:1em;height:1em}[_nghost-%COMP%]   .message[_ngcontent-%COMP%]{margin-left:.5rem}\n\n\n\n\n\n"]
});
var NbSpinnerComponent = _NbSpinnerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSpinnerComponent, [{
    type: Component,
    args: [{
      selector: "nb-spinner",
      template: `
    <span class="spin-circle"></span>
    <span class="message" *ngIf="message">{{ message }}</span>
  `,
      standalone: false,
      styles: [":host{opacity:1;position:absolute;border-radius:inherit;inset:0;overflow:hidden;z-index:9999;display:flex;justify-content:center;align-items:center;visibility:visible}:host .spin-circle{animation:spin .8s infinite linear;border-radius:50%;border-style:solid;border-width:.125em;width:1em;height:1em}:host .message{margin-left:.5rem}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: NbStatusService
  }], {
    message: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var _NbSpinnerDirective = class _NbSpinnerDirective {
  /**
   * Directive value - show or hide spinner
   * @param {boolean} val
   */
  set nbSpinner(val) {
    if (val) {
      this.show();
    } else {
      this.hide();
    }
  }
  constructor(directiveView, renderer, directiveElement) {
    this.directiveView = directiveView;
    this.renderer = renderer;
    this.directiveElement = directiveElement;
    this.spinnerStatus = "basic";
    this.spinnerSize = "medium";
    this.isSpinnerExist = false;
  }
  hide() {
    if (this.isSpinnerExist) {
      this.directiveView.remove();
      this.isSpinnerExist = false;
    }
  }
  show() {
    if (!this.isSpinnerExist) {
      this.spinner = this.directiveView.createComponent(NbSpinnerComponent);
      this.setInstanceInputs(this.spinner.instance);
      this.spinner.changeDetectorRef.detectChanges();
      this.renderer.appendChild(this.directiveElement.nativeElement, this.spinner.location.nativeElement);
      this.isSpinnerExist = true;
    }
  }
  setInstanceInputs(instance) {
    instance.message = this.spinnerMessage;
    typeof this.spinnerStatus !== "undefined" && (instance.status = this.spinnerStatus);
    typeof this.spinnerSize !== "undefined" && (instance.size = this.spinnerSize);
  }
};
_NbSpinnerDirective.\u0275fac = function NbSpinnerDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbSpinnerDirective)(\u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef));
};
_NbSpinnerDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbSpinnerDirective,
  selectors: [["", "nbSpinner", ""]],
  hostVars: 2,
  hostBindings: function NbSpinnerDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("nb-spinner-container", ctx.isSpinnerExist);
    }
  },
  inputs: {
    spinnerMessage: [0, "nbSpinnerMessage", "spinnerMessage"],
    spinnerStatus: [0, "nbSpinnerStatus", "spinnerStatus"],
    spinnerSize: [0, "nbSpinnerSize", "spinnerSize"],
    nbSpinner: "nbSpinner"
  },
  standalone: false
});
var NbSpinnerDirective = _NbSpinnerDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSpinnerDirective, [{
    type: Directive,
    args: [{
      selector: "[nbSpinner]",
      standalone: false
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: Renderer2
  }, {
    type: ElementRef
  }], {
    spinnerMessage: [{
      type: Input,
      args: ["nbSpinnerMessage"]
    }],
    spinnerStatus: [{
      type: Input,
      args: ["nbSpinnerStatus"]
    }],
    spinnerSize: [{
      type: Input,
      args: ["nbSpinnerSize"]
    }],
    nbSpinner: [{
      type: Input,
      args: ["nbSpinner"]
    }],
    isSpinnerExist: [{
      type: HostBinding,
      args: ["class.nb-spinner-container"]
    }]
  });
})();
var _NbSpinnerModule = class _NbSpinnerModule {
};
_NbSpinnerModule.\u0275fac = function NbSpinnerModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbSpinnerModule)();
};
_NbSpinnerModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbSpinnerModule,
  declarations: [NbSpinnerComponent, NbSpinnerDirective],
  imports: [NbSharedModule],
  exports: [NbSpinnerComponent, NbSpinnerDirective]
});
_NbSpinnerModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NbSharedModule]
});
var NbSpinnerModule = _NbSpinnerModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSpinnerModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule],
      exports: [NbSpinnerComponent, NbSpinnerDirective],
      declarations: [NbSpinnerComponent, NbSpinnerDirective]
    }]
  }], null, null);
})();
var NB_STEPPER = new InjectionToken("Nebular Stepper Component");
var _NbStepComponent = class _NbStepComponent {
  /**
   * Whether step will be displayed in wizard
   *
   * @type {boolean}
   */
  get hidden() {
    return this._hidden;
  }
  set hidden(value) {
    this._hidden = convertToBoolProperty(value);
  }
  /**
   * Check that label is a TemplateRef.
   *
   * @return boolean
   * */
  get isLabelTemplate() {
    return this.label instanceof TemplateRef;
  }
  /**
   * Whether step is marked as completed.
   *
   * @type {boolean}
   */
  get completed() {
    return this._completed || this.isCompleted;
  }
  set completed(value) {
    this._completed = convertToBoolProperty(value);
  }
  get isCompleted() {
    return this.stepControl ? this.stepControl.valid && this.interacted : this.interacted;
  }
  constructor(stepper) {
    this._hidden = false;
    this._completed = false;
    this.interacted = false;
    this.stepper = stepper;
  }
  /**
   * Mark step as selected
   * */
  select() {
    this.stepper.selected = this;
  }
  /**
   * Reset step and stepControl state
   * */
  reset() {
    this.interacted = false;
    if (this.stepControl) {
      this.stepControl.reset();
    }
  }
};
_NbStepComponent.\u0275fac = function NbStepComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbStepComponent)(\u0275\u0275directiveInject(NB_STEPPER));
};
_NbStepComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbStepComponent,
  selectors: [["nb-step"]],
  viewQuery: function NbStepComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(TemplateRef, 7);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.content = _t.first);
    }
  },
  inputs: {
    stepControl: "stepControl",
    label: "label",
    hidden: "hidden",
    completed: "completed"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function NbStepComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275template(0, NbStepComponent_ng_template_0_Template, 1, 0, "ng-template");
    }
  },
  encapsulation: 2
});
var NbStepComponent = _NbStepComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbStepComponent, [{
    type: Component,
    args: [{
      selector: "nb-step",
      template: `
    <ng-template>
      <ng-content></ng-content>
    </ng-template>
  `,
      standalone: false
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_STEPPER]
    }]
  }], {
    content: [{
      type: ViewChild,
      args: [TemplateRef, {
        static: true
      }]
    }],
    stepControl: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    hidden: [{
      type: Input
    }],
    completed: [{
      type: Input
    }]
  });
})();
var _NbStepperComponent = class _NbStepperComponent {
  constructor() {
    this._selectedIndex = 0;
    this._disableStepNavigation = false;
    this.orientation = "horizontal";
    this._linear = true;
    this.stepChange = new EventEmitter();
  }
  /**
   * Selected step index
   */
  get selectedIndex() {
    return this._selectedIndex;
  }
  set selectedIndex(index) {
    if (!this.steps) {
      this._selectedIndex = index;
      return;
    }
    this.markCurrentStepInteracted();
    if (this.canBeSelected(index)) {
      const previouslySelectedIndex = this._selectedIndex;
      const previouslySelectedStep = this.selected;
      this._selectedIndex = index;
      this.stepChange.emit({
        index: this.selectedIndex,
        step: this.selected,
        previouslySelectedIndex,
        previouslySelectedStep
      });
    }
  }
  /**
   * Disables navigation by clicking on steps. False by default
   * @param {boolean} value
   */
  set disableStepNavigation(value) {
    this._disableStepNavigation = convertToBoolProperty(value);
  }
  get disableStepNavigation() {
    return this._disableStepNavigation;
  }
  /**
   * Selected step component
   */
  get selected() {
    return this.steps ? this.steps.toArray()[this.selectedIndex] : void 0;
  }
  set selected(step) {
    if (!this.steps) {
      return;
    }
    this.selectedIndex = this.steps.toArray().indexOf(step);
  }
  /**
   * Allow moving forward only if the current step is complete
   * @default true
   */
  set linear(value) {
    this._linear = convertToBoolProperty(value);
  }
  get linear() {
    return this._linear;
  }
  get vertical() {
    return this.orientation === "vertical";
  }
  get horizontal() {
    return this.orientation === "horizontal";
  }
  /**
   * Navigate to next step
   * */
  next() {
    this.selectedIndex = Math.min(this.selectedIndex + 1, this.steps.length - 1);
  }
  /**
   * Navigate to previous step
   * */
  previous() {
    this.selectedIndex = Math.max(this.selectedIndex - 1, 0);
  }
  /**
   * Select step if navigation is not disabled
   * @param { NbStepComponent } step
   */
  changeStep(step) {
    if (!this.disableStepNavigation) {
      step.select();
    }
  }
  /**
   * Reset stepper and stepControls to initial state
   * */
  reset() {
    const previouslySelectedIndex = this.selectedIndex;
    const previouslySelectedStep = this.selected;
    this._selectedIndex = 0;
    this.steps.forEach((step) => step.reset());
    this.stepChange.emit({
      index: this.selectedIndex,
      step: this.selected,
      previouslySelectedIndex,
      previouslySelectedStep
    });
  }
  isStepSelected(step) {
    return this.selected === step;
  }
  /*
   * @docs-private
   **/
  getStepTemplate(step) {
    if (step.isLabelTemplate) {
      return step.label;
    }
    return null;
  }
  isStepValid(index) {
    return this.steps.toArray()[index].completed;
  }
  canBeSelected(indexToCheck) {
    const noSteps = !this.steps || this.steps.length === 0;
    if (noSteps || indexToCheck < 0 || indexToCheck >= this.steps.length || indexToCheck === this.selectedIndex) {
      return false;
    }
    if (indexToCheck <= this.selectedIndex || !this.linear) {
      return true;
    }
    let isAllStepsValid = true;
    for (let i = this.selectedIndex; i < indexToCheck; i++) {
      if (!this.isStepValid(i)) {
        isAllStepsValid = false;
        break;
      }
    }
    return isAllStepsValid;
  }
  markCurrentStepInteracted() {
    if (this.selected) {
      this.selected.interacted = true;
    }
  }
};
_NbStepperComponent.\u0275fac = function NbStepperComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbStepperComponent)();
};
_NbStepperComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbStepperComponent,
  selectors: [["nb-stepper"]],
  contentQueries: function NbStepperComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, NbStepComponent, 4);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.steps = _t);
    }
  },
  hostVars: 4,
  hostBindings: function NbStepperComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("vertical", ctx.vertical)("horizontal", ctx.horizontal);
    }
  },
  inputs: {
    selectedIndex: "selectedIndex",
    disableStepNavigation: "disableStepNavigation",
    selected: "selected",
    orientation: "orientation",
    linear: "linear"
  },
  outputs: {
    stepChange: "stepChange"
  },
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NB_STEPPER,
    useExisting: _NbStepperComponent
  }])],
  ngContentSelectors: _c32,
  decls: 5,
  vars: 2,
  consts: [[1, "header"], [4, "ngFor", "ngForOf"], [1, "step-content"], [3, "ngTemplateOutlet"], ["class", "connector", 3, "connector-past", 4, "ngIf"], ["class", "step", 3, "selected", "completed", "noninteractive", "click", 4, "ngIf"], [1, "connector"], [1, "step", 3, "click"], [1, "label-index"], [4, "ngIf"], ["icon", "checkmark-outline", "pack", "nebular-essentials", 4, "ngIf"], [1, "label"], ["icon", "checkmark-outline", "pack", "nebular-essentials"], [4, "ngTemplateOutlet"]],
  template: function NbStepperComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef(_c31);
      \u0275\u0275template(0, NbStepperComponent_ng_template_0_Template, 1, 0, "ng-template");
      \u0275\u0275elementStart(1, "div", 0);
      \u0275\u0275template(2, NbStepperComponent_ng_container_2_Template, 3, 2, "ng-container", 1);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(3, "div", 2);
      \u0275\u0275elementContainer(4, 3);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance(2);
      \u0275\u0275property("ngForOf", ctx.steps);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngTemplateOutlet", ctx.selected == null ? null : ctx.selected.content);
    }
  },
  dependencies: [NgForOf, NgIf, NgTemplateOutlet, NbIconComponent],
  styles: [".horizontal[_nghost-%COMP%]   .header[_ngcontent-%COMP%]   .step[_ngcontent-%COMP%]{flex-direction:column}.horizontal[_nghost-%COMP%]   .header[_ngcontent-%COMP%]   .connector[_ngcontent-%COMP%]{height:2px}.horizontal[_nghost-%COMP%]   .label-index[_ngcontent-%COMP%]{margin-bottom:10px}.vertical[_nghost-%COMP%]{display:flex;height:100%}.vertical[_nghost-%COMP%]   .header[_ngcontent-%COMP%]{flex-direction:column}.vertical[_nghost-%COMP%]   .header[_ngcontent-%COMP%]   .label[_ngcontent-%COMP%]{margin:0 10px}.vertical[_nghost-%COMP%]   .header[_ngcontent-%COMP%]   .connector[_ngcontent-%COMP%]{width:2px}.header[_ngcontent-%COMP%]{display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:10px}.header[_ngcontent-%COMP%]   .connector[_ngcontent-%COMP%]{flex:auto}.header[_ngcontent-%COMP%]   .step[_ngcontent-%COMP%]{display:flex;align-items:center;cursor:pointer}.header[_ngcontent-%COMP%]   .step.noninteractive[_ngcontent-%COMP%]{cursor:default}.header[_ngcontent-%COMP%]   .label-index[_ngcontent-%COMP%]{display:flex;justify-content:center;align-items:center}.header[_ngcontent-%COMP%]   .label[_ngcontent-%COMP%]{width:max-content}"]
});
var NbStepperComponent = _NbStepperComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbStepperComponent, [{
    type: Component,
    args: [{
      selector: "nb-stepper",
      providers: [{
        provide: NB_STEPPER,
        useExisting: NbStepperComponent
      }],
      standalone: false,
      template: '<ng-template><ng-content select="nb-step"></ng-content></ng-template>\n<div class="header">\n  <ng-container *ngFor="let step of steps; let index = index; let first = first">\n\n    <div *ngIf="!first && !step.hidden"\n         [class.connector-past]="index <= selectedIndex"\n         class="connector"></div>\n\n    <div *ngIf="!step.hidden" class="step"\n         [class.selected]="isStepSelected(step)"\n         [class.completed]="!isStepSelected(step) && step.completed"\n         [class.noninteractive]="disableStepNavigation"\n         (click)="changeStep(step)">\n      <div class="label-index">\n        <span *ngIf="!step.completed || isStepSelected(step)">{{ index + 1 }}</span>\n        <nb-icon *ngIf="!isStepSelected(step) && step.completed" icon="checkmark-outline" pack="nebular-essentials">\n        </nb-icon>\n      </div>\n      <div class="label">\n        <ng-container *ngIf="step.isLabelTemplate">\n          <ng-container *ngTemplateOutlet="getStepTemplate(step)"></ng-container>\n        </ng-container>\n        <span *ngIf="!step.isLabelTemplate">{{ step.label }}</span>\n      </div>\n    </div>\n  </ng-container>\n</div>\n<div class="step-content">\n  <ng-container [ngTemplateOutlet]="selected?.content"></ng-container>\n</div>\n',
      styles: [":host(.horizontal) .header .step{flex-direction:column}:host(.horizontal) .header .connector{height:2px}:host(.horizontal) .label-index{margin-bottom:10px}:host(.vertical){display:flex;height:100%}:host(.vertical) .header{flex-direction:column}:host(.vertical) .header .label{margin:0 10px}:host(.vertical) .header .connector{width:2px}.header{display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:10px}.header .connector{flex:auto}.header .step{display:flex;align-items:center;cursor:pointer}.header .step.noninteractive{cursor:default}.header .label-index{display:flex;justify-content:center;align-items:center}.header .label{width:max-content}\n"]
    }]
  }], null, {
    selectedIndex: [{
      type: Input
    }],
    disableStepNavigation: [{
      type: Input
    }],
    selected: [{
      type: Input
    }],
    orientation: [{
      type: Input
    }],
    linear: [{
      type: Input
    }],
    stepChange: [{
      type: Output
    }],
    vertical: [{
      type: HostBinding,
      args: ["class.vertical"]
    }],
    horizontal: [{
      type: HostBinding,
      args: ["class.horizontal"]
    }],
    steps: [{
      type: ContentChildren,
      args: [NbStepComponent]
    }]
  });
})();
var _NbStepperNextDirective = class _NbStepperNextDirective {
  constructor(stepper) {
    this.stepper = stepper;
    this.type = "submit";
  }
  onClick() {
    this.stepper.next();
  }
};
_NbStepperNextDirective.\u0275fac = function NbStepperNextDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbStepperNextDirective)(\u0275\u0275directiveInject(NbStepperComponent));
};
_NbStepperNextDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbStepperNextDirective,
  selectors: [["button", "nbStepperNext", ""]],
  hostVars: 1,
  hostBindings: function NbStepperNextDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function NbStepperNextDirective_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
    if (rf & 2) {
      \u0275\u0275attribute("type", ctx.type);
    }
  },
  inputs: {
    type: "type"
  },
  standalone: false
});
var NbStepperNextDirective = _NbStepperNextDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbStepperNextDirective, [{
    type: Directive,
    args: [{
      selector: "button[nbStepperNext]",
      standalone: false
    }]
  }], () => [{
    type: NbStepperComponent
  }], {
    type: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.type"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var _NbStepperPreviousDirective = class _NbStepperPreviousDirective {
  constructor(stepper) {
    this.stepper = stepper;
    this.type = "button";
  }
  onClick() {
    this.stepper.previous();
  }
};
_NbStepperPreviousDirective.\u0275fac = function NbStepperPreviousDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbStepperPreviousDirective)(\u0275\u0275directiveInject(NbStepperComponent));
};
_NbStepperPreviousDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbStepperPreviousDirective,
  selectors: [["button", "nbStepperPrevious", ""]],
  hostVars: 1,
  hostBindings: function NbStepperPreviousDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function NbStepperPreviousDirective_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
    if (rf & 2) {
      \u0275\u0275attribute("type", ctx.type);
    }
  },
  inputs: {
    type: "type"
  },
  standalone: false
});
var NbStepperPreviousDirective = _NbStepperPreviousDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbStepperPreviousDirective, [{
    type: Directive,
    args: [{
      selector: "button[nbStepperPrevious]",
      standalone: false
    }]
  }], () => [{
    type: NbStepperComponent
  }], {
    type: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.type"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var _NbStepperModule = class _NbStepperModule {
};
_NbStepperModule.\u0275fac = function NbStepperModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbStepperModule)();
};
_NbStepperModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbStepperModule,
  declarations: [NbStepperComponent, NbStepComponent, NbStepperNextDirective, NbStepperPreviousDirective],
  imports: [NbSharedModule, NbIconModule],
  exports: [NbStepperComponent, NbStepComponent, NbStepperNextDirective, NbStepperPreviousDirective]
});
_NbStepperModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NbSharedModule, NbIconModule]
});
var NbStepperModule = _NbStepperModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbStepperModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbIconModule],
      declarations: [NbStepperComponent, NbStepComponent, NbStepperNextDirective, NbStepperPreviousDirective],
      exports: [NbStepperComponent, NbStepComponent, NbStepperNextDirective, NbStepperPreviousDirective]
    }]
  }], null, null);
})();
var _NbAccordionComponent = class _NbAccordionComponent {
  constructor() {
    this.openCloseItems = new Subject();
    this.multiValue = false;
  }
  /**
   *  Allow multiple items to be expanded at the same time.
   * @type {boolean}
   */
  get multi() {
    return this.multiValue;
  }
  set multi(val) {
    this.multiValue = convertToBoolProperty(val);
  }
  /**
   * Opens all enabled accordion items.
   */
  openAll() {
    if (this.multi) {
      this.openCloseItems.next(false);
    }
  }
  /**
   * Closes all enabled accordion items.
   */
  closeAll() {
    this.openCloseItems.next(true);
  }
};
_NbAccordionComponent.\u0275fac = function NbAccordionComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbAccordionComponent)();
};
_NbAccordionComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbAccordionComponent,
  selectors: [["nb-accordion"]],
  inputs: {
    multi: "multi"
  },
  standalone: false,
  ngContentSelectors: _c34,
  decls: 1,
  vars: 0,
  template: function NbAccordionComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef(_c33);
      \u0275\u0275projection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbAccordionComponent = _NbAccordionComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAccordionComponent, [{
    type: Component,
    args: [{
      selector: "nb-accordion",
      template: `
    <ng-content select="nb-accordion-item"></ng-content>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], null, {
    multi: [{
      type: Input,
      args: ["multi"]
    }]
  });
})();
var _NbAccordionItemComponent = class _NbAccordionItemComponent {
  /**
   * Item is collapse (`true` by default)
   * @type {boolean}
   */
  get collapsed() {
    return this.collapsedValue;
  }
  set collapsed(val) {
    this.collapsedValue = convertToBoolProperty(val);
    this.collapsedChange.emit(this.collapsedValue);
    this.invalidate();
  }
  /**
   * Item is expanded (`false` by default)
   * @type {boolean}
   */
  get expanded() {
    return !this.collapsed;
  }
  set expanded(val) {
    this.collapsedValue = !convertToBoolProperty(val);
  }
  /**
   * Item is disabled and cannot be opened.
   * @type {boolean}
   */
  get disabled() {
    return this.disabledValue;
  }
  set disabled(val) {
    this.disabledValue = convertToBoolProperty(val);
    this.invalidate();
  }
  constructor(accordion, cd) {
    this.accordion = accordion;
    this.cd = cd;
    this.collapsedChange = new EventEmitter();
    this.accordionItemInvalidate = new Subject();
    this.collapsedValue = true;
    this.disabledValue = false;
    this.destroy$ = new Subject();
  }
  /**
   * Open/close the item
   */
  toggle() {
    if (!this.disabled) {
      const willSet = !this.collapsed;
      if (!this.accordion.multi) {
        this.accordion.openCloseItems.next(true);
      }
      this.collapsed = willSet;
    }
  }
  /**
   * Open the item.
   */
  open() {
    !this.disabled && (this.collapsed = false);
  }
  /**
   * Collapse the item.
   */
  close() {
    !this.disabled && (this.collapsed = true);
  }
  ngOnInit() {
    this.accordion.openCloseItems.pipe(takeUntil(this.destroy$)).subscribe((collapsed) => {
      !this.disabled && (this.collapsed = collapsed);
    });
  }
  ngOnChanges(changes) {
    this.accordionItemInvalidate.next(true);
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
    this.accordionItemInvalidate.complete();
  }
  invalidate() {
    this.accordionItemInvalidate.next(true);
    this.cd.markForCheck();
  }
};
_NbAccordionItemComponent.\u0275fac = function NbAccordionItemComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbAccordionItemComponent)(\u0275\u0275directiveInject(NbAccordionComponent, 1), \u0275\u0275directiveInject(ChangeDetectorRef));
};
_NbAccordionItemComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbAccordionItemComponent,
  selectors: [["nb-accordion-item"]],
  hostVars: 6,
  hostBindings: function NbAccordionItemComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("collapsed", ctx.collapsed)("expanded", ctx.expanded)("disabled", ctx.disabled);
    }
  },
  inputs: {
    collapsed: "collapsed",
    expanded: "expanded",
    disabled: "disabled"
  },
  outputs: {
    collapsedChange: "collapsedChange"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  ngContentSelectors: _c36,
  decls: 2,
  vars: 0,
  template: function NbAccordionItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef(_c35);
      \u0275\u0275projection(0);
      \u0275\u0275projection(1, 1);
    }
  },
  styles: [_c8],
  changeDetection: 0
});
var NbAccordionItemComponent = _NbAccordionItemComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAccordionItemComponent, [{
    type: Component,
    args: [{
      selector: "nb-accordion-item",
      template: `
    <ng-content select="nb-accordion-item-header"></ng-content>
    <ng-content select="nb-accordion-item-body"></ng-content>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      styles: [":host{display:flex;flex-direction:column}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: NbAccordionComponent,
    decorators: [{
      type: Host
    }]
  }, {
    type: ChangeDetectorRef
  }], {
    collapsed: [{
      type: Input,
      args: ["collapsed"]
    }, {
      type: HostBinding,
      args: ["class.collapsed"]
    }],
    expanded: [{
      type: Input,
      args: ["expanded"]
    }, {
      type: HostBinding,
      args: ["class.expanded"]
    }],
    disabled: [{
      type: Input,
      args: ["disabled"]
    }, {
      type: HostBinding,
      args: ["class.disabled"]
    }],
    collapsedChange: [{
      type: Output
    }]
  });
})();
var accordionItemBodyTrigger = trigger("accordionItemBody", [state("collapsed", style({
  overflow: "hidden",
  visibility: "hidden",
  height: 0
})), state("expanded", style({
  overflow: "hidden",
  visibility: "visible"
})), transition("collapsed => expanded", animate("100ms ease-in")), transition("expanded => collapsed", animate("100ms ease-out"))]);
var _NbAccordionItemBodyComponent = class _NbAccordionItemBodyComponent {
  constructor(accordionItem, cd) {
    this.accordionItem = accordionItem;
    this.cd = cd;
    this.destroy$ = new Subject();
  }
  get state() {
    return this.accordionItem.collapsed ? "collapsed" : "expanded";
  }
  ngOnInit() {
    this.accordionItem.accordionItemInvalidate.pipe(takeUntil(this.destroy$)).subscribe(() => this.cd.markForCheck());
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
};
_NbAccordionItemBodyComponent.\u0275fac = function NbAccordionItemBodyComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbAccordionItemBodyComponent)(\u0275\u0275directiveInject(NbAccordionItemComponent, 1), \u0275\u0275directiveInject(ChangeDetectorRef));
};
_NbAccordionItemBodyComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbAccordionItemBodyComponent,
  selectors: [["nb-accordion-item-body"]],
  standalone: false,
  ngContentSelectors: _c0,
  decls: 3,
  vars: 3,
  consts: [[1, "item-body"]],
  template: function NbAccordionItemBodyComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275elementStart(0, "div")(1, "div", 0);
      \u0275\u0275projection(2);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275property("@accordionItemBody", \u0275\u0275pureFunction1(1, _c37, ctx.state));
    }
  },
  encapsulation: 2,
  data: {
    animation: [accordionItemBodyTrigger]
  },
  changeDetection: 0
});
var NbAccordionItemBodyComponent = _NbAccordionItemBodyComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAccordionItemBodyComponent, [{
    type: Component,
    args: [{
      selector: "nb-accordion-item-body",
      template: `
    <div [@accordionItemBody]="{ value: state }">
      <div class="item-body">
        <ng-content></ng-content>
      </div>
    </div>
  `,
      animations: [accordionItemBodyTrigger],
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], () => [{
    type: NbAccordionItemComponent,
    decorators: [{
      type: Host
    }]
  }, {
    type: ChangeDetectorRef
  }], null);
})();
var _NbAccordionItemHeaderComponent = class _NbAccordionItemHeaderComponent {
  get isCollapsed() {
    return this.accordionItem.collapsed;
  }
  get expanded() {
    return !this.accordionItem.collapsed;
  }
  // issue #794
  get tabbable() {
    return this.accordionItem.disabled ? "-1" : "0";
  }
  get disabled() {
    return this.accordionItem.disabled;
  }
  toggle() {
    this.accordionItem.toggle();
  }
  get state() {
    if (this.isCollapsed) {
      return "collapsed";
    }
    return "expanded";
  }
  constructor(accordionItem, cd) {
    this.accordionItem = accordionItem;
    this.cd = cd;
    this.destroy$ = new Subject();
  }
  ngOnInit() {
    this.accordionItem.accordionItemInvalidate.pipe(takeUntil(this.destroy$)).subscribe(() => this.cd.markForCheck());
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
};
_NbAccordionItemHeaderComponent.\u0275fac = function NbAccordionItemHeaderComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbAccordionItemHeaderComponent)(\u0275\u0275directiveInject(NbAccordionItemComponent, 1), \u0275\u0275directiveInject(ChangeDetectorRef));
};
_NbAccordionItemHeaderComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbAccordionItemHeaderComponent,
  selectors: [["nb-accordion-item-header"]],
  hostVars: 7,
  hostBindings: function NbAccordionItemHeaderComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function NbAccordionItemHeaderComponent_click_HostBindingHandler() {
        return ctx.toggle();
      })("keydown.space", function NbAccordionItemHeaderComponent_keydown_space_HostBindingHandler() {
        return ctx.toggle();
      })("keydown.enter", function NbAccordionItemHeaderComponent_keydown_enter_HostBindingHandler() {
        return ctx.toggle();
      });
    }
    if (rf & 2) {
      \u0275\u0275attribute("aria-expanded", ctx.expanded)("tabindex", ctx.tabbable)("aria-disabled", ctx.disabled);
      \u0275\u0275classProp("accordion-item-header-collapsed", ctx.isCollapsed)("accordion-item-header-expanded", ctx.expanded);
    }
  },
  standalone: false,
  ngContentSelectors: _c39,
  decls: 4,
  vars: 1,
  consts: [["icon", "chevron-down-outline", "pack", "nebular-essentials", "class", "expansion-indicator", 4, "ngIf"], ["icon", "chevron-down-outline", "pack", "nebular-essentials", 1, "expansion-indicator"]],
  template: function NbAccordionItemHeaderComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef(_c38);
      \u0275\u0275projection(0);
      \u0275\u0275projection(1, 1);
      \u0275\u0275projection(2, 2);
      \u0275\u0275template(3, NbAccordionItemHeaderComponent_nb_icon_3_Template, 1, 1, "nb-icon", 0);
    }
    if (rf & 2) {
      \u0275\u0275advance(3);
      \u0275\u0275property("ngIf", !ctx.disabled);
    }
  },
  dependencies: [NgIf, NbIconComponent],
  styles: ["[_nghost-%COMP%]{display:flex;align-items:center;cursor:pointer}[_nghost-%COMP%]:focus{outline:0}\n\n\n\n\n\n"],
  data: {
    animation: [trigger("expansionIndicator", [state("expanded", style({
      transform: "rotate(180deg)"
    })), transition("collapsed => expanded", animate("100ms ease-in")), transition("expanded => collapsed", animate("100ms ease-out"))])]
  },
  changeDetection: 0
});
var NbAccordionItemHeaderComponent = _NbAccordionItemHeaderComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAccordionItemHeaderComponent, [{
    type: Component,
    args: [{
      selector: "nb-accordion-item-header",
      template: `
    <ng-content select="nb-accordion-item-title"></ng-content>
    <ng-content select="nb-accordion-item-description"></ng-content>
    <ng-content></ng-content>
    <nb-icon icon="chevron-down-outline"
             pack="nebular-essentials"
             [@expansionIndicator]="state"
             *ngIf="!disabled"
             class="expansion-indicator">
    </nb-icon>
  `,
      animations: [trigger("expansionIndicator", [state("expanded", style({
        transform: "rotate(180deg)"
      })), transition("collapsed => expanded", animate("100ms ease-in")), transition("expanded => collapsed", animate("100ms ease-out"))])],
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      styles: [":host{display:flex;align-items:center;cursor:pointer}:host:focus{outline:0}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: NbAccordionItemComponent,
    decorators: [{
      type: Host
    }]
  }, {
    type: ChangeDetectorRef
  }], {
    isCollapsed: [{
      type: HostBinding,
      args: ["class.accordion-item-header-collapsed"]
    }],
    expanded: [{
      type: HostBinding,
      args: ["class.accordion-item-header-expanded"]
    }, {
      type: HostBinding,
      args: ["attr.aria-expanded"]
    }],
    tabbable: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    disabled: [{
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }],
    toggle: [{
      type: HostListener,
      args: ["click"]
    }, {
      type: HostListener,
      args: ["keydown.space"]
    }, {
      type: HostListener,
      args: ["keydown.enter"]
    }]
  });
})();
var NB_ACCORDION_COMPONENTS = [NbAccordionComponent, NbAccordionItemComponent, NbAccordionItemHeaderComponent, NbAccordionItemBodyComponent];
var _NbAccordionModule = class _NbAccordionModule {
};
_NbAccordionModule.\u0275fac = function NbAccordionModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbAccordionModule)();
};
_NbAccordionModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbAccordionModule,
  declarations: [NbAccordionComponent, NbAccordionItemComponent, NbAccordionItemHeaderComponent, NbAccordionItemBodyComponent],
  imports: [CommonModule, NbIconModule],
  exports: [NbAccordionComponent, NbAccordionItemComponent, NbAccordionItemHeaderComponent, NbAccordionItemBodyComponent]
});
_NbAccordionModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, NbIconModule]
});
var NbAccordionModule = _NbAccordionModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAccordionModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NbIconModule],
      exports: [...NB_ACCORDION_COMPONENTS],
      declarations: [...NB_ACCORDION_COMPONENTS],
      providers: []
    }]
  }], null, null);
})();
var NB_BUTTON_GROUP = new InjectionToken("NB_BUTTON_GROUP");
var _NbButtonToggleDirective = class _NbButtonToggleDirective extends NbButton {
  get pressedChange$() {
    return this._pressedChange$.asObservable();
  }
  /**
   * Controls button pressed state
   **/
  get pressed() {
    return this._pressed;
  }
  set pressed(value) {
    if (this.pressed !== convertToBoolProperty(value)) {
      this._pressed = !this.pressed;
      this.pressedChange.emit(this.pressed);
      this._pressedChange$.next({
        source: this,
        pressed: this.pressed
      });
    }
  }
  get basic() {
    return !this.pressed;
  }
  get primary() {
    return this.pressed && (this.status === "basic" || this.status === "primary");
  }
  get success() {
    return this.pressed && this.status === "success";
  }
  get info() {
    return this.pressed && this.status === "info";
  }
  get warning() {
    return this.pressed && this.status === "warning";
  }
  get danger() {
    return this.pressed && this.status === "danger";
  }
  get control() {
    return this.pressed && this.status === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  onClick() {
    if (this.buttonGroup?.multiple || !this.pressed) {
      this.pressed = !this.pressed;
    }
  }
  constructor(renderer, hostElement, cd, zone, statusService, buttonGroup) {
    super(renderer, hostElement, cd, zone, statusService);
    this.renderer = renderer;
    this.hostElement = hostElement;
    this.cd = cd;
    this.zone = zone;
    this.statusService = statusService;
    this.buttonGroup = buttonGroup;
    this._pressedChange$ = new Subject();
    this.appearance = "filled";
    this._pressed = false;
    this.pressedChange = new EventEmitter();
  }
  /**
   * @docs-private
   */
  _updatePressed(value) {
    this.pressed = value;
    this.cd.markForCheck();
  }
};
_NbButtonToggleDirective.\u0275fac = function NbButtonToggleDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbButtonToggleDirective)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(NbStatusService), \u0275\u0275directiveInject(NB_BUTTON_GROUP, 8));
};
_NbButtonToggleDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbButtonToggleDirective,
  selectors: [["button", "nbButtonToggle", ""]],
  hostVars: 17,
  hostBindings: function NbButtonToggleDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function NbButtonToggleDirective_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
    if (rf & 2) {
      \u0275\u0275attribute("aria-pressed", ctx.pressed);
      \u0275\u0275classMap(ctx.additionalClasses);
      \u0275\u0275classProp("status-basic", ctx.basic)("status-primary", ctx.primary)("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-control", ctx.control);
    }
  },
  inputs: {
    appearance: "appearance",
    value: "value",
    pressed: "pressed"
  },
  outputs: {
    pressedChange: "pressedChange"
  },
  exportAs: ["nbButtonToggle"],
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NbButton,
    useExisting: _NbButtonToggleDirective
  }]), \u0275\u0275InheritDefinitionFeature]
});
var NbButtonToggleDirective = _NbButtonToggleDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbButtonToggleDirective, [{
    type: Directive,
    args: [{
      selector: "button[nbButtonToggle]",
      providers: [{
        provide: NbButton,
        useExisting: NbButtonToggleDirective
      }],
      exportAs: "nbButtonToggle",
      standalone: false
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NB_BUTTON_GROUP]
    }]
  }], {
    appearance: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    pressed: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.aria-pressed"]
    }],
    pressedChange: [{
      type: Output
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var _NbButtonGroupComponent = class _NbButtonGroupComponent {
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    if (this.disabled !== convertToBoolProperty(value)) {
      this._disabled = !this.disabled;
    }
  }
  /**
   * Allows to keep multiple button toggles pressed. Off by default.
   */
  get multiple() {
    return this._multiple;
  }
  set multiple(value) {
    this._multiple = convertToBoolProperty(value);
  }
  /**
   * Sets `filled` appearance
   */
  get filled() {
    return this.appearance === "filled";
  }
  set filled(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "filled";
    }
  }
  /**
   * Sets `outline` appearance
   */
  get outline() {
    return this.appearance === "outline";
  }
  set outline(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "outline";
    }
  }
  /**
   * Sets `ghost` appearance
   */
  get ghost() {
    return this.appearance === "ghost";
  }
  set ghost(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "ghost";
    }
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  constructor(cd, statusService) {
    this.cd = cd;
    this.statusService = statusService;
    this.lastEmittedValue = [];
    this.destroy$ = new Subject();
    this.buttonsChange$ = new Subject();
    this.size = "medium";
    this.status = "basic";
    this.shape = "rectangle";
    this.appearance = "filled";
    this._disabled = false;
    this._multiple = false;
    this.valueChange = new EventEmitter();
    this.role = "group";
  }
  ngOnChanges({
    size,
    status,
    shape,
    multiple,
    filled,
    outline,
    ghost,
    disabled
  }) {
    if (size || status || shape || multiple || filled || outline || ghost || disabled) {
      this.syncButtonsProperties(this.buttons?.toArray() || []);
    }
  }
  ngAfterContentInit() {
    this.buttonsChange$.pipe(takeUntil(this.destroy$)).subscribe((buttons) => {
      this.listenButtonPressedState(buttons);
      this.syncButtonsProperties(buttons);
    });
    this.buttons.changes.pipe(
      // `buttons.changes` emit during change detection run after projected content already was initialized.
      // So at this time, it's too late to update projected buttons properties as updating bindings after
      // initialization doesn't make sense. Changes won't be picked up and should cause an "expression changed" error.
      // Instead, we wrap the new buttons list into a promise to defer update to the following microtask and also to
      // trigger change detection one more time.
      switchMap((buttons) => from(Promise.resolve(buttons.toArray()))),
      takeUntil(this.destroy$)
    ).subscribe(this.buttonsChange$);
    this.buttonsChange$.next(this.buttons.toArray());
  }
  listenButtonPressedState(buttons) {
    const toggleButtons = buttons.filter((button) => {
      return button instanceof NbButtonToggleDirective;
    });
    if (!toggleButtons.length) {
      return;
    }
    const buttonsPressedChange$ = toggleButtons.map((button) => button.pressedChange$);
    merge(...buttonsPressedChange$).pipe(filter(({
      pressed
    }) => !this.multiple && pressed), takeUntil(merge(this.buttonsChange$, this.destroy$))).subscribe(({
      source
    }) => {
      toggleButtons.filter((button) => button !== source).forEach((button) => button._updatePressed(false));
    });
    merge(...buttonsPressedChange$).pipe(
      // Use startWith to emit if some buttons are initially pressed.
      startWith(""),
      // Use debounce to emit change once when pressed state change in multiple button toggles.
      debounceTime(0),
      takeUntil(merge(this.buttonsChange$, this.destroy$))
    ).subscribe(() => this.emitCurrentValue(toggleButtons));
  }
  syncButtonsProperties(buttons) {
    buttons.forEach((button) => {
      button.updateProperties({
        appearance: this.appearance,
        size: this.size,
        status: this.status,
        shape: this.shape,
        disabled: this.disabled
      });
    });
  }
  emitCurrentValue(toggleButtons) {
    const pressedToggleValues = toggleButtons.filter((b) => b.pressed && typeof b.value !== "undefined").map((b) => b.value);
    if (pressedToggleValues.length === 0 && this.lastEmittedValue.length === 0) {
      return;
    }
    this.valueChange.emit(pressedToggleValues);
    this.lastEmittedValue = pressedToggleValues;
  }
};
_NbButtonGroupComponent.\u0275fac = function NbButtonGroupComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbButtonGroupComponent)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NbStatusService));
};
_NbButtonGroupComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbButtonGroupComponent,
  selectors: [["nb-button-group"]],
  contentQueries: function NbButtonGroupComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, NbButton, 4);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.buttons = _t);
    }
  },
  hostVars: 3,
  hostBindings: function NbButtonGroupComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("role", ctx.role);
      \u0275\u0275classMap(ctx.additionalClasses);
    }
  },
  inputs: {
    size: "size",
    status: "status",
    shape: "shape",
    appearance: "appearance",
    disabled: "disabled",
    multiple: "multiple",
    filled: "filled",
    outline: "outline",
    ghost: "ghost"
  },
  outputs: {
    valueChange: "valueChange"
  },
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NB_BUTTON_GROUP,
    useExisting: _NbButtonGroupComponent
  }]), \u0275\u0275NgOnChangesFeature],
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function NbButtonGroupComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275projection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbButtonGroupComponent = _NbButtonGroupComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbButtonGroupComponent, [{
    type: Component,
    args: [{
      selector: "nb-button-group",
      template: ` <ng-content></ng-content> `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [{
        provide: NB_BUTTON_GROUP,
        useExisting: NbButtonGroupComponent
      }],
      standalone: false
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: NbStatusService
  }], {
    buttons: [{
      type: ContentChildren,
      args: [NbButton]
    }],
    size: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    shape: [{
      type: Input
    }],
    appearance: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    multiple: [{
      type: Input
    }],
    filled: [{
      type: Input
    }],
    outline: [{
      type: Input
    }],
    ghost: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var _NbButtonGroupModule = class _NbButtonGroupModule {
};
_NbButtonGroupModule.\u0275fac = function NbButtonGroupModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbButtonGroupModule)();
};
_NbButtonGroupModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbButtonGroupModule,
  declarations: [NbButtonGroupComponent, NbButtonToggleDirective],
  exports: [NbButtonGroupComponent, NbButtonToggleDirective]
});
_NbButtonGroupModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var NbButtonGroupModule = _NbButtonGroupModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbButtonGroupModule, [{
    type: NgModule,
    args: [{
      declarations: [NbButtonGroupComponent, NbButtonToggleDirective],
      exports: [NbButtonGroupComponent, NbButtonToggleDirective]
    }]
  }], null, null);
})();
var _NbListPageTrackerDirective = class _NbListPageTrackerDirective {
  constructor() {
    this.destroy$ = new Subject();
    this.startPage = 1;
    this.pageChange = new EventEmitter();
    this.observer = new IntersectionObserver((entries) => this.checkForPageChange(entries), {
      threshold: 0.5
    });
  }
  ngAfterViewInit() {
    if (this.listItems && this.listItems.length) {
      this.observeItems();
    }
    this.listItems.changes.pipe(takeUntil(this.destroy$)).subscribe(() => this.observeItems());
  }
  ngOnDestroy() {
    this.observer.disconnect && this.observer.disconnect();
  }
  observeItems() {
    this.listItems.forEach((i) => this.observer.observe(i.nativeElement));
  }
  checkForPageChange(entries) {
    const mostVisiblePage = this.findMostVisiblePage(entries);
    if (mostVisiblePage && this.currentPage !== mostVisiblePage) {
      this.currentPage = mostVisiblePage;
      this.pageChange.emit(this.currentPage);
    }
  }
  findMostVisiblePage(entries) {
    const intersectionRatioByPage = /* @__PURE__ */ new Map();
    for (const entry of entries) {
      if (entry.intersectionRatio < 0.5) {
        continue;
      }
      const elementIndex = this.elementIndex(entry.target);
      if (elementIndex === -1) {
        continue;
      }
      const page = this.startPage + Math.floor(elementIndex / this.pageSize);
      let ratio = entry.intersectionRatio;
      if (intersectionRatioByPage.has(page)) {
        ratio += intersectionRatioByPage.get(page);
      }
      intersectionRatioByPage.set(page, ratio);
    }
    let maxRatio = 0;
    let mostVisiblePage;
    intersectionRatioByPage.forEach((ratio, page) => {
      if (ratio > maxRatio) {
        maxRatio = ratio;
        mostVisiblePage = page;
      }
    });
    return mostVisiblePage;
  }
  elementIndex(element) {
    return element.parentElement && element.parentElement.children ? Array.from(element.parentElement.children).indexOf(element) : -1;
  }
};
_NbListPageTrackerDirective.\u0275fac = function NbListPageTrackerDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbListPageTrackerDirective)();
};
_NbListPageTrackerDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbListPageTrackerDirective,
  selectors: [["", "nbListPageTracker", ""]],
  contentQueries: function NbListPageTrackerDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, NbListItemComponent, 4, ElementRef);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.listItems = _t);
    }
  },
  inputs: {
    pageSize: "pageSize",
    startPage: "startPage"
  },
  outputs: {
    pageChange: "pageChange"
  },
  standalone: false
});
var NbListPageTrackerDirective = _NbListPageTrackerDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbListPageTrackerDirective, [{
    type: Directive,
    args: [{
      selector: "[nbListPageTracker]",
      standalone: false
    }]
  }], () => [], {
    pageSize: [{
      type: Input
    }],
    startPage: [{
      type: Input
    }],
    pageChange: [{
      type: Output
    }],
    listItems: [{
      type: ContentChildren,
      args: [NbListItemComponent, {
        read: ElementRef
      }]
    }]
  });
})();
var _NbInfiniteListDirective = class _NbInfiniteListDirective {
  get elementScroll() {
    return !this.windowScroll;
  }
  /**
   * Prevent subsequent bottom/topThreshold emissions for specified duration after emitting once.
   * In milliseconds.
   */
  set throttleTime(value) {
    this.throttleTime$.next(value);
  }
  get throttleTime() {
    return this.throttleTime$.value;
  }
  /**
   * By default component observes list scroll position.
   * If set to `true`, component will observe position of page scroll instead.
   */
  set listenWindowScroll(value) {
    this.windowScroll = convertToBoolProperty(value);
  }
  onElementScroll() {
    if (this.elementScroll) {
      this.elementScroll$.next();
    }
  }
  constructor(elementRef, scrollService, dimensionsService) {
    this.elementRef = elementRef;
    this.scrollService = scrollService;
    this.dimensionsService = dimensionsService;
    this.destroy$ = new Subject();
    this.windowScroll = false;
    this.elementScroll$ = new Subject();
    this.windowScroll$ = this.scrollService.onScroll().pipe(filter(() => this.windowScroll));
    this.bottomThreshold$ = new Subject();
    this.topThreshold$ = new Subject();
    this.throttleTime$ = new BehaviorSubject(0);
    this.bottomThreshold = new EventEmitter(true);
    this.topThreshold = new EventEmitter(true);
  }
  ngAfterViewInit() {
    merge(this.windowScroll$, this.elementScroll$).pipe(switchMap(() => this.getContainerDimensions()), takeUntil(this.destroy$)).subscribe((dimensions) => this.checkPosition(dimensions));
    this.throttleTime$.pipe(switchMap(() => this.topThreshold$.pipe(throttle(() => interval(this.throttleTime)))), takeUntil(this.destroy$)).subscribe(() => {
      this.topThreshold.emit();
    });
    this.throttleTime$.pipe(switchMap(() => this.bottomThreshold$.pipe(throttle(() => interval(this.throttleTime)))), takeUntil(this.destroy$)).subscribe(() => {
      this.bottomThreshold.emit();
    });
    this.listItems.changes.pipe(
      // For some reason, changes are emitted before list item removed from dom,
      // so dimensions will be incorrect.
      // Check every 50ms for a second if dom and query are in sync.
      // Once they synchronized, we can get proper dimensions.
      switchMap(() => interval(50).pipe(filter(() => this.inSyncWithDom()), take(1), takeUntil(timer(1e3)))),
      switchMap(() => this.getContainerDimensions()),
      takeUntil(this.destroy$)
    ).subscribe((dimensions) => this.checkPosition(dimensions));
    this.getContainerDimensions().subscribe((dimensions) => this.checkPosition(dimensions));
  }
  ngOnDestroy() {
    this.topThreshold$.complete();
    this.bottomThreshold$.complete();
    this.elementScroll$.complete();
    this.destroy$.next();
    this.destroy$.complete();
  }
  checkPosition({
    scrollHeight,
    scrollTop,
    clientHeight
  }) {
    const initialCheck = this.lastScrollPosition == null;
    const manualCheck = this.lastScrollPosition === scrollTop;
    const scrollUp = scrollTop < this.lastScrollPosition;
    const scrollDown = scrollTop > this.lastScrollPosition;
    const distanceToBottom = scrollHeight - scrollTop - clientHeight;
    if ((initialCheck || manualCheck || scrollDown) && distanceToBottom <= this.threshold) {
      this.bottomThreshold$.next();
    }
    if ((initialCheck || scrollUp) && scrollTop <= this.threshold) {
      this.topThreshold$.next();
    }
    this.lastScrollPosition = scrollTop;
  }
  getContainerDimensions() {
    if (this.elementScroll) {
      const {
        scrollTop,
        scrollHeight,
        clientHeight
      } = this.elementRef.nativeElement;
      return of({
        scrollTop,
        scrollHeight,
        clientHeight
      });
    }
    return forkJoin([this.scrollService.getPosition(), this.dimensionsService.getDimensions()]).pipe(map(([scrollPosition, dimensions]) => ({
      scrollTop: scrollPosition.y,
      scrollHeight: dimensions.scrollHeight,
      clientHeight: dimensions.clientHeight
    })));
  }
  inSyncWithDom() {
    return this.elementRef.nativeElement.children.length === this.listItems.length;
  }
};
_NbInfiniteListDirective.\u0275fac = function NbInfiniteListDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbInfiniteListDirective)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NbLayoutScrollService), \u0275\u0275directiveInject(NbLayoutRulerService));
};
_NbInfiniteListDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbInfiniteListDirective,
  selectors: [["", "nbInfiniteList", ""]],
  contentQueries: function NbInfiniteListDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, NbListItemComponent, 4);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.listItems = _t);
    }
  },
  hostBindings: function NbInfiniteListDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("scroll", function NbInfiniteListDirective_scroll_HostBindingHandler() {
        return ctx.onElementScroll();
      });
    }
  },
  inputs: {
    threshold: "threshold",
    throttleTime: "throttleTime",
    listenWindowScroll: "listenWindowScroll"
  },
  outputs: {
    bottomThreshold: "bottomThreshold",
    topThreshold: "topThreshold"
  },
  standalone: false
});
var NbInfiniteListDirective = _NbInfiniteListDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbInfiniteListDirective, [{
    type: Directive,
    args: [{
      selector: "[nbInfiniteList]",
      standalone: false
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NbLayoutScrollService
  }, {
    type: NbLayoutRulerService
  }], {
    threshold: [{
      type: Input
    }],
    throttleTime: [{
      type: Input
    }],
    listenWindowScroll: [{
      type: Input
    }],
    bottomThreshold: [{
      type: Output
    }],
    topThreshold: [{
      type: Output
    }],
    onElementScroll: [{
      type: HostListener,
      args: ["scroll"]
    }],
    listItems: [{
      type: ContentChildren,
      args: [NbListItemComponent]
    }]
  });
})();
var components = [NbListComponent, NbListItemComponent, NbListPageTrackerDirective, NbInfiniteListDirective];
var _NbListModule = class _NbListModule {
};
_NbListModule.\u0275fac = function NbListModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbListModule)();
};
_NbListModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbListModule,
  declarations: [NbListComponent, NbListItemComponent, NbListPageTrackerDirective, NbInfiniteListDirective],
  exports: [NbListComponent, NbListItemComponent, NbListPageTrackerDirective, NbInfiniteListDirective]
});
_NbListModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var NbListModule = _NbListModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbListModule, [{
    type: NgModule,
    args: [{
      declarations: components,
      exports: components
    }]
  }], null, null);
})();
var _NbDirectionality = class _NbDirectionality extends Directionality {
};
_NbDirectionality.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NbDirectionality_BaseFactory;
  return function NbDirectionality_Factory(__ngFactoryType__) {
    return (\u0275NbDirectionality_BaseFactory || (\u0275NbDirectionality_BaseFactory = \u0275\u0275getInheritedFactory(_NbDirectionality)))(__ngFactoryType__ || _NbDirectionality);
  };
})();
_NbDirectionality.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbDirectionality,
  factory: _NbDirectionality.\u0275fac
});
var NbDirectionality = _NbDirectionality;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDirectionality, [{
    type: Injectable
  }], null, null);
})();
var _NbBidiModule = class _NbBidiModule extends BidiModule {
};
_NbBidiModule.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NbBidiModule_BaseFactory;
  return function NbBidiModule_Factory(__ngFactoryType__) {
    return (\u0275NbBidiModule_BaseFactory || (\u0275NbBidiModule_BaseFactory = \u0275\u0275getInheritedFactory(_NbBidiModule)))(__ngFactoryType__ || _NbBidiModule);
  };
})();
_NbBidiModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbBidiModule
});
_NbBidiModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [{
    provide: NbDirectionality,
    useExisting: Directionality
  }]
});
var NbBidiModule = _NbBidiModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbBidiModule, [{
    type: NgModule,
    args: [{
      providers: [{
        provide: NbDirectionality,
        useExisting: Directionality
      }]
    }]
  }], null, null);
})();
var _NbCellDefDirective = class _NbCellDefDirective extends CdkCellDef {
};
_NbCellDefDirective.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NbCellDefDirective_BaseFactory;
  return function NbCellDefDirective_Factory(__ngFactoryType__) {
    return (\u0275NbCellDefDirective_BaseFactory || (\u0275NbCellDefDirective_BaseFactory = \u0275\u0275getInheritedFactory(_NbCellDefDirective)))(__ngFactoryType__ || _NbCellDefDirective);
  };
})();
_NbCellDefDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbCellDefDirective,
  selectors: [["", "nbCellDef", ""]],
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: CdkCellDef,
    useExisting: _NbCellDefDirective
  }]), \u0275\u0275InheritDefinitionFeature]
});
var NbCellDefDirective = _NbCellDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCellDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbCellDef]",
      providers: [{
        provide: CdkCellDef,
        useExisting: NbCellDefDirective
      }],
      standalone: false
    }]
  }], null, null);
})();
var _NbHeaderCellDefDirective = class _NbHeaderCellDefDirective extends CdkHeaderCellDef {
};
_NbHeaderCellDefDirective.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NbHeaderCellDefDirective_BaseFactory;
  return function NbHeaderCellDefDirective_Factory(__ngFactoryType__) {
    return (\u0275NbHeaderCellDefDirective_BaseFactory || (\u0275NbHeaderCellDefDirective_BaseFactory = \u0275\u0275getInheritedFactory(_NbHeaderCellDefDirective)))(__ngFactoryType__ || _NbHeaderCellDefDirective);
  };
})();
_NbHeaderCellDefDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbHeaderCellDefDirective,
  selectors: [["", "nbHeaderCellDef", ""]],
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: CdkHeaderCellDef,
    useExisting: _NbHeaderCellDefDirective
  }]), \u0275\u0275InheritDefinitionFeature]
});
var NbHeaderCellDefDirective = _NbHeaderCellDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbHeaderCellDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbHeaderCellDef]",
      providers: [{
        provide: CdkHeaderCellDef,
        useExisting: NbHeaderCellDefDirective
      }],
      standalone: false
    }]
  }], null, null);
})();
var _NbFooterCellDefDirective = class _NbFooterCellDefDirective extends CdkFooterCellDef {
};
_NbFooterCellDefDirective.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NbFooterCellDefDirective_BaseFactory;
  return function NbFooterCellDefDirective_Factory(__ngFactoryType__) {
    return (\u0275NbFooterCellDefDirective_BaseFactory || (\u0275NbFooterCellDefDirective_BaseFactory = \u0275\u0275getInheritedFactory(_NbFooterCellDefDirective)))(__ngFactoryType__ || _NbFooterCellDefDirective);
  };
})();
_NbFooterCellDefDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbFooterCellDefDirective,
  selectors: [["", "nbFooterCellDef", ""]],
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: CdkFooterCellDef,
    useExisting: _NbFooterCellDefDirective
  }]), \u0275\u0275InheritDefinitionFeature]
});
var NbFooterCellDefDirective = _NbFooterCellDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFooterCellDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbFooterCellDef]",
      providers: [{
        provide: CdkFooterCellDef,
        useExisting: NbFooterCellDefDirective
      }],
      standalone: false
    }]
  }], null, null);
})();
var NB_SORT_HEADER_COLUMN_DEF = new InjectionToken("NB_SORT_HEADER_COLUMN_DEF");
var _NbColumnDefDirective = class _NbColumnDefDirective extends CdkColumnDef {
  constructor() {
    super(...arguments);
    this._hasStickyCellChanged = false;
    this._stickyCell = false;
  }
  /** Unique name for this column. */
  get name() {
    return this._name;
  }
  set name(value) {
    this._setNameInput(value);
  }
  /** Whether this column should be sticky positioned at the start of the row */
  get sticky() {
    return this._stickyCell;
  }
  set sticky(value) {
    if (value !== this._stickyCell) {
      this._stickyCell = value;
      this._hasStickyCellChanged = true;
    }
  }
  /** Whether this column should be sticky positioned on the end of the row */
  get stickyEnd() {
    return this._stickyEnd;
  }
  set stickyEnd(value) {
    const prevValue = this._stickyEnd;
    this._stickyEnd = coerceBooleanProperty(value);
    this._hasStickyCellChanged = prevValue !== this._stickyEnd;
  }
  /** Whether the sticky state has changed. */
  hasStickyChanged() {
    const hasStickyChanged = this._hasStickyCellChanged;
    this.resetStickyChanged();
    return hasStickyChanged;
  }
  /** Resets the sticky changed state. */
  resetStickyChanged() {
    this._hasStickyCellChanged = false;
  }
};
_NbColumnDefDirective.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NbColumnDefDirective_BaseFactory;
  return function NbColumnDefDirective_Factory(__ngFactoryType__) {
    return (\u0275NbColumnDefDirective_BaseFactory || (\u0275NbColumnDefDirective_BaseFactory = \u0275\u0275getInheritedFactory(_NbColumnDefDirective)))(__ngFactoryType__ || _NbColumnDefDirective);
  };
})();
_NbColumnDefDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbColumnDefDirective,
  selectors: [["", "nbColumnDef", ""]],
  inputs: {
    name: [0, "nbColumnDef", "name"],
    sticky: "sticky",
    stickyEnd: "stickyEnd"
  },
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: CdkColumnDef,
    useExisting: _NbColumnDefDirective
  }, {
    provide: NB_SORT_HEADER_COLUMN_DEF,
    useExisting: _NbColumnDefDirective
  }]), \u0275\u0275InheritDefinitionFeature]
});
var NbColumnDefDirective = _NbColumnDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbColumnDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbColumnDef]",
      providers: [{
        provide: CdkColumnDef,
        useExisting: NbColumnDefDirective
      }, {
        provide: NB_SORT_HEADER_COLUMN_DEF,
        useExisting: NbColumnDefDirective
      }],
      standalone: false
    }]
  }], null, {
    name: [{
      type: Input,
      args: ["nbColumnDef"]
    }],
    sticky: [{
      type: Input
    }],
    stickyEnd: [{
      type: Input
    }]
  });
})();
var _NbHeaderCellDirective = class _NbHeaderCellDirective extends CdkHeaderCell {
  constructor(columnDef, elementRef) {
    super(columnDef, elementRef);
    elementRef.nativeElement.classList.add(`nb-column-${columnDef.cssClassFriendlyName}`);
  }
};
_NbHeaderCellDirective.\u0275fac = function NbHeaderCellDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbHeaderCellDirective)(\u0275\u0275directiveInject(NbColumnDefDirective), \u0275\u0275directiveInject(ElementRef));
};
_NbHeaderCellDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbHeaderCellDirective,
  selectors: [["nb-header-cell"], ["th", "nbHeaderCell", ""]],
  hostAttrs: ["role", "columnheader", 1, "nb-header-cell"],
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature]
});
var NbHeaderCellDirective = _NbHeaderCellDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbHeaderCellDirective, [{
    type: Directive,
    args: [{
      selector: "nb-header-cell, th[nbHeaderCell]",
      host: {
        class: "nb-header-cell",
        role: "columnheader"
      },
      standalone: false
    }]
  }], () => [{
    type: NbColumnDefDirective
  }, {
    type: ElementRef
  }], null);
})();
var _NbFooterCellDirective = class _NbFooterCellDirective extends CdkFooterCell {
  constructor(columnDef, elementRef) {
    super(columnDef, elementRef);
    elementRef.nativeElement.classList.add(`nb-column-${columnDef.cssClassFriendlyName}`);
  }
};
_NbFooterCellDirective.\u0275fac = function NbFooterCellDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbFooterCellDirective)(\u0275\u0275directiveInject(NbColumnDefDirective), \u0275\u0275directiveInject(ElementRef));
};
_NbFooterCellDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbFooterCellDirective,
  selectors: [["nb-footer-cell"], ["td", "nbFooterCell", ""]],
  hostAttrs: ["role", "gridcell", 1, "nb-footer-cell"],
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature]
});
var NbFooterCellDirective = _NbFooterCellDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFooterCellDirective, [{
    type: Directive,
    args: [{
      selector: "nb-footer-cell, td[nbFooterCell]",
      host: {
        class: "nb-footer-cell",
        role: "gridcell"
      },
      standalone: false
    }]
  }], () => [{
    type: NbColumnDefDirective
  }, {
    type: ElementRef
  }], null);
})();
var _NbCellDirective = class _NbCellDirective extends CdkCell {
  constructor(columnDef, elementRef) {
    super(columnDef, elementRef);
    elementRef.nativeElement.classList.add(`nb-column-${columnDef.cssClassFriendlyName}`);
  }
};
_NbCellDirective.\u0275fac = function NbCellDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbCellDirective)(\u0275\u0275directiveInject(NbColumnDefDirective), \u0275\u0275directiveInject(ElementRef));
};
_NbCellDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbCellDirective,
  selectors: [["nb-cell"], ["td", "nbCell", ""]],
  hostAttrs: ["role", "gridcell", 1, "nb-cell"],
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature]
});
var NbCellDirective = _NbCellDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCellDirective, [{
    type: Directive,
    args: [{
      selector: "nb-cell, td[nbCell]",
      host: {
        class: "nb-cell",
        role: "gridcell"
      },
      standalone: false
    }]
  }], () => [{
    type: NbColumnDefDirective
  }, {
    type: ElementRef
  }], null);
})();
var NbDataSource = class extends DataSource {
};
var _NbDataRowOutletDirective = class _NbDataRowOutletDirective extends DataRowOutlet {
};
_NbDataRowOutletDirective.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NbDataRowOutletDirective_BaseFactory;
  return function NbDataRowOutletDirective_Factory(__ngFactoryType__) {
    return (\u0275NbDataRowOutletDirective_BaseFactory || (\u0275NbDataRowOutletDirective_BaseFactory = \u0275\u0275getInheritedFactory(_NbDataRowOutletDirective)))(__ngFactoryType__ || _NbDataRowOutletDirective);
  };
})();
_NbDataRowOutletDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbDataRowOutletDirective,
  selectors: [["", "nbRowOutlet", ""]],
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: DataRowOutlet,
    useExisting: _NbDataRowOutletDirective
  }]), \u0275\u0275InheritDefinitionFeature]
});
var NbDataRowOutletDirective = _NbDataRowOutletDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDataRowOutletDirective, [{
    type: Directive,
    args: [{
      selector: "[nbRowOutlet]",
      providers: [{
        provide: DataRowOutlet,
        useExisting: NbDataRowOutletDirective
      }],
      standalone: false
    }]
  }], null, null);
})();
var _NbHeaderRowOutletDirective = class _NbHeaderRowOutletDirective extends HeaderRowOutlet {
};
_NbHeaderRowOutletDirective.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NbHeaderRowOutletDirective_BaseFactory;
  return function NbHeaderRowOutletDirective_Factory(__ngFactoryType__) {
    return (\u0275NbHeaderRowOutletDirective_BaseFactory || (\u0275NbHeaderRowOutletDirective_BaseFactory = \u0275\u0275getInheritedFactory(_NbHeaderRowOutletDirective)))(__ngFactoryType__ || _NbHeaderRowOutletDirective);
  };
})();
_NbHeaderRowOutletDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbHeaderRowOutletDirective,
  selectors: [["", "nbHeaderRowOutlet", ""]],
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: HeaderRowOutlet,
    useExisting: _NbHeaderRowOutletDirective
  }]), \u0275\u0275InheritDefinitionFeature]
});
var NbHeaderRowOutletDirective = _NbHeaderRowOutletDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbHeaderRowOutletDirective, [{
    type: Directive,
    args: [{
      selector: "[nbHeaderRowOutlet]",
      providers: [{
        provide: HeaderRowOutlet,
        useExisting: NbHeaderRowOutletDirective
      }],
      standalone: false
    }]
  }], null, null);
})();
var _NbFooterRowOutletDirective = class _NbFooterRowOutletDirective extends FooterRowOutlet {
};
_NbFooterRowOutletDirective.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NbFooterRowOutletDirective_BaseFactory;
  return function NbFooterRowOutletDirective_Factory(__ngFactoryType__) {
    return (\u0275NbFooterRowOutletDirective_BaseFactory || (\u0275NbFooterRowOutletDirective_BaseFactory = \u0275\u0275getInheritedFactory(_NbFooterRowOutletDirective)))(__ngFactoryType__ || _NbFooterRowOutletDirective);
  };
})();
_NbFooterRowOutletDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbFooterRowOutletDirective,
  selectors: [["", "nbFooterRowOutlet", ""]],
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: FooterRowOutlet,
    useExisting: _NbFooterRowOutletDirective
  }]), \u0275\u0275InheritDefinitionFeature]
});
var NbFooterRowOutletDirective = _NbFooterRowOutletDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFooterRowOutletDirective, [{
    type: Directive,
    args: [{
      selector: "[nbFooterRowOutlet]",
      providers: [{
        provide: FooterRowOutlet,
        useExisting: NbFooterRowOutletDirective
      }],
      standalone: false
    }]
  }], null, null);
})();
var _NbNoDataRowOutletDirective = class _NbNoDataRowOutletDirective extends NoDataRowOutlet {
};
_NbNoDataRowOutletDirective.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NbNoDataRowOutletDirective_BaseFactory;
  return function NbNoDataRowOutletDirective_Factory(__ngFactoryType__) {
    return (\u0275NbNoDataRowOutletDirective_BaseFactory || (\u0275NbNoDataRowOutletDirective_BaseFactory = \u0275\u0275getInheritedFactory(_NbNoDataRowOutletDirective)))(__ngFactoryType__ || _NbNoDataRowOutletDirective);
  };
})();
_NbNoDataRowOutletDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbNoDataRowOutletDirective,
  selectors: [["", "nbNoDataRowOutlet", ""]],
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NoDataRowOutlet,
    useExisting: _NbNoDataRowOutletDirective
  }]), \u0275\u0275InheritDefinitionFeature]
});
var NbNoDataRowOutletDirective = _NbNoDataRowOutletDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbNoDataRowOutletDirective, [{
    type: Directive,
    args: [{
      selector: "[nbNoDataRowOutlet]",
      providers: [{
        provide: NoDataRowOutlet,
        useExisting: NbNoDataRowOutletDirective
      }],
      standalone: false
    }]
  }], null, null);
})();
var _NbCellOutletDirective = class _NbCellOutletDirective extends CdkCellOutlet {
};
_NbCellOutletDirective.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NbCellOutletDirective_BaseFactory;
  return function NbCellOutletDirective_Factory(__ngFactoryType__) {
    return (\u0275NbCellOutletDirective_BaseFactory || (\u0275NbCellOutletDirective_BaseFactory = \u0275\u0275getInheritedFactory(_NbCellOutletDirective)))(__ngFactoryType__ || _NbCellOutletDirective);
  };
})();
_NbCellOutletDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbCellOutletDirective,
  selectors: [["", "nbCellOutlet", ""]],
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: CdkCellOutlet,
    useExisting: _NbCellOutletDirective
  }]), \u0275\u0275InheritDefinitionFeature]
});
var NbCellOutletDirective = _NbCellOutletDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCellOutletDirective, [{
    type: Directive,
    args: [{
      selector: "[nbCellOutlet]",
      providers: [{
        provide: CdkCellOutlet,
        useExisting: NbCellOutletDirective
      }],
      standalone: false
    }]
  }], null, null);
})();
var _NbHeaderRowDefDirective = class _NbHeaderRowDefDirective extends CdkHeaderRowDef {
  constructor() {
    super(...arguments);
    this._hasStickyRowChanged = false;
    this._stickyRow = false;
  }
  get sticky() {
    return this._stickyRow;
  }
  set sticky(value) {
    if (value !== this._stickyRow) {
      this._stickyRow = value;
      this._hasStickyRowChanged = true;
    }
  }
  hasStickyChanged() {
    const hasStickyChanged = this._hasStickyRowChanged;
    this.resetStickyChanged();
    return hasStickyChanged;
  }
  /** Resets the sticky changed state. */
  resetStickyChanged() {
    this._hasStickyRowChanged = false;
  }
};
_NbHeaderRowDefDirective.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NbHeaderRowDefDirective_BaseFactory;
  return function NbHeaderRowDefDirective_Factory(__ngFactoryType__) {
    return (\u0275NbHeaderRowDefDirective_BaseFactory || (\u0275NbHeaderRowDefDirective_BaseFactory = \u0275\u0275getInheritedFactory(_NbHeaderRowDefDirective)))(__ngFactoryType__ || _NbHeaderRowDefDirective);
  };
})();
_NbHeaderRowDefDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbHeaderRowDefDirective,
  selectors: [["", "nbHeaderRowDef", ""]],
  inputs: {
    columns: [0, "nbHeaderRowDef", "columns"],
    sticky: [0, "nbHeaderRowDefSticky", "sticky"]
  },
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: CdkHeaderRowDef,
    useExisting: _NbHeaderRowDefDirective
  }]), \u0275\u0275InheritDefinitionFeature]
});
var NbHeaderRowDefDirective = _NbHeaderRowDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbHeaderRowDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbHeaderRowDef]",
      providers: [{
        provide: CdkHeaderRowDef,
        useExisting: NbHeaderRowDefDirective
      }],
      standalone: false
    }]
  }], null, {
    columns: [{
      type: Input,
      args: ["nbHeaderRowDef"]
    }],
    sticky: [{
      type: Input,
      args: ["nbHeaderRowDefSticky"]
    }]
  });
})();
var _NbFooterRowDefDirective = class _NbFooterRowDefDirective extends CdkFooterRowDef {
  constructor() {
    super(...arguments);
    this._hasStickyRowChanged = false;
    this._stickyRow = false;
  }
  get sticky() {
    return this._stickyRow;
  }
  set sticky(value) {
    if (value !== this._stickyRow) {
      this._stickyRow = value;
      this._hasStickyRowChanged = true;
    }
  }
  /** Whether the sticky state has changed. */
  hasStickyChanged() {
    const hasStickyChanged = this._hasStickyRowChanged;
    this.resetStickyChanged();
    return hasStickyChanged;
  }
  /** Resets the sticky changed state. */
  resetStickyChanged() {
    this._hasStickyRowChanged = false;
  }
};
_NbFooterRowDefDirective.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NbFooterRowDefDirective_BaseFactory;
  return function NbFooterRowDefDirective_Factory(__ngFactoryType__) {
    return (\u0275NbFooterRowDefDirective_BaseFactory || (\u0275NbFooterRowDefDirective_BaseFactory = \u0275\u0275getInheritedFactory(_NbFooterRowDefDirective)))(__ngFactoryType__ || _NbFooterRowDefDirective);
  };
})();
_NbFooterRowDefDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbFooterRowDefDirective,
  selectors: [["", "nbFooterRowDef", ""]],
  inputs: {
    columns: [0, "nbFooterRowDef", "columns"],
    sticky: [0, "nbFooterRowDefSticky", "sticky"]
  },
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: CdkFooterRowDef,
    useExisting: _NbFooterRowDefDirective
  }]), \u0275\u0275InheritDefinitionFeature]
});
var NbFooterRowDefDirective = _NbFooterRowDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFooterRowDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbFooterRowDef]",
      providers: [{
        provide: CdkFooterRowDef,
        useExisting: NbFooterRowDefDirective
      }],
      standalone: false
    }]
  }], null, {
    columns: [{
      type: Input,
      args: ["nbFooterRowDef"]
    }],
    sticky: [{
      type: Input,
      args: ["nbFooterRowDefSticky"]
    }]
  });
})();
var _NbRowDefDirective = class _NbRowDefDirective extends CdkRowDef {
};
_NbRowDefDirective.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NbRowDefDirective_BaseFactory;
  return function NbRowDefDirective_Factory(__ngFactoryType__) {
    return (\u0275NbRowDefDirective_BaseFactory || (\u0275NbRowDefDirective_BaseFactory = \u0275\u0275getInheritedFactory(_NbRowDefDirective)))(__ngFactoryType__ || _NbRowDefDirective);
  };
})();
_NbRowDefDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbRowDefDirective,
  selectors: [["", "nbRowDef", ""]],
  inputs: {
    columns: [0, "nbRowDefColumns", "columns"],
    when: [0, "nbRowDefWhen", "when"]
  },
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: CdkRowDef,
    useExisting: _NbRowDefDirective
  }]), \u0275\u0275InheritDefinitionFeature]
});
var NbRowDefDirective = _NbRowDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRowDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbRowDef]",
      providers: [{
        provide: CdkRowDef,
        useExisting: NbRowDefDirective
      }],
      standalone: false
    }]
  }], null, {
    columns: [{
      type: Input,
      args: ["nbRowDefColumns"]
    }],
    when: [{
      type: Input,
      args: ["nbRowDefWhen"]
    }]
  });
})();
var _NbHeaderRowComponent = class _NbHeaderRowComponent extends CdkHeaderRow {
};
_NbHeaderRowComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NbHeaderRowComponent_BaseFactory;
  return function NbHeaderRowComponent_Factory(__ngFactoryType__) {
    return (\u0275NbHeaderRowComponent_BaseFactory || (\u0275NbHeaderRowComponent_BaseFactory = \u0275\u0275getInheritedFactory(_NbHeaderRowComponent)))(__ngFactoryType__ || _NbHeaderRowComponent);
  };
})();
_NbHeaderRowComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbHeaderRowComponent,
  selectors: [["nb-header-row"], ["tr", "nbHeaderRow", ""]],
  hostAttrs: ["role", "row", 1, "nb-header-row"],
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: CdkHeaderRow,
    useExisting: _NbHeaderRowComponent
  }]), \u0275\u0275InheritDefinitionFeature],
  decls: 1,
  vars: 0,
  consts: [["nbCellOutlet", ""]],
  template: function NbHeaderRowComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementContainer(0, 0);
    }
  },
  dependencies: [NbCellOutletDirective],
  encapsulation: 2
});
var NbHeaderRowComponent = _NbHeaderRowComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbHeaderRowComponent, [{
    type: Component,
    args: [{
      selector: "nb-header-row, tr[nbHeaderRow]",
      template: ` <ng-container nbCellOutlet></ng-container>`,
      host: {
        class: "nb-header-row",
        role: "row"
      },
      providers: [{
        provide: CdkHeaderRow,
        useExisting: NbHeaderRowComponent
      }],
      standalone: false
    }]
  }], null, null);
})();
var _NbFooterRowComponent = class _NbFooterRowComponent extends CdkFooterRow {
};
_NbFooterRowComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NbFooterRowComponent_BaseFactory;
  return function NbFooterRowComponent_Factory(__ngFactoryType__) {
    return (\u0275NbFooterRowComponent_BaseFactory || (\u0275NbFooterRowComponent_BaseFactory = \u0275\u0275getInheritedFactory(_NbFooterRowComponent)))(__ngFactoryType__ || _NbFooterRowComponent);
  };
})();
_NbFooterRowComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbFooterRowComponent,
  selectors: [["nb-footer-row"], ["tr", "nbFooterRow", ""]],
  hostAttrs: ["role", "row", 1, "nb-footer-row"],
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: CdkFooterRow,
    useExisting: _NbFooterRowComponent
  }]), \u0275\u0275InheritDefinitionFeature],
  decls: 1,
  vars: 0,
  consts: [["nbCellOutlet", ""]],
  template: function NbFooterRowComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementContainer(0, 0);
    }
  },
  dependencies: [NbCellOutletDirective],
  encapsulation: 2
});
var NbFooterRowComponent = _NbFooterRowComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFooterRowComponent, [{
    type: Component,
    args: [{
      selector: "nb-footer-row, tr[nbFooterRow]",
      template: ` <ng-container nbCellOutlet></ng-container>`,
      host: {
        class: "nb-footer-row",
        role: "row"
      },
      providers: [{
        provide: CdkFooterRow,
        useExisting: NbFooterRowComponent
      }],
      standalone: false
    }]
  }], null, null);
})();
var _NbRowComponent = class _NbRowComponent extends CdkRow {
};
_NbRowComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NbRowComponent_BaseFactory;
  return function NbRowComponent_Factory(__ngFactoryType__) {
    return (\u0275NbRowComponent_BaseFactory || (\u0275NbRowComponent_BaseFactory = \u0275\u0275getInheritedFactory(_NbRowComponent)))(__ngFactoryType__ || _NbRowComponent);
  };
})();
_NbRowComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbRowComponent,
  selectors: [["nb-row"], ["tr", "nbRow", ""]],
  hostAttrs: ["role", "row", 1, "nb-row"],
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: CdkRow,
    useExisting: _NbRowComponent
  }]), \u0275\u0275InheritDefinitionFeature],
  decls: 1,
  vars: 0,
  consts: [["nbCellOutlet", ""]],
  template: function NbRowComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementContainer(0, 0);
    }
  },
  dependencies: [NbCellOutletDirective],
  encapsulation: 2
});
var NbRowComponent = _NbRowComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRowComponent, [{
    type: Component,
    args: [{
      selector: "nb-row, tr[nbRow]",
      template: ` <ng-container nbCellOutlet></ng-container>`,
      host: {
        class: "nb-row",
        role: "row"
      },
      providers: [{
        provide: CdkRow,
        useExisting: NbRowComponent
      }],
      standalone: false
    }]
  }], null, null);
})();
var NbCdkRowDef = CdkRowDef;
var NbCdkRow = CdkRow;
var NbCdkCellDef = CdkCellDef;
var NbCdkHeaderRowDef = CdkHeaderRowDef;
var NbCdkHeaderRow = CdkHeaderRow;
var NbCdkHeaderCellDef = CdkHeaderCellDef;
var NbCdkFooterRowDef = CdkFooterRowDef;
var NbCdkFooterRow = CdkFooterRow;
var NbCdkFooterCellDef = CdkFooterCellDef;
var NbCdkColumnDef = CdkColumnDef;
var NbCdkCell = CdkCell;
var NbCdkHeaderCell = CdkHeaderCell;
var NbCdkFooterCell = CdkFooterCell;
var NB_STICKY_POSITIONING_LISTENER = STICKY_POSITIONING_LISTENER;
var NB_TABLE_TEMPLATE = `
  <ng-container nbHeaderRowOutlet></ng-container>
  <ng-container nbRowOutlet></ng-container>
  <ng-container nbNoDataRowOutlet></ng-container>
  <ng-container nbFooterRowOutlet></ng-container>
`;
var NB_VIEW_REPEATER_STRATEGY = _VIEW_REPEATER_STRATEGY;
var NB_TABLE_PROVIDERS = [{
  provide: NB_VIEW_REPEATER_STRATEGY,
  useClass: _DisposeViewRepeaterStrategy
}];
var _NbTable = class _NbTable extends CdkTable {
  constructor(differs, changeDetectorRef, elementRef, role, dir, document2, platform, _viewRepeater, _viewportRuler, _stickyPositioningListener) {
    super(differs, changeDetectorRef, elementRef, role, dir, document2, platform, _viewRepeater, _viewportRuler, _stickyPositioningListener);
    this._viewRepeater = _viewRepeater;
    this._stickyPositioningListener = _stickyPositioningListener;
  }
};
_NbTable.\u0275fac = function NbTable_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbTable)(\u0275\u0275directiveInject(IterableDiffers), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(ElementRef), \u0275\u0275injectAttribute("role"), \u0275\u0275directiveInject(NbDirectionality), \u0275\u0275directiveInject(NB_DOCUMENT), \u0275\u0275directiveInject(NbPlatform), \u0275\u0275directiveInject(_VIEW_REPEATER_STRATEGY), \u0275\u0275directiveInject(NbViewportRulerAdapter), \u0275\u0275directiveInject(NB_STICKY_POSITIONING_LISTENER, 12));
};
_NbTable.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbTable,
  selectors: [["nb-table-not-implemented"]],
  standalone: false,
  features: [\u0275\u0275ProvidersFeature(NB_TABLE_PROVIDERS), \u0275\u0275InheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NbTable_Template(rf, ctx) {
  },
  encapsulation: 2
});
var NbTable = _NbTable;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTable, [{
    type: Component,
    args: [{
      selector: "nb-table-not-implemented",
      template: ``,
      providers: NB_TABLE_PROVIDERS,
      standalone: false
    }]
  }], () => [{
    type: IterableDiffers
  }, {
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Attribute,
      args: ["role"]
    }]
  }, {
    type: NbDirectionality
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: NbPlatform
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [_VIEW_REPEATER_STRATEGY]
    }]
  }, {
    type: NbViewportRulerAdapter
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: SkipSelf
    }, {
      type: Inject,
      args: [NB_STICKY_POSITIONING_LISTENER]
    }]
  }], null);
})();
var COMPONENTS$2 = [
  NbTable,
  // Template defs
  NbHeaderCellDefDirective,
  NbHeaderRowDefDirective,
  NbColumnDefDirective,
  NbCellDefDirective,
  NbRowDefDirective,
  NbFooterCellDefDirective,
  NbFooterRowDefDirective,
  // Outlets
  NbDataRowOutletDirective,
  NbHeaderRowOutletDirective,
  NbFooterRowOutletDirective,
  NbNoDataRowOutletDirective,
  NbCellOutletDirective,
  // Cell directives
  NbHeaderCellDirective,
  NbCellDirective,
  NbFooterCellDirective,
  // Row directives
  NbHeaderRowComponent,
  NbRowComponent,
  NbFooterRowComponent
];
var _NbTableModule = class _NbTableModule extends CdkTableModule {
};
_NbTableModule.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NbTableModule_BaseFactory;
  return function NbTableModule_Factory(__ngFactoryType__) {
    return (\u0275NbTableModule_BaseFactory || (\u0275NbTableModule_BaseFactory = \u0275\u0275getInheritedFactory(_NbTableModule)))(__ngFactoryType__ || _NbTableModule);
  };
})();
_NbTableModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbTableModule,
  declarations: [
    NbTable,
    // Template defs
    NbHeaderCellDefDirective,
    NbHeaderRowDefDirective,
    NbColumnDefDirective,
    NbCellDefDirective,
    NbRowDefDirective,
    NbFooterCellDefDirective,
    NbFooterRowDefDirective,
    // Outlets
    NbDataRowOutletDirective,
    NbHeaderRowOutletDirective,
    NbFooterRowOutletDirective,
    NbNoDataRowOutletDirective,
    NbCellOutletDirective,
    // Cell directives
    NbHeaderCellDirective,
    NbCellDirective,
    NbFooterCellDirective,
    // Row directives
    NbHeaderRowComponent,
    NbRowComponent,
    NbFooterRowComponent
  ],
  imports: [NbBidiModule],
  exports: [
    NbTable,
    // Template defs
    NbHeaderCellDefDirective,
    NbHeaderRowDefDirective,
    NbColumnDefDirective,
    NbCellDefDirective,
    NbRowDefDirective,
    NbFooterCellDefDirective,
    NbFooterRowDefDirective,
    // Outlets
    NbDataRowOutletDirective,
    NbHeaderRowOutletDirective,
    NbFooterRowOutletDirective,
    NbNoDataRowOutletDirective,
    NbCellOutletDirective,
    // Cell directives
    NbHeaderCellDirective,
    NbCellDirective,
    NbFooterCellDirective,
    // Row directives
    NbHeaderRowComponent,
    NbRowComponent,
    NbFooterRowComponent
  ]
});
_NbTableModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NbBidiModule]
});
var NbTableModule = _NbTableModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTableModule, [{
    type: NgModule,
    args: [{
      imports: [NbBidiModule],
      declarations: [...COMPONENTS$2],
      exports: [...COMPONENTS$2]
    }]
  }], null, null);
})();
var NB_DIALOG_CONFIG = new InjectionToken("Default dialog options");
var NbDialogConfig = class {
  constructor(config) {
    this.hasBackdrop = true;
    this.backdropClass = "overlay-backdrop";
    this.dialogClass = "";
    this.closeOnBackdropClick = true;
    this.closeOnEsc = true;
    this.hasScroll = false;
    this.autoFocus = true;
    Object.assign(this, config);
  }
};
var NbDialogRef = class {
  constructor(overlayRef) {
    this.overlayRef = overlayRef;
    this.onClose$ = new Subject();
    this.onClose = this.onClose$.asObservable();
    this.onBackdropClick = this.overlayRef.backdropClick();
  }
  /**
   * Hides dialog.
   * */
  close(res) {
    this.overlayRef.detach();
    this.overlayRef.dispose();
    this.onClose$.next(res);
    this.onClose$.complete();
  }
};
var _NbDialogContainerComponent = class _NbDialogContainerComponent {
  constructor(config, elementRef, focusTrapFactory) {
    this.config = config;
    this.elementRef = elementRef;
    this.focusTrapFactory = focusTrapFactory;
  }
  ngOnInit() {
    if (this.config.autoFocus) {
      this.focusTrap = this.focusTrapFactory.create(this.elementRef.nativeElement);
      this.focusTrap.blurPreviouslyFocusedElement();
      this.focusTrap.focusInitialElement();
    }
  }
  ngOnDestroy() {
    if (this.config.autoFocus && this.focusTrap) {
      this.focusTrap.restoreFocus();
    }
  }
  attachComponentPortal(portal) {
    return this.portalOutlet.attachComponentPortal(portal);
  }
  attachTemplatePortal(portal) {
    return this.portalOutlet.attachTemplatePortal(portal);
  }
};
_NbDialogContainerComponent.\u0275fac = function NbDialogContainerComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbDialogContainerComponent)(\u0275\u0275directiveInject(NbDialogConfig), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NbFocusTrapFactoryService));
};
_NbDialogContainerComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbDialogContainerComponent,
  selectors: [["nb-dialog-container"]],
  viewQuery: function NbDialogContainerComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(NbPortalOutletDirective, 7);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.portalOutlet = _t.first);
    }
  },
  standalone: false,
  decls: 1,
  vars: 0,
  consts: [["nbPortalOutlet", ""]],
  template: function NbDialogContainerComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NbDialogContainerComponent_ng_template_0_Template, 0, 0, "ng-template", 0);
    }
  },
  dependencies: [NbPortalOutletDirective],
  encapsulation: 2
});
var NbDialogContainerComponent = _NbDialogContainerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDialogContainerComponent, [{
    type: Component,
    args: [{
      selector: "nb-dialog-container",
      template: "<ng-template nbPortalOutlet></ng-template>",
      standalone: false
    }]
  }], () => [{
    type: NbDialogConfig
  }, {
    type: ElementRef
  }, {
    type: NbFocusTrapFactoryService
  }], {
    portalOutlet: [{
      type: ViewChild,
      args: [NbPortalOutletDirective, {
        static: true
      }]
    }]
  });
})();
var _NbDialogService = class _NbDialogService {
  constructor(document2, globalConfig, positionBuilder, overlay, injector) {
    this.document = document2;
    this.globalConfig = globalConfig;
    this.positionBuilder = positionBuilder;
    this.overlay = overlay;
    this.injector = injector;
  }
  /**
   * Opens new instance of the dialog, may receive optional config.
   * */
  open(content, userConfig = {}) {
    const config = new NbDialogConfig(__spreadValues(__spreadValues({}, this.globalConfig), userConfig));
    const overlayRef = this.createOverlay(config);
    const dialogRef = new NbDialogRef(overlayRef);
    const container = this.createContainer(config, overlayRef);
    this.createContent(config, content, container, dialogRef);
    this.registerCloseListeners(config, overlayRef, dialogRef);
    return dialogRef;
  }
  createOverlay(config) {
    const positionStrategy = this.createPositionStrategy();
    const scrollStrategy = this.createScrollStrategy(config.hasScroll);
    return this.overlay.create({
      positionStrategy,
      scrollStrategy,
      hasBackdrop: config.hasBackdrop,
      backdropClass: config.backdropClass,
      panelClass: config.dialogClass
    });
  }
  createPositionStrategy() {
    return this.positionBuilder.global().centerVertically().centerHorizontally();
  }
  createScrollStrategy(hasScroll) {
    if (hasScroll) {
      return this.overlay.scrollStrategies.noop();
    } else {
      return this.overlay.scrollStrategies.block();
    }
  }
  createContainer(config, overlayRef) {
    const injector = Injector.create({
      parent: this.createInjector(config),
      providers: [{
        provide: NbDialogConfig,
        useValue: config
      }]
    });
    const containerPortal = new NbComponentPortal(NbDialogContainerComponent, null, injector);
    const containerRef = overlayRef.attach(containerPortal);
    return containerRef.instance;
  }
  createContent(config, content, container, dialogRef) {
    if (content instanceof TemplateRef) {
      const portal = this.createTemplatePortal(config, content, dialogRef);
      container.attachTemplatePortal(portal);
    } else {
      const portal = this.createComponentPortal(config, content, dialogRef);
      dialogRef.componentRef = container.attachComponentPortal(portal);
      if (config.context) {
        Object.assign(dialogRef.componentRef.instance, __spreadValues({}, config.context));
      }
    }
  }
  createTemplatePortal(config, content, dialogRef) {
    return new NbTemplatePortal(content, null, {
      $implicit: config.context,
      dialogRef
    });
  }
  /**
   * We're creating portal with custom injector provided through config or using global injector.
   * This approach provides us capability inject `NbDialogRef` in dialog component.
   * */
  createComponentPortal(config, content, dialogRef) {
    const injector = this.createInjector(config);
    const portalInjector = Injector.create({
      parent: injector,
      providers: [{
        provide: NbDialogRef,
        useValue: dialogRef
      }]
    });
    return new NbComponentPortal(content, config.viewContainerRef, portalInjector);
  }
  createInjector(config) {
    return config.viewContainerRef && config.viewContainerRef.injector || this.injector;
  }
  registerCloseListeners(config, overlayRef, dialogRef) {
    if (config.closeOnBackdropClick) {
      overlayRef.backdropClick().subscribe(() => dialogRef.close());
    }
    if (config.closeOnEsc) {
      fromEvent(this.document, "keyup").pipe(filter((event) => event.keyCode === 27), takeUntil(dialogRef.onClose)).subscribe(() => dialogRef.close());
    }
  }
};
_NbDialogService.\u0275fac = function NbDialogService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbDialogService)(\u0275\u0275inject(NB_DOCUMENT), \u0275\u0275inject(NB_DIALOG_CONFIG), \u0275\u0275inject(NbPositionBuilderService), \u0275\u0275inject(NbOverlayService), \u0275\u0275inject(Injector));
};
_NbDialogService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbDialogService,
  factory: _NbDialogService.\u0275fac
});
var NbDialogService = _NbDialogService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDialogService, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DIALOG_CONFIG]
    }]
  }, {
    type: NbPositionBuilderService
  }, {
    type: NbOverlayService
  }, {
    type: Injector
  }], null);
})();
var _NbDialogModule = class _NbDialogModule {
  static forRoot(dialogConfig = {}) {
    return {
      ngModule: _NbDialogModule,
      providers: [NbDialogService, {
        provide: NB_DIALOG_CONFIG,
        useValue: dialogConfig
      }]
    };
  }
  static forChild(dialogConfig = {}) {
    return {
      ngModule: _NbDialogModule,
      providers: [NbDialogService, {
        provide: NB_DIALOG_CONFIG,
        useValue: dialogConfig
      }]
    };
  }
};
_NbDialogModule.\u0275fac = function NbDialogModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbDialogModule)();
};
_NbDialogModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbDialogModule,
  declarations: [NbDialogContainerComponent],
  imports: [NbSharedModule, NbOverlayModule]
});
_NbDialogModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NbSharedModule, NbOverlayModule]
});
var NbDialogModule = _NbDialogModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDialogModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbOverlayModule],
      declarations: [NbDialogContainerComponent]
    }]
  }], null, null);
})();
var _NbToastComponent = class _NbToastComponent {
  get success() {
    return this.toast.config.status === "success";
  }
  get info() {
    return this.toast.config.status === "info";
  }
  get warning() {
    return this.toast.config.status === "warning";
  }
  get primary() {
    return this.toast.config.status === "primary";
  }
  get danger() {
    return this.toast.config.status === "danger";
  }
  get basic() {
    return this.toast.config.status === "basic";
  }
  get control() {
    return this.toast.config.status === "control";
  }
  get destroyByClick() {
    return this.toast.config.destroyByClick;
  }
  get hasIcon() {
    const {
      icon
    } = this.toast.config;
    if (typeof icon === "string") {
      return true;
    }
    return !!(icon && icon.icon);
  }
  get customIcon() {
    return !!this.icon;
  }
  get icon() {
    return this.toast.config.icon;
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.toast.config.status)) {
      return [this.statusService.getStatusClass(this.toast.config.status)];
    }
    return [];
  }
  onClick() {
    this.toastClick.emit();
  }
  constructor(renderer, elementRef, statusService) {
    this.renderer = renderer;
    this.elementRef = elementRef;
    this.statusService = statusService;
    this.destroy = new EventEmitter();
    this.toastClick = new EventEmitter();
  }
  ngOnInit() {
    if (this.toast.config.toastClass) {
      this.renderer.addClass(this.elementRef.nativeElement, this.toast.config.toastClass);
    }
  }
  ngOnDestroy() {
    this.destroy.emit();
  }
};
_NbToastComponent.\u0275fac = function NbToastComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbToastComponent)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NbStatusService));
};
_NbToastComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbToastComponent,
  selectors: [["nb-toast"]],
  hostVars: 22,
  hostBindings: function NbToastComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function NbToastComponent_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
    if (rf & 2) {
      \u0275\u0275classMap(ctx.additionalClasses);
      \u0275\u0275classProp("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-primary", ctx.primary)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("destroy-by-click", ctx.destroyByClick)("has-icon", ctx.hasIcon)("custom-icon", ctx.customIcon);
    }
  },
  inputs: {
    toast: "toast"
  },
  outputs: {
    destroy: "destroy",
    toastClick: "toastClick"
  },
  standalone: false,
  decls: 6,
  vars: 3,
  consts: [["class", "icon-container", 4, "ngIf"], [1, "content-container"], [1, "title", "subtitle"], [1, "message"], [1, "icon-container"], [3, "config"]],
  template: function NbToastComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NbToastComponent_div_0_Template, 2, 1, "div", 0);
      \u0275\u0275elementStart(1, "div", 1)(2, "span", 2);
      \u0275\u0275text(3);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(4, "div", 3);
      \u0275\u0275text(5);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.hasIcon && ctx.icon);
      \u0275\u0275advance(3);
      \u0275\u0275textInterpolate(ctx.toast.title);
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate(ctx.toast.message);
    }
  },
  dependencies: [NgIf, NbIconComponent],
  styles: ["[_nghost-%COMP%]{display:flex;align-items:center;width:25rem;margin:.5rem}[_nghost-%COMP%]   .title[_ngcontent-%COMP%]{margin-right:.25rem}.default[_nghost-%COMP%]   .content-container[_ngcontent-%COMP%], [_nghost-%COMP%]:not(.has-icon)   .content-container[_ngcontent-%COMP%]{display:flex;flex-direction:row}.destroy-by-click[_nghost-%COMP%]{cursor:pointer}[_nghost-%COMP%]   nb-icon[_ngcontent-%COMP%]{font-size:2.5rem}[_nghost-%COMP%]   svg[_ngcontent-%COMP%]{width:2.5rem;height:2.5rem}\n\n\n\n\n\n"]
});
var NbToastComponent = _NbToastComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbToastComponent, [{
    type: Component,
    args: [{
      selector: "nb-toast",
      standalone: false,
      template: '<div class="icon-container" *ngIf="hasIcon && icon">\n  <nb-icon [config]="icon"></nb-icon>\n</div>\n<div class="content-container">\n  <span class="title subtitle">{{ toast.title }}</span>\n  <div class="message">{{ toast.message }}</div>\n</div>\n',
      styles: [":host{display:flex;align-items:center;width:25rem;margin:.5rem}:host .title{margin-right:.25rem}:host.default .content-container,:host:not(.has-icon) .content-container{display:flex;flex-direction:row}:host.destroy-by-click{cursor:pointer}:host nb-icon{font-size:2.5rem}:host svg{width:2.5rem;height:2.5rem}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: NbStatusService
  }], {
    toast: [{
      type: Input
    }],
    destroy: [{
      type: Output
    }],
    toastClick: [{
      type: Output
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    destroyByClick: [{
      type: HostBinding,
      args: ["class.destroy-by-click"]
    }],
    hasIcon: [{
      type: HostBinding,
      args: ["class.has-icon"]
    }],
    customIcon: [{
      type: HostBinding,
      args: ["class.custom-icon"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var voidState = style({
  transform: "translateX({{ direction }}110%)",
  height: 0,
  marginLeft: "0",
  marginRight: "0",
  marginTop: "0",
  marginBottom: "0"
});
var defaultOptions = {
  params: {
    direction: ""
  }
};
var _NbToastrContainerComponent = class _NbToastrContainerComponent {
  constructor(layoutDirection, positionHelper) {
    this.layoutDirection = layoutDirection;
    this.positionHelper = positionHelper;
    this.destroy$ = new Subject();
    this.content = [];
  }
  ngOnInit() {
    this.layoutDirection.onDirectionChange().pipe(takeUntil(this.destroy$)).subscribe(() => this.onDirectionChange());
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  onDirectionChange() {
    const direction = this.positionHelper.isRightPosition(this.position) ? "" : "-";
    this.fadeIn = {
      value: "",
      params: {
        direction
      }
    };
  }
};
_NbToastrContainerComponent.\u0275fac = function NbToastrContainerComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbToastrContainerComponent)(\u0275\u0275directiveInject(NbLayoutDirectionService), \u0275\u0275directiveInject(NbPositionHelper));
};
_NbToastrContainerComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbToastrContainerComponent,
  selectors: [["nb-toastr-container"]],
  viewQuery: function NbToastrContainerComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(NbToastComponent, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.toasts = _t);
    }
  },
  inputs: {
    content: "content",
    context: "context",
    position: "position"
  },
  standalone: false,
  decls: 1,
  vars: 1,
  consts: [[3, "toast", 4, "ngFor", "ngForOf"], [3, "toast"]],
  template: function NbToastrContainerComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NbToastrContainerComponent_nb_toast_0_Template, 1, 2, "nb-toast", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("ngForOf", ctx.content);
    }
  },
  dependencies: [NgForOf, NbToastComponent],
  encapsulation: 2,
  data: {
    animation: [trigger("fadeIn", [transition(":enter", [voidState, animate(100)], defaultOptions), transition(":leave", [animate(100, voidState)], defaultOptions)])]
  }
});
var NbToastrContainerComponent = _NbToastrContainerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbToastrContainerComponent, [{
    type: Component,
    args: [{
      selector: "nb-toastr-container",
      template: `
    <nb-toast [@fadeIn]="fadeIn" *ngFor="let toast of content" [toast]="toast"></nb-toast>`,
      animations: [trigger("fadeIn", [transition(":enter", [voidState, animate(100)], defaultOptions), transition(":leave", [animate(100, voidState)], defaultOptions)])],
      standalone: false
    }]
  }], () => [{
    type: NbLayoutDirectionService
  }, {
    type: NbPositionHelper
  }], {
    content: [{
      type: Input
    }],
    context: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    toasts: [{
      type: ViewChildren,
      args: [NbToastComponent]
    }]
  });
})();
var NB_TOASTR_CONFIG = new InjectionToken("Default toastr options");
var NbToastrConfig = class {
  constructor(config) {
    this.position = NbGlobalLogicalPosition.TOP_END;
    this.status = "basic";
    this.duration = 3e3;
    this.destroyByClick = true;
    this.preventDuplicates = false;
    this.duplicatesBehaviour = "previous";
    this.limit = null;
    this.toastClass = "";
    this.hasIcon = true;
    this.icon = "email";
    this.icons = {
      danger: "flash-outline",
      success: "checkmark-outline",
      info: "question-mark-outline",
      warning: "alert-triangle-outline",
      primary: "email-outline",
      control: "email-outline",
      basic: "email-outline"
    };
    this.patchIcon(config);
    Object.assign(this, config);
  }
  patchIcon(config) {
    if (!("icon" in config)) {
      config.icon = {
        icon: this.icons[config.status] || this.icons.basic,
        pack: "nebular-essentials"
      };
    }
  }
};
var NbToastRef = class {
  constructor(toastContainer, toast) {
    this.toastContainer = toastContainer;
    this.toast = toast;
  }
  close() {
    this.toastContainer.destroy(this.toast);
  }
  onClose() {
    return this.toastInstance.destroy.asObservable();
  }
  onClick() {
    return this.toastInstance.toastClick.asObservable();
  }
};
var NbToastContainer = class {
  get nativeElement() {
    return this.containerRef.location.nativeElement;
  }
  constructor(position, containerRef, positionHelper) {
    this.position = position;
    this.containerRef = containerRef;
    this.positionHelper = positionHelper;
    this.toasts = [];
    this.toastDuplicateCompareFunc = (t1, t2) => {
      return t1.message === t2.message && t1.title === t2.title && t1.config.status === t2.config.status;
    };
  }
  attach(toast) {
    if (toast.config.preventDuplicates && this.isDuplicate(toast)) {
      return void 0;
    }
    this.removeToastIfLimitReached(toast);
    const toastComponent = this.attachToast(toast);
    if (toast.config.destroyByClick) {
      this.subscribeOnClick(toastComponent, toast);
    }
    if (toast.config.duration) {
      this.setDestroyTimeout(toast);
    }
    this.prevToast = toast;
    const toastRef = new NbToastRef(this, toast);
    toastRef.toastInstance = toastComponent;
    return toastRef;
  }
  destroy(toast) {
    if (this.prevToast === toast) {
      this.prevToast = null;
    }
    this.toasts = this.toasts.filter((t) => t !== toast);
    this.updateContainer();
  }
  isDuplicate(toast) {
    return toast.config.duplicatesBehaviour === "previous" ? this.isDuplicatePrevious(toast) : this.isDuplicateAmongAll(toast);
  }
  isDuplicatePrevious(toast) {
    return this.prevToast && this.toastDuplicateCompareFunc(this.prevToast, toast);
  }
  isDuplicateAmongAll(toast) {
    return this.toasts.some((t) => this.toastDuplicateCompareFunc(t, toast));
  }
  removeToastIfLimitReached(toast) {
    if (!toast.config.limit || this.toasts.length < toast.config.limit) {
      return;
    }
    if (this.positionHelper.isTopPosition(toast.config.position)) {
      this.toasts.pop();
    } else {
      this.toasts.shift();
    }
  }
  attachToast(toast) {
    if (this.positionHelper.isTopPosition(toast.config.position)) {
      return this.attachToTop(toast);
    } else {
      return this.attachToBottom(toast);
    }
  }
  attachToTop(toast) {
    this.toasts.unshift(toast);
    this.updateContainer();
    return this.containerRef.instance.toasts.first;
  }
  attachToBottom(toast) {
    this.toasts.push(toast);
    this.updateContainer();
    return this.containerRef.instance.toasts.last;
  }
  setDestroyTimeout(toast) {
    setTimeout(() => this.destroy(toast), toast.config.duration);
  }
  subscribeOnClick(toastComponent, toast) {
    toastComponent.toastClick.pipe(filter(() => toast.config.destroyByClick), takeUntil(toastComponent.destroy)).subscribe(() => this.destroy(toast));
  }
  updateContainer() {
    patch(this.containerRef, {
      content: this.toasts,
      position: this.position
    });
  }
};
var _NbToastrContainerRegistry = class _NbToastrContainerRegistry {
  constructor(overlay, positionBuilder, positionHelper, document2) {
    this.overlay = overlay;
    this.positionBuilder = positionBuilder;
    this.positionHelper = positionHelper;
    this.document = document2;
    this.overlays = /* @__PURE__ */ new Map();
  }
  get(position) {
    const logicalPosition = this.positionHelper.toLogicalPosition(position);
    const overlayWithContainer = this.overlays.get(logicalPosition);
    if (!overlayWithContainer || !this.existsInDom(overlayWithContainer.toastrContainer)) {
      if (overlayWithContainer) {
        overlayWithContainer.overlayRef.dispose();
      }
      this.instantiateContainer(logicalPosition);
    }
    return this.overlays.get(logicalPosition).toastrContainer;
  }
  instantiateContainer(position) {
    const toastrOverlayWithContainer = this.createContainer(position);
    this.overlays.set(position, toastrOverlayWithContainer);
  }
  createContainer(position) {
    const positionStrategy = this.positionBuilder.global().position(position);
    const ref = this.overlay.create({
      positionStrategy
    });
    this.addClassToOverlayHost(ref);
    const containerRef = ref.attach(new NbComponentPortal(NbToastrContainerComponent, null, null));
    return {
      overlayRef: ref,
      toastrContainer: new NbToastContainer(position, containerRef, this.positionHelper)
    };
  }
  addClassToOverlayHost(overlayRef) {
    overlayRef.hostElement.classList.add("toastr-overlay-container");
  }
  existsInDom(toastContainer) {
    return this.document.body.contains(toastContainer.nativeElement);
  }
};
_NbToastrContainerRegistry.\u0275fac = function NbToastrContainerRegistry_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbToastrContainerRegistry)(\u0275\u0275inject(NbOverlayService), \u0275\u0275inject(NbPositionBuilderService), \u0275\u0275inject(NbPositionHelper), \u0275\u0275inject(NB_DOCUMENT));
};
_NbToastrContainerRegistry.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbToastrContainerRegistry,
  factory: _NbToastrContainerRegistry.\u0275fac
});
var NbToastrContainerRegistry = _NbToastrContainerRegistry;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbToastrContainerRegistry, [{
    type: Injectable
  }], () => [{
    type: NbOverlayService
  }, {
    type: NbPositionBuilderService
  }, {
    type: NbPositionHelper
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }], null);
})();
var _NbToastrService = class _NbToastrService {
  constructor(globalConfig, containerRegistry) {
    this.globalConfig = globalConfig;
    this.containerRegistry = containerRegistry;
  }
  /**
   * Shows toast with message, title and user config.
   * */
  show(message, title, userConfig) {
    const config = new NbToastrConfig(__spreadValues(__spreadValues({}, this.globalConfig), userConfig));
    const container = this.containerRegistry.get(config.position);
    const toast = {
      message,
      title,
      config
    };
    return container.attach(toast);
  }
  /**
   * Shows success toast with message, title and user config.
   * */
  success(message, title, config) {
    return this.show(message, title, __spreadProps(__spreadValues({}, config), {
      status: "success"
    }));
  }
  /**
   * Shows info toast with message, title and user config.
   * */
  info(message, title, config) {
    return this.show(message, title, __spreadProps(__spreadValues({}, config), {
      status: "info"
    }));
  }
  /**
   * Shows warning toast with message, title and user config.
   * */
  warning(message, title, config) {
    return this.show(message, title, __spreadProps(__spreadValues({}, config), {
      status: "warning"
    }));
  }
  /**
   * Shows primary toast with message, title and user config.
   * */
  primary(message, title, config) {
    return this.show(message, title, __spreadProps(__spreadValues({}, config), {
      status: "primary"
    }));
  }
  /**
   * Shows danger toast with message, title and user config.
   * */
  danger(message, title, config) {
    return this.show(message, title, __spreadProps(__spreadValues({}, config), {
      status: "danger"
    }));
  }
  /**
   * Shows default toast with message, title and user config.
   * */
  default(message, title, config) {
    return this.show(message, title, __spreadProps(__spreadValues({}, config), {
      status: "basic"
    }));
  }
  /**
   * Shows control toast with message, title and user config.
   * */
  control(message, title, config) {
    return this.default(message, title, __spreadProps(__spreadValues({}, config), {
      status: "control"
    }));
  }
};
_NbToastrService.\u0275fac = function NbToastrService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbToastrService)(\u0275\u0275inject(NB_TOASTR_CONFIG), \u0275\u0275inject(NbToastrContainerRegistry));
};
_NbToastrService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbToastrService,
  factory: _NbToastrService.\u0275fac
});
var NbToastrService = _NbToastrService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbToastrService, [{
    type: Injectable
  }], () => [{
    type: NbToastrConfig,
    decorators: [{
      type: Inject,
      args: [NB_TOASTR_CONFIG]
    }]
  }, {
    type: NbToastrContainerRegistry
  }], null);
})();
var _NbToastrModule = class _NbToastrModule {
  static forRoot(toastrConfig = {}) {
    return {
      ngModule: _NbToastrModule,
      providers: [NbToastrService, NbToastrContainerRegistry, {
        provide: NB_TOASTR_CONFIG,
        useValue: toastrConfig
      }]
    };
  }
};
_NbToastrModule.\u0275fac = function NbToastrModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbToastrModule)();
};
_NbToastrModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbToastrModule,
  declarations: [NbToastrContainerComponent, NbToastComponent],
  imports: [NbSharedModule, NbOverlayModule, NbIconModule]
});
_NbToastrModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NbSharedModule, NbOverlayModule, NbIconModule]
});
var NbToastrModule = _NbToastrModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbToastrModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbOverlayModule, NbIconModule],
      declarations: [NbToastrContainerComponent, NbToastComponent]
    }]
  }], null, null);
})();
var _NbTooltipComponent = class _NbTooltipComponent {
  get binding() {
    return `${this.position} ${this.statusClass}`;
  }
  get show() {
    return true;
  }
  get statusClass() {
    if (this.context.status) {
      return this.statusService.getStatusClass(this.context.status);
    }
    return "";
  }
  constructor(statusService) {
    this.statusService = statusService;
    this.position = NbPosition.TOP;
    this.context = {};
  }
  /**
   * The method is empty since we don't need to do anything additionally
   * render is handled by change detection
   */
  renderContent() {
  }
};
_NbTooltipComponent.\u0275fac = function NbTooltipComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbTooltipComponent)(\u0275\u0275directiveInject(NbStatusService));
};
_NbTooltipComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbTooltipComponent,
  selectors: [["nb-tooltip"]],
  hostVars: 3,
  hostBindings: function NbTooltipComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275syntheticHostProperty("@showTooltip", ctx.show);
      \u0275\u0275classMap(ctx.binding);
    }
  },
  inputs: {
    content: "content",
    position: "position",
    context: "context"
  },
  standalone: false,
  decls: 4,
  vars: 2,
  consts: [[1, "arrow"], [1, "content"], [3, "config", 4, "ngIf"], [4, "ngIf"], [3, "config"]],
  template: function NbTooltipComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275element(0, "span", 0);
      \u0275\u0275elementStart(1, "div", 1);
      \u0275\u0275template(2, NbTooltipComponent_nb_icon_2_Template, 1, 1, "nb-icon", 2)(3, NbTooltipComponent_span_3_Template, 2, 1, "span", 3);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", ctx.context == null ? null : ctx.context.icon);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.content);
    }
  },
  dependencies: [NgIf, NbIconComponent],
  styles: ["[_nghost-%COMP%]{z-index:10000}[_nghost-%COMP%]   .content[_ngcontent-%COMP%]{display:flex;align-items:center}.right[_nghost-%COMP%]   .content[_ngcontent-%COMP%]{flex-direction:row-reverse}[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{position:absolute;width:0;height:0}[_nghost-%COMP%]   nb-icon[_ngcontent-%COMP%] + span[_ngcontent-%COMP%]{margin-left:.5rem}.right[_nghost-%COMP%]   nb-icon[_ngcontent-%COMP%] + span[_ngcontent-%COMP%]{margin-right:.5rem}[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{border-left:6px solid transparent;border-right:6px solid transparent}.bottom[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{top:-6px;left:calc(50% - 6px)}.bottom-start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{top:-6px}[dir=ltr]   .bottom-start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:6px}[dir=rtl]   .bottom-start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:6px}.bottom-end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{top:-6px}[dir=ltr]   .bottom-end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:6px}[dir=rtl]   .bottom-end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:6px}.left[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%], .start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{top:calc(50% - 2.4px)}[dir=ltr]   .left[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%], [dir=ltr]   .start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:-8px;transform:rotate(90deg)}[dir=rtl]   .left[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%], [dir=rtl]   .start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:-8px;transform:rotate(270deg)}.start-top[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:-8px;bottom:6px;transform:rotate(90deg)}.start-bottom[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:-8px;top:6px;transform:rotate(90deg)}.top[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{bottom:-6px;left:calc(50% - 6px);transform:rotate(180deg)}.top-start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{bottom:-5px;transform:rotate(180deg)}[dir=ltr]   .top-start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:6px}[dir=rtl]   .top-start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:6px}.top-end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{bottom:-5px;transform:rotate(180deg)}[dir=ltr]   .top-end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:6px}[dir=rtl]   .top-end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:6px}.right[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%], .end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{top:calc(50% - 2.4px)}[dir=ltr]   .right[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%], [dir=ltr]   .end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:-8px;transform:rotate(270deg)}[dir=rtl]   .right[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%], [dir=rtl]   .end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:-8px;transform:rotate(90deg)}.end-top[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:-8.4px;bottom:6px;transform:rotate(270deg)}.end-bottom[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:-8.4px;top:6px;transform:rotate(270deg)}\n\n\n\n\n\n"],
  data: {
    animation: [trigger("showTooltip", [state("in", style({
      opacity: 1
    })), transition("void => *", [style({
      opacity: 0
    }), animate(100)]), transition("* => void", [animate(100, style({
      opacity: 0
    }))])])]
  }
});
var NbTooltipComponent = _NbTooltipComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTooltipComponent, [{
    type: Component,
    args: [{
      selector: "nb-tooltip",
      template: `
    <span class="arrow"></span>
    <div class="content">
      <nb-icon *ngIf="context?.icon" [config]="context.icon"></nb-icon>
      <span *ngIf="content">{{ content }}</span>
    </div>
  `,
      animations: [trigger("showTooltip", [state("in", style({
        opacity: 1
      })), transition("void => *", [style({
        opacity: 0
      }), animate(100)]), transition("* => void", [animate(100, style({
        opacity: 0
      }))])])],
      standalone: false,
      styles: [":host{z-index:10000}:host .content{display:flex;align-items:center}:host.right .content{flex-direction:row-reverse}:host .arrow{position:absolute;width:0;height:0}:host nb-icon+span{margin-left:.5rem}:host.right nb-icon+span{margin-right:.5rem}:host .arrow{border-left:6px solid transparent;border-right:6px solid transparent}:host(.bottom) .arrow{top:-6px;left:calc(50% - 6px)}:host(.bottom-start) .arrow{top:-6px}[dir=ltr] :host(.bottom-start) .arrow{right:6px}[dir=rtl] :host(.bottom-start) .arrow{left:6px}:host(.bottom-end) .arrow{top:-6px}[dir=ltr] :host(.bottom-end) .arrow{left:6px}[dir=rtl] :host(.bottom-end) .arrow{right:6px}:host(.left) .arrow,:host(.start) .arrow{top:calc(50% - 2.4px)}[dir=ltr] :host(.left) .arrow,[dir=ltr] :host(.start) .arrow{right:-8px;transform:rotate(90deg)}[dir=rtl] :host(.left) .arrow,[dir=rtl] :host(.start) .arrow{left:-8px;transform:rotate(270deg)}:host(.start-top) .arrow{right:-8px;bottom:6px;transform:rotate(90deg)}:host(.start-bottom) .arrow{right:-8px;top:6px;transform:rotate(90deg)}:host(.top) .arrow{bottom:-6px;left:calc(50% - 6px);transform:rotate(180deg)}:host(.top-start) .arrow{bottom:-5px;transform:rotate(180deg)}[dir=ltr] :host(.top-start) .arrow{right:6px}[dir=rtl] :host(.top-start) .arrow{left:6px}:host(.top-end) .arrow{bottom:-5px;transform:rotate(180deg)}[dir=ltr] :host(.top-end) .arrow{left:6px}[dir=rtl] :host(.top-end) .arrow{right:6px}:host(.right) .arrow,:host(.end) .arrow{top:calc(50% - 2.4px)}[dir=ltr] :host(.right) .arrow,[dir=ltr] :host(.end) .arrow{left:-8px;transform:rotate(270deg)}[dir=rtl] :host(.right) .arrow,[dir=rtl] :host(.end) .arrow{right:-8px;transform:rotate(90deg)}:host(.end-top) .arrow{left:-8.4px;bottom:6px;transform:rotate(270deg)}:host(.end-bottom) .arrow{left:-8.4px;top:6px;transform:rotate(270deg)}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: NbStatusService
  }], {
    content: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    binding: [{
      type: HostBinding,
      args: ["class"]
    }],
    show: [{
      type: HostBinding,
      args: ["@showTooltip"]
    }],
    context: [{
      type: Input
    }]
  });
})();
var _NbTooltipDirective = class _NbTooltipDirective {
  /**
   * Container position will change automatically based on this strategy if container can't fit view port.
   * Set this property to `noop` value if you want to disable automatic adjustment.
   * Available values: `clockwise` (default), `counterclockwise`, `vertical`, `horizontal`, `noop`.
   */
  get adjustment() {
    return this._adjustment;
  }
  set adjustment(value) {
    this._adjustment = value;
  }
  get tooltipClass() {
    return this._tooltipClass;
  }
  set tooltipClass(value) {
    if (value !== this.tooltipClass) {
      this._tooltipClass = value;
      this.overlayConfig = {
        panelClass: this.tooltipClass
      };
    }
  }
  /**
   * Accepts icon name or icon config object
   * @param {string | NbIconConfig} icon name or config object
   */
  set icon(icon) {
    this.context = Object.assign(this.context, {
      icon
    });
  }
  /**
   *
   * @param {string} status
   */
  set status(status) {
    this.context = Object.assign(this.context, {
      status
    });
  }
  get isShown() {
    return !!(this.dynamicOverlay && this.dynamicOverlay.isAttached);
  }
  constructor(hostRef, dynamicOverlayHandler) {
    this.hostRef = hostRef;
    this.dynamicOverlayHandler = dynamicOverlayHandler;
    this.destroy$ = new Subject();
    this.tooltipComponent = NbTooltipComponent;
    this.context = {};
    this.position = NbPosition.TOP;
    this._adjustment = NbAdjustment.CLOCKWISE;
    this._tooltipClass = "";
    this.trigger = NbTrigger.HINT;
    this.offset = 8;
    this.disabled = false;
    this.nbTooltipShowStateChange = new EventEmitter();
    this.overlayConfig = {
      panelClass: this.tooltipClass
    };
  }
  ngOnInit() {
    this.dynamicOverlayHandler.host(this.hostRef).componentType(this.tooltipComponent).offset(this.offset);
  }
  ngOnChanges() {
    this.rebuild();
  }
  ngAfterViewInit() {
    this.dynamicOverlay = this.configureDynamicOverlay().build();
    this.dynamicOverlay.isShown.pipe(skip(1), takeUntil(this.destroy$)).subscribe((isShown) => this.nbTooltipShowStateChange.emit({
      isShown
    }));
  }
  rebuild() {
    this.dynamicOverlay = this.configureDynamicOverlay().rebuild();
  }
  show() {
    this.dynamicOverlay.show();
  }
  hide() {
    this.dynamicOverlay.hide();
  }
  toggle() {
    this.dynamicOverlay.toggle();
  }
  ngOnDestroy() {
    this.dynamicOverlayHandler.destroy();
    this.destroy$.next();
    this.destroy$.complete();
  }
  configureDynamicOverlay() {
    return this.dynamicOverlayHandler.position(this.position).trigger(this.trigger).disabled(this.disabled).adjustment(this.adjustment).content(this.content).context(this.context).overlayConfig(this.overlayConfig);
  }
};
_NbTooltipDirective.\u0275fac = function NbTooltipDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbTooltipDirective)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NbDynamicOverlayHandler));
};
_NbTooltipDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbTooltipDirective,
  selectors: [["", "nbTooltip", ""]],
  inputs: {
    content: [0, "nbTooltip", "content"],
    position: [0, "nbTooltipPlacement", "position"],
    adjustment: [0, "nbTooltipAdjustment", "adjustment"],
    tooltipClass: [0, "nbTooltipClass", "tooltipClass"],
    icon: [0, "nbTooltipIcon", "icon"],
    status: [0, "nbTooltipStatus", "status"],
    trigger: [0, "nbTooltipTrigger", "trigger"],
    offset: [0, "nbTooltipOffset", "offset"],
    disabled: [0, "nbTooltipDisabled", "disabled"]
  },
  outputs: {
    nbTooltipShowStateChange: "nbTooltipShowStateChange"
  },
  exportAs: ["nbTooltip"],
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([NbDynamicOverlayHandler, NbDynamicOverlay]), \u0275\u0275NgOnChangesFeature]
});
var NbTooltipDirective = _NbTooltipDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTooltipDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTooltip]",
      exportAs: "nbTooltip",
      providers: [NbDynamicOverlayHandler, NbDynamicOverlay],
      standalone: false
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NbDynamicOverlayHandler
  }], {
    content: [{
      type: Input,
      args: ["nbTooltip"]
    }],
    position: [{
      type: Input,
      args: ["nbTooltipPlacement"]
    }],
    adjustment: [{
      type: Input,
      args: ["nbTooltipAdjustment"]
    }],
    tooltipClass: [{
      type: Input,
      args: ["nbTooltipClass"]
    }],
    icon: [{
      type: Input,
      args: ["nbTooltipIcon"]
    }],
    status: [{
      type: Input,
      args: ["nbTooltipStatus"]
    }],
    trigger: [{
      type: Input,
      args: ["nbTooltipTrigger"]
    }],
    offset: [{
      type: Input,
      args: ["nbTooltipOffset"]
    }],
    disabled: [{
      type: Input,
      args: ["nbTooltipDisabled"]
    }],
    nbTooltipShowStateChange: [{
      type: Output
    }]
  });
})();
var _NbTooltipModule = class _NbTooltipModule {
};
_NbTooltipModule.\u0275fac = function NbTooltipModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbTooltipModule)();
};
_NbTooltipModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbTooltipModule,
  declarations: [NbTooltipComponent, NbTooltipDirective],
  imports: [NbSharedModule, NbOverlayModule, NbIconModule],
  exports: [NbTooltipDirective]
});
_NbTooltipModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NbSharedModule, NbOverlayModule, NbIconModule]
});
var NbTooltipModule = _NbTooltipModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTooltipModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbOverlayModule, NbIconModule],
      declarations: [NbTooltipComponent, NbTooltipDirective],
      exports: [NbTooltipDirective]
    }]
  }], null, null);
})();
var NB_SELECT_INJECTION_TOKEN = new InjectionToken("NB_SELECT_INJECTION_TOKEN");
var lastOptionId = 0;
var _NbOptionComponent = class _NbOptionComponent {
  get disabled() {
    return this._disabled || this.disabledByGroup;
  }
  set disabled(value) {
    this._disabled = convertToBoolProperty(value);
  }
  get click() {
    return this.click$.asObservable();
  }
  constructor(parent, elementRef, cd, zone, renderer) {
    this.elementRef = elementRef;
    this.cd = cd;
    this.zone = zone;
    this.renderer = renderer;
    this.disabledByGroup = false;
    this._disabled = false;
    this.selectionChange = new EventEmitter();
    this.click$ = new Subject();
    this.selected = false;
    this.alive = true;
    this.id = `nb-option-${lastOptionId++}`;
    this._active = false;
    this.parent = parent;
  }
  ngOnDestroy() {
    this.alive = false;
  }
  ngAfterViewInit() {
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this.elementRef.nativeElement, "nb-transition");
    }));
  }
  /**
   * Determines should we render checkbox.
   * */
  get withCheckbox() {
    return this.multiple && this.value != null;
  }
  get content() {
    return this.elementRef.nativeElement.textContent;
  }
  get hidden() {
    return this.elementRef.nativeElement.hidden;
  }
  // TODO: replace with isShowCheckbox property to control this behaviour outside, issues/1965
  get multiple() {
    return this.parent ? this.parent.multiple : false;
  }
  get selectedClass() {
    return this.selected;
  }
  get disabledAttribute() {
    return this.disabled ? "" : null;
  }
  get tabindex() {
    return "-1";
  }
  get activeClass() {
    return this._active;
  }
  onClick(event) {
    this.click$.next(this);
    event.preventDefault();
  }
  select() {
    this.setSelection(true);
  }
  deselect() {
    this.setSelection(false);
  }
  /**
   * Sets disabled by group state and marks component for check.
   */
  setDisabledByGroupState(disabled) {
    if (this.disabledByGroup !== disabled && this.alive) {
      this.disabledByGroup = disabled;
      this.cd.markForCheck();
    }
  }
  setSelection(selected) {
    if (this.alive && this.selected !== selected) {
      this.selected = selected;
      this.selectionChange.emit(this);
      this.cd.markForCheck();
    }
  }
  focus() {
    this.elementRef.nativeElement.focus();
  }
  getLabel() {
    return this.content;
  }
  setActiveStyles() {
    this._active = true;
    this.cd.markForCheck();
  }
  setInactiveStyles() {
    this._active = false;
    this.cd.markForCheck();
  }
};
_NbOptionComponent.\u0275fac = function NbOptionComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbOptionComponent)(\u0275\u0275directiveInject(NB_SELECT_INJECTION_TOKEN, 8), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(Renderer2));
};
_NbOptionComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbOptionComponent,
  selectors: [["nb-option"]],
  hostVars: 9,
  hostBindings: function NbOptionComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function NbOptionComponent_click_HostBindingHandler($event) {
        return ctx.onClick($event);
      })("keydown.space", function NbOptionComponent_keydown_space_HostBindingHandler($event) {
        return ctx.onClick($event);
      })("keydown.enter", function NbOptionComponent_keydown_enter_HostBindingHandler($event) {
        return ctx.onClick($event);
      });
    }
    if (rf & 2) {
      \u0275\u0275domProperty("tabIndex", ctx.tabindex);
      \u0275\u0275attribute("id", ctx.id)("disabled", ctx.disabledAttribute);
      \u0275\u0275classProp("multiple", ctx.multiple)("selected", ctx.selectedClass)("active", ctx.activeClass);
    }
  },
  inputs: {
    value: "value",
    disabled: "disabled"
  },
  outputs: {
    selectionChange: "selectionChange"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 2,
  vars: 1,
  consts: [["aria-hidden", "true", 3, "checked", "disabled", 4, "ngIf"], ["aria-hidden", "true", 3, "checked", "disabled"]],
  template: function NbOptionComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275template(0, NbOptionComponent_nb_checkbox_0_Template, 1, 2, "nb-checkbox", 0);
      \u0275\u0275projection(1);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.withCheckbox);
    }
  },
  dependencies: [NgIf, NbCheckboxComponent],
  styles: ["[_nghost-%COMP%]{display:flex}[hidden][_nghost-%COMP%]{display:none}[_nghost-%COMP%]:hover{cursor:pointer}[_nghost-%COMP%]   nb-checkbox[_ngcontent-%COMP%]{display:flex;pointer-events:none}[dir=ltr]   [_nghost-%COMP%]   nb-checkbox[_ngcontent-%COMP%]{margin-right:.5rem}[dir=rtl]   [_nghost-%COMP%]   nb-checkbox[_ngcontent-%COMP%]{margin-left:.5rem}[_nghost-%COMP%]   nb-checkbox[_ngcontent-%COMP%]     .label{padding:0}[disabled][_nghost-%COMP%]{pointer-events:none}.nb-transition[_nghost-%COMP%]{transition-duration:.15s;transition-property:background-color,color;transition-timing-function:ease-in}\n\n\n\n\n\n\n\n\n\n\n\n"],
  changeDetection: 0
});
var NbOptionComponent = _NbOptionComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOptionComponent, [{
    type: Component,
    args: [{
      selector: "nb-option",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <nb-checkbox *ngIf="withCheckbox" [checked]="selected" [disabled]="disabled" aria-hidden="true"> </nb-checkbox>
    <ng-content></ng-content>
  `,
      standalone: false,
      styles: [":host{display:flex}:host[hidden]{display:none}:host:hover{cursor:pointer}:host nb-checkbox{display:flex;pointer-events:none}[dir=ltr] :host nb-checkbox{margin-right:.5rem}[dir=rtl] :host nb-checkbox{margin-left:.5rem}:host nb-checkbox ::ng-deep .label{padding:0}:host([disabled]){pointer-events:none}:host(.nb-transition){transition-duration:.15s;transition-property:background-color,color;transition-timing-function:ease-in}\n/*!\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NB_SELECT_INJECTION_TOKEN]
    }]
  }, {
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: NgZone
  }, {
    type: Renderer2
  }], {
    value: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    selectionChange: [{
      type: Output
    }],
    id: [{
      type: HostBinding,
      args: ["attr.id"]
    }],
    multiple: [{
      type: HostBinding,
      args: ["class.multiple"]
    }],
    selectedClass: [{
      type: HostBinding,
      args: ["class.selected"]
    }],
    disabledAttribute: [{
      type: HostBinding,
      args: ["attr.disabled"]
    }],
    tabindex: [{
      type: HostBinding,
      args: ["tabIndex"]
    }],
    activeClass: [{
      type: HostBinding,
      args: ["class.active"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }, {
      type: HostListener,
      args: ["keydown.space", ["$event"]]
    }, {
      type: HostListener,
      args: ["keydown.enter", ["$event"]]
    }]
  });
})();
var _NbOptionListComponent = class _NbOptionListComponent {
  constructor() {
    this.size = "medium";
  }
  get positionTop() {
    return this.position === NbPosition.TOP;
  }
  get positionBottom() {
    return this.position === NbPosition.BOTTOM;
  }
  get sizeTiny() {
    return this.size === "tiny";
  }
  get sizeSmall() {
    return this.size === "small";
  }
  get sizeMedium() {
    return this.size === "medium";
  }
  get sizeLarge() {
    return this.size === "large";
  }
  get sizeGiant() {
    return this.size === "giant";
  }
};
_NbOptionListComponent.\u0275fac = function NbOptionListComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbOptionListComponent)();
};
_NbOptionListComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbOptionListComponent,
  selectors: [["nb-option-list"]],
  hostVars: 14,
  hostBindings: function NbOptionListComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("position-top", ctx.positionTop)("position-bottom", ctx.positionBottom)("size-tiny", ctx.sizeTiny)("size-small", ctx.sizeSmall)("size-medium", ctx.sizeMedium)("size-large", ctx.sizeLarge)("size-giant", ctx.sizeGiant);
    }
  },
  inputs: {
    size: "size",
    position: "position"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 2,
  vars: 0,
  consts: [[1, "option-list"]],
  template: function NbOptionListComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275elementStart(0, "ul", 0);
      \u0275\u0275projection(1);
      \u0275\u0275elementEnd();
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbOptionListComponent = _NbOptionListComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOptionListComponent, [{
    type: Component,
    args: [{
      selector: "nb-option-list",
      template: `
    <ul class="option-list">
      <ng-content></ng-content>
    </ul>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], null, {
    size: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    positionTop: [{
      type: HostBinding,
      args: ["class.position-top"]
    }],
    positionBottom: [{
      type: HostBinding,
      args: ["class.position-bottom"]
    }],
    sizeTiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    sizeSmall: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    sizeMedium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    sizeLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    sizeGiant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }]
  });
})();
var _NbSelectLabelComponent = class _NbSelectLabelComponent {
};
_NbSelectLabelComponent.\u0275fac = function NbSelectLabelComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbSelectLabelComponent)();
};
_NbSelectLabelComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbSelectLabelComponent,
  selectors: [["nb-select-label"]],
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function NbSelectLabelComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275projection(0);
    }
  },
  encapsulation: 2
});
var NbSelectLabelComponent = _NbSelectLabelComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSelectLabelComponent, [{
    type: Component,
    args: [{
      selector: "nb-select-label",
      template: "<ng-content></ng-content>",
      standalone: false
    }]
  }], null, null);
})();
function nbSelectFormFieldControlConfigFactory() {
  const config = new NbFormFieldControlConfig();
  config.supportsSuffix = false;
  return config;
}
var _NbSelectComponent = class _NbSelectComponent {
  /**
   * Specifies width (in pixels) to be set on `nb-option`s container (`nb-option-list`)
   * */
  get optionsWidth() {
    return this._optionsWidth ?? this.hostWidth;
  }
  set optionsWidth(value) {
    this._optionsWidth = value;
  }
  /**
   * Adds `outline` styles
   */
  get outline() {
    return this.appearance === "outline";
  }
  set outline(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "outline";
    }
  }
  /**
   * Adds `filled` styles
   */
  get filled() {
    return this.appearance === "filled";
  }
  set filled(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "filled";
    }
  }
  /**
   * Adds `hero` styles
   */
  get hero() {
    return this.appearance === "hero";
  }
  set hero(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "hero";
    }
  }
  /**
   * Disables the select
   */
  get disabled() {
    return !!this._disabled;
  }
  set disabled(value) {
    this._disabled = convertToBoolProperty(value);
  }
  /**
   * If set element will fill its container
   */
  get fullWidth() {
    return this._fullWidth;
  }
  set fullWidth(value) {
    this._fullWidth = convertToBoolProperty(value);
  }
  /**
   * A function to compare option value with selected value.
   * By default, values are compared with strict equality (`===`).
   */
  get compareWith() {
    return this._compareWith;
  }
  set compareWith(fn) {
    if (typeof fn !== "function") {
      return;
    }
    this._compareWith = fn;
    if (this.selectionModel.length && this.canSelectValue()) {
      this.setSelection(this.selected);
    }
  }
  /**
   * Accepts selected item or array of selected items.
   * */
  set selected(value) {
    this.writeValue(value);
  }
  get selected() {
    return this.multiple ? this.selectionModel.map((o) => o.value) : this.selectionModel[0].value;
  }
  /**
   * Gives capability just write `multiple` over the element.
   * */
  get multiple() {
    return this._multiple;
  }
  set multiple(value) {
    this._multiple = convertToBoolProperty(value);
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  /**
   * Determines is select opened.
   * */
  get isOpen() {
    return this.ref && this.ref.hasAttached();
  }
  constructor(document2, overlay, hostRef, positionBuilder, triggerStrategyBuilder, cd, focusKeyManagerFactoryService, focusMonitor, renderer, zone, statusService) {
    this.document = document2;
    this.overlay = overlay;
    this.hostRef = hostRef;
    this.positionBuilder = positionBuilder;
    this.triggerStrategyBuilder = triggerStrategyBuilder;
    this.cd = cd;
    this.focusKeyManagerFactoryService = focusKeyManagerFactoryService;
    this.focusMonitor = focusMonitor;
    this.renderer = renderer;
    this.zone = zone;
    this.statusService = statusService;
    this.size = "medium";
    this.status = "basic";
    this.shape = "rectangle";
    this.appearance = "outline";
    this._fullWidth = false;
    this.placeholder = "";
    this._compareWith = (v1, v2) => v1 === v2;
    this._multiple = false;
    this.optionsOverlayOffset = 8;
    this.scrollStrategy = "block";
    this.selectedChange = new EventEmitter();
    this.selectionModel = [];
    this.overlayPosition = "";
    this.alive = true;
    this.destroy$ = new Subject();
    this.onChange = () => {
    };
    this.onTouched = () => {
    };
    this.status$ = new BehaviorSubject(this.status);
    this.size$ = new BehaviorSubject(this.size);
    this.focused$ = new BehaviorSubject(false);
    this.disabled$ = new BehaviorSubject(this.disabled);
    this.fullWidth$ = new BehaviorSubject(this.fullWidth);
  }
  /**
   * Determines is select hidden.
   * */
  get isHidden() {
    return !this.isOpen;
  }
  /**
   * Returns width of the select button.
   * */
  get hostWidth() {
    return this.button.nativeElement.getBoundingClientRect().width;
  }
  get selectButtonClasses() {
    const classes = [];
    if (!this.selectionModel.length) {
      classes.push("placeholder");
    }
    if (!this.selectionModel.length && !this.placeholder) {
      classes.push("empty");
    }
    if (this.isOpen) {
      classes.push(this.overlayPosition);
    }
    return classes;
  }
  /**
   * Content rendered in the label.
   * */
  get selectionView() {
    if (this.selectionModel.length > 1) {
      return this.selectionModel.map((option) => option.content).join(", ");
    }
    return this.selectionModel[0].content;
  }
  ngOnChanges({
    disabled,
    status,
    size,
    fullWidth
  }) {
    if (disabled) {
      this.disabled$.next(disabled.currentValue);
    }
    if (status) {
      this.status$.next(status.currentValue);
    }
    if (size) {
      this.size$.next(size.currentValue);
    }
    if (fullWidth) {
      this.fullWidth$.next(this.fullWidth);
    }
  }
  ngAfterContentInit() {
    this.options.changes.pipe(
      startWith(this.options),
      filter(() => this.queue != null && this.canSelectValue()),
      // Call 'writeValue' when current change detection run is finished.
      // When writing is finished, change detection starts again, since
      // microtasks queue is empty.
      // Prevents ExpressionChangedAfterItHasBeenCheckedError.
      switchMap((options) => from(Promise.resolve(options))),
      takeUntil(this.destroy$)
    ).subscribe(() => this.writeValue(this.queue));
  }
  ngAfterViewInit() {
    this.triggerStrategy = this.createTriggerStrategy();
    this.subscribeOnButtonFocus();
    this.subscribeOnTriggers();
    this.subscribeOnOptionClick();
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this.hostRef.nativeElement, "nb-transition");
    }));
  }
  ngOnDestroy() {
    this.alive = false;
    this.destroy$.next();
    this.destroy$.complete();
    if (this.ref) {
      this.ref.dispose();
    }
    if (this.triggerStrategy) {
      this.triggerStrategy.destroy();
    }
  }
  show() {
    if (this.shouldShow()) {
      this.attachToOverlay();
      this.positionStrategy.positionChange.pipe(take(1), takeUntil(this.destroy$)).subscribe(() => {
        this.setActiveOption();
      });
      this.cd.markForCheck();
    }
  }
  hide() {
    if (this.isOpen) {
      this.ref.detach();
      this.cd.markForCheck();
    }
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
    this.cd.markForCheck();
  }
  writeValue(value) {
    if (!this.alive) {
      return;
    }
    if (this.canSelectValue()) {
      this.setSelection(value);
      if (this.selectionModel.length) {
        this.queue = null;
      }
    } else {
      this.queue = value;
    }
  }
  /**
   * Selects option or clear all selected options if value is null.
   * */
  handleOptionClick(option) {
    this.queue = null;
    if (option.value == null) {
      this.reset();
    } else {
      this.selectOption(option);
    }
    this.cd.markForCheck();
  }
  /**
   * Deselect all selected options.
   * */
  reset() {
    this.selectionModel.forEach((option) => option.deselect());
    this.selectionModel = [];
    this.hide();
    this.button.nativeElement.focus();
    this.emitSelected(this.multiple ? [] : null);
  }
  /**
   * Determines how to select option as multiple or single.
   * */
  selectOption(option) {
    if (this.multiple) {
      this.handleMultipleSelect(option);
    } else {
      this.handleSingleSelect(option);
    }
  }
  /**
   * Select single option.
   * */
  handleSingleSelect(option) {
    const selected = this.selectionModel.pop();
    if (selected && !this._compareWith(selected.value, option.value)) {
      selected.deselect();
    }
    this.selectionModel = [option];
    option.select();
    this.hide();
    this.button.nativeElement.focus();
    this.emitSelected(option.value);
  }
  /**
   * Select for multiple options.
   * */
  handleMultipleSelect(option) {
    if (option.selected) {
      this.selectionModel = this.selectionModel.filter((s) => !this._compareWith(s.value, option.value));
      option.deselect();
    } else {
      this.selectionModel.push(option);
      option.select();
    }
    this.emitSelected(this.selectionModel.map((opt) => opt.value));
  }
  attachToOverlay() {
    if (!this.ref) {
      this.createOverlay();
      this.subscribeOnPositionChange();
      this.createKeyManager();
      this.subscribeOnOverlayKeys();
    }
    this.ref.attach(this.portal);
  }
  setActiveOption() {
    if (this.selectionModel.length) {
      this.keyManager.setActiveItem(this.selectionModel[0]);
    } else {
      this.keyManager.setFirstItemActive();
    }
  }
  createOverlay() {
    const scrollStrategy = this.createScrollStrategy();
    this.positionStrategy = this.createPositionStrategy();
    this.ref = this.overlay.create({
      positionStrategy: this.positionStrategy,
      scrollStrategy,
      panelClass: this.optionsPanelClass
    });
  }
  createKeyManager() {
    this.keyManager = this.focusKeyManagerFactoryService.create(this.options).withTypeAhead(200);
  }
  createPositionStrategy() {
    return this.positionBuilder.connectedTo(this.button).position(NbPosition.BOTTOM).offset(this.optionsOverlayOffset).adjustment(NbAdjustment.VERTICAL);
  }
  createScrollStrategy() {
    return this.overlay.scrollStrategies[this.scrollStrategy]();
  }
  createTriggerStrategy() {
    return this.triggerStrategyBuilder.trigger(NbTrigger.CLICK).host(this.hostRef.nativeElement).container(() => this.getContainer()).build();
  }
  subscribeOnTriggers() {
    this.triggerStrategy.show$.subscribe(() => this.show());
    this.triggerStrategy.hide$.pipe(filter(() => this.isOpen)).subscribe(($event) => {
      this.hide();
      if (!this.isClickedWithinComponent($event)) {
        this.onTouched();
      }
    });
  }
  subscribeOnPositionChange() {
    this.positionStrategy.positionChange.pipe(takeUntil(this.destroy$)).subscribe((position) => {
      this.overlayPosition = position;
      this.cd.detectChanges();
    });
  }
  subscribeOnOptionClick() {
    this.options.changes.pipe(startWith(this.options), switchMap((options) => {
      return merge(...options.map((option) => option.click));
    }), takeUntil(this.destroy$)).subscribe((clickedOption) => this.handleOptionClick(clickedOption));
  }
  subscribeOnOverlayKeys() {
    this.ref.keydownEvents().pipe(filter(() => this.isOpen), takeUntil(this.destroy$)).subscribe((event) => {
      if (event.keyCode === ESCAPE) {
        this.button.nativeElement.focus();
        this.hide();
      } else {
        this.keyManager.onKeydown(event);
      }
    });
    this.keyManager.tabOut.pipe(takeUntil(this.destroy$)).subscribe(() => {
      this.hide();
      this.onTouched();
    });
  }
  subscribeOnButtonFocus() {
    this.focusMonitor.monitor(this.button).pipe(map((origin) => !!origin), finalize(() => this.focusMonitor.stopMonitoring(this.button)), takeUntil(this.destroy$)).subscribe(this.focused$);
  }
  getContainer() {
    return this.ref && this.ref.hasAttached() && {
      location: {
        nativeElement: this.ref.overlayElement
      }
    };
  }
  /**
   * Propagate selected value.
   * */
  emitSelected(selected) {
    this.onChange(selected);
    this.selectedChange.emit(selected);
  }
  /**
   * Set selected value in model.
   * */
  setSelection(value) {
    const isResetValue = value == null;
    let safeValue = value;
    if (this.multiple) {
      safeValue = value ?? [];
    }
    const isArray = Array.isArray(safeValue);
    if (this.multiple && !isArray && !isResetValue) {
      throw new Error("Can't assign single value if select is marked as multiple");
    }
    if (!this.multiple && isArray) {
      throw new Error("Can't assign array if select is not marked as multiple");
    }
    const previouslySelectedOptions = this.selectionModel;
    this.selectionModel = [];
    if (this.multiple) {
      safeValue.forEach((option) => this.selectValue(option));
    } else {
      this.selectValue(safeValue);
    }
    previouslySelectedOptions.filter((option) => !this.selectionModel.includes(option)).forEach((option) => option.deselect());
    this.cd.markForCheck();
  }
  /**
   * Selects value.
   * */
  selectValue(value) {
    if (value == null) {
      return;
    }
    const corresponding = this.options.find((option) => this._compareWith(option.value, value));
    if (corresponding) {
      corresponding.select();
      this.selectionModel.push(corresponding);
    }
  }
  shouldShow() {
    return this.isHidden && this.options?.length > 0;
  }
  /**
   * Sets touched if focus moved outside of button and overlay,
   * ignoring the case when focus moved to options overlay.
   */
  trySetTouched() {
    if (this.isHidden) {
      this.onTouched();
    }
  }
  isClickedWithinComponent($event) {
    return this.hostRef.nativeElement === $event.target || this.hostRef.nativeElement.contains($event.target);
  }
  canSelectValue() {
    return !!(this.options && this.options.length);
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get primary() {
    return this.status === "primary";
  }
  get info() {
    return this.status === "info";
  }
  get success() {
    return this.status === "success";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get rectangle() {
    return this.shape === "rectangle";
  }
  get round() {
    return this.shape === "round";
  }
  get semiRound() {
    return this.shape === "semi-round";
  }
};
_NbSelectComponent.\u0275fac = function NbSelectComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbSelectComponent)(\u0275\u0275directiveInject(NB_DOCUMENT), \u0275\u0275directiveInject(NbOverlayService), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NbPositionBuilderService), \u0275\u0275directiveInject(NbTriggerStrategyBuilderService), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NbFocusKeyManagerFactoryService), \u0275\u0275directiveInject(NbFocusMonitor), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(NbStatusService));
};
_NbSelectComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbSelectComponent,
  selectors: [["nb-select"]],
  contentQueries: function NbSelectComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, NbSelectLabelComponent, 5);
      \u0275\u0275contentQuery(dirIndex, NbOptionComponent, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.customLabel = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.options = _t);
    }
  },
  viewQuery: function NbSelectComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(NbPortalDirective, 5);
      \u0275\u0275viewQuery(_c40, 5, ElementRef);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.portal = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.button = _t.first);
    }
  },
  hostVars: 42,
  hostBindings: function NbSelectComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classMap(ctx.additionalClasses);
      \u0275\u0275classProp("appearance-outline", ctx.outline)("appearance-filled", ctx.filled)("appearance-hero", ctx.hero)("full-width", ctx.fullWidth)("open", ctx.isOpen)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("shape-rectangle", ctx.rectangle)("shape-round", ctx.round)("shape-semi-round", ctx.semiRound);
    }
  },
  inputs: {
    size: "size",
    status: "status",
    shape: "shape",
    appearance: "appearance",
    optionsListClass: "optionsListClass",
    optionsPanelClass: "optionsPanelClass",
    optionsWidth: "optionsWidth",
    outline: "outline",
    filled: "filled",
    hero: "hero",
    disabled: "disabled",
    fullWidth: "fullWidth",
    placeholder: "placeholder",
    compareWith: "compareWith",
    selected: "selected",
    multiple: "multiple",
    optionsOverlayOffset: "optionsOverlayOffset",
    scrollStrategy: "scrollStrategy"
  },
  outputs: {
    selectedChange: "selectedChange"
  },
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => _NbSelectComponent),
    multi: true
  }, {
    provide: NB_SELECT_INJECTION_TOKEN,
    useExisting: _NbSelectComponent
  }, {
    provide: NbFormFieldControl,
    useExisting: _NbSelectComponent
  }, {
    provide: NbFormFieldControlConfig,
    useFactory: nbSelectFormFieldControlConfigFactory
  }]), \u0275\u0275NgOnChangesFeature],
  ngContentSelectors: _c42,
  decls: 8,
  vars: 4,
  consts: [["selectButton", ""], ["placeholderTemplate", ""], ["defaultSelectionTemplate", ""], ["type", "button", 1, "select-button", 3, "blur", "keydown.arrowDown", "keydown.arrowUp", "disabled", "ngClass"], [3, "click"], [4, "ngIf", "ngIfElse"], ["icon", "chevron-down-outline", "pack", "nebular-essentials", "aria-hidden", "true", 3, "click"], [3, "size", "position", "width", "ngClass", 4, "nbPortal"], [3, "size", "position", "ngClass"]],
  template: function NbSelectComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = \u0275\u0275getCurrentView();
      \u0275\u0275projectionDef(_c41);
      \u0275\u0275elementStart(0, "button", 3, 0);
      \u0275\u0275listener("blur", function NbSelectComponent_Template_button_blur_0_listener() {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.trySetTouched());
      })("keydown.arrowDown", function NbSelectComponent_Template_button_keydown_arrowDown_0_listener() {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.show());
      })("keydown.arrowUp", function NbSelectComponent_Template_button_keydown_arrowUp_0_listener() {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.show());
      });
      \u0275\u0275elementStart(2, "span", 4);
      \u0275\u0275listener("click", function NbSelectComponent_Template_span_click_2_listener($event) {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.disabled && $event.stopPropagation());
      });
      \u0275\u0275template(3, NbSelectComponent_ng_container_3_Template, 4, 2, "ng-container", 5)(4, NbSelectComponent_ng_template_4_Template, 1, 1, "ng-template", null, 1, \u0275\u0275templateRefExtractor);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(6, "nb-icon", 6);
      \u0275\u0275listener("click", function NbSelectComponent_Template_nb_icon_click_6_listener($event) {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.disabled && $event.stopPropagation());
      });
      \u0275\u0275elementEnd()();
      \u0275\u0275template(7, NbSelectComponent_nb_option_list_7_Template, 2, 5, "nb-option-list", 7);
    }
    if (rf & 2) {
      const placeholderTemplate_r4 = \u0275\u0275reference(5);
      \u0275\u0275property("disabled", ctx.disabled)("ngClass", ctx.selectButtonClasses);
      \u0275\u0275advance(3);
      \u0275\u0275property("ngIf", ctx.selectionModel.length)("ngIfElse", placeholderTemplate_r4);
    }
  },
  dependencies: [NgClass, NgIf, NbPortalDirective, NbIconComponent, NbOptionListComponent],
  styles: ["[_nghost-%COMP%]{display:inline-block;max-width:100%}[dir=ltr]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]{text-align:left}[dir=ltr]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{right:.2em}[dir=rtl]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]{text-align:right}[dir=rtl]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{left:.2em}.full-width[_nghost-%COMP%]{width:100%}.nb-transition[_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]{transition-duration:.15s;transition-property:background-color,border-color,border-radius,box-shadow,color;transition-timing-function:ease-in}.select-button[_ngcontent-%COMP%]{position:relative;width:100%;overflow:hidden;text-overflow:ellipsis;text-transform:none;white-space:nowrap}nb-icon[_ngcontent-%COMP%]{font-size:1.5em;position:absolute;top:50%;transform:translateY(-50%);transition-duration:.15s;transition-property:transform;transition-timing-function:ease-in}[dir=ltr][_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{right:.5rem}[dir=rtl][_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{left:.5rem}.open[_nghost-%COMP%]   nb-icon[_ngcontent-%COMP%]{transform:translateY(-50%) rotate(180deg)}\n\n\n\n\n\n\n\n\n\n\n\n"],
  changeDetection: 0
});
var NbSelectComponent = _NbSelectComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSelectComponent, [{
    type: Component,
    args: [{
      selector: "nb-select",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NbSelectComponent),
        multi: true
      }, {
        provide: NB_SELECT_INJECTION_TOKEN,
        useExisting: NbSelectComponent
      }, {
        provide: NbFormFieldControl,
        useExisting: NbSelectComponent
      }, {
        provide: NbFormFieldControlConfig,
        useFactory: nbSelectFormFieldControlConfigFactory
      }],
      standalone: false,
      template: '<button\n  [disabled]="disabled"\n  [ngClass]="selectButtonClasses"\n  (blur)="trySetTouched()"\n  (keydown.arrowDown)="show()"\n  (keydown.arrowUp)="show()"\n  class="select-button"\n  type="button"\n  #selectButton\n>\n  <span (click)="disabled && $event.stopPropagation()">\n    <ng-container *ngIf="selectionModel.length; else placeholderTemplate">\n      <ng-container *ngIf="customLabel; else defaultSelectionTemplate">\n        <ng-content select="nb-select-label"></ng-content>\n      </ng-container>\n\n      <ng-template #defaultSelectionTemplate>{{ selectionView }}</ng-template>\n    </ng-container>\n\n    <ng-template #placeholderTemplate>{{ placeholder }}</ng-template>\n  </span>\n\n  <nb-icon\n    icon="chevron-down-outline"\n    pack="nebular-essentials"\n    (click)="disabled && $event.stopPropagation()"\n    aria-hidden="true"\n  >\n  </nb-icon>\n</button>\n\n<nb-option-list\n  *nbPortal\n  [size]="size"\n  [position]="overlayPosition"\n  [style.width.px]="optionsWidth"\n  [ngClass]="optionsListClass"\n>\n  <ng-content select="nb-option, nb-option-group"></ng-content>\n</nb-option-list>\n',
      styles: [":host{display:inline-block;max-width:100%}[dir=ltr] :host .select-button{text-align:left}[dir=ltr] :host .select-button nb-icon{right:.2em}[dir=rtl] :host .select-button{text-align:right}[dir=rtl] :host .select-button nb-icon{left:.2em}:host(.full-width){width:100%}:host(.nb-transition) .select-button{transition-duration:.15s;transition-property:background-color,border-color,border-radius,box-shadow,color;transition-timing-function:ease-in}.select-button{position:relative;width:100%;overflow:hidden;text-overflow:ellipsis;text-transform:none;white-space:nowrap}nb-icon{font-size:1.5em;position:absolute;top:50%;transform:translateY(-50%);transition-duration:.15s;transition-property:transform;transition-timing-function:ease-in}[dir=ltr] nb-icon{right:.5rem}[dir=rtl] nb-icon{left:.5rem}:host(.open) nb-icon{transform:translateY(-50%) rotate(180deg)}\n/*!\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: NbOverlayService
  }, {
    type: ElementRef
  }, {
    type: NbPositionBuilderService
  }, {
    type: NbTriggerStrategyBuilderService
  }, {
    type: ChangeDetectorRef
  }, {
    type: NbFocusKeyManagerFactoryService
  }, {
    type: NbFocusMonitor
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }], {
    size: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    shape: [{
      type: Input
    }],
    appearance: [{
      type: Input
    }],
    optionsListClass: [{
      type: Input
    }],
    optionsPanelClass: [{
      type: Input
    }],
    optionsWidth: [{
      type: Input
    }],
    outline: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-outline"]
    }],
    filled: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-filled"]
    }],
    hero: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-hero"]
    }],
    disabled: [{
      type: Input
    }],
    fullWidth: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.full-width"]
    }],
    placeholder: [{
      type: Input
    }],
    compareWith: [{
      type: Input
    }],
    selected: [{
      type: Input
    }],
    multiple: [{
      type: Input
    }],
    optionsOverlayOffset: [{
      type: Input
    }],
    scrollStrategy: [{
      type: Input
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    selectedChange: [{
      type: Output
    }],
    options: [{
      type: ContentChildren,
      args: [NbOptionComponent, {
        descendants: true
      }]
    }],
    customLabel: [{
      type: ContentChild,
      args: [NbSelectLabelComponent]
    }],
    portal: [{
      type: ViewChild,
      args: [NbPortalDirective]
    }],
    button: [{
      type: ViewChild,
      args: ["selectButton", {
        read: ElementRef
      }]
    }],
    isOpen: [{
      type: HostBinding,
      args: ["class.open"]
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    rectangle: [{
      type: HostBinding,
      args: ["class.shape-rectangle"]
    }],
    round: [{
      type: HostBinding,
      args: ["class.shape-round"]
    }],
    semiRound: [{
      type: HostBinding,
      args: ["class.shape-semi-round"]
    }]
  });
})();
var _NbOptionGroupComponent = class _NbOptionGroupComponent {
  constructor() {
    this.destroy$ = new Subject();
    this._disabled = false;
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = convertToBoolProperty(value);
    if (this.options) {
      this.updateOptionsDisabledState();
    }
  }
  get disabledAttribute() {
    return this.disabled ? "" : null;
  }
  ngAfterContentInit() {
    if (this.options.length) {
      this.asyncUpdateOptionsDisabledState();
    }
    this.options.changes.pipe(takeUntil(this.destroy$)).subscribe(() => this.asyncUpdateOptionsDisabledState());
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  /**
   * Sets disabled state for each option to current group disabled state.
   */
  updateOptionsDisabledState() {
    this.options.forEach((option) => option.setDisabledByGroupState(this.disabled));
  }
  /**
   * Updates options disabled state after promise resolution.
   * This way change detection will be triggered after options state updated.
   * Use this method when updating options during change detection run (e.g. QueryList.changes, lifecycle hooks).
   */
  asyncUpdateOptionsDisabledState() {
    from(Promise.resolve()).pipe(takeUntil(this.destroy$)).subscribe(() => this.updateOptionsDisabledState());
  }
};
_NbOptionGroupComponent.\u0275fac = function NbOptionGroupComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbOptionGroupComponent)();
};
_NbOptionGroupComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbOptionGroupComponent,
  selectors: [["nb-option-group"]],
  contentQueries: function NbOptionGroupComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, NbOptionComponent, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.options = _t);
    }
  },
  hostVars: 1,
  hostBindings: function NbOptionGroupComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("disabled", ctx.disabledAttribute);
    }
  },
  inputs: {
    title: "title",
    disabled: "disabled"
  },
  standalone: false,
  ngContentSelectors: _c44,
  decls: 3,
  vars: 1,
  consts: [[1, "option-group-title"]],
  template: function NbOptionGroupComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef(_c43);
      \u0275\u0275elementStart(0, "span", 0);
      \u0275\u0275text(1);
      \u0275\u0275elementEnd();
      \u0275\u0275projection(2);
    }
    if (rf & 2) {
      \u0275\u0275advance();
      \u0275\u0275textInterpolate(ctx.title);
    }
  },
  styles: ["[_nghost-%COMP%]{display:block}.option-group-title[_ngcontent-%COMP%]{display:block}\n\n\n\n\n\n"],
  changeDetection: 0
});
var NbOptionGroupComponent = _NbOptionGroupComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOptionGroupComponent, [{
    type: Component,
    args: [{
      selector: "nb-option-group",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <span class="option-group-title">{{ title }}</span>
    <ng-content select="nb-option, ng-container"></ng-content>
  `,
      standalone: false,
      styles: [":host{display:block}.option-group-title{display:block}\n/*\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], null, {
    title: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    disabledAttribute: [{
      type: HostBinding,
      args: ["attr.disabled"]
    }],
    options: [{
      type: ContentChildren,
      args: [NbOptionComponent, {
        descendants: true
      }]
    }]
  });
})();
var NB_OPTION_LIST_COMPONENTS = [NbOptionListComponent, NbOptionComponent, NbOptionGroupComponent];
var _NbOptionModule = class _NbOptionModule {
};
_NbOptionModule.\u0275fac = function NbOptionModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbOptionModule)();
};
_NbOptionModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbOptionModule,
  declarations: [NbOptionListComponent, NbOptionComponent, NbOptionGroupComponent],
  imports: [CommonModule, NbCheckboxModule],
  exports: [NbOptionListComponent, NbOptionComponent, NbOptionGroupComponent]
});
_NbOptionModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, NbCheckboxModule]
});
var NbOptionModule = _NbOptionModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOptionModule, [{
    type: NgModule,
    args: [{
      declarations: [...NB_OPTION_LIST_COMPONENTS],
      imports: [CommonModule, NbCheckboxModule],
      exports: [...NB_OPTION_LIST_COMPONENTS]
    }]
  }], null, null);
})();
var NB_SELECT_COMPONENTS$1 = [NbSelectComponent, NbSelectLabelComponent];
var _NbSelectModule = class _NbSelectModule {
};
_NbSelectModule.\u0275fac = function NbSelectModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbSelectModule)();
};
_NbSelectModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbSelectModule,
  declarations: [NbSelectComponent, NbSelectLabelComponent],
  imports: [NbSharedModule, NbOverlayModule, NbButtonModule, NbInputModule, NbCardModule, NbIconModule, NbOptionModule],
  exports: [NbSelectComponent, NbSelectLabelComponent, NbOptionModule]
});
_NbSelectModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NbSharedModule, NbOverlayModule, NbButtonModule, NbInputModule, NbCardModule, NbIconModule, NbOptionModule, NbOptionModule]
});
var NbSelectModule = _NbSelectModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSelectModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbOverlayModule, NbButtonModule, NbInputModule, NbCardModule, NbIconModule, NbOptionModule],
      exports: [...NB_SELECT_COMPONENTS$1, NbOptionModule],
      declarations: [...NB_SELECT_COMPONENTS$1]
    }]
  }], null, null);
})();
var _NbPrefixDirective = class _NbPrefixDirective {
};
_NbPrefixDirective.\u0275fac = function NbPrefixDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbPrefixDirective)();
};
_NbPrefixDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbPrefixDirective,
  selectors: [["", "nbPrefix", ""]],
  standalone: false
});
var NbPrefixDirective = _NbPrefixDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPrefixDirective, [{
    type: Directive,
    args: [{
      selector: "[nbPrefix]",
      standalone: false
    }]
  }], null, null);
})();
var _NbSuffixDirective = class _NbSuffixDirective {
};
_NbSuffixDirective.\u0275fac = function NbSuffixDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbSuffixDirective)();
};
_NbSuffixDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbSuffixDirective,
  selectors: [["", "nbSuffix", ""]],
  standalone: false
});
var NbSuffixDirective = _NbSuffixDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSuffixDirective, [{
    type: Directive,
    args: [{
      selector: "[nbSuffix]",
      standalone: false
    }]
  }], null, null);
})();
function throwFormControlElementNotFound() {
  throw new Error(`NbFormFieldComponent must contain [nbInput]`);
}
var _NbFormFieldComponent = class _NbFormFieldComponent {
  constructor(cd, zone, elementRef, renderer) {
    this.cd = cd;
    this.zone = zone;
    this.elementRef = elementRef;
    this.renderer = renderer;
    this.destroy$ = new Subject();
    this.formControlState$ = new ReplaySubject(1);
    this.prefixClasses$ = this.formControlState$.pipe(map((s) => this.getAddonClasses("prefix", s)));
    this.suffixClasses$ = this.formControlState$.pipe(map((s) => this.getAddonClasses("suffix", s)));
  }
  ngAfterContentChecked() {
    if (!this.formControl) {
      throwFormControlElementNotFound();
    }
  }
  ngAfterContentInit() {
    this.subscribeToFormControlStateChange();
    this.subscribeToAddonChange();
  }
  ngAfterViewInit() {
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this.elementRef.nativeElement, "nb-transition");
    }));
  }
  ngOnDestroy() {
    this.destroy$.next();
  }
  shouldShowPrefix() {
    return this.getFormControlConfig().supportsPrefix && !!this.prefix.length;
  }
  shouldShowSuffix() {
    return this.getFormControlConfig().supportsSuffix && !!this.suffix.length;
  }
  subscribeToFormControlStateChange() {
    const {
      disabled$,
      focused$,
      size$,
      status$,
      fullWidth$
    } = this.formControl;
    combineLatest([disabled$, focused$, size$, status$, fullWidth$]).pipe(map(([disabled, focused, size, status, fullWidth]) => ({
      disabled,
      focused,
      size,
      status,
      fullWidth
    })), distinctUntilChanged((oldState, state2) => this.isStatesEqual(oldState, state2)), tap(({
      size,
      fullWidth
    }) => {
      const formFieldClasses = [`nb-form-field-size-${size}`];
      if (!fullWidth) {
        formFieldClasses.push("nb-form-field-limited-width");
      }
      this.formFieldClasses = formFieldClasses.join(" ");
    }), takeUntil(this.destroy$)).subscribe(this.formControlState$);
  }
  subscribeToAddonChange() {
    merge(this.prefix.changes, this.suffix.changes).pipe(takeUntil(this.destroy$)).subscribe(() => this.cd.markForCheck());
  }
  getAddonClasses(addon, state2) {
    const classes = ["nb-form-field-addon", `nb-form-field-${addon}-${state2.size}`];
    if (state2.disabled) {
      classes.push(`nb-form-field-addon-disabled`);
    } else if (state2.focused) {
      classes.push(`nb-form-field-addon-${state2.status}-highlight`);
    } else {
      classes.push(`nb-form-field-addon-${state2.status}`);
    }
    return classes;
  }
  getFormControlConfig() {
    return this.formControlConfig || new NbFormFieldControlConfig();
  }
  isStatesEqual(oldState, state2) {
    return oldState.status === state2.status && oldState.disabled === state2.disabled && oldState.focused === state2.focused && oldState.fullWidth === state2.fullWidth && oldState.size === state2.size;
  }
};
_NbFormFieldComponent.\u0275fac = function NbFormFieldComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbFormFieldComponent)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2));
};
_NbFormFieldComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbFormFieldComponent,
  selectors: [["nb-form-field"]],
  contentQueries: function NbFormFieldComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, NbFormFieldControl, 5);
      \u0275\u0275contentQuery(dirIndex, NbFormFieldControlConfig, 5);
      \u0275\u0275contentQuery(dirIndex, NbPrefixDirective, 5);
      \u0275\u0275contentQuery(dirIndex, NbSuffixDirective, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.formControl = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.formControlConfig = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.prefix = _t);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.suffix = _t);
    }
  },
  hostVars: 2,
  hostBindings: function NbFormFieldComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classMap(ctx.formFieldClasses);
    }
  },
  standalone: false,
  ngContentSelectors: _c46,
  decls: 4,
  vars: 6,
  consts: [[3, "ngClass", 4, "ngIf"], [1, "nb-form-control-container"], [3, "ngClass"]],
  template: function NbFormFieldComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef(_c45);
      \u0275\u0275template(0, NbFormFieldComponent_div_0_Template, 3, 3, "div", 0);
      \u0275\u0275elementStart(1, "div", 1);
      \u0275\u0275projection(2);
      \u0275\u0275elementEnd();
      \u0275\u0275template(3, NbFormFieldComponent_div_3_Template, 3, 3, "div", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.shouldShowPrefix());
      \u0275\u0275advance();
      \u0275\u0275classProp("nb-form-field-control-with-prefix", ctx.shouldShowPrefix())("nb-form-field-control-with-suffix", ctx.shouldShowSuffix());
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", ctx.shouldShowSuffix());
    }
  },
  dependencies: [NgClass, NgIf, AsyncPipe],
  styles: ["[_nghost-%COMP%]{display:flex;align-items:center}[hidden][_nghost-%COMP%]{display:none}.nb-form-control-container[_ngcontent-%COMP%]{width:100%}\n\n\n\n\n\n"],
  changeDetection: 0
});
var NbFormFieldComponent = _NbFormFieldComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFormFieldComponent, [{
    type: Component,
    args: [{
      selector: "nb-form-field",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: '<div *ngIf="shouldShowPrefix()" [ngClass]="prefixClasses$ | async">\n  <ng-content select="[nbPrefix]"></ng-content>\n</div>\n\n<div class="nb-form-control-container"\n     [class.nb-form-field-control-with-prefix]="shouldShowPrefix()"\n     [class.nb-form-field-control-with-suffix]="shouldShowSuffix()">\n  <ng-content></ng-content>\n</div>\n\n<div *ngIf="shouldShowSuffix()" [ngClass]="suffixClasses$ | async">\n  <ng-content select="[nbSuffix]"></ng-content>\n</div>\n',
      styles: [":host{display:flex;align-items:center}:host[hidden]{display:none}.nb-form-control-container{width:100%}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: NgZone
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }], {
    prefix: [{
      type: ContentChildren,
      args: [NbPrefixDirective, {
        descendants: true
      }]
    }],
    suffix: [{
      type: ContentChildren,
      args: [NbSuffixDirective, {
        descendants: true
      }]
    }],
    formControl: [{
      type: ContentChild,
      args: [NbFormFieldControl, {
        static: false
      }]
    }],
    formControlConfig: [{
      type: ContentChild,
      args: [NbFormFieldControlConfig, {
        static: false
      }]
    }],
    formFieldClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var _NbSelectWithAutocompleteComponent = class _NbSelectWithAutocompleteComponent {
  /**
   * Specifies width (in pixels) to be set on `nb-option`s container (`nb-option-list`)
   * */
  get optionsWidth() {
    return this._optionsWidth ?? this.hostWidth;
  }
  set optionsWidth(value) {
    this._optionsWidth = value;
  }
  /**
   * Adds `outline` styles
   */
  get outline() {
    return this.appearance === "outline";
  }
  set outline(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "outline";
    }
  }
  /**
   * Adds `filled` styles
   */
  get filled() {
    return this.appearance === "filled";
  }
  set filled(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "filled";
    }
  }
  /**
   * Adds `hero` styles
   */
  get hero() {
    return this.appearance === "hero";
  }
  set hero(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "hero";
    }
  }
  /**
   * Disables the select
   */
  get disabled() {
    return !!this._disabled;
  }
  set disabled(value) {
    this._disabled = convertToBoolProperty(value);
  }
  /**
   * If set element will fill its container
   */
  get fullWidth() {
    return this._fullWidth;
  }
  set fullWidth(value) {
    this._fullWidth = convertToBoolProperty(value);
  }
  /**
   * A function to compare option value with selected value.
   * By default, values are compared with strict equality (`===`).
   */
  get compareWith() {
    return this._compareWith;
  }
  set compareWith(fn) {
    if (typeof fn !== "function") {
      return;
    }
    this._compareWith = fn;
    if (this.selectionModel.length && this.canSelectValue()) {
      this.setSelection(this.selected);
    }
  }
  /**
   * Accepts selected item or array of selected items.
   * */
  set selected(value) {
    this.writeValue(value);
  }
  get selected() {
    return this.multiple ? this.selectionModel.map((o) => o.value) : this.selectionModel[0].value;
  }
  /**
   * Gives capability just write `multiple` over the element.
   * */
  get multiple() {
    return this._multiple;
  }
  set multiple(value) {
    this._multiple = convertToBoolProperty(value);
    this.updatePositionStrategy();
    this.updateCurrentKeyManager();
  }
  /**
   * Experimental input.
   * Could be changed without any prior notice.
   * Use at your own risk.
   *
   * It replaces the button with input when the select is opened.
   * That replacement provides a very basic API to implement options filtering functionality.
   * Filtering itself isn't implemented inside select.
   * So it should be implemented by the user.
   */
  set withOptionsAutocomplete(value) {
    this._withOptionsAutocomplete = convertToBoolProperty(value);
    this.updatePositionStrategy();
    this.updateCurrentKeyManager();
    if (!value) {
      this.resetAutocompleteInput();
    }
  }
  get withOptionsAutocomplete() {
    return this._withOptionsAutocomplete;
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  /**
   * Determines is select opened.
   * */
  get isOpen() {
    return this.ref && this.ref.hasAttached();
  }
  get isOptionsAutocompleteAllowed() {
    return this.withOptionsAutocomplete;
  }
  get isOptionsAutocompleteInputShown() {
    return this.isOptionsAutocompleteAllowed && this.isOpen;
  }
  constructor(document2, overlay, hostRef, positionBuilder, triggerStrategyBuilder, cd, focusKeyManagerFactoryService, focusMonitor, renderer, zone, statusService, activeDescendantKeyManagerFactoryService) {
    this.document = document2;
    this.overlay = overlay;
    this.hostRef = hostRef;
    this.positionBuilder = positionBuilder;
    this.triggerStrategyBuilder = triggerStrategyBuilder;
    this.cd = cd;
    this.focusKeyManagerFactoryService = focusKeyManagerFactoryService;
    this.focusMonitor = focusMonitor;
    this.renderer = renderer;
    this.zone = zone;
    this.statusService = statusService;
    this.activeDescendantKeyManagerFactoryService = activeDescendantKeyManagerFactoryService;
    this.size = "medium";
    this.status = "basic";
    this.shape = "rectangle";
    this.appearance = "outline";
    this._fullWidth = false;
    this.placeholder = "";
    this._compareWith = (v1, v2) => v1 === v2;
    this._multiple = false;
    this.optionsOverlayOffset = 8;
    this.scrollStrategy = "block";
    this._withOptionsAutocomplete = false;
    this.selectedChange = new EventEmitter();
    this.selectOpen = new EventEmitter();
    this.selectClose = new EventEmitter();
    this.optionsAutocompleteInputChange = new EventEmitter();
    this.selectionModel = [];
    this.positionStrategy$ = new BehaviorSubject(void 0);
    this.overlayPosition = "";
    this.alive = true;
    this.destroy$ = new Subject();
    this.onChange = () => {
    };
    this.onTouched = () => {
    };
    this.status$ = new BehaviorSubject(this.status);
    this.size$ = new BehaviorSubject(this.size);
    this.focused$ = new BehaviorSubject(false);
    this.disabled$ = new BehaviorSubject(this.disabled);
    this.fullWidth$ = new BehaviorSubject(this.fullWidth);
    this.lastShownButtonWidth = void 0;
  }
  /**
   * Determines is select hidden.
   * */
  get isHidden() {
    return !this.isOpen;
  }
  /**
   * Returns width of the select button.
   * */
  get hostWidth() {
    if (this.isOptionsAutocompleteInputShown) {
      return this.optionsAutocompleteInput.nativeElement.getBoundingClientRect().width;
    }
    return this.button.nativeElement.getBoundingClientRect().width;
  }
  get selectButtonClasses() {
    const classes = [];
    if (!this.selectionModel.length) {
      classes.push("placeholder");
    }
    if (!this.selectionModel.length && !this.placeholder) {
      classes.push("empty");
    }
    if (this.isOpen) {
      classes.push(this.overlayPosition);
    }
    return classes;
  }
  /**
   * Content rendered in the label.
   * */
  get selectionView() {
    if (this.isOptionsAutocompleteInputShown && this.multiple) {
      return "";
    }
    if (this.selectionModel.length > 1) {
      return this.selectionModel.map((option) => option.content).join(", ");
    }
    return this.selectionModel[0]?.content?.trim() ?? "";
  }
  ngOnChanges({
    disabled,
    status,
    size,
    fullWidth
  }) {
    if (disabled) {
      this.disabled$.next(disabled.currentValue);
    }
    if (status) {
      this.status$.next(status.currentValue);
    }
    if (size) {
      this.size$.next(size.currentValue);
    }
    if (fullWidth) {
      this.fullWidth$.next(this.fullWidth);
    }
  }
  ngAfterContentInit() {
    this.options.changes.pipe(
      startWith(this.options),
      filter(() => this.queue != null && this.canSelectValue()),
      // Call 'writeValue' when current change detection run is finished.
      // When writing is finished, change detection starts again, since
      // microtasks queue is empty.
      // Prevents ExpressionChangedAfterItHasBeenCheckedError.
      switchMap((options) => from(Promise.resolve(options))),
      takeUntil(this.destroy$)
    ).subscribe(() => this.writeValue(this.queue));
  }
  ngAfterViewInit() {
    this.triggerStrategy = this.createTriggerStrategy();
    this.subscribeOnButtonFocus();
    this.subscribeOnTriggers();
    this.subscribeOnOptionClick();
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this.hostRef.nativeElement, "nb-transition");
    }));
  }
  ngOnDestroy() {
    this.alive = false;
    this.destroy$.next();
    this.destroy$.complete();
    if (this.ref) {
      this.ref.dispose();
    }
    if (this.triggerStrategy) {
      this.triggerStrategy.destroy();
    }
  }
  onAutocompleteInputChange(event) {
    this.optionsAutocompleteInputChange.emit(event.target.value);
  }
  show() {
    if (this.shouldShow()) {
      this.lastShownButtonWidth = this.hostWidth;
      this.attachToOverlay();
      this.positionStrategy$.pipe(switchMap((positionStrategy) => positionStrategy.positionChange ?? EMPTY), take(1), takeUntil(this.destroy$)).subscribe(() => {
        if (this.isOptionsAutocompleteInputShown) {
          this.optionsAutocompleteInput.nativeElement.focus();
        }
        this.setActiveOption();
      });
      this.selectOpen.emit();
      this.cd.markForCheck();
    }
  }
  hide() {
    if (this.isOpen) {
      this.ref.detach();
      this.cd.markForCheck();
      this.selectClose.emit();
      this.resetAutocompleteInput();
    }
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
    this.cd.markForCheck();
  }
  writeValue(value) {
    if (!this.alive) {
      return;
    }
    if (this.canSelectValue()) {
      this.setSelection(value);
      if (this.selectionModel.length) {
        this.queue = null;
      }
    } else {
      this.queue = value;
    }
  }
  /**
   * Selects option or clear all selected options if value is null.
   * */
  handleOptionClick(option) {
    this.queue = null;
    if (option.value == null) {
      this.reset();
    } else {
      this.selectOption(option);
    }
    this.cd.markForCheck();
  }
  /**
   * Deselect all selected options.
   * */
  reset() {
    this.selectionModel.forEach((option) => option.deselect());
    this.selectionModel = [];
    this.hide();
    this.focusButton();
    this.emitSelected(this.multiple ? [] : null);
  }
  /**
   * Determines how to select option as multiple or single.
   * */
  selectOption(option) {
    if (this.multiple) {
      this.handleMultipleSelect(option);
    } else {
      this.handleSingleSelect(option);
    }
  }
  /**
   * Select single option.
   * */
  handleSingleSelect(option) {
    const selected = this.selectionModel.pop();
    if (selected && !this._compareWith(selected.value, option.value)) {
      selected.deselect();
    }
    this.selectionModel = [option];
    option.select();
    this.hide();
    this.focusButton();
    this.emitSelected(option.value);
  }
  /**
   * Select for multiple options.
   * */
  handleMultipleSelect(option) {
    if (option.selected) {
      this.selectionModel = this.selectionModel.filter((s) => !this._compareWith(s.value, option.value));
      option.deselect();
    } else {
      this.selectionModel.push(option);
      option.select();
    }
    this.emitSelected(this.selectionModel.map((opt) => opt.value));
  }
  attachToOverlay() {
    if (!this.ref) {
      this.createOverlay();
      this.subscribeOnPositionChange();
      this.createKeyManager();
      this.subscribeOnOverlayKeys();
      this.subscribeOnOptionsAutocompleteChange();
    }
    this.ref.attach(this.portal);
  }
  setActiveOption() {
    if (this.selectionModel.length && !this.selectionModel[0].hidden) {
      this.currentKeyManager?.setActiveItem(this.selectionModel[0]);
    } else {
      this.currentKeyManager?.setFirstItemActive();
    }
  }
  createOverlay() {
    const scrollStrategy = this.createScrollStrategy();
    this.positionStrategy$.next(this.createPositionStrategy());
    this.ref = this.overlay.create({
      positionStrategy: this.positionStrategy$.value,
      scrollStrategy,
      panelClass: this.optionsPanelClass
    });
  }
  createKeyManager() {
    this.activeDescendantKeyManager = this.activeDescendantKeyManagerFactoryService.create(this.options).skipPredicate((option) => {
      return this.isOptionHidden(option);
    });
    this.focusKeyManager = this.focusKeyManagerFactoryService.create(this.options).withTypeAhead(200).skipPredicate((option) => {
      return this.isOptionHidden(option);
    });
    this.updateCurrentKeyManager();
  }
  updateCurrentKeyManager() {
    this.currentKeyManager?.setActiveItem(-1);
    if (this.isOptionsAutocompleteAllowed) {
      this.currentKeyManager = this.activeDescendantKeyManager;
    } else {
      this.currentKeyManager = this.focusKeyManager;
    }
    this.setActiveOption();
  }
  resetAutocompleteInput() {
    if (this.optionsAutocompleteInput?.nativeElement) {
      this.optionsAutocompleteInput.nativeElement.value = this.selectionView;
      this.optionsAutocompleteInputChange.emit("");
    }
  }
  createPositionStrategy() {
    const element = this.isOptionsAutocompleteAllowed ? this.optionsAutocompleteInput : this.button;
    return this.positionBuilder.connectedTo(element).position(NbPosition.BOTTOM).offset(this.optionsOverlayOffset).adjustment(NbAdjustment.VERTICAL);
  }
  updatePositionStrategy() {
    if (this.ref) {
      this.positionStrategy$.next(this.createPositionStrategy());
      this.ref.updatePositionStrategy(this.positionStrategy$.value);
      if (this.isOpen) {
        this.ref.updatePosition();
      }
    }
  }
  createScrollStrategy() {
    return this.overlay.scrollStrategies[this.scrollStrategy]();
  }
  createTriggerStrategy() {
    return this.triggerStrategyBuilder.trigger(NbTrigger.CLICK).host(this.hostRef.nativeElement).container(() => this.getContainer()).build();
  }
  subscribeOnTriggers() {
    this.triggerStrategy.show$.subscribe(() => this.show());
    this.triggerStrategy.hide$.pipe(filter(() => this.isOpen)).subscribe(($event) => {
      this.hide();
      if (!this.isClickedWithinComponent($event)) {
        this.onTouched();
      }
    });
  }
  subscribeOnPositionChange() {
    this.positionStrategy$.pipe(switchMap((positionStrategy) => positionStrategy.positionChange ?? EMPTY), takeUntil(this.destroy$)).subscribe((position) => {
      this.overlayPosition = position;
      this.cd.detectChanges();
    });
  }
  subscribeOnOptionClick() {
    this.options.changes.pipe(startWith(this.options), switchMap((options) => {
      return merge(...options.map((option) => option.click));
    }), takeUntil(this.destroy$)).subscribe((clickedOption) => this.handleOptionClick(clickedOption));
  }
  subscribeOnOverlayKeys() {
    this.ref.keydownEvents().pipe(filter(() => this.isOpen), takeUntil(this.destroy$)).subscribe((event) => {
      if (event.keyCode === ESCAPE) {
        this.hide();
        this.focusButton();
      } else if (event.keyCode === ENTER && this.isOptionsAutocompleteInputShown) {
        event.preventDefault();
        const activeItem = this.currentKeyManager.activeItem;
        if (activeItem) {
          this.selectOption(activeItem);
        }
      } else {
        this.currentKeyManager.onKeydown(event);
      }
    });
    merge(this.focusKeyManager.tabOut.pipe(filter(() => !this.isOptionsAutocompleteInputShown)), this.activeDescendantKeyManager.tabOut.pipe(filter(() => this.isOptionsAutocompleteInputShown))).pipe(takeUntil(this.destroy$)).subscribe(() => {
      this.hide();
      this.onTouched();
    });
  }
  subscribeOnOptionsAutocompleteChange() {
    this.optionsAutocompleteInputChange.pipe(observeOn(animationFrameScheduler), filter(() => this.isOptionsAutocompleteInputShown), takeUntil(this.destroy$)).subscribe(() => {
      if (this.isOptionHidden(this.currentKeyManager.activeItem)) {
        this.currentKeyManager.setFirstItemActive();
      }
    });
  }
  subscribeOnButtonFocus() {
    const buttonFocus$ = this.focusMonitor.monitor(this.button).pipe(map((origin) => !!origin), startWith(false), finalize(() => this.focusMonitor.stopMonitoring(this.button)));
    const filterInputFocus$ = this.focusMonitor.monitor(this.optionsAutocompleteInput).pipe(map((origin) => !!origin), startWith(false), finalize(() => this.focusMonitor.stopMonitoring(this.button)));
    combineLatest([buttonFocus$, filterInputFocus$]).pipe(map(([buttonFocus, filterInputFocus]) => buttonFocus || filterInputFocus), takeUntil(this.destroy$)).subscribe(this.focused$);
  }
  getContainer() {
    return this.ref && this.ref.hasAttached() && {
      location: {
        nativeElement: this.ref.overlayElement
      }
    };
  }
  focusButton() {
    setTimeout(() => {
      this.button?.nativeElement?.focus();
    });
  }
  /**
   * Propagate selected value.
   * */
  emitSelected(selected) {
    this.onChange(selected);
    this.selectedChange.emit(selected);
  }
  /**
   * Set selected value in model.
   * */
  setSelection(value) {
    const isResetValue = value == null;
    let safeValue = value;
    if (this.multiple) {
      safeValue = value ?? [];
    }
    const isArray = Array.isArray(safeValue);
    if (this.multiple && !isArray && !isResetValue) {
      throw new Error("Can't assign single value if select is marked as multiple");
    }
    if (!this.multiple && isArray) {
      throw new Error("Can't assign array if select is not marked as multiple");
    }
    const previouslySelectedOptions = this.selectionModel;
    this.selectionModel = [];
    if (this.multiple) {
      safeValue.forEach((option) => this.selectValue(option));
    } else {
      this.selectValue(safeValue);
    }
    previouslySelectedOptions.filter((option) => !this.selectionModel.includes(option)).forEach((option) => option.deselect());
    this.cd.markForCheck();
  }
  /**
   * Selects value.
   * */
  selectValue(value) {
    if (value == null) {
      return;
    }
    const corresponding = this.options.find((option) => this._compareWith(option.value, value));
    if (corresponding) {
      corresponding.select();
      this.selectionModel.push(corresponding);
    }
  }
  shouldShow() {
    return this.isHidden && this.options?.length > 0;
  }
  /**
   * Sets touched if focus moved outside of button and overlay,
   * ignoring the case when focus moved to options overlay.
   */
  trySetTouched() {
    if (this.isHidden) {
      this.onTouched();
    }
  }
  isClickedWithinComponent($event) {
    return this.hostRef.nativeElement === $event.target || this.hostRef.nativeElement.contains($event.target);
  }
  canSelectValue() {
    return !!(this.options && this.options.length);
  }
  isOptionHidden(option) {
    return option.hidden;
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get primary() {
    return this.status === "primary";
  }
  get info() {
    return this.status === "info";
  }
  get success() {
    return this.status === "success";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get rectangle() {
    return this.shape === "rectangle";
  }
  get round() {
    return this.shape === "round";
  }
  get semiRound() {
    return this.shape === "semi-round";
  }
};
_NbSelectWithAutocompleteComponent.\u0275fac = function NbSelectWithAutocompleteComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbSelectWithAutocompleteComponent)(\u0275\u0275directiveInject(NB_DOCUMENT), \u0275\u0275directiveInject(NbOverlayService), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NbPositionBuilderService), \u0275\u0275directiveInject(NbTriggerStrategyBuilderService), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NbFocusKeyManagerFactoryService), \u0275\u0275directiveInject(NbFocusMonitor), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(NbStatusService), \u0275\u0275directiveInject(NbActiveDescendantKeyManagerFactoryService));
};
_NbSelectWithAutocompleteComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbSelectWithAutocompleteComponent,
  selectors: [["nb-select-with-autocomplete"]],
  contentQueries: function NbSelectWithAutocompleteComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, NbSelectLabelComponent, 5);
      \u0275\u0275contentQuery(dirIndex, NbOptionComponent, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.customLabel = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.options = _t);
    }
  },
  viewQuery: function NbSelectWithAutocompleteComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(NbPortalDirective, 5);
      \u0275\u0275viewQuery(_c40, 5, ElementRef);
      \u0275\u0275viewQuery(_c47, 5, ElementRef);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.portal = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.button = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.optionsAutocompleteInput = _t.first);
    }
  },
  hostVars: 42,
  hostBindings: function NbSelectWithAutocompleteComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classMap(ctx.additionalClasses);
      \u0275\u0275classProp("appearance-outline", ctx.outline)("appearance-filled", ctx.filled)("appearance-hero", ctx.hero)("full-width", ctx.fullWidth)("open", ctx.isOpen)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("shape-rectangle", ctx.rectangle)("shape-round", ctx.round)("shape-semi-round", ctx.semiRound);
    }
  },
  inputs: {
    size: "size",
    status: "status",
    shape: "shape",
    appearance: "appearance",
    optionsListClass: "optionsListClass",
    optionsPanelClass: "optionsPanelClass",
    optionsWidth: "optionsWidth",
    outline: "outline",
    filled: "filled",
    hero: "hero",
    disabled: "disabled",
    fullWidth: "fullWidth",
    placeholder: "placeholder",
    compareWith: "compareWith",
    selected: "selected",
    multiple: "multiple",
    optionsOverlayOffset: "optionsOverlayOffset",
    scrollStrategy: "scrollStrategy",
    withOptionsAutocomplete: "withOptionsAutocomplete"
  },
  outputs: {
    selectedChange: "selectedChange",
    selectOpen: "selectOpen",
    selectClose: "selectClose",
    optionsAutocompleteInputChange: "optionsAutocompleteInputChange"
  },
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => _NbSelectWithAutocompleteComponent),
    multi: true
  }, {
    provide: NB_SELECT_INJECTION_TOKEN,
    useExisting: _NbSelectWithAutocompleteComponent
  }, {
    provide: NbFormFieldControl,
    useExisting: _NbSelectWithAutocompleteComponent
  }, {
    provide: NbFormFieldControlConfig,
    useFactory: nbSelectFormFieldControlConfigFactory
  }]), \u0275\u0275NgOnChangesFeature],
  ngContentSelectors: _c42,
  decls: 12,
  vars: 13,
  consts: [["selectButton", ""], ["placeholderTemplate", ""], ["optionsAutocompleteInput", ""], ["defaultSelectionTemplate", ""], ["type", "button", 1, "select-button", 3, "blur", "keydown.arrowDown", "keydown.arrowUp", "hidden", "disabled", "ngClass"], [3, "click"], [4, "ngIf", "ngIfElse"], ["icon", "chevron-down-outline", "pack", "nebular-essentials", "aria-hidden", "true", 3, "click"], [3, "hidden"], ["nbInput", "", "fullWidth", "", 3, "blur", "click", "dblclick", "input", "value", "placeholder", "status", "shape", "fieldSize"], ["nbSuffix", "", "icon", "chevron-up-outline", "pack", "nebular-essentials", "aria-hidden", "true"], [3, "size", "position", "width", "ngClass", 4, "nbPortal"], [3, "size", "position", "ngClass"]],
  template: function NbSelectWithAutocompleteComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = \u0275\u0275getCurrentView();
      \u0275\u0275projectionDef(_c41);
      \u0275\u0275elementStart(0, "button", 4, 0);
      \u0275\u0275listener("blur", function NbSelectWithAutocompleteComponent_Template_button_blur_0_listener() {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.trySetTouched());
      })("keydown.arrowDown", function NbSelectWithAutocompleteComponent_Template_button_keydown_arrowDown_0_listener() {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.show());
      })("keydown.arrowUp", function NbSelectWithAutocompleteComponent_Template_button_keydown_arrowUp_0_listener() {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.show());
      });
      \u0275\u0275elementStart(2, "span", 5);
      \u0275\u0275listener("click", function NbSelectWithAutocompleteComponent_Template_span_click_2_listener($event) {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.disabled && $event.stopPropagation());
      });
      \u0275\u0275template(3, NbSelectWithAutocompleteComponent_ng_container_3_Template, 4, 2, "ng-container", 6)(4, NbSelectWithAutocompleteComponent_ng_template_4_Template, 1, 1, "ng-template", null, 1, \u0275\u0275templateRefExtractor);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(6, "nb-icon", 7);
      \u0275\u0275listener("click", function NbSelectWithAutocompleteComponent_Template_nb_icon_click_6_listener($event) {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.disabled && $event.stopPropagation());
      });
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(7, "nb-form-field", 8)(8, "input", 9, 2);
      \u0275\u0275listener("blur", function NbSelectWithAutocompleteComponent_Template_input_blur_8_listener() {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.trySetTouched());
      })("click", function NbSelectWithAutocompleteComponent_Template_input_click_8_listener($event) {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView($event.stopPropagation());
      })("dblclick", function NbSelectWithAutocompleteComponent_Template_input_dblclick_8_listener($event) {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView($event.stopPropagation());
      })("input", function NbSelectWithAutocompleteComponent_Template_input_input_8_listener($event) {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.onAutocompleteInputChange($event));
      });
      \u0275\u0275elementEnd();
      \u0275\u0275element(10, "nb-icon", 10);
      \u0275\u0275elementEnd();
      \u0275\u0275template(11, NbSelectWithAutocompleteComponent_nb_option_list_11_Template, 2, 5, "nb-option-list", 11);
    }
    if (rf & 2) {
      const placeholderTemplate_r4 = \u0275\u0275reference(5);
      \u0275\u0275property("hidden", ctx.isOptionsAutocompleteInputShown)("disabled", ctx.disabled)("ngClass", ctx.selectButtonClasses);
      \u0275\u0275advance(3);
      \u0275\u0275property("ngIf", ctx.selectionModel.length)("ngIfElse", placeholderTemplate_r4);
      \u0275\u0275advance(4);
      \u0275\u0275property("hidden", !ctx.isOptionsAutocompleteInputShown);
      \u0275\u0275advance();
      \u0275\u0275styleProp("max-width", ctx.lastShownButtonWidth, "px");
      \u0275\u0275property("value", ctx.selectionView)("placeholder", ctx.placeholder)("status", ctx.status)("shape", ctx.shape)("fieldSize", ctx.size);
    }
  },
  dependencies: [NgClass, NgIf, NbPortalDirective, NbInputDirective, NbIconComponent, NbOptionListComponent, NbFormFieldComponent, NbSuffixDirective],
  styles: ["[_nghost-%COMP%]{display:inline-block;max-width:100%}[dir=ltr]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]{text-align:left}[dir=ltr]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{right:.2em}[dir=rtl]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]{text-align:right}[dir=rtl]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{left:.2em}.full-width[_nghost-%COMP%]{width:100%}.nb-transition[_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]{transition-duration:.15s;transition-property:background-color,border-color,border-radius,box-shadow,color;transition-timing-function:ease-in}.select-button[_ngcontent-%COMP%], nb-form-field[_ngcontent-%COMP%]{position:relative;width:100%;overflow:hidden;text-overflow:ellipsis;text-transform:none;white-space:nowrap}nb-icon[_ngcontent-%COMP%]:not([nbSuffix]){font-size:1.5em;position:absolute;top:50%;transform:translateY(-50%);transition-duration:.15s;transition-property:transform;transition-timing-function:ease-in}[dir=ltr][_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]:not([nbSuffix]){right:.5rem}[dir=rtl][_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]:not([nbSuffix]){left:.5rem}.open[_nghost-%COMP%]   nb-icon[_ngcontent-%COMP%]:not([nbSuffix]){transform:translateY(-50%) rotate(180deg)}\n\n\n\n\n\n\n\n\n\n\n\n"],
  changeDetection: 0
});
var NbSelectWithAutocompleteComponent = _NbSelectWithAutocompleteComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSelectWithAutocompleteComponent, [{
    type: Component,
    args: [{
      selector: "nb-select-with-autocomplete",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NbSelectWithAutocompleteComponent),
        multi: true
      }, {
        provide: NB_SELECT_INJECTION_TOKEN,
        useExisting: NbSelectWithAutocompleteComponent
      }, {
        provide: NbFormFieldControl,
        useExisting: NbSelectWithAutocompleteComponent
      }, {
        provide: NbFormFieldControlConfig,
        useFactory: nbSelectFormFieldControlConfigFactory
      }],
      standalone: false,
      template: '<button\n  [hidden]="isOptionsAutocompleteInputShown"\n  [disabled]="disabled"\n  [ngClass]="selectButtonClasses"\n  (blur)="trySetTouched()"\n  (keydown.arrowDown)="show()"\n  (keydown.arrowUp)="show()"\n  class="select-button"\n  type="button"\n  #selectButton\n>\n  <span (click)="disabled && $event.stopPropagation()">\n    <ng-container *ngIf="selectionModel.length; else placeholderTemplate">\n      <ng-container *ngIf="customLabel; else defaultSelectionTemplate">\n        <ng-content select="nb-select-label"></ng-content>\n      </ng-container>\n\n      <ng-template #defaultSelectionTemplate>{{ selectionView }}</ng-template>\n    </ng-container>\n\n    <ng-template #placeholderTemplate>{{ placeholder }}</ng-template>\n  </span>\n\n  <nb-icon\n    icon="chevron-down-outline"\n    pack="nebular-essentials"\n    (click)="disabled && $event.stopPropagation()"\n    aria-hidden="true"\n  >\n  </nb-icon>\n</button>\n\n<nb-form-field [hidden]="!isOptionsAutocompleteInputShown">\n  <input\n    nbInput\n    fullWidth\n    [style.max-width.px]="lastShownButtonWidth"\n    #optionsAutocompleteInput\n    [value]="selectionView"\n    [placeholder]="placeholder"\n    [status]="status"\n    [shape]="shape"\n    [fieldSize]="size"\n    (blur)="trySetTouched()"\n    (click)="$event.stopPropagation()"\n    (dblclick)="$event.stopPropagation()"\n    (input)="onAutocompleteInputChange($event)"\n  />\n  <nb-icon nbSuffix icon="chevron-up-outline" pack="nebular-essentials" aria-hidden="true"> </nb-icon>\n</nb-form-field>\n\n<nb-option-list\n  *nbPortal\n  [size]="size"\n  [position]="overlayPosition"\n  [style.width.px]="optionsWidth"\n  [ngClass]="optionsListClass"\n>\n  <ng-content select="nb-option, nb-option-group"></ng-content>\n</nb-option-list>\n',
      styles: [":host{display:inline-block;max-width:100%}[dir=ltr] :host .select-button{text-align:left}[dir=ltr] :host .select-button nb-icon{right:.2em}[dir=rtl] :host .select-button{text-align:right}[dir=rtl] :host .select-button nb-icon{left:.2em}:host(.full-width){width:100%}:host(.nb-transition) .select-button{transition-duration:.15s;transition-property:background-color,border-color,border-radius,box-shadow,color;transition-timing-function:ease-in}.select-button,nb-form-field{position:relative;width:100%;overflow:hidden;text-overflow:ellipsis;text-transform:none;white-space:nowrap}nb-icon:not([nbSuffix]){font-size:1.5em;position:absolute;top:50%;transform:translateY(-50%);transition-duration:.15s;transition-property:transform;transition-timing-function:ease-in}[dir=ltr] nb-icon:not([nbSuffix]){right:.5rem}[dir=rtl] nb-icon:not([nbSuffix]){left:.5rem}:host(.open) nb-icon:not([nbSuffix]){transform:translateY(-50%) rotate(180deg)}\n/*!\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: NbOverlayService
  }, {
    type: ElementRef
  }, {
    type: NbPositionBuilderService
  }, {
    type: NbTriggerStrategyBuilderService
  }, {
    type: ChangeDetectorRef
  }, {
    type: NbFocusKeyManagerFactoryService
  }, {
    type: NbFocusMonitor
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }, {
    type: NbActiveDescendantKeyManagerFactoryService
  }], {
    size: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    shape: [{
      type: Input
    }],
    appearance: [{
      type: Input
    }],
    optionsListClass: [{
      type: Input
    }],
    optionsPanelClass: [{
      type: Input
    }],
    optionsWidth: [{
      type: Input
    }],
    outline: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-outline"]
    }],
    filled: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-filled"]
    }],
    hero: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-hero"]
    }],
    disabled: [{
      type: Input
    }],
    fullWidth: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.full-width"]
    }],
    placeholder: [{
      type: Input
    }],
    compareWith: [{
      type: Input
    }],
    selected: [{
      type: Input
    }],
    multiple: [{
      type: Input
    }],
    optionsOverlayOffset: [{
      type: Input
    }],
    scrollStrategy: [{
      type: Input
    }],
    withOptionsAutocomplete: [{
      type: Input
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    selectedChange: [{
      type: Output
    }],
    selectOpen: [{
      type: Output
    }],
    selectClose: [{
      type: Output
    }],
    optionsAutocompleteInputChange: [{
      type: Output
    }],
    options: [{
      type: ContentChildren,
      args: [NbOptionComponent, {
        descendants: true
      }]
    }],
    customLabel: [{
      type: ContentChild,
      args: [NbSelectLabelComponent]
    }],
    portal: [{
      type: ViewChild,
      args: [NbPortalDirective]
    }],
    button: [{
      type: ViewChild,
      args: ["selectButton", {
        read: ElementRef
      }]
    }],
    optionsAutocompleteInput: [{
      type: ViewChild,
      args: ["optionsAutocompleteInput", {
        read: ElementRef
      }]
    }],
    isOpen: [{
      type: HostBinding,
      args: ["class.open"]
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    rectangle: [{
      type: HostBinding,
      args: ["class.shape-rectangle"]
    }],
    round: [{
      type: HostBinding,
      args: ["class.shape-round"]
    }],
    semiRound: [{
      type: HostBinding,
      args: ["class.shape-semi-round"]
    }]
  });
})();
var COMPONENTS$1 = [NbFormFieldComponent, NbPrefixDirective, NbSuffixDirective];
var _NbFormFieldModule = class _NbFormFieldModule {
};
_NbFormFieldModule.\u0275fac = function NbFormFieldModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbFormFieldModule)();
};
_NbFormFieldModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbFormFieldModule,
  declarations: [NbFormFieldComponent, NbPrefixDirective, NbSuffixDirective],
  imports: [CommonModule],
  exports: [NbFormFieldComponent, NbPrefixDirective, NbSuffixDirective]
});
_NbFormFieldModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule]
});
var NbFormFieldModule = _NbFormFieldModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFormFieldModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [...COMPONENTS$1],
      exports: [...COMPONENTS$1]
    }]
  }], null, null);
})();
var NB_SELECT_COMPONENTS = [NbSelectWithAutocompleteComponent];
var _NbSelectWithAutocompleteModule = class _NbSelectWithAutocompleteModule {
};
_NbSelectWithAutocompleteModule.\u0275fac = function NbSelectWithAutocompleteModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbSelectWithAutocompleteModule)();
};
_NbSelectWithAutocompleteModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbSelectWithAutocompleteModule,
  declarations: [NbSelectWithAutocompleteComponent],
  imports: [NbSharedModule, NbOverlayModule, NbButtonModule, NbInputModule, NbCardModule, NbIconModule, NbOptionModule, NbFormFieldModule, NbSelectModule],
  exports: [NbSelectWithAutocompleteComponent, NbOptionModule, NbSelectModule]
});
_NbSelectWithAutocompleteModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NbSharedModule, NbOverlayModule, NbButtonModule, NbInputModule, NbCardModule, NbIconModule, NbOptionModule, NbFormFieldModule, NbSelectModule, NbOptionModule, NbSelectModule]
});
var NbSelectWithAutocompleteModule = _NbSelectWithAutocompleteModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSelectWithAutocompleteModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbOverlayModule, NbButtonModule, NbInputModule, NbCardModule, NbIconModule, NbOptionModule, NbFormFieldModule, NbSelectModule],
      exports: [...NB_SELECT_COMPONENTS, NbOptionModule, NbSelectModule],
      declarations: [...NB_SELECT_COMPONENTS]
    }]
  }], null, null);
})();
var lastAutocompleteId = 0;
var _NbAutocompleteComponent = class _NbAutocompleteComponent {
  get overlayPosition() {
    return this._overlayPosition;
  }
  set overlayPosition(value) {
    this._overlayPosition = value;
    this.cd.detectChanges();
  }
  /**
   * Returns width of the input.
   * */
  get hostWidth() {
    return this.hostRef.nativeElement.getBoundingClientRect().width;
  }
  /**
   * Specifies width (in pixels) to be set on `nb-option`s container (`nb-option-list`)
   * */
  get optionsWidth() {
    return this._optionsWidth ?? this.hostWidth;
  }
  set optionsWidth(value) {
    this._optionsWidth = value;
  }
  constructor(cd) {
    this.cd = cd;
    this.destroy$ = new Subject();
    this.id = `nb-autocomplete-${lastAutocompleteId++}`;
    this._overlayPosition = "";
    this.size = "medium";
    this.activeFirst = false;
    this.selectedChange = new EventEmitter();
  }
  ngAfterContentInit() {
    this.options.changes.pipe(takeUntil(this.destroy$)).subscribe(() => this.cd.detectChanges());
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  /**
   * Autocomplete knows nothing about host html input element.
   * So, attach method set input hostRef for styling.
   * */
  setHost(hostRef) {
    this.hostRef = hostRef;
  }
  /**
   * Propagate selected value.
   * */
  emitSelected(selected) {
    this.selectedChange.emit(selected);
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
};
_NbAutocompleteComponent.\u0275fac = function NbAutocompleteComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbAutocompleteComponent)(\u0275\u0275directiveInject(ChangeDetectorRef));
};
_NbAutocompleteComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbAutocompleteComponent,
  selectors: [["nb-autocomplete"]],
  contentQueries: function NbAutocompleteComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, NbOptionComponent, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.options = _t);
    }
  },
  viewQuery: function NbAutocompleteComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(NbPortalDirective, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.portal = _t.first);
    }
  },
  hostVars: 10,
  hostBindings: function NbAutocompleteComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant);
    }
  },
  inputs: {
    handleDisplayFn: "handleDisplayFn",
    size: "size",
    activeFirst: "activeFirst",
    optionsListClass: "optionsListClass",
    optionsPanelClass: "optionsPanelClass",
    optionsWidth: "optionsWidth"
  },
  outputs: {
    selectedChange: "selectedChange"
  },
  standalone: false,
  ngContentSelectors: _c49,
  decls: 1,
  vars: 0,
  consts: [["role", "listbox", 3, "size", "position", "width", "id", "empty", "ngClass", 4, "nbPortal"], ["role", "listbox", 3, "size", "position", "id", "ngClass"]],
  template: function NbAutocompleteComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef(_c48);
      \u0275\u0275template(0, NbAutocompleteComponent_nb_option_list_0_Template, 2, 8, "nb-option-list", 0);
    }
  },
  dependencies: [NgClass, NbPortalDirective, NbOptionListComponent],
  styles: ["[_nghost-%COMP%]:hover{cursor:pointer}nb-option-list.empty[_ngcontent-%COMP%]{border:none}\n\n\n\n\n\n"],
  changeDetection: 0
});
var NbAutocompleteComponent = _NbAutocompleteComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAutocompleteComponent, [{
    type: Component,
    args: [{
      selector: "nb-autocomplete",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: '<nb-option-list *nbPortal\n                [size]="size"\n                [position]="overlayPosition"\n                [style.width.px]="optionsWidth"\n                role="listbox"\n                [id]="id"\n                [class.empty]="!options?.length"\n                [ngClass]="optionsListClass">\n  <ng-content select="nb-option, nb-option-group"></ng-content>\n</nb-option-list>\n',
      styles: [":host(:hover){cursor:pointer}nb-option-list.empty{border:none}\n/*\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: ChangeDetectorRef
  }], {
    handleDisplayFn: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    activeFirst: [{
      type: Input
    }],
    optionsListClass: [{
      type: Input
    }],
    optionsPanelClass: [{
      type: Input
    }],
    optionsWidth: [{
      type: Input
    }],
    selectedChange: [{
      type: Output
    }],
    options: [{
      type: ContentChildren,
      args: [NbOptionComponent, {
        descendants: true
      }]
    }],
    portal: [{
      type: ViewChild,
      args: [NbPortalDirective]
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }]
  });
})();
var _NbAutocompleteDirective = class _NbAutocompleteDirective {
  /**
   * Determines is autocomplete overlay opened.
   * */
  get isOpen() {
    return this.overlayRef && this.overlayRef.hasAttached();
  }
  /**
   * Determines is autocomplete overlay closed.
   * */
  get isClosed() {
    return !this.isOpen;
  }
  /**
   * Provides autocomplete component.
   * */
  get autocomplete() {
    return this._autocomplete;
  }
  set autocomplete(autocomplete) {
    this._autocomplete = autocomplete;
  }
  get top() {
    return this.isOpen && this.autocomplete.options.length && this.autocomplete.overlayPosition === NbPosition.TOP;
  }
  get bottom() {
    return this.isOpen && this.autocomplete.options.length && this.autocomplete.overlayPosition === NbPosition.BOTTOM;
  }
  get ariaExpanded() {
    return this.isOpen && this.isOpen.toString();
  }
  get ariaOwns() {
    return this.isOpen ? this.autocomplete.id : null;
  }
  get ariaActiveDescendant() {
    return this.isOpen && this.keyManager.activeItem ? this.keyManager.activeItem.id : null;
  }
  constructor(hostRef, overlay, cd, triggerStrategyBuilder, positionBuilder, activeDescendantKeyManagerFactory, renderer) {
    this.hostRef = hostRef;
    this.overlay = overlay;
    this.cd = cd;
    this.triggerStrategyBuilder = triggerStrategyBuilder;
    this.positionBuilder = positionBuilder;
    this.activeDescendantKeyManagerFactory = activeDescendantKeyManagerFactory;
    this.renderer = renderer;
    this.destroy$ = new Subject();
    this._onChange = () => {
    };
    this._onTouched = () => {
    };
    this.overlayOffset = 8;
    this.scrollStrategy = "block";
    this.role = "combobox";
    this.ariaAutocomplete = "list";
    this.hasPopup = "true";
  }
  ngAfterViewInit() {
    this.triggerStrategy = this.createTriggerStrategy();
    this.subscribeOnTriggers();
  }
  ngOnDestroy() {
    if (this.triggerStrategy) {
      this.triggerStrategy.destroy();
    }
    if (this.positionStrategy) {
      this.positionStrategy.dispose();
    }
    if (this.overlayRef) {
      this.overlayRef.dispose();
    }
    this.destroy$.next();
    this.destroy$.complete();
  }
  handleInput() {
    const currentValue = this.hostRef.nativeElement.value;
    this._onChange(currentValue);
    this.setHostInputValue(this.getDisplayValue(currentValue));
    this.show();
  }
  handleKeydown() {
    this.show();
  }
  handleBlur() {
    this._onTouched();
  }
  show() {
    if (this.shouldShow()) {
      this.attachToOverlay();
      this.setActiveItem();
    }
  }
  hide() {
    if (this.isOpen) {
      this.overlayRef.detach();
      this.cd.markForCheck();
    }
  }
  writeValue(value) {
    this.handleInputValueUpdate(value);
  }
  registerOnChange(fn) {
    this._onChange = fn;
  }
  registerOnTouched(fn) {
    this._onTouched = fn;
  }
  setDisabledState(disabled) {
    this.renderer.setProperty(this.hostRef.nativeElement, "disabled", disabled);
  }
  subscribeOnOptionClick() {
    this.autocomplete.options.changes.pipe(tap(() => this.setActiveItem()), startWith(this.autocomplete.options), switchMap((options) => {
      return merge(...options.map((option) => option.click));
    }), takeUntil(this.destroy$)).subscribe((clickedOption) => this.handleInputValueUpdate(clickedOption.value, true));
  }
  subscribeOnPositionChange() {
    this.positionStrategy.positionChange.pipe(takeUntil(this.destroy$)).subscribe((position) => {
      this.autocomplete.overlayPosition = position;
      this.cd.detectChanges();
    });
  }
  getActiveItem() {
    return this.keyManager.activeItem;
  }
  setupAutocomplete() {
    this.autocomplete.setHost(this.customOverlayHost || this.hostRef);
  }
  getDisplayValue(value) {
    const displayFn = this.autocomplete.handleDisplayFn;
    return displayFn ? displayFn(value) : value;
  }
  getContainer() {
    return this.overlayRef && this.isOpen && {
      location: {
        nativeElement: this.overlayRef.overlayElement
      }
    };
  }
  handleInputValueUpdate(value, focusInput = false) {
    this.setHostInputValue(value ?? "");
    this._onChange(value);
    if (focusInput) {
      this.hostRef.nativeElement.focus();
    }
    this.autocomplete.emitSelected(value);
    this.hide();
  }
  subscribeOnTriggers() {
    this.triggerStrategy.show$.pipe(filter(() => this.isClosed)).subscribe(() => this.show());
    this.triggerStrategy.hide$.pipe(filter(() => this.isOpen)).subscribe(() => this.hide());
  }
  createTriggerStrategy() {
    return this.triggerStrategyBuilder.trigger(NbTrigger.FOCUS).host(this.hostRef.nativeElement).container(() => this.getContainer()).build();
  }
  createKeyManager() {
    this.keyManager = this.activeDescendantKeyManagerFactory.create(this.autocomplete.options);
  }
  setHostInputValue(value) {
    this.hostRef.nativeElement.value = this.getDisplayValue(value);
  }
  createPositionStrategy() {
    return this.positionBuilder.connectedTo(this.customOverlayHost || this.hostRef).position(NbPosition.BOTTOM).offset(this.overlayOffset).adjustment(NbAdjustment.VERTICAL);
  }
  subscribeOnOverlayKeys() {
    this.overlayRef.keydownEvents().pipe(takeUntil(this.destroy$)).subscribe((event) => {
      if (event.keyCode === ESCAPE && this.isOpen) {
        event.preventDefault();
        this.hostRef.nativeElement.focus();
        this.hide();
      } else if (event.keyCode === ENTER) {
        event.preventDefault();
        const activeItem = this.getActiveItem();
        if (!activeItem) {
          return;
        }
        this.handleInputValueUpdate(activeItem.value, true);
      } else {
        this.keyManager.onKeydown(event);
      }
    });
  }
  setActiveItem() {
    const mode = this.autocomplete.activeFirst ? NbKeyManagerActiveItemMode.FIRST_ACTIVE : NbKeyManagerActiveItemMode.RESET_ACTIVE;
    this.keyManager.setActiveItem(mode);
    this.cd.detectChanges();
  }
  attachToOverlay() {
    if (!this.overlayRef) {
      this.setupAutocomplete();
      this.initOverlay();
    }
    this.overlayRef.attach(this.autocomplete.portal);
  }
  createOverlay() {
    const scrollStrategy = this.createScrollStrategy();
    this.overlayRef = this.overlay.create({
      positionStrategy: this.positionStrategy,
      scrollStrategy,
      panelClass: this.autocomplete.optionsPanelClass
    });
  }
  initOverlay() {
    this.positionStrategy = this.createPositionStrategy();
    this.createKeyManager();
    this.subscribeOnPositionChange();
    this.subscribeOnOptionClick();
    this.checkOverlayVisibility();
    this.createOverlay();
    this.subscribeOnOverlayKeys();
  }
  checkOverlayVisibility() {
    this.autocomplete.options.changes.pipe(takeUntil(this.destroy$)).subscribe(() => {
      if (!this.autocomplete.options.length) {
        this.hide();
      }
    });
  }
  createScrollStrategy() {
    return this.overlay.scrollStrategies[this.scrollStrategy]();
  }
  shouldShow() {
    return this.isClosed;
  }
};
_NbAutocompleteDirective.\u0275fac = function NbAutocompleteDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbAutocompleteDirective)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NbOverlayService), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NbTriggerStrategyBuilderService), \u0275\u0275directiveInject(NbPositionBuilderService), \u0275\u0275directiveInject(NbActiveDescendantKeyManagerFactoryService), \u0275\u0275directiveInject(Renderer2));
};
_NbAutocompleteDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbAutocompleteDirective,
  selectors: [["input", "nbAutocomplete", ""]],
  hostVars: 10,
  hostBindings: function NbAutocompleteDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("input", function NbAutocompleteDirective_input_HostBindingHandler() {
        return ctx.handleInput();
      })("keydown.arrowDown", function NbAutocompleteDirective_keydown_arrowDown_HostBindingHandler() {
        return ctx.handleKeydown();
      })("keydown.arrowUp", function NbAutocompleteDirective_keydown_arrowUp_HostBindingHandler() {
        return ctx.handleKeydown();
      })("blur", function NbAutocompleteDirective_blur_HostBindingHandler() {
        return ctx.handleBlur();
      });
    }
    if (rf & 2) {
      \u0275\u0275attribute("role", ctx.role)("aria-autocomplete", ctx.ariaAutocomplete)("haspopup", ctx.hasPopup)("aria-expanded", ctx.ariaExpanded)("aria-owns", ctx.ariaOwns)("aria-activedescendant", ctx.ariaActiveDescendant);
      \u0275\u0275classProp("nb-autocomplete-position-top", ctx.top)("nb-autocomplete-position-bottom", ctx.bottom);
    }
  },
  inputs: {
    autocomplete: [0, "nbAutocomplete", "autocomplete"],
    overlayOffset: "overlayOffset",
    scrollStrategy: "scrollStrategy",
    customOverlayHost: "customOverlayHost"
  },
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => _NbAutocompleteDirective),
    multi: true
  }])]
});
var NbAutocompleteDirective = _NbAutocompleteDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAutocompleteDirective, [{
    type: Directive,
    args: [{
      selector: "input[nbAutocomplete]",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NbAutocompleteDirective),
        multi: true
      }],
      standalone: false
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NbOverlayService
  }, {
    type: ChangeDetectorRef
  }, {
    type: NbTriggerStrategyBuilderService
  }, {
    type: NbPositionBuilderService
  }, {
    type: NbActiveDescendantKeyManagerFactoryService
  }, {
    type: Renderer2
  }], {
    autocomplete: [{
      type: Input,
      args: ["nbAutocomplete"]
    }],
    overlayOffset: [{
      type: Input
    }],
    scrollStrategy: [{
      type: Input
    }],
    customOverlayHost: [{
      type: Input
    }],
    top: [{
      type: HostBinding,
      args: ["class.nb-autocomplete-position-top"]
    }],
    bottom: [{
      type: HostBinding,
      args: ["class.nb-autocomplete-position-bottom"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    ariaAutocomplete: [{
      type: HostBinding,
      args: ["attr.aria-autocomplete"]
    }],
    hasPopup: [{
      type: HostBinding,
      args: ["attr.haspopup"]
    }],
    ariaExpanded: [{
      type: HostBinding,
      args: ["attr.aria-expanded"]
    }],
    ariaOwns: [{
      type: HostBinding,
      args: ["attr.aria-owns"]
    }],
    ariaActiveDescendant: [{
      type: HostBinding,
      args: ["attr.aria-activedescendant"]
    }],
    handleInput: [{
      type: HostListener,
      args: ["input"]
    }],
    handleKeydown: [{
      type: HostListener,
      args: ["keydown.arrowDown"]
    }, {
      type: HostListener,
      args: ["keydown.arrowUp"]
    }],
    handleBlur: [{
      type: HostListener,
      args: ["blur"]
    }]
  });
})();
var NB_AUTOCOMPLETE_COMPONENTS = [NbAutocompleteComponent, NbAutocompleteDirective];
var _NbAutocompleteModule = class _NbAutocompleteModule {
};
_NbAutocompleteModule.\u0275fac = function NbAutocompleteModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbAutocompleteModule)();
};
_NbAutocompleteModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbAutocompleteModule,
  declarations: [NbAutocompleteComponent, NbAutocompleteDirective],
  imports: [CommonModule, FormsModule, NbOverlayModule, NbCardModule, NbOptionModule],
  exports: [NbAutocompleteComponent, NbAutocompleteDirective, NbOptionModule]
});
_NbAutocompleteModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, FormsModule, NbOverlayModule, NbCardModule, NbOptionModule, NbOptionModule]
});
var NbAutocompleteModule = _NbAutocompleteModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAutocompleteModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, NbOverlayModule, NbCardModule, NbOptionModule],
      exports: [...NB_AUTOCOMPLETE_COMPONENTS, NbOptionModule],
      declarations: [...NB_AUTOCOMPLETE_COMPONENTS]
    }]
  }], null, null);
})();
var NbWindowState;
(function(NbWindowState2) {
  NbWindowState2["MINIMIZED"] = "minimized";
  NbWindowState2["MAXIMIZED"] = "maximized";
  NbWindowState2["FULL_SCREEN"] = "full-screen";
})(NbWindowState || (NbWindowState = {}));
var NB_WINDOW_DEFAULT_BUTTONS_CONFIG = {
  minimize: true,
  maximize: true,
  fullScreen: true,
  close: true
};
var NbWindowConfig = class {
  constructor(...configs) {
    this.title = "";
    this.titleTemplateContext = {};
    this.initialState = NbWindowState.FULL_SCREEN;
    this.hasBackdrop = true;
    this.closeOnBackdropClick = true;
    this.closeOnEsc = true;
    this.windowClass = "";
    this.context = {};
    this.viewContainerRef = null;
    this.buttons = {};
    Object.assign(this, ...configs);
    this.applyDefaultButtonConfig();
  }
  applyDefaultButtonConfig() {
    Object.assign(this, {
      buttons: __spreadValues(__spreadValues({}, NB_WINDOW_DEFAULT_BUTTONS_CONFIG), this.buttons)
    });
  }
};
var NB_WINDOW_CONTENT = new InjectionToken("Nebular Window Content");
var NB_WINDOW_CONFIG = new InjectionToken("Nebular Window Config");
var NB_WINDOW_CONTEXT = new InjectionToken("Nebular Window Context");
var NbWindowRef = class {
  /**
   * Current window state.
   */
  get state() {
    return this.stateValue;
  }
  set state(newState) {
    if (newState && this.stateValue !== newState) {
      this.prevStateValue = this.state;
      this.stateValue = newState;
      this.stateChange$.next({
        oldState: this.prevStateValue,
        newState
      });
    }
  }
  /**
   * Emits when window state change.
   */
  get stateChange() {
    return this.stateChange$.asObservable();
  }
  /**
   * Emits when window was closed.
   */
  get onClose() {
    return this.closed$.asObservable();
  }
  constructor(config) {
    this.config = config;
    this.stateChange$ = new ReplaySubject(1);
    this._closed = false;
    this.closed$ = new Subject();
    this.state = config.initialState;
  }
  /**
   * Minimize window.
   */
  minimize() {
    this.state = NbWindowState.MINIMIZED;
  }
  /**
   * Maximize window.
   */
  maximize() {
    this.state = NbWindowState.MAXIMIZED;
  }
  /**
   * Set window on top.
   */
  fullScreen() {
    this.state = NbWindowState.FULL_SCREEN;
  }
  toPreviousState() {
    this.state = this.prevStateValue;
  }
  /**
   * Closes window.
   * */
  close(res) {
    if (this._closed) {
      return;
    }
    this._closed = true;
    this.componentRef.destroy();
    this.componentInstance = null;
    this.stateChange$.complete();
    this.closed$.next(res);
    this.closed$.complete();
  }
};
var _NbWindowsContainerComponent = class _NbWindowsContainerComponent {
};
_NbWindowsContainerComponent.\u0275fac = function NbWindowsContainerComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbWindowsContainerComponent)();
};
_NbWindowsContainerComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbWindowsContainerComponent,
  selectors: [["nb-windows-container"]],
  viewQuery: function NbWindowsContainerComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c50, 7, ViewContainerRef);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.viewContainerRef = _t.first);
    }
  },
  standalone: false,
  decls: 2,
  vars: 0,
  consts: [["viewContainerRef", ""]],
  template: function NbWindowsContainerComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementContainer(0, null, 0);
    }
  },
  styles: ["[_nghost-%COMP%]{display:flex;align-items:flex-end;overflow-x:auto}[_nghost-%COMP%]     nb-window:not(.full-screen){margin:0 2rem}"]
});
var NbWindowsContainerComponent = _NbWindowsContainerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbWindowsContainerComponent, [{
    type: Component,
    args: [{
      selector: "nb-windows-container",
      template: `<ng-container #viewContainerRef></ng-container>`,
      standalone: false,
      styles: [":host{display:flex;align-items:flex-end;overflow-x:auto}:host ::ng-deep nb-window:not(.full-screen){margin:0 2rem}\n"]
    }]
  }], null, {
    viewContainerRef: [{
      type: ViewChild,
      args: ["viewContainerRef", {
        read: ViewContainerRef,
        static: true
      }]
    }]
  });
})();
var _NbWindowComponent = class _NbWindowComponent {
  get isFullScreen() {
    return this.windowRef.state === NbWindowState.FULL_SCREEN;
  }
  get maximized() {
    return this.windowRef.state === NbWindowState.MAXIMIZED;
  }
  get minimized() {
    return this.windowRef.state === NbWindowState.MINIMIZED;
  }
  get showMinimize() {
    return this.config.buttons.minimize;
  }
  get showMaximize() {
    return this.config.buttons.maximize;
  }
  get showFullScreen() {
    return this.config.buttons.fullScreen;
  }
  get showClose() {
    return this.config.buttons.close;
  }
  constructor(content, context, windowRef, config, focusTrapFactory, elementRef, renderer) {
    this.content = content;
    this.context = context;
    this.windowRef = windowRef;
    this.config = config;
    this.focusTrapFactory = focusTrapFactory;
    this.elementRef = elementRef;
    this.renderer = renderer;
  }
  ngOnInit() {
    this.focusTrap = this.focusTrapFactory.create(this.elementRef.nativeElement);
    this.focusTrap.blurPreviouslyFocusedElement();
    this.focusTrap.focusInitialElement();
    if (this.config.windowClass) {
      this.renderer.addClass(this.elementRef.nativeElement, this.config.windowClass);
    }
  }
  ngAfterViewChecked() {
    if (!this.overlayContainer || this.overlayContainer.isAttached) {
      return;
    }
    if (this.content instanceof TemplateRef) {
      this.attachTemplate();
    } else {
      this.attachComponent();
    }
  }
  ngOnDestroy() {
    if (this.focusTrap) {
      this.focusTrap.restoreFocus();
    }
    this.close();
  }
  minimize() {
    if (this.windowRef.state === NbWindowState.MINIMIZED) {
      this.windowRef.toPreviousState();
    } else {
      this.windowRef.minimize();
    }
  }
  maximize() {
    this.windowRef.maximize();
  }
  fullScreen() {
    this.windowRef.fullScreen();
  }
  maximizeOrFullScreen() {
    if (this.windowRef.state === NbWindowState.MINIMIZED && this.showMaximize) {
      this.maximize();
    } else {
      this.fullScreen();
    }
  }
  close() {
    this.windowRef.close();
  }
  attachTemplate() {
    this.overlayContainer.attachTemplatePortal(new NbTemplatePortal(this.content, null, this.context));
  }
  attachComponent() {
    const portal = new NbComponentPortal(this.content, null, null);
    const ref = this.overlayContainer.attachComponentPortal(portal, this.context);
    this.windowRef.componentInstance = ref.instance;
    ref.changeDetectorRef.detectChanges();
  }
};
_NbWindowComponent.\u0275fac = function NbWindowComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbWindowComponent)(\u0275\u0275directiveInject(NB_WINDOW_CONTENT), \u0275\u0275directiveInject(NB_WINDOW_CONTEXT), \u0275\u0275directiveInject(NbWindowRef), \u0275\u0275directiveInject(NbWindowConfig), \u0275\u0275directiveInject(NbFocusTrapFactoryService), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2));
};
_NbWindowComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbWindowComponent,
  selectors: [["nb-window"]],
  viewQuery: function NbWindowComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(NbOverlayContainerComponent, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.overlayContainer = _t.first);
    }
  },
  hostVars: 6,
  hostBindings: function NbWindowComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("full-screen", ctx.isFullScreen)("maximized", ctx.maximized)("minimized", ctx.minimized);
    }
  },
  standalone: false,
  decls: 11,
  vars: 7,
  consts: [["textTitleTemplate", ""], ["cdkFocusInitial", "", "tabindex", "-1", 4, "ngIf", "ngIfElse"], [1, "buttons"], [4, "ngIf"], ["cdkFocusInitial", "", "tabindex", "-1"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["cdkFocusInitial", "", "tabindex", "-1", 1, "title"], ["nbButton", "", "ghost", "", 3, "click"], ["icon", "minus-outline", "pack", "nebular-essentials"], ["nbButton", "", "ghost", "", 3, "click", 4, "ngIf"], ["icon", "collapse-outline", "pack", "nebular-essentials"], ["icon", "expand-outline", "pack", "nebular-essentials"], ["icon", "close-outline", "pack", "nebular-essentials"]],
  template: function NbWindowComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "nb-card")(1, "nb-card-header");
      \u0275\u0275template(2, NbWindowComponent_div_2_Template, 2, 4, "div", 1)(3, NbWindowComponent_ng_template_3_Template, 2, 1, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
      \u0275\u0275elementStart(5, "div", 2);
      \u0275\u0275template(6, NbWindowComponent_ng_container_6_Template, 3, 0, "ng-container", 3)(7, NbWindowComponent_ng_container_7_Template, 2, 1, "ng-container", 3)(8, NbWindowComponent_ng_container_8_Template, 2, 1, "ng-container", 3)(9, NbWindowComponent_ng_container_9_Template, 3, 0, "ng-container", 3);
      \u0275\u0275elementEnd()();
      \u0275\u0275template(10, NbWindowComponent_nb_card_body_10_Template, 2, 0, "nb-card-body", 3);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      const textTitleTemplate_r6 = \u0275\u0275reference(4);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", ctx.config.titleTemplate)("ngIfElse", textTitleTemplate_r6);
      \u0275\u0275advance(4);
      \u0275\u0275property("ngIf", ctx.showMinimize);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.showMaximize);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.showFullScreen);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.showClose);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.maximized || ctx.isFullScreen);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, NbOverlayContainerComponent, NbCardComponent, NbCardBodyComponent, NbCardHeaderComponent, NbIconComponent, NbButtonComponent],
  styles: ["[_nghost-%COMP%]{flex:1 0 auto;min-width:20rem}[_nghost-%COMP%]   nb-card[_ngcontent-%COMP%]{margin:0}[_nghost-%COMP%]   nb-card-header[_ngcontent-%COMP%]{display:flex;justify-content:space-between;align-items:center;overflow:hidden}[_nghost-%COMP%]   .title[_ngcontent-%COMP%]{flex:1 0 auto;margin-right:3rem;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[_nghost-%COMP%]   .buttons[_ngcontent-%COMP%]{width:9.5rem;display:flex;justify-content:flex-end}[_nghost-%COMP%]   .buttons[_ngcontent-%COMP%]   [nbButton][_ngcontent-%COMP%]{flex:0 0 3rem}.full-screen[_nghost-%COMP%]{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%)}.maximized[_nghost-%COMP%]   nb-card[_ngcontent-%COMP%]{border-bottom-left-radius:0;border-bottom-right-radius:0}.minimized[_nghost-%COMP%]   nb-card[_ngcontent-%COMP%]{border-bottom-left-radius:0;border-bottom-right-radius:0;height:auto}.minimized[_nghost-%COMP%]   nb-card[_ngcontent-%COMP%]   nb-card-header[_ngcontent-%COMP%]{border-bottom:none}"]
});
var NbWindowComponent = _NbWindowComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbWindowComponent, [{
    type: Component,
    args: [{
      selector: "nb-window",
      template: `
    <nb-card>
      <nb-card-header>
        <div *ngIf="config.titleTemplate; else textTitleTemplate" cdkFocusInitial tabindex="-1">
          <ng-container
            *ngTemplateOutlet="config.titleTemplate; context: { $implicit: config.titleTemplateContext }"
          ></ng-container>
        </div>

        <ng-template #textTitleTemplate>
          <div cdkFocusInitial class="title" tabindex="-1">{{ config.title }}</div>
        </ng-template>

        <div class="buttons">
          <ng-container *ngIf="showMinimize">
            <button nbButton ghost (click)="minimize()">
              <nb-icon icon="minus-outline" pack="nebular-essentials"></nb-icon>
            </button>
          </ng-container>

          <ng-container *ngIf="showMaximize">
            <button nbButton ghost *ngIf="isFullScreen" (click)="maximize()">
              <nb-icon icon="collapse-outline" pack="nebular-essentials"></nb-icon>
            </button>
          </ng-container>

          <ng-container *ngIf="showFullScreen">
            <button nbButton ghost *ngIf="minimized || maximized" (click)="maximizeOrFullScreen()">
              <nb-icon icon="expand-outline" pack="nebular-essentials"></nb-icon>
            </button>
          </ng-container>

          <ng-container *ngIf="showClose">
            <button nbButton ghost (click)="close()">
              <nb-icon icon="close-outline" pack="nebular-essentials"></nb-icon>
            </button>
          </ng-container>
        </div>
      </nb-card-header>
      <nb-card-body *ngIf="maximized || isFullScreen">
        <nb-overlay-container></nb-overlay-container>
      </nb-card-body>
    </nb-card>
  `,
      standalone: false,
      styles: [":host{flex:1 0 auto;min-width:20rem}:host nb-card{margin:0}:host nb-card-header{display:flex;justify-content:space-between;align-items:center;overflow:hidden}:host .title{flex:1 0 auto;margin-right:3rem;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}:host .buttons{width:9.5rem;display:flex;justify-content:flex-end}:host .buttons [nbButton]{flex:0 0 3rem}:host(.full-screen){position:fixed;top:50%;left:50%;transform:translate(-50%,-50%)}:host(.maximized) nb-card{border-bottom-left-radius:0;border-bottom-right-radius:0}:host(.minimized) nb-card{border-bottom-left-radius:0;border-bottom-right-radius:0;height:auto}:host(.minimized) nb-card nb-card-header{border-bottom:none}\n"]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_WINDOW_CONTENT]
    }]
  }, {
    type: Object,
    decorators: [{
      type: Inject,
      args: [NB_WINDOW_CONTEXT]
    }]
  }, {
    type: NbWindowRef
  }, {
    type: NbWindowConfig
  }, {
    type: NbFocusTrapFactoryService
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }], {
    isFullScreen: [{
      type: HostBinding,
      args: ["class.full-screen"]
    }],
    maximized: [{
      type: HostBinding,
      args: ["class.maximized"]
    }],
    minimized: [{
      type: HostBinding,
      args: ["class.minimized"]
    }],
    overlayContainer: [{
      type: ViewChild,
      args: [NbOverlayContainerComponent]
    }]
  });
})();
var _NbWindowService = class _NbWindowService {
  constructor(overlayService, overlayPositionBuilder, blockScrollStrategy, defaultWindowsConfig, document2) {
    this.overlayService = overlayService;
    this.overlayPositionBuilder = overlayPositionBuilder;
    this.blockScrollStrategy = blockScrollStrategy;
    this.defaultWindowsConfig = defaultWindowsConfig;
    this.openWindows = [];
    this.document = document2;
  }
  /**
   * Opens new window.
   * @param windowContent
   * @param windowConfig
   * */
  open(windowContent, windowConfig = {}) {
    if (this.shouldCreateWindowsContainer()) {
      this.createWindowsContainer();
    }
    const config = new NbWindowConfig(this.defaultWindowsConfig, windowConfig);
    const windowRef = new NbWindowRef(config);
    windowRef.componentRef = this.appendWindow(windowContent, config, windowRef);
    this.openWindows.push(windowRef);
    this.subscribeToEvents(windowRef);
    return windowRef;
  }
  shouldCreateWindowsContainer() {
    if (this.windowsContainerViewRef) {
      const containerEl = this.windowsContainerViewRef.element.nativeElement;
      return !this.document.body.contains(containerEl);
    }
    return true;
  }
  createWindowsContainer() {
    if (this.overlayRef) {
      this.overlayRef.dispose();
    }
    this.overlayRef = this.overlayService.create({
      scrollStrategy: this.overlayService.scrollStrategies.noop(),
      positionStrategy: this.overlayPositionBuilder.global().bottom().right(),
      hasBackdrop: true
    });
    const windowsContainerPortal = new NbComponentPortal(NbWindowsContainerComponent, null, null);
    const overlayRef = this.overlayRef.attach(windowsContainerPortal);
    this.windowsContainerViewRef = overlayRef.instance.viewContainerRef;
  }
  appendWindow(content, config, windowRef) {
    const context = content instanceof TemplateRef ? {
      $implicit: config.context,
      windowRef
    } : config.context;
    const providers = [{
      provide: NB_WINDOW_CONTENT,
      useValue: content
    }, {
      provide: NB_WINDOW_CONTEXT,
      useValue: context
    }, {
      provide: NbWindowConfig,
      useValue: config
    }, {
      provide: NbWindowRef,
      useValue: windowRef
    }];
    const parentInjector = config.viewContainerRef ? config.viewContainerRef.injector : this.windowsContainerViewRef.injector;
    const injector = Injector.create({
      parent: parentInjector,
      providers
    });
    const ref = this.windowsContainerViewRef.createComponent(NbWindowComponent, {
      injector,
      index: this.windowsContainerViewRef.length
    });
    ref.changeDetectorRef.detectChanges();
    return ref;
  }
  subscribeToEvents(windowRef) {
    if (windowRef.config.closeOnBackdropClick) {
      this.overlayRef.backdropClick().subscribe(() => windowRef.close());
    }
    if (windowRef.config.closeOnEsc) {
      this.overlayRef.keydownEvents().pipe(filter((event) => event.keyCode === 27)).subscribe(() => windowRef.close());
    }
    windowRef.stateChange.subscribe(() => this.checkAndUpdateOverlay());
    windowRef.onClose.subscribe(() => {
      this.openWindows.splice(this.openWindows.indexOf(windowRef), 1);
      this.checkAndUpdateOverlay();
    });
  }
  checkAndUpdateOverlay() {
    const fullScreenWindows = this.openWindows.filter((w) => w.state === NbWindowState.FULL_SCREEN);
    if (fullScreenWindows.length > 0) {
      this.blockScrollStrategy.enable();
    } else {
      this.blockScrollStrategy.disable();
    }
    if (fullScreenWindows.some((w) => w.config.hasBackdrop)) {
      this.overlayRef.backdropElement.removeAttribute("hidden");
    } else {
      this.overlayRef.backdropElement.setAttribute("hidden", "");
    }
  }
};
_NbWindowService.\u0275fac = function NbWindowService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbWindowService)(\u0275\u0275inject(NbOverlayService), \u0275\u0275inject(NbOverlayPositionBuilder), \u0275\u0275inject(NbBlockScrollStrategyAdapter), \u0275\u0275inject(NB_WINDOW_CONFIG), \u0275\u0275inject(NB_DOCUMENT));
};
_NbWindowService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbWindowService,
  factory: _NbWindowService.\u0275fac
});
var NbWindowService = _NbWindowService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbWindowService, [{
    type: Injectable
  }], () => [{
    type: NbOverlayService
  }, {
    type: NbOverlayPositionBuilder
  }, {
    type: NbBlockScrollStrategyAdapter
  }, {
    type: NbWindowConfig,
    decorators: [{
      type: Inject,
      args: [NB_WINDOW_CONFIG]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }], null);
})();
var _NbWindowModule = class _NbWindowModule {
  static forRoot(defaultConfig) {
    return {
      ngModule: _NbWindowModule,
      providers: [NbWindowService, {
        provide: NB_WINDOW_CONFIG,
        useValue: defaultConfig
      }]
    };
  }
  static forChild(defaultConfig) {
    return {
      ngModule: _NbWindowModule,
      providers: [NbWindowService, {
        provide: NB_WINDOW_CONFIG,
        useValue: defaultConfig
      }]
    };
  }
};
_NbWindowModule.\u0275fac = function NbWindowModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbWindowModule)();
};
_NbWindowModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbWindowModule,
  declarations: [NbWindowsContainerComponent, NbWindowComponent],
  imports: [CommonModule, NbOverlayModule, NbCardModule, NbIconModule, NbButtonModule]
});
_NbWindowModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, NbOverlayModule, NbCardModule, NbIconModule, NbButtonModule]
});
var NbWindowModule = _NbWindowModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbWindowModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NbOverlayModule, NbCardModule, NbIconModule, NbButtonModule],
      declarations: [NbWindowsContainerComponent, NbWindowComponent]
    }]
  }], null, null);
})();
var _NbTimePickerDirective = class _NbTimePickerDirective {
  /**
   * Provides timepicker component.
   * */
  get timepicker() {
    return this._timePickerComponent;
  }
  set timepicker(timePicker) {
    this._timePickerComponent = timePicker;
    this.pickerInputsChangedSubscription?.unsubscribe();
    this.pickerInputsChangedSubscription = this._timePickerComponent.timepickerFormatChange$.pipe(map(() => this._timePickerComponent.computedTimeFormat), startWith(this._timePickerComponent.computedTimeFormat), distinctUntilChanged(), pairwise(), takeUntil(this.destroy$)).subscribe(([prevFormat, nextFormat]) => {
      if (this.inputValue) {
        const date = this.dateService.parse(this.inputValue, prevFormat);
        this.writeValue(date);
      }
    });
  }
  /**
   * Returns html input element.
   * @docs-private
   * */
  get input() {
    return this.hostRef.nativeElement;
  }
  /**
   * Determines is timepicker overlay opened.
   * @docs-private
   * */
  get isOpen() {
    return this.overlayRef && this.overlayRef.hasAttached();
  }
  /**
   * Determines is timepicker overlay closed.
   * @docs-private
   * */
  get isClosed() {
    return !this.isOpen;
  }
  constructor(document2, positionBuilder, hostRef, triggerStrategyBuilder, overlay, cd, calendarTimeModelService, dateService, renderer, placeholder) {
    this.document = document2;
    this.positionBuilder = positionBuilder;
    this.hostRef = hostRef;
    this.triggerStrategyBuilder = triggerStrategyBuilder;
    this.overlay = overlay;
    this.cd = cd;
    this.calendarTimeModelService = calendarTimeModelService;
    this.dateService = dateService;
    this.renderer = renderer;
    this.placeholder = placeholder;
    this.overlayOffset = 8;
    this.destroy$ = new Subject();
    this.onChange = () => {
    };
    this.onTouched = () => {
    };
  }
  /**
   * Returns host input value.
   * @docs-private
   * */
  get inputValue() {
    return this.input.value;
  }
  set inputValue(value) {
    this.input.value = value;
  }
  ngAfterViewInit() {
    this.subscribeOnInputChange();
    if (!this.placeholder) {
      this.renderer.setProperty(this.input, "placeholder", this.timepicker.computedTimeFormat);
    }
    this.triggerStrategy = this.createTriggerStrategy();
    this.subscribeOnTriggers();
    this.subscribeToBlur();
  }
  show() {
    if (this.isClosed) {
      this.attachToOverlay();
    }
  }
  hide() {
    if (this.isOpen) {
      this.overlayRef.detach();
      this.cd.markForCheck();
    }
  }
  /**
   * Attaches picker to the timepicker portal.
   * @docs-private
   * */
  attachToOverlay() {
    if (!this.overlayRef) {
      this.setupTimepicker();
      this.initOverlay();
    }
    this.overlayRef.attach(this.timepicker.portal);
  }
  setupTimepicker() {
    if (this.dateService.getId() === "native" && isDevMode()) {
      console.warn("Date.parse does not support parsing time with custom format. See details here https://akveo.github.io/nebular/docs/components/datepicker/overview#native-parse-issue");
    }
    this.timepicker.setHost(this.hostRef);
    if (this.inputValue) {
      const val = this.dateService.getId() === "native" ? this.parseNativeDateString(this.inputValue) : this.inputValue;
      this.timepicker.date = this.dateService.parse(val, this.timepicker.computedTimeFormat);
    } else {
      this.timepicker.date = this.calendarTimeModelService.getResetTime();
    }
  }
  initOverlay() {
    this.positionStrategy = this.createPositionStrategy();
    this.subscribeOnApplyClick();
    this.createOverlay();
  }
  subscribeOnApplyClick() {
    this.timepicker.onSelectTime.pipe(takeUntil(this.destroy$)).subscribe((value) => {
      const time = this.dateService.format(value.time, this.timepicker.computedTimeFormat).toUpperCase();
      this.inputValue = time;
      this.timepicker.date = value.time;
      this.onChange(value.time);
      if (value.save) {
        this.lastInputValue = time;
        this.hide();
      }
    });
  }
  createOverlay() {
    const scrollStrategy = this.createScrollStrategy();
    this.overlayRef = this.overlay.create({
      positionStrategy: this.positionStrategy,
      scrollStrategy
    });
  }
  subscribeOnTriggers() {
    this.triggerStrategy.show$.pipe(filter(() => this.isClosed)).subscribe(() => this.show());
    this.triggerStrategy.hide$.pipe(filter(() => this.isOpen)).subscribe(() => {
      this.inputValue = this.lastInputValue || "";
      this.hide();
    });
  }
  createTriggerStrategy() {
    return this.triggerStrategyBuilder.trigger(NbTrigger.FOCUS).host(this.hostRef.nativeElement).container(() => this.getContainer()).build();
  }
  createPositionStrategy() {
    return this.positionBuilder.connectedTo(this.hostRef).position(NbPosition.BOTTOM).offset(this.overlayOffset).adjustment(NbAdjustment.COUNTERCLOCKWISE);
  }
  getContainer() {
    return this.overlayRef && this.isOpen && {
      location: {
        nativeElement: this.overlayRef.overlayElement
      }
    };
  }
  createScrollStrategy() {
    return this.overlay.scrollStrategies.block();
  }
  subscribeOnInputChange() {
    fromEvent(this.input, "input").pipe(map(() => this.inputValue), takeUntil(this.destroy$)).subscribe((value) => this.handleInputChange(value));
  }
  subscribeToBlur() {
    merge(this.timepicker.blur, fromEvent(this.input, "blur").pipe(filter(() => !this.isOpen && this.document.activeElement !== this.input))).pipe(takeUntil(this.destroy$)).subscribe(() => this.onTouched());
  }
  /**
   * Parses input value and write if it isn't null.
   * @docs-private
   * */
  handleInputChange(value) {
    if (this.dateService.getId() === "native") {
      value = this.parseNativeDateString(value);
    }
    const isValidDate = this.dateService.isValidDateString(value, this.timepicker.computedTimeFormat);
    if (isValidDate) {
      this.lastInputValue = value;
      const date = this.dateService.parse(value, this.timepicker.computedTimeFormat);
      this.onChange(date);
      this.timepicker.date = date;
    }
  }
  updateValue(value) {
    if (value) {
      this.timepicker.date = value;
      const timeString = this.dateService.format(value, this.timepicker.computedTimeFormat).toUpperCase();
      this.inputValue = timeString;
      this.lastInputValue = timeString;
    }
  }
  writeValue(value) {
    this.updateValue(value);
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  setDisabledState(isDisabled) {
    this.input.disabled = isDisabled;
  }
  parseNativeDateString(value) {
    const date = this.dateService.today();
    const year = this.dateService.getYear(date);
    const month = this.calendarTimeModelService.paddToTwoSymbols(this.dateService.getMonth(date));
    const day = this.calendarTimeModelService.paddToTwoSymbols(this.dateService.getDate(date));
    return `${year}-${month}-${day} ${value}`;
  }
};
_NbTimePickerDirective.\u0275fac = function NbTimePickerDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbTimePickerDirective)(\u0275\u0275directiveInject(NB_DOCUMENT), \u0275\u0275directiveInject(NbPositionBuilderService), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NbTriggerStrategyBuilderService), \u0275\u0275directiveInject(NbOverlayService), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NbCalendarTimeModelService), \u0275\u0275directiveInject(NbDateService), \u0275\u0275directiveInject(Renderer2), \u0275\u0275injectAttribute("placeholder"));
};
_NbTimePickerDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbTimePickerDirective,
  selectors: [["input", "nbTimepicker", ""]],
  inputs: {
    timepicker: [0, "nbTimepicker", "timepicker"],
    overlayOffset: "overlayOffset"
  },
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => _NbTimePickerDirective),
    multi: true
  }])]
});
var NbTimePickerDirective = _NbTimePickerDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTimePickerDirective, [{
    type: Directive,
    args: [{
      selector: "input[nbTimepicker]",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NbTimePickerDirective),
        multi: true
      }],
      standalone: false
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: NbPositionBuilderService
  }, {
    type: ElementRef
  }, {
    type: NbTriggerStrategyBuilderService
  }, {
    type: NbOverlayService
  }, {
    type: ChangeDetectorRef
  }, {
    type: NbCalendarTimeModelService
  }, {
    type: NbDateService
  }, {
    type: Renderer2
  }, {
    type: void 0,
    decorators: [{
      type: Attribute,
      args: ["placeholder"]
    }]
  }], {
    timepicker: [{
      type: Input,
      args: ["nbTimepicker"]
    }],
    overlayOffset: [{
      type: Input
    }]
  });
})();
var _NbTimepickerModule = class _NbTimepickerModule {
  static forRoot(config = {}) {
    return {
      ngModule: _NbTimepickerModule,
      providers: [{
        provide: NB_TIME_PICKER_CONFIG,
        useValue: config
      }]
    };
  }
  static forChild(config = {}) {
    return {
      ngModule: _NbTimepickerModule,
      providers: [{
        provide: NB_TIME_PICKER_CONFIG,
        useValue: config
      }]
    };
  }
};
_NbTimepickerModule.\u0275fac = function NbTimepickerModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbTimepickerModule)();
};
_NbTimepickerModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbTimepickerModule,
  declarations: [NbTimePickerComponent, NbTimePickerCellComponent, NbTimePickerDirective],
  imports: [CommonModule, NbOverlayModule, NbListModule, NbCardModule, NbCalendarKitModule],
  exports: [NbTimePickerComponent, NbTimePickerCellComponent, NbTimePickerDirective]
});
_NbTimepickerModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [NbCalendarTimeModelService],
  imports: [CommonModule, NbOverlayModule, NbListModule, NbCardModule, NbCalendarKitModule]
});
var NbTimepickerModule = _NbTimepickerModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTimepickerModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NbOverlayModule, NbListModule, NbCardModule, NbCalendarKitModule],
      providers: [NbCalendarTimeModelService],
      exports: [NbTimePickerComponent, NbTimePickerCellComponent, NbTimePickerDirective],
      declarations: [NbTimePickerComponent, NbTimePickerCellComponent, NbTimePickerDirective]
    }]
  }], null, null);
})();
var _NbDateAdapterService = class _NbDateAdapterService extends NbDatepickerAdapter {
  constructor(dateService) {
    super();
    this.dateService = dateService;
    this.picker = NbDatepickerComponent;
  }
  parse(date, format) {
    return this.dateService.parse(date, format);
  }
  format(date, format) {
    return this.dateService.format(date, format);
  }
  isValid(date, format) {
    return this.dateService.isValidDateString(date, format);
  }
};
_NbDateAdapterService.\u0275fac = function NbDateAdapterService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbDateAdapterService)(\u0275\u0275inject(NbDateService));
};
_NbDateAdapterService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbDateAdapterService,
  factory: _NbDateAdapterService.\u0275fac
});
var NbDateAdapterService = _NbDateAdapterService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDateAdapterService, [{
    type: Injectable
  }], () => [{
    type: NbDateService
  }], null);
})();
var _NbRangeAdapterService = class _NbRangeAdapterService extends NbDatepickerAdapter {
  constructor(dateService) {
    super();
    this.dateService = dateService;
    this.picker = NbRangepickerComponent;
  }
  parse(range2, format) {
    const [start, end] = range2.split("-").map((subDate) => subDate.trim());
    return {
      start: this.dateService.parse(start, format),
      end: this.dateService.parse(end, format)
    };
  }
  format(range2, format) {
    if (!range2) {
      return "";
    }
    const start = this.dateService.format(range2.start, format);
    const isStartValid = this.dateService.isValidDateString(start, format);
    if (!isStartValid) {
      return "";
    }
    const end = this.dateService.format(range2.end, format);
    const isEndValid = this.dateService.isValidDateString(end, format);
    if (isEndValid) {
      return `${start} - ${end}`;
    } else {
      return start;
    }
  }
  isValid(range2, format) {
    const [start, end] = range2.split("-").map((subDate) => subDate.trim());
    return this.dateService.isValidDateString(start, format) && this.dateService.isValidDateString(end, format);
  }
};
_NbRangeAdapterService.\u0275fac = function NbRangeAdapterService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbRangeAdapterService)(\u0275\u0275inject(NbDateService));
};
_NbRangeAdapterService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbRangeAdapterService,
  factory: _NbRangeAdapterService.\u0275fac
});
var NbRangeAdapterService = _NbRangeAdapterService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRangeAdapterService, [{
    type: Injectable
  }], () => [{
    type: NbDateService
  }], null);
})();
var _NbDateTimeAdapterService = class _NbDateTimeAdapterService extends NbDatepickerAdapter {
  constructor(dateService) {
    super();
    this.dateService = dateService;
    this.picker = NbDateTimePickerComponent;
  }
  parse(date, format) {
    return this.dateService.parse(date, format);
  }
  format(date, format) {
    return this.dateService.format(date, format);
  }
  isValid(date, format) {
    return this.dateService.isValidDateString(date, format);
  }
};
_NbDateTimeAdapterService.\u0275fac = function NbDateTimeAdapterService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbDateTimeAdapterService)(\u0275\u0275inject(NbDateService));
};
_NbDateTimeAdapterService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbDateTimeAdapterService,
  factory: _NbDateTimeAdapterService.\u0275fac
});
var NbDateTimeAdapterService = _NbDateTimeAdapterService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDateTimeAdapterService, [{
    type: Injectable
  }], () => [{
    type: NbDateService
  }], null);
})();
var _NbDatepickerModule = class _NbDatepickerModule {
  static forRoot() {
    return {
      ngModule: _NbDatepickerModule,
      providers: [DatePipe, {
        provide: NB_DATE_ADAPTER,
        multi: true,
        useClass: NbDateAdapterService
      }, {
        provide: NB_DATE_ADAPTER,
        multi: true,
        useClass: NbRangeAdapterService
      }, {
        provide: NB_DATE_ADAPTER,
        multi: true,
        useClass: NbDateTimeAdapterService
      }]
    };
  }
};
_NbDatepickerModule.\u0275fac = function NbDatepickerModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbDatepickerModule)();
};
_NbDatepickerModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbDatepickerModule,
  declarations: [NbDatepickerDirective, NbDatepickerContainerComponent, NbCalendarWithTimeComponent, NbDateTimePickerComponent, NbDatepickerComponent, NbRangepickerComponent, NbBasePickerComponent],
  imports: [NbOverlayModule, NbCalendarModule, NbCalendarRangeModule, NbCardModule, NbBaseCalendarModule, NbTimepickerModule, NbCalendarKitModule],
  exports: [NbDatepickerDirective, NbDatepickerComponent, NbRangepickerComponent, NbDateTimePickerComponent, NbCalendarWithTimeComponent]
});
_NbDatepickerModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NbOverlayModule, NbCalendarModule, NbCalendarRangeModule, NbCardModule, NbBaseCalendarModule, NbTimepickerModule, NbCalendarKitModule]
});
var NbDatepickerModule = _NbDatepickerModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDatepickerModule, [{
    type: NgModule,
    args: [{
      imports: [NbOverlayModule, NbCalendarModule, NbCalendarRangeModule, NbCardModule, NbBaseCalendarModule, NbTimepickerModule, NbCalendarKitModule],
      exports: [NbDatepickerDirective, NbDatepickerComponent, NbRangepickerComponent, NbDateTimePickerComponent, NbCalendarWithTimeComponent],
      declarations: [NbDatepickerDirective, NbDatepickerContainerComponent, NbCalendarWithTimeComponent, NbDateTimePickerComponent, NbDatepickerComponent, NbRangepickerComponent, NbBasePickerComponent]
    }]
  }], null, null);
})();
var _NbRadioComponent = class _NbRadioComponent {
  get name() {
    return this._name;
  }
  set name(value) {
    if (this._name !== value) {
      this._name = value;
    }
  }
  get checked() {
    return this._checked;
  }
  set checked(value) {
    const boolValue = convertToBoolProperty(value);
    if (this._checked !== boolValue) {
      this._checked = boolValue;
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    if (this._value !== value) {
      this._value = value;
    }
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(disabled) {
    const boolValue = convertToBoolProperty(disabled);
    if (this._disabled !== boolValue) {
      this._disabled = boolValue;
    }
  }
  constructor(cd, renderer, statusService) {
    this.cd = cd;
    this.renderer = renderer;
    this.statusService = statusService;
    this._checked = false;
    this._disabled = false;
    this.status = "basic";
    this.valueChange = new EventEmitter();
    this.blur = new EventEmitter();
  }
  get isPrimary() {
    return this.status === "primary";
  }
  get isSuccess() {
    return this.status === "success";
  }
  get isWarning() {
    return this.status === "warning";
  }
  get isDanger() {
    return this.status === "danger";
  }
  get isInfo() {
    return this.status === "info";
  }
  get isBasic() {
    return this.status === "basic";
  }
  get isControl() {
    return this.status === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  onChange(event) {
    event.stopPropagation();
    this.checked = true;
    this.valueChange.emit(this.value);
  }
  onClick(event) {
    event.stopPropagation();
  }
  /*
   * @docs-private
   * We use this method when setting radio inputs from radio group component.
   * Otherwise Angular won't detect changes in radio template as cached last rendered
   * value didn't updated.
   **/
  _markForCheck() {
    this.cd.markForCheck();
  }
  /*
   * @docs-private
   * Use this method when setting radio name from radio group component.
   * In case option 'name' isn't set on nb-radio component we need to set name
   * right away, so it won't overlap with options without names from other radio
   * groups. Otherwise they all would have same name and will be considered as
   * options from one group so only the last option will stay selected.
   **/
  _setName(name) {
    this.name = name;
    if (this.input) {
      this.renderer.setProperty(this.input.nativeElement, "name", name);
    }
  }
};
_NbRadioComponent.\u0275fac = function NbRadioComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbRadioComponent)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(NbStatusService));
};
_NbRadioComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbRadioComponent,
  selectors: [["nb-radio"]],
  viewQuery: function NbRadioComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c51, 5, ElementRef);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.input = _t.first);
    }
  },
  hostVars: 16,
  hostBindings: function NbRadioComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classMap(ctx.additionalClasses);
      \u0275\u0275classProp("status-primary", ctx.isPrimary)("status-success", ctx.isSuccess)("status-warning", ctx.isWarning)("status-danger", ctx.isDanger)("status-info", ctx.isInfo)("status-basic", ctx.isBasic)("status-control", ctx.isControl);
    }
  },
  inputs: {
    name: "name",
    checked: "checked",
    value: "value",
    disabled: "disabled",
    status: "status"
  },
  outputs: {
    valueChange: "valueChange",
    blur: "blur"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 7,
  vars: 4,
  consts: [["input", ""], ["type", "radio", 1, "native-input", "visually-hidden", 3, "change", "click", "name", "value", "checked", "disabled"], [1, "outer-circle"], [1, "inner-circle"], [1, "text"]],
  template: function NbRadioComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = \u0275\u0275getCurrentView();
      \u0275\u0275projectionDef();
      \u0275\u0275elementStart(0, "label")(1, "input", 1, 0);
      \u0275\u0275listener("change", function NbRadioComponent_Template_input_change_1_listener($event) {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.onChange($event));
      })("click", function NbRadioComponent_Template_input_click_1_listener($event) {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.onClick($event));
      });
      \u0275\u0275elementEnd();
      \u0275\u0275element(3, "span", 2)(4, "span", 3);
      \u0275\u0275elementStart(5, "span", 4);
      \u0275\u0275projection(6);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275advance();
      \u0275\u0275property("name", ctx.name)("value", ctx.value)("checked", ctx.checked)("disabled", ctx.disabled);
    }
  },
  styles: ["[_nghost-%COMP%]{display:block;position:relative}[_nghost-%COMP%]   label[_ngcontent-%COMP%]{display:inline-flex;margin:0;min-height:inherit;padding:.375rem 0;align-items:center}[dir=ltr]   [_nghost-%COMP%]   label[_ngcontent-%COMP%]{padding-right:1.5rem}[dir=rtl]   [_nghost-%COMP%]   label[_ngcontent-%COMP%]{padding-left:1.5rem}[_nghost-%COMP%]   .outer-circle[_ngcontent-%COMP%], [_nghost-%COMP%]   .inner-circle[_ngcontent-%COMP%]{border-radius:50%;position:absolute;top:50%;transform:translateY(-50%)}[dir=ltr]   [_nghost-%COMP%]   .outer-circle[_ngcontent-%COMP%], [dir=ltr]   [_nghost-%COMP%]   .inner-circle[_ngcontent-%COMP%]{left:0}[dir=rtl]   [_nghost-%COMP%]   .outer-circle[_ngcontent-%COMP%], [dir=rtl]   [_nghost-%COMP%]   .inner-circle[_ngcontent-%COMP%]{right:0}[_nghost-%COMP%]   .inner-circle[_ngcontent-%COMP%]{transform:translateY(-50%) scale(.6)}[dir=ltr]   [_nghost-%COMP%]   .text[_ngcontent-%COMP%]{padding-left:.5rem}[dir=rtl]   [_nghost-%COMP%]   .text[_ngcontent-%COMP%]{padding-right:.5rem}\n\n\n\n\n\n\n\n\n\n\n\n"],
  changeDetection: 0
});
var NbRadioComponent = _NbRadioComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRadioComponent, [{
    type: Component,
    args: [{
      selector: "nb-radio",
      template: `
    <label>
      <input
        #input
        type="radio"
        class="native-input visually-hidden"
        [name]="name"
        [value]="value"
        [checked]="checked"
        [disabled]="disabled"
        (change)="onChange($event)"
        (click)="onClick($event)">
      <span class="outer-circle"></span>
      <span class="inner-circle"></span>
      <span class="text">
        <ng-content></ng-content>
      </span>
    </label>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      styles: [":host{display:block;position:relative}:host label{display:inline-flex;margin:0;min-height:inherit;padding:.375rem 0;align-items:center}[dir=ltr] :host label{padding-right:1.5rem}[dir=rtl] :host label{padding-left:1.5rem}:host .outer-circle,:host .inner-circle{border-radius:50%;position:absolute;top:50%;transform:translateY(-50%)}[dir=ltr] :host .outer-circle,[dir=ltr] :host .inner-circle{left:0}[dir=rtl] :host .outer-circle,[dir=rtl] :host .inner-circle{right:0}:host .inner-circle{transform:translateY(-50%) scale(.6)}[dir=ltr] :host .text{padding-left:.5rem}[dir=rtl] :host .text{padding-right:.5rem}\n/*\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: Renderer2
  }, {
    type: NbStatusService
  }], {
    name: [{
      type: Input
    }],
    checked: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    blur: [{
      type: Output
    }],
    input: [{
      type: ViewChild,
      args: ["input", {
        read: ElementRef
      }]
    }],
    isPrimary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    isSuccess: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    isWarning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    isDanger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    isInfo: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    isBasic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    isControl: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var _NbRadioGroupComponent = class _NbRadioGroupComponent {
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.updateValues();
  }
  get name() {
    return this._name;
  }
  set name(name) {
    this._name = name;
    this.updateNames();
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(disabled) {
    this._disabled = convertToBoolProperty(disabled);
    this.updateDisabled();
  }
  /**
   * Radio buttons status.
   * Possible values are `primary` (default), `success`, `warning`, `danger`, `info`.
   */
  get status() {
    return this._status;
  }
  set status(value) {
    if (this._status !== value) {
      this._status = value;
      this.updateStatus();
    }
  }
  constructor(hostElement, platformId, document2) {
    this.hostElement = hostElement;
    this.platformId = platformId;
    this.document = document2;
    this.destroy$ = new Subject();
    this.onChange = (value) => {
    };
    this.onTouched = () => {
    };
    this._status = "basic";
    this.valueChange = new EventEmitter();
  }
  ngAfterContentInit() {
    this.updateNames();
    this.radios.changes.pipe(
      startWith(this.radios),
      // 'changes' emit during change detection run and we can't update
      // option properties right of since they already was initialized.
      // Instead we schedule microtask to update radios after change detection
      // run is finished and trigger one more change detection run.
      switchMap((radios) => from(Promise.resolve(radios))),
      takeUntil(this.destroy$)
    ).subscribe(() => this.updateAndSubscribeToRadios());
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  writeValue(value) {
    this.value = value;
  }
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  updateAndSubscribeToRadios() {
    this.updateValueFromCheckedOption();
    this.updateNames();
    this.updateValues();
    this.updateDisabled();
    this.updateStatus();
    this.subscribeOnRadiosValueChange();
    this.subscribeOnRadiosBlur();
  }
  updateNames() {
    if (this.radios) {
      this.radios.forEach((radio) => radio._setName(this.name));
    }
  }
  updateValues() {
    this.updateAndMarkForCheckRadios((radio) => radio.checked = radio.value === this.value);
  }
  updateDisabled() {
    if (typeof this.disabled !== "undefined") {
      this.updateAndMarkForCheckRadios((radio) => radio.disabled = this.disabled);
    }
  }
  subscribeOnRadiosValueChange() {
    if (!this.radios || !this.radios.length) {
      return;
    }
    merge(...this.radios.map((radio) => radio.valueChange)).pipe(takeUntil(merge(this.radios.changes, this.destroy$))).subscribe((value) => {
      this.writeValue(value);
      this.propagateValue(value);
    });
  }
  propagateValue(value) {
    this.valueChange.emit(value);
    this.onChange(value);
  }
  subscribeOnRadiosBlur() {
    const hasNoRadios = !this.radios || !this.radios.length;
    if (!isPlatformBrowser(this.platformId) || hasNoRadios) {
      return;
    }
    const hostElement = this.hostElement.nativeElement;
    fromEvent(hostElement, "focusin").pipe(filter((event) => hostElement.contains(event.target)), switchMap(() => merge(fromEvent(this.document, "focusin"), fromEvent(this.document, "click"))), filter((event) => !hostElement.contains(event.target)), takeUntil(merge(this.radios.changes, this.destroy$))).subscribe(() => this.onTouched());
  }
  updateStatus() {
    this.updateAndMarkForCheckRadios((radio) => radio.status = this.status);
  }
  updateAndMarkForCheckRadios(updateFn) {
    if (this.radios) {
      this.radios.forEach((radio) => {
        updateFn(radio);
        radio._markForCheck();
      });
    }
  }
  updateValueFromCheckedOption() {
    const checkedRadio = this.radios.find((radio) => radio.checked);
    const isValueMissing = this.value === void 0 || this.value === null;
    if (checkedRadio && isValueMissing && checkedRadio.value !== this.value) {
      this.value = checkedRadio.value;
    }
  }
};
_NbRadioGroupComponent.\u0275fac = function NbRadioGroupComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbRadioGroupComponent)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(PLATFORM_ID), \u0275\u0275directiveInject(NB_DOCUMENT));
};
_NbRadioGroupComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbRadioGroupComponent,
  selectors: [["nb-radio-group"]],
  contentQueries: function NbRadioGroupComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, NbRadioComponent, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.radios = _t);
    }
  },
  inputs: {
    value: "value",
    name: "name",
    disabled: "disabled",
    status: "status"
  },
  outputs: {
    valueChange: "valueChange"
  },
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => _NbRadioGroupComponent),
    multi: true
  }])],
  ngContentSelectors: _c53,
  decls: 1,
  vars: 0,
  template: function NbRadioGroupComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef(_c52);
      \u0275\u0275projection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbRadioGroupComponent = _NbRadioGroupComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRadioGroupComponent, [{
    type: Component,
    args: [{
      selector: "nb-radio-group",
      template: `
    <ng-content select="nb-radio"></ng-content>`,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NbRadioGroupComponent),
        multi: true
      }],
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }], {
    value: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    radios: [{
      type: ContentChildren,
      args: [NbRadioComponent, {
        descendants: true
      }]
    }],
    valueChange: [{
      type: Output
    }]
  });
})();
var _NbRadioModule = class _NbRadioModule {
};
_NbRadioModule.\u0275fac = function NbRadioModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbRadioModule)();
};
_NbRadioModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbRadioModule,
  declarations: [NbRadioComponent, NbRadioGroupComponent],
  exports: [NbRadioComponent, NbRadioGroupComponent]
});
_NbRadioModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var NbRadioModule = _NbRadioModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRadioModule, [{
    type: NgModule,
    args: [{
      imports: [],
      exports: [NbRadioComponent, NbRadioGroupComponent],
      declarations: [NbRadioComponent, NbRadioGroupComponent]
    }]
  }], null, null);
})();
var tagUniqueId = 0;
var _NbTagComponent = class _NbTagComponent {
  get destroy$() {
    return this._destroy$.asObservable();
  }
  get selected() {
    return this._selected;
  }
  set selected(value) {
    if (this.selected !== convertToBoolProperty(value)) {
      this._selected = !this.selected;
      this.selectedChange.emit({
        tag: this,
        selected: this.selected
      });
    }
  }
  /**
   * Controls whether the user can remove a tag or not.
   */
  get removable() {
    return this._removable;
  }
  set removable(value) {
    this._removable = convertToBoolProperty(value);
  }
  get filled() {
    return this.appearance === "filled";
  }
  set filled(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "filled";
    }
  }
  get outline() {
    return this.appearance === "outline";
  }
  set outline(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "outline";
    }
  }
  get basic() {
    return this.status === "basic";
  }
  get primary() {
    return this.status === "primary";
  }
  get success() {
    return this.status === "success";
  }
  get info() {
    return this.status === "info";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get control() {
    return this.status === "control";
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  _remove() {
    if (this.removable) {
      this.remove.emit(this);
    }
  }
  constructor(_hostElement, cd, renderer, zone, statusService) {
    this._hostElement = _hostElement;
    this.cd = cd;
    this.renderer = renderer;
    this.zone = zone;
    this.statusService = statusService;
    this._destroy$ = new Subject();
    this._selected = false;
    this._removable = false;
    this.appearance = "filled";
    this.status = "basic";
    this.size = "medium";
    this.role = "option";
    this.remove = new EventEmitter();
    this.selectedChange = new EventEmitter();
    this._isActive = false;
    this._id = `nb-tag-${tagUniqueId++}`;
  }
  ngAfterViewInit() {
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this._hostElement.nativeElement, "nb-transition");
    }));
  }
  ngOnDestroy() {
    this._destroy$.next(this);
  }
  _toggleSelection() {
    this.selected = !this.selected;
    this.cd.markForCheck();
  }
  setActiveStyles() {
    if (!this._isActive) {
      this._isActive = true;
      this.cd.markForCheck();
    }
  }
  setInactiveStyles() {
    if (this._isActive) {
      this._isActive = false;
      this.cd.markForCheck();
    }
  }
};
_NbTagComponent.\u0275fac = function NbTagComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbTagComponent)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(NbStatusService));
};
_NbTagComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbTagComponent,
  selectors: [["nb-tag"]],
  hostVars: 37,
  hostBindings: function NbTagComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("keydown.delete", function NbTagComponent_keydown_delete_HostBindingHandler() {
        return ctx._remove();
      })("keydown.backspace", function NbTagComponent_keydown_backspace_HostBindingHandler() {
        return ctx._remove();
      });
    }
    if (rf & 2) {
      \u0275\u0275attribute("aria-selected", ctx.selected)("role", ctx.role)("id", ctx._id);
      \u0275\u0275classMap(ctx.additionalClasses);
      \u0275\u0275classProp("selected", ctx.selected)("active", ctx._isActive)("appearance-filled", ctx.filled)("appearance-outline", ctx.outline)("status-basic", ctx.basic)("status-primary", ctx.primary)("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-control", ctx.control)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant);
    }
  },
  inputs: {
    text: "text",
    selected: "selected",
    removable: "removable",
    appearance: "appearance",
    status: "status",
    size: "size",
    role: "role"
  },
  outputs: {
    remove: "remove",
    selectedChange: "selectedChange"
  },
  exportAs: ["nbTag"],
  standalone: false,
  decls: 2,
  vars: 2,
  consts: [["icon", "close-outline", "pack", "nebular-essentials", "aria-hidden", "true", 3, "class", "click", 4, "ngIf"], ["icon", "close-outline", "pack", "nebular-essentials", "aria-hidden", "true", 3, "click"]],
  template: function NbTagComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275text(0);
      \u0275\u0275template(1, NbTagComponent_nb_icon_1_Template, 1, 3, "nb-icon", 0);
    }
    if (rf & 2) {
      \u0275\u0275textInterpolate1("", ctx.text, "\n");
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.removable);
    }
  },
  dependencies: [NgIf, NbIconComponent],
  encapsulation: 2,
  changeDetection: 0
});
var NbTagComponent = _NbTagComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTagComponent, [{
    type: Component,
    args: [{
      selector: "nb-tag",
      exportAs: "nbTag",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: '{{ text }}\n<nb-icon *ngIf="removable"\n         (click)="_remove()"\n         class="nb-tag-remove size-{{size}}"\n         icon="close-outline"\n         pack="nebular-essentials"\n         aria-hidden="true">\n</nb-icon>\n'
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }], {
    text: [{
      type: Input
    }],
    selected: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.selected"]
    }, {
      type: HostBinding,
      args: ["attr.aria-selected"]
    }],
    removable: [{
      type: Input
    }],
    appearance: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    role: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.role"]
    }],
    remove: [{
      type: Output
    }],
    selectedChange: [{
      type: Output
    }],
    _isActive: [{
      type: HostBinding,
      args: ["class.active"]
    }],
    _id: [{
      type: HostBinding,
      args: ["attr.id"]
    }],
    filled: [{
      type: HostBinding,
      args: ["class.appearance-filled"]
    }],
    outline: [{
      type: HostBinding,
      args: ["class.appearance-outline"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    _remove: [{
      type: HostListener,
      args: ["keydown.delete"]
    }, {
      type: HostListener,
      args: ["keydown.backspace"]
    }]
  });
})();
var _NbTagInputDirective = class _NbTagInputDirective extends NbInputDirective {
  get _value() {
    return this._hostElement.nativeElement.value;
  }
  _onKeydown(event) {
    this.keyDown$.next(event);
  }
  constructor(_hostElement, focusMonitor, renderer, zone, statusService) {
    super(_hostElement, focusMonitor, renderer, zone, statusService);
    this._hostElement = _hostElement;
    this.focusMonitor = focusMonitor;
    this.renderer = renderer;
    this.zone = zone;
    this.statusService = statusService;
    this.keyDown$ = new Subject();
    this.separatorKeys = [ENTER];
    this.tagAdd = new EventEmitter();
    this.nbTagInputClass = true;
  }
  ngAfterViewInit() {
    super.ngAfterViewInit();
    this.keyDown$.pipe(filter(({
      keyCode
    }) => this.isSeparatorKey(keyCode)), map(() => this._value), takeUntil(this.destroy$)).subscribe((value) => this.tagAdd.emit({
      value,
      input: this._hostElement
    }));
  }
  isSeparatorKey(keyCode) {
    return this.separatorKeys.includes(keyCode);
  }
};
_NbTagInputDirective.\u0275fac = function NbTagInputDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbTagInputDirective)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NbFocusMonitor), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(NbStatusService));
};
_NbTagInputDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbTagInputDirective,
  selectors: [["input", "nbTagInput", ""]],
  hostVars: 2,
  hostBindings: function NbTagInputDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("keydown", function NbTagInputDirective_keydown_HostBindingHandler($event) {
        return ctx._onKeydown($event);
      });
    }
    if (rf & 2) {
      \u0275\u0275classProp("nb-tag-input", ctx.nbTagInputClass);
    }
  },
  inputs: {
    separatorKeys: "separatorKeys"
  },
  outputs: {
    tagAdd: "tagAdd"
  },
  exportAs: ["nbTagInput"],
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NbFormFieldControl,
    useExisting: _NbTagInputDirective
  }]), \u0275\u0275InheritDefinitionFeature]
});
var NbTagInputDirective = _NbTagInputDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTagInputDirective, [{
    type: Directive,
    args: [{
      selector: "input[nbTagInput]",
      exportAs: "nbTagInput",
      providers: [{
        provide: NbFormFieldControl,
        useExisting: NbTagInputDirective
      }],
      standalone: false
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NbFocusMonitor
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }], {
    separatorKeys: [{
      type: Input
    }],
    tagAdd: [{
      type: Output
    }],
    nbTagInputClass: [{
      type: HostBinding,
      args: ["class.nb-tag-input"]
    }],
    _onKeydown: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }]
  });
})();
var _NbTagListComponent = class _NbTagListComponent {
  get multiple() {
    return this._multiple;
  }
  set multiple(value) {
    this._multiple = convertToBoolProperty(value);
  }
  get _hasInput() {
    return !!this.tagInput;
  }
  get _isFocused() {
    return this.focused;
  }
  get _isFullWidth() {
    return !!this.tagInput?.fullWidth;
  }
  get _inputClasses() {
    if (this._hasInput) {
      return [`shape-${this.tagInput.shape}`, `size-${this.tagInput.fieldSize}`, this.statusService.getStatusClass(this.tagInput.status)];
    }
    return [`size-${this.size}`];
  }
  _onKeydown(event) {
    this.keyDown$.next(event);
  }
  _onClick({
    target
  }) {
    const clickedTag = this.tags.find((tag) => tag._hostElement.nativeElement === target);
    if (clickedTag) {
      this.tagClick$.next(clickedTag);
    }
  }
  constructor(hostElement, cd, renderer, zone, focusMonitor, activeDescendantKeyManagerFactory, directionService, statusService) {
    this.hostElement = hostElement;
    this.cd = cd;
    this.renderer = renderer;
    this.zone = zone;
    this.focusMonitor = focusMonitor;
    this.activeDescendantKeyManagerFactory = activeDescendantKeyManagerFactory;
    this.directionService = directionService;
    this.statusService = statusService;
    this.destroy$ = new Subject();
    this.keyDown$ = new Subject();
    this.tagClick$ = new Subject();
    this.focused = false;
    this.size = "medium";
    this.tabIndex = 0;
    this.role = "listbox";
    this._multiple = false;
    this.activeTagId = null;
    this.tagRemove = new EventEmitter();
  }
  ngOnInit() {
    this.focusMonitor.monitor(this.hostElement, true).pipe(map((origin) => !!origin), finalize(() => this.focusMonitor.stopMonitoring(this.hostElement)), takeUntil(this.destroy$)).subscribe((isFocused) => this.onFocusChange(isFocused));
  }
  ngAfterContentInit() {
    this.initKeyManager();
    this.setAutocompleteCustomHost();
  }
  ngAfterViewInit() {
    this.listenToLayoutDirectionChange();
    this.listenListKeyDown();
    this.listenInputKeyDown();
    this.listenTagClick();
    this.listenTagRemove();
    this.listenTagDestroy();
    this.listenActiveTagChange();
    this.listenNoTags();
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this.hostElement.nativeElement, "nb-transition");
    }));
  }
  ngOnDestroy() {
    this.destroy$.next();
  }
  initKeyManager() {
    this.keyManager = this.activeDescendantKeyManagerFactory.create(this.tags).withHorizontalOrientation(this.directionService.getDirection()).withWrap();
  }
  listenToLayoutDirectionChange() {
    this.directionService.onDirectionChange().pipe(takeUntil(this.destroy$)).subscribe((direction) => this.keyManager.withHorizontalOrientation(direction));
  }
  listenListKeyDown() {
    const tagListKeyDown$ = this.keyDown$.pipe(filter(({
      target
    }) => target === this.hostElement.nativeElement));
    const activeTagKeyDown$ = tagListKeyDown$.pipe(filter(() => !!this.keyManager.activeItem));
    tagListKeyDown$.pipe(takeUntil(this.destroy$)).subscribe((event) => this.keyManager.onKeydown(event));
    activeTagKeyDown$.pipe(filter(({
      keyCode
    }) => keyCode === SPACE), takeUntil(this.destroy$)).subscribe((event) => {
      this.toggleTag(this.keyManager.activeItem);
      event.preventDefault();
    });
    activeTagKeyDown$.pipe(filter(({
      keyCode
    }) => this.isBackspaceOrDelete(keyCode)), map(() => this.keyManager.activeItem), takeUntil(this.destroy$)).subscribe((tagToRemove) => tagToRemove._remove());
  }
  listenInputKeyDown() {
    const inputKeyDown$ = this.keyDown$.pipe(filter(({
      target
    }) => target === this.tagInput?._hostElement.nativeElement));
    inputKeyDown$.pipe(filter(({
      keyCode
    }) => {
      return this.tagInput._value === "" && this.isBackspaceOrDelete(keyCode) && this.tags.length > 0;
    }), takeUntil(this.destroy$)).subscribe(() => {
      this.hostElement.nativeElement.focus();
      this.keyManager.setLastItemActive();
      this.cd.markForCheck();
    });
  }
  listenTagClick() {
    this.tagClick$.pipe(takeUntil(this.destroy$)).subscribe((clickedTag) => {
      this.toggleTag(clickedTag);
      this.keyManager.setActiveItem(clickedTag);
    });
  }
  listenTagRemove() {
    this.tags.changes.pipe(startWith(this.tags), switchMap((tags) => merge(...tags.map((tag) => tag.remove))), takeUntil(this.destroy$)).subscribe((tagToRemove) => this.tagRemove.emit(tagToRemove));
  }
  listenTagDestroy() {
    this.tags.changes.pipe(startWith(this.tags), switchMap((tags) => merge(...tags.map((tag) => tag.destroy$))), filter((destroyedTag) => destroyedTag === this.keyManager.activeItem), map((destroyedTag) => destroyedTag === this.tags.last), takeUntil(this.destroy$)).subscribe((isLastTagDestroyed) => {
      if (isLastTagDestroyed) {
        this.keyManager.setPreviousItemActive();
      } else {
        this.keyManager.setNextItemActive();
      }
    });
  }
  listenNoTags() {
    this.tags.changes.pipe(startWith(this.tags), filter((tags) => tags.length === 0), takeUntil(this.destroy$)).subscribe(() => this.focusInputIfActive());
  }
  listenActiveTagChange() {
    this.keyManager.change.pipe(map(() => this.keyManager.activeItem?._id), takeUntil(this.destroy$)).subscribe((activeTagId) => {
      this.activeTagId = activeTagId;
      this.cd.markForCheck();
    });
  }
  onFocusChange(isFocused) {
    this.focused = isFocused;
    this.cd.markForCheck();
    if (!isFocused || this.tagInput?.focused$.value) {
      this.keyManager?.setActiveItem(-1);
      return;
    }
    if (this.tags.length === 0 && this._hasInput) {
      this.focusInput();
    } else {
      this.keyManager.setFirstItemActive();
    }
  }
  isBackspaceOrDelete(keyCode) {
    return keyCode === BACKSPACE || keyCode === DELETE;
  }
  setAutocompleteCustomHost() {
    if (this.autocompleteDirective) {
      this.autocompleteDirective.customOverlayHost = this.hostElement;
    }
  }
  toggleTag(tagToToggle) {
    tagToToggle._toggleSelection();
    if (tagToToggle.selected && !this.multiple) {
      this.tags.forEach((tag) => {
        if (tag !== tagToToggle) {
          tag.selected = false;
        }
      });
    }
  }
  focusInput() {
    if (this._hasInput) {
      this.tagInput._hostElement.nativeElement.focus();
    }
  }
  focusInputIfActive() {
    if (this._isFocused) {
      this.focusInput();
    }
  }
};
_NbTagListComponent.\u0275fac = function NbTagListComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbTagListComponent)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(NbFocusMonitor), \u0275\u0275directiveInject(NbActiveDescendantKeyManagerFactoryService), \u0275\u0275directiveInject(NbLayoutDirectionService), \u0275\u0275directiveInject(NbStatusService));
};
_NbTagListComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbTagListComponent,
  selectors: [["nb-tag-list"]],
  contentQueries: function NbTagListComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, NbTagInputDirective, 5);
      \u0275\u0275contentQuery(dirIndex, NbAutocompleteDirective, 5);
      \u0275\u0275contentQuery(dirIndex, NbTagComponent, 4);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tagInput = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.autocompleteDirective = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tags = _t);
    }
  },
  hostVars: 12,
  hostBindings: function NbTagListComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("keydown", function NbTagListComponent_keydown_HostBindingHandler($event) {
        return ctx._onKeydown($event);
      })("click", function NbTagListComponent_click_HostBindingHandler($event) {
        return ctx._onClick($event);
      });
    }
    if (rf & 2) {
      \u0275\u0275attribute("tabindex", ctx.tabIndex)("role", ctx.role)("aria-multiselectable", ctx.multiple)("aria-activedescendant", ctx.activeTagId);
      \u0275\u0275classMap(ctx._inputClasses);
      \u0275\u0275classProp("nb-tag-list-with-input", ctx._hasInput)("focus", ctx._isFocused)("input-full-width", ctx._isFullWidth);
    }
  },
  inputs: {
    size: "size",
    tabIndex: "tabIndex",
    role: "role",
    multiple: "multiple"
  },
  outputs: {
    tagRemove: "tagRemove"
  },
  exportAs: ["nbTagList"],
  standalone: false,
  ngContentSelectors: _c55,
  decls: 2,
  vars: 0,
  consts: [[1, "nb-tag-list-tags-wrapper"]],
  template: function NbTagListComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef(_c54);
      \u0275\u0275elementStart(0, "div", 0);
      \u0275\u0275projection(1);
      \u0275\u0275elementEnd();
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbTagListComponent = _NbTagListComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTagListComponent, [{
    type: Component,
    args: [{
      selector: "nb-tag-list",
      template: `
    <div class="nb-tag-list-tags-wrapper">
      <ng-content select="nb-tag, input[nbTagInput]"></ng-content>
    </div>
  `,
      exportAs: "nbTagList",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: NbFocusMonitor
  }, {
    type: NbActiveDescendantKeyManagerFactoryService
  }, {
    type: NbLayoutDirectionService
  }, {
    type: NbStatusService
  }], {
    tags: [{
      type: ContentChildren,
      args: [NbTagComponent]
    }],
    tagInput: [{
      type: ContentChild,
      args: [NbTagInputDirective]
    }],
    autocompleteDirective: [{
      type: ContentChild,
      args: [NbAutocompleteDirective]
    }],
    size: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    role: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.role"]
    }],
    multiple: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.aria-multiselectable"]
    }],
    activeTagId: [{
      type: HostBinding,
      args: ["attr.aria-activedescendant"]
    }],
    tagRemove: [{
      type: Output
    }],
    _hasInput: [{
      type: HostBinding,
      args: ["class.nb-tag-list-with-input"]
    }],
    _isFocused: [{
      type: HostBinding,
      args: ["class.focus"]
    }],
    _isFullWidth: [{
      type: HostBinding,
      args: ["class.input-full-width"]
    }],
    _inputClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    _onKeydown: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }],
    _onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var _NbTagModule = class _NbTagModule {
};
_NbTagModule.\u0275fac = function NbTagModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbTagModule)();
};
_NbTagModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbTagModule,
  declarations: [NbTagComponent, NbTagListComponent, NbTagInputDirective],
  imports: [CommonModule, NbIconModule],
  exports: [NbTagComponent, NbTagListComponent, NbTagInputDirective]
});
_NbTagModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, NbIconModule]
});
var NbTagModule = _NbTagModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTagModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NbIconModule],
      declarations: [NbTagComponent, NbTagListComponent, NbTagInputDirective],
      exports: [NbTagComponent, NbTagListComponent, NbTagInputDirective]
    }]
  }], null, null);
})();
var NB_DEFAULT_ROW_LEVEL = 0;
var NbTreeGridPresentationNode = class {
  constructor(data, children, expanded, level) {
    this.data = data;
    this.children = children;
    this.expanded = expanded;
    this.level = level;
  }
  /**
   * True if row has child rows
   */
  hasChildren() {
    return !!this.children && !!this.children.length;
  }
};
var _NbTreeGridFilterService = class _NbTreeGridFilterService {
  filter(query2, data) {
    if (!query2) {
      return data;
    }
    return data.reduce((filtered, node) => {
      let filteredChildren;
      if (node.children) {
        filteredChildren = this.filter(query2, node.children);
        node.children = filteredChildren;
      }
      node.expanded = false;
      if (filteredChildren && filteredChildren.length) {
        node.expanded = true;
        filtered.push(node);
      } else if (this.filterPredicate(node.data, query2)) {
        filtered.push(node);
      }
      return filtered;
    }, []);
  }
  filterPredicate(data, searchQuery) {
    const preparedQuery = searchQuery.trim().toLocaleLowerCase();
    for (const val of Object.values(data)) {
      const preparedVal = `${val}`.trim().toLocaleLowerCase();
      if (preparedVal.includes(preparedQuery)) {
        return true;
      }
    }
    return false;
  }
};
_NbTreeGridFilterService.\u0275fac = function NbTreeGridFilterService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbTreeGridFilterService)();
};
_NbTreeGridFilterService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbTreeGridFilterService,
  factory: _NbTreeGridFilterService.\u0275fac
});
var NbTreeGridFilterService = _NbTreeGridFilterService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridFilterService, [{
    type: Injectable
  }], null, null);
})();
var NbSortDirection;
(function(NbSortDirection2) {
  NbSortDirection2["ASCENDING"] = "asc";
  NbSortDirection2["DESCENDING"] = "desc";
  NbSortDirection2["NONE"] = "";
})(NbSortDirection || (NbSortDirection = {}));
var sortDirections = [NbSortDirection.ASCENDING, NbSortDirection.DESCENDING, NbSortDirection.NONE];
var _NbSortDirective = class _NbSortDirective {
  constructor() {
    this.sort = new EventEmitter();
  }
  emitSort(sortRequest) {
    if (this.sortable && this.sortable.sort) {
      this.sortable.sort(sortRequest);
    }
    this.sort.emit(sortRequest);
  }
};
_NbSortDirective.\u0275fac = function NbSortDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbSortDirective)();
};
_NbSortDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbSortDirective,
  selectors: [["", "nbSort", ""]],
  inputs: {
    sortable: [0, "nbSort", "sortable"]
  },
  outputs: {
    sort: "sort"
  },
  standalone: false
});
var NbSortDirective = _NbSortDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSortDirective, [{
    type: Directive,
    args: [{
      selector: "[nbSort]",
      standalone: false
    }]
  }], null, {
    sortable: [{
      type: Input,
      args: ["nbSort"]
    }],
    sort: [{
      type: Output
    }]
  });
})();
var _NbSortHeaderIconDirective = class _NbSortHeaderIconDirective {
};
_NbSortHeaderIconDirective.\u0275fac = function NbSortHeaderIconDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbSortHeaderIconDirective)();
};
_NbSortHeaderIconDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbSortHeaderIconDirective,
  selectors: [["", "nbSortHeaderIcon", ""]],
  standalone: false
});
var NbSortHeaderIconDirective = _NbSortHeaderIconDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSortHeaderIconDirective, [{
    type: Directive,
    args: [{
      selector: "[nbSortHeaderIcon]",
      standalone: false
    }]
  }], null, null);
})();
var _NbSortIconComponent = class _NbSortIconComponent {
  constructor() {
    this.direction = NbSortDirection.NONE;
  }
  isAscending() {
    return this.direction === NbSortDirection.ASCENDING;
  }
  isDescending() {
    return this.direction === NbSortDirection.DESCENDING;
  }
  isDirectionSet() {
    return this.isAscending() || this.isDescending();
  }
};
_NbSortIconComponent.\u0275fac = function NbSortIconComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbSortIconComponent)();
};
_NbSortIconComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbSortIconComponent,
  selectors: [["nb-sort-icon"]],
  inputs: {
    direction: "direction"
  },
  standalone: false,
  decls: 1,
  vars: 1,
  consts: [[4, "ngIf"], ["icon", "chevron-down-outline", "pack", "nebular-essentials", "aria-hidden", "true", 4, "ngIf"], ["icon", "chevron-up-outline", "pack", "nebular-essentials", "aria-hidden", "true", 4, "ngIf"], ["icon", "chevron-down-outline", "pack", "nebular-essentials", "aria-hidden", "true"], ["icon", "chevron-up-outline", "pack", "nebular-essentials", "aria-hidden", "true"]],
  template: function NbSortIconComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NbSortIconComponent_ng_container_0_Template, 3, 2, "ng-container", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.isDirectionSet());
    }
  },
  dependencies: [NgIf, NbIconComponent],
  encapsulation: 2
});
var NbSortIconComponent = _NbSortIconComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSortIconComponent, [{
    type: Component,
    args: [{
      selector: "nb-sort-icon",
      template: `
    <ng-container *ngIf="isDirectionSet()">
      <nb-icon *ngIf="isAscending()" icon="chevron-down-outline" pack="nebular-essentials" aria-hidden="true"></nb-icon>
      <nb-icon *ngIf="isDescending()" icon="chevron-up-outline" pack="nebular-essentials" aria-hidden="true"></nb-icon>
    </ng-container>
  `,
      standalone: false
    }]
  }], null, {
    direction: [{
      type: Input
    }]
  });
})();
var _NbSortHeaderComponent = class _NbSortHeaderComponent {
  /**
   * Disable sort header
   */
  set disabled(value) {
    this.disabledValue = convertToBoolProperty(value);
  }
  get disabled() {
    return this.disabledValue;
  }
  sortIfEnabled() {
    if (!this.disabled) {
      this.sortData();
    }
  }
  constructor(sort, columnDef) {
    this.sort = sort;
    this.columnDef = columnDef;
    this.disabledValue = false;
  }
  isAscending() {
    return this.direction === NbSortDirection.ASCENDING;
  }
  isDescending() {
    return this.direction === NbSortDirection.DESCENDING;
  }
  sortData() {
    const sortRequest = this.createSortRequest();
    this.sort.emitSort(sortRequest);
  }
  getIconContext() {
    return {
      $implicit: this.direction,
      isAscending: this.isAscending(),
      isDescending: this.isDescending(),
      isNone: !this.isAscending() && !this.isDescending()
    };
  }
  getDisabledAttributeValue() {
    return this.disabled ? "" : null;
  }
  createSortRequest() {
    this.direction = this.getNextDirection();
    return {
      direction: this.direction,
      column: this.columnDef.name
    };
  }
  getNextDirection() {
    const sortDirectionCycle = sortDirections;
    let nextDirectionIndex = sortDirectionCycle.indexOf(this.direction) + 1;
    if (nextDirectionIndex >= sortDirectionCycle.length) {
      nextDirectionIndex = 0;
    }
    return sortDirectionCycle[nextDirectionIndex];
  }
};
_NbSortHeaderComponent.\u0275fac = function NbSortHeaderComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbSortHeaderComponent)(\u0275\u0275directiveInject(NbSortDirective), \u0275\u0275directiveInject(NB_SORT_HEADER_COLUMN_DEF));
};
_NbSortHeaderComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbSortHeaderComponent,
  selectors: [["", "nbSortHeader", ""]],
  contentQueries: function NbSortHeaderComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, NbSortHeaderIconDirective, 5, TemplateRef);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.sortIcon = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function NbSortHeaderComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function NbSortHeaderComponent_click_HostBindingHandler() {
        return ctx.sortIfEnabled();
      });
    }
    if (rf & 2) {
      \u0275\u0275classProp("disabled", ctx.disabled);
    }
  },
  inputs: {
    direction: [0, "nbSortHeader", "direction"],
    disabled: "disabled"
  },
  standalone: false,
  attrs: _c56,
  ngContentSelectors: _c0,
  decls: 5,
  vars: 5,
  consts: [["customIcon", ""], ["type", "button", 1, "nb-tree-grid-header-change-sort-button", 3, "click"], [3, "direction", 4, "ngIf", "ngIfElse"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "direction"]],
  template: function NbSortHeaderComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = \u0275\u0275getCurrentView();
      \u0275\u0275projectionDef();
      \u0275\u0275elementStart(0, "button", 1);
      \u0275\u0275listener("click", function NbSortHeaderComponent_Template_button_click_0_listener() {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.sortData());
      });
      \u0275\u0275projection(1);
      \u0275\u0275elementEnd();
      \u0275\u0275template(2, NbSortHeaderComponent_nb_sort_icon_2_Template, 1, 1, "nb-sort-icon", 2)(3, NbSortHeaderComponent_ng_template_3_Template, 0, 0, "ng-template", 3, 0, \u0275\u0275templateRefExtractor);
    }
    if (rf & 2) {
      const customIcon_r3 = \u0275\u0275reference(4);
      \u0275\u0275attribute("disabled", ctx.getDisabledAttributeValue());
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", !ctx.sortIcon)("ngIfElse", customIcon_r3);
      \u0275\u0275advance();
      \u0275\u0275property("ngTemplateOutlet", ctx.sortIcon)("ngTemplateOutletContext", ctx.getIconContext());
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, NbSortIconComponent],
  encapsulation: 2
});
var NbSortHeaderComponent = _NbSortHeaderComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSortHeaderComponent, [{
    type: Component,
    args: [{
      selector: "[nbSortHeader]",
      template: `
    <button
      class="nb-tree-grid-header-change-sort-button"
      type="button"
      [attr.disabled]="getDisabledAttributeValue()"
      (click)="sortData()">
      <ng-content></ng-content>
    </button>
    <nb-sort-icon *ngIf="!sortIcon; else customIcon" [direction]="direction"></nb-sort-icon>
    <ng-template #customIcon [ngTemplateOutlet]="sortIcon" [ngTemplateOutletContext]="getIconContext()"></ng-template>
  `,
      standalone: false
    }]
  }], () => [{
    type: NbSortDirective
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_SORT_HEADER_COLUMN_DEF]
    }]
  }], {
    sortIcon: [{
      type: ContentChild,
      args: [NbSortHeaderIconDirective, {
        read: TemplateRef
      }]
    }],
    direction: [{
      type: Input,
      args: ["nbSortHeader"]
    }],
    disabled: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.disabled"]
    }],
    sortIfEnabled: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var _NbTreeGridSortService = class _NbTreeGridSortService {
  sort(request, data) {
    if (!request) {
      return data;
    }
    const sorted = data.sort((na, nb) => this.comparator(request, na, nb));
    for (const node of data) {
      if (node.children) {
        node.children = this.sort(request, node.children);
      }
    }
    return sorted;
  }
  comparator(request, na, nb) {
    const key = request.column;
    const dir = request.direction;
    const a = na.data[key];
    const b = nb.data[key];
    let res = 0;
    if (a > b) {
      res = 1;
    }
    if (a < b) {
      res = -1;
    }
    return dir === NbSortDirection.ASCENDING ? res : res * -1;
  }
};
_NbTreeGridSortService.\u0275fac = function NbTreeGridSortService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbTreeGridSortService)();
};
_NbTreeGridSortService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbTreeGridSortService,
  factory: _NbTreeGridSortService.\u0275fac
});
var NbTreeGridSortService = _NbTreeGridSortService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridSortService, [{
    type: Injectable
  }], null, null);
})();
var _NbTreeGridService = class _NbTreeGridService {
  expand(data, row, options = {}) {
    const node = this.find(data, row);
    node.expanded = true;
    if (options.deep && node.hasChildren()) {
      node.children.forEach((n) => this.expand(data, n.data, options));
    }
  }
  collapse(data, row, options = {}) {
    const node = this.find(data, row);
    node.expanded = false;
    if (options.deep && node.hasChildren()) {
      node.children.forEach((n) => this.collapse(data, n.data, options));
    }
  }
  toggle(data, row, options = {}) {
    const node = this.find(data, row);
    if (node.expanded) {
      this.collapse(data, row, options);
    } else {
      this.expand(data, row, options);
    }
  }
  find(data, row) {
    const toCheck = [...data];
    for (const node of toCheck) {
      if (node.data === row) {
        return node;
      }
      if (node.hasChildren()) {
        toCheck.push(...node.children);
      }
    }
    return void 0;
  }
};
_NbTreeGridService.\u0275fac = function NbTreeGridService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbTreeGridService)();
};
_NbTreeGridService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbTreeGridService,
  factory: _NbTreeGridService.\u0275fac
});
var NbTreeGridService = _NbTreeGridService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridService, [{
    type: Injectable
  }], null, null);
})();
var _NbTreeGridDataService = class _NbTreeGridDataService {
  constructor() {
    this.defaultGetters = {
      dataGetter: (node) => node.data,
      childrenGetter: (d) => d.children || void 0,
      expandedGetter: (d) => !!d.expanded
    };
  }
  toPresentationNodes(nodes, customGetters, level = NB_DEFAULT_ROW_LEVEL) {
    const getters = __spreadValues(__spreadValues({}, this.defaultGetters), customGetters);
    return this.mapNodes(nodes, getters, level);
  }
  mapNodes(nodes, getters, level) {
    const {
      dataGetter,
      childrenGetter,
      expandedGetter
    } = getters;
    return nodes.map((node) => {
      const childrenNodes = childrenGetter(node);
      let children;
      if (childrenNodes) {
        children = this.toPresentationNodes(childrenNodes, getters, level + 1);
      }
      return new NbTreeGridPresentationNode(dataGetter(node), children, expandedGetter(node), level);
    });
  }
  flattenExpanded(nodes) {
    return nodes.reduce((res, node) => {
      res.push(node);
      if (node.expanded && node.hasChildren()) {
        res.push(...this.flattenExpanded(node.children));
      }
      return res;
    }, []);
  }
  copy(nodes) {
    return nodes.map((node) => {
      let children;
      if (node.hasChildren()) {
        children = this.copy(node.children);
      }
      return new NbTreeGridPresentationNode(node.data, children, node.expanded, node.level);
    });
  }
};
_NbTreeGridDataService.\u0275fac = function NbTreeGridDataService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbTreeGridDataService)();
};
_NbTreeGridDataService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbTreeGridDataService,
  factory: _NbTreeGridDataService.\u0275fac
});
var NbTreeGridDataService = _NbTreeGridDataService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridDataService, [{
    type: Injectable
  }], null, null);
})();
var NbTreeGridDataSource = class extends NbDataSource {
  constructor(sortService, filterService, treeGridService, treeGridDataService) {
    super();
    this.sortService = sortService;
    this.filterService = filterService;
    this.treeGridService = treeGridService;
    this.treeGridDataService = treeGridDataService;
    this.renderData = new BehaviorSubject([]);
    this.filterRequest = new BehaviorSubject("");
    this.sortRequest = new BehaviorSubject(null);
  }
  setData(data, customGetters) {
    let presentationData = [];
    if (data) {
      presentationData = this.treeGridDataService.toPresentationNodes(data, customGetters);
    }
    this.data = new BehaviorSubject(presentationData);
    this.updateChangeSubscription();
  }
  connect(collectionViewer) {
    return this.renderData;
  }
  disconnect(collectionViewer) {
  }
  expand(row) {
    this.treeGridService.expand(this.data.value, row);
    this.data.next(this.data.value);
  }
  collapse(row) {
    this.treeGridService.collapse(this.data.value, row);
    this.data.next(this.data.value);
  }
  toggle(row, options) {
    this.treeGridService.toggle(this.data.value, row, options);
    this.data.next(this.data.value);
  }
  toggleByIndex(dataIndex, options) {
    const node = this.renderData.value && this.renderData.value[dataIndex];
    if (node) {
      this.toggle(node.data, options);
    }
  }
  getLevel(rowIndex) {
    const row = this.renderData.value[rowIndex];
    return row ? row.level : NB_DEFAULT_ROW_LEVEL;
  }
  sort(sortRequest) {
    this.sortRequest.next(sortRequest);
  }
  filter(searchQuery) {
    this.filterRequest.next(searchQuery);
  }
  updateChangeSubscription() {
    const dataStream = this.data;
    const filteredData = combineLatest([dataStream, this.filterRequest]).pipe(map(([data]) => this.treeGridDataService.copy(data)), map((data) => this.filterData(data)));
    const sortedData = combineLatest([filteredData, this.sortRequest]).pipe(map(([data]) => this.sortData(data)));
    sortedData.pipe(map((data) => this.treeGridDataService.flattenExpanded(data))).subscribe((data) => this.renderData.next(data));
  }
  filterData(data) {
    return this.filterService.filter(this.filterRequest.value, data);
  }
  sortData(data) {
    return this.sortService.sort(this.sortRequest.value, data);
  }
};
var _NbTreeGridDataSourceBuilder = class _NbTreeGridDataSourceBuilder {
  constructor(filterService, sortService, treeGridService, treeGridDataService) {
    this.filterService = filterService;
    this.sortService = sortService;
    this.treeGridService = treeGridService;
    this.treeGridDataService = treeGridDataService;
  }
  create(data, customGetters) {
    const dataSource = new NbTreeGridDataSource(this.sortService, this.filterService, this.treeGridService, this.treeGridDataService);
    dataSource.setData(data, customGetters);
    return dataSource;
  }
};
_NbTreeGridDataSourceBuilder.\u0275fac = function NbTreeGridDataSourceBuilder_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbTreeGridDataSourceBuilder)(\u0275\u0275inject(NbTreeGridFilterService), \u0275\u0275inject(NbTreeGridSortService), \u0275\u0275inject(NbTreeGridService), \u0275\u0275inject(NbTreeGridDataService));
};
_NbTreeGridDataSourceBuilder.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbTreeGridDataSourceBuilder,
  factory: _NbTreeGridDataSourceBuilder.\u0275fac
});
var NbTreeGridDataSourceBuilder = _NbTreeGridDataSourceBuilder;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridDataSourceBuilder, [{
    type: Injectable
  }], () => [{
    type: NbTreeGridFilterService
  }, {
    type: NbTreeGridSortService
  }, {
    type: NbTreeGridService
  }, {
    type: NbTreeGridDataService
  }], null);
})();
var NB_TREE_GRID = new InjectionToken("NB_TREE_GRID");
var _NbColumnsService = class _NbColumnsService {
  constructor(differs) {
    this.differs = differs;
    this.columnHide$ = new Subject();
    this.columnShow$ = new Subject();
  }
  setColumns(columns) {
    if (!this.changesDiffer) {
      this.changesDiffer = this.differs.find(columns || []).create();
    }
    if (this.changesDiffer.diff(columns)) {
      this.allColumns = Array.from(columns);
      this.visibleColumns = Array.from(columns);
    }
  }
  getVisibleColumns() {
    return this.visibleColumns;
  }
  hideColumn(column) {
    const toRemove = this.visibleColumns.indexOf(column);
    if (toRemove > -1) {
      this.visibleColumns.splice(toRemove, 1);
      this.columnHide$.next();
    }
  }
  showColumn(column) {
    if (this.visibleColumns.includes(column)) {
      return;
    }
    this.visibleColumns.splice(this.findInsertIndex(column), 0, column);
    this.columnShow$.next();
  }
  onColumnsChange() {
    return merge(this.columnShow$, this.columnHide$);
  }
  findInsertIndex(column) {
    const initialIndex = this.allColumns.indexOf(column);
    if (initialIndex === 0 || !this.visibleColumns.length) {
      return 0;
    }
    if (initialIndex === this.allColumns.length - 1) {
      return this.visibleColumns.length;
    }
    const leftSiblingIndex = initialIndex - 1;
    for (let i = leftSiblingIndex; i >= 0; i--) {
      const leftSibling = this.allColumns[i];
      const index = this.visibleColumns.indexOf(leftSibling);
      if (index !== -1) {
        return index + 1;
      }
    }
    const rightSiblingIndex = initialIndex + 1;
    for (let i = rightSiblingIndex; i < this.allColumns.length; i++) {
      const rightSibling = this.allColumns[i];
      const index = this.visibleColumns.indexOf(rightSibling);
      if (index !== -1) {
        return index;
      }
    }
    throw new Error(`Can't restore column position.`);
  }
};
_NbColumnsService.\u0275fac = function NbColumnsService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbColumnsService)(\u0275\u0275inject(IterableDiffers));
};
_NbColumnsService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NbColumnsService,
  factory: _NbColumnsService.\u0275fac
});
var NbColumnsService = _NbColumnsService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbColumnsService, [{
    type: Injectable
  }], () => [{
    type: IterableDiffers
  }], null);
})();
var _NbTreeGridComponent = class _NbTreeGridComponent extends NbTable {
  constructor(dataSourceBuilder, differs, changeDetectorRef, elementRef, role, dir, document2, platform, window2, _viewRepeater, _viewportRuler, _stickyPositioningListener) {
    super(differs, changeDetectorRef, elementRef, role, dir, document2, platform, _viewRepeater, _viewportRuler, _stickyPositioningListener);
    this.dataSourceBuilder = dataSourceBuilder;
    this.window = window2;
    this._viewRepeater = _viewRepeater;
    this._stickyPositioningListener = _stickyPositioningListener;
    this.destroy$ = new Subject();
    this.levelPadding = "";
    this.equalColumnsWidthValue = false;
    this.treeClass = true;
    this.platform = platform;
  }
  /**
   * The table's data
   * @param data
   * @type {<T>[] | NbTreeGridDataSource}
   */
  set source(data) {
    if (!data) {
      return;
    }
    if (data instanceof NbTreeGridDataSource) {
      this._source = data;
    } else {
      this._source = this.dataSourceBuilder.create(data);
    }
    this.dataSource = this._source;
  }
  /**
   * Make all columns equal width. False by default.
   */
  set equalColumnsWidth(value) {
    this.equalColumnsWidthValue = convertToBoolProperty(value);
  }
  get equalColumnsWidth() {
    return this.equalColumnsWidthValue;
  }
  ngAfterViewInit() {
    this.checkDefsCount();
    const rowsChange$ = merge(this._contentRowDefs.changes, this._contentHeaderRowDefs.changes, this._contentFooterRowDefs.changes);
    rowsChange$.pipe(takeUntil(this.destroy$)).subscribe(() => this.checkDefsCount());
    if (this.platform.isBrowser) {
      this.updateVisibleColumns();
      const windowResize$ = fromEvent(this.window, "resize").pipe(debounceTime(50));
      merge(rowsChange$, this._contentColumnDefs.changes, windowResize$).pipe(takeUntil(this.destroy$)).subscribe(() => this.updateVisibleColumns());
    }
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    this.destroy$.next();
    this.destroy$.complete();
  }
  toggleRow(row, options) {
    const context = this.getRowContext(row);
    this._source.toggle(context.$implicit.data, options);
  }
  toggleCellRow(cell) {
    const context = this.getCellContext(cell);
    this._source.toggle(context.$implicit.data);
  }
  getColumnWidth() {
    if (this.equalColumnsWidth) {
      return `${100 / this.getColumnsCount()}%`;
    }
    return "";
  }
  getCellLevel(cell, columnName) {
    if (this.isFirstColumn(columnName)) {
      return this.getCellContext(cell).$implicit.level;
    }
    return NB_DEFAULT_ROW_LEVEL;
  }
  getRowContext(row) {
    return this.getContextByRowEl(row.elementRef.nativeElement);
  }
  getCellContext(cell) {
    return this.getContextByCellEl(cell.elementRef.nativeElement);
  }
  getContextByCellEl(cellEl) {
    return this.getContextByRowEl(cellEl.parentElement);
  }
  getContextByRowEl(rowEl) {
    const rowsContainer = this._rowOutlet.viewContainer;
    for (let i = 0; i < rowsContainer.length; i++) {
      const rowViewRef = rowsContainer.get(i);
      if (rowViewRef.rootNodes.includes(rowEl)) {
        return rowViewRef.context;
      }
    }
    return void 0;
  }
  getColumns() {
    let rowDef;
    if (this._contentHeaderRowDefs.length) {
      rowDef = this._contentHeaderRowDefs.first;
    } else {
      rowDef = this._contentRowDefs.first;
    }
    return Array.from(rowDef.getVisibleColumns() || []);
  }
  getColumnsCount() {
    return this.getColumns().length;
  }
  isFirstColumn(columnName) {
    return this.getColumns()[0] === columnName;
  }
  checkDefsCount() {
    if (this._contentRowDefs.length > 1) {
      throw new Error(`Found multiple row definitions`);
    }
    if (this._contentHeaderRowDefs.length > 1) {
      throw new Error(`Found multiple header row definitions`);
    }
    if (this._contentFooterRowDefs.length > 1) {
      throw new Error(`Found multiple footer row definitions`);
    }
  }
  updateVisibleColumns() {
    const width = this.window.innerWidth;
    const columnDefs = this._contentColumnDefs;
    const columnsToHide = columnDefs.filter((col) => col.shouldHide(width)).map((col) => col.name);
    const columnsToShow = columnDefs.filter((col) => col.shouldShow(width)).map((col) => col.name);
    if (!columnsToHide.length && !columnsToShow.length) {
      return;
    }
    const rowDefs = [this._contentHeaderRowDefs.first, this._contentRowDefs.first, this._contentFooterRowDefs.first].filter((d) => !!d);
    for (const rowDef of rowDefs) {
      for (const column of columnsToHide) {
        rowDef.hideColumn(column);
      }
      for (const column of columnsToShow) {
        rowDef.showColumn(column);
      }
    }
  }
};
_NbTreeGridComponent.\u0275fac = function NbTreeGridComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbTreeGridComponent)(\u0275\u0275directiveInject(NbTreeGridDataSourceBuilder), \u0275\u0275directiveInject(IterableDiffers), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(ElementRef), \u0275\u0275injectAttribute("role"), \u0275\u0275directiveInject(NbDirectionality), \u0275\u0275directiveInject(NB_DOCUMENT), \u0275\u0275directiveInject(NbPlatform), \u0275\u0275directiveInject(NB_WINDOW), \u0275\u0275directiveInject(NB_VIEW_REPEATER_STRATEGY), \u0275\u0275directiveInject(NbViewportRulerAdapter), \u0275\u0275directiveInject(NB_STICKY_POSITIONING_LISTENER, 12));
};
_NbTreeGridComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbTreeGridComponent,
  selectors: [["table", "nbTreeGrid", ""]],
  hostVars: 2,
  hostBindings: function NbTreeGridComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("nb-tree-grid", ctx.treeClass);
    }
  },
  inputs: {
    source: [0, "nbTreeGrid", "source"],
    levelPadding: "levelPadding",
    equalColumnsWidth: "equalColumnsWidth"
  },
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NB_TREE_GRID,
    useExisting: _NbTreeGridComponent
  }, {
    provide: CDK_TABLE,
    useExisting: _NbTreeGridComponent
  }, NbColumnsService, ...NB_TABLE_PROVIDERS]), \u0275\u0275InheritDefinitionFeature],
  attrs: _c57,
  decls: 4,
  vars: 0,
  consts: [["nbHeaderRowOutlet", ""], ["nbRowOutlet", ""], ["nbNoDataRowOutlet", ""], ["nbFooterRowOutlet", ""]],
  template: function NbTreeGridComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementContainer(0, 0)(1, 1)(2, 2)(3, 3);
    }
  },
  dependencies: [NbDataRowOutletDirective, NbHeaderRowOutletDirective, NbFooterRowOutletDirective, NbNoDataRowOutletDirective],
  styles: ["[_nghost-%COMP%]{table-layout:fixed;border-spacing:0;border-collapse:collapse;width:100%;max-width:100%;overflow:auto}  .nb-tree-grid-cell,   .nb-tree-grid-header-cell,   .nb-tree-grid-footer-cell{overflow:hidden}\n\n\n\n\n\n"]
});
var NbTreeGridComponent = _NbTreeGridComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridComponent, [{
    type: Component,
    args: [{
      selector: "table[nbTreeGrid]",
      template: NB_TABLE_TEMPLATE,
      providers: [{
        provide: NB_TREE_GRID,
        useExisting: NbTreeGridComponent
      }, {
        provide: CDK_TABLE,
        useExisting: NbTreeGridComponent
      }, NbColumnsService, ...NB_TABLE_PROVIDERS],
      standalone: false,
      styles: [":host{table-layout:fixed;border-spacing:0;border-collapse:collapse;width:100%;max-width:100%;overflow:auto}::ng-deep .nb-tree-grid-cell,::ng-deep .nb-tree-grid-header-cell,::ng-deep .nb-tree-grid-footer-cell{overflow:hidden}\n/*\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: NbTreeGridDataSourceBuilder
  }, {
    type: IterableDiffers
  }, {
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Attribute,
      args: ["role"]
    }]
  }, {
    type: NbDirectionality
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: NbPlatform
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_WINDOW]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_VIEW_REPEATER_STRATEGY]
    }]
  }, {
    type: NbViewportRulerAdapter
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: SkipSelf
    }, {
      type: Inject,
      args: [NB_STICKY_POSITIONING_LISTENER]
    }]
  }], {
    source: [{
      type: Input,
      args: ["nbTreeGrid"]
    }],
    levelPadding: [{
      type: Input
    }],
    equalColumnsWidth: [{
      type: Input
    }],
    treeClass: [{
      type: HostBinding,
      args: ["class.nb-tree-grid"]
    }]
  });
})();
var _NbTreeGridRowDefDirective = class _NbTreeGridRowDefDirective extends NbRowDefDirective {
  constructor(template, differs, columnsService) {
    super(template, differs);
    this.columnsService = columnsService;
  }
  ngOnChanges(changes) {
    super.ngOnChanges(changes);
    if (changes["columns"]) {
      this.updateColumns(this.columns);
    }
  }
  updateColumns(columns) {
    this.columnsService.setColumns(columns);
  }
  getVisibleColumns() {
    return this.columnsService.getVisibleColumns();
  }
  /** @docs-private */
  hideColumn(column) {
    this.columnsService.hideColumn(column);
  }
  /** @docs-private */
  showColumn(column) {
    this.columnsService.showColumn(column);
  }
};
_NbTreeGridRowDefDirective.\u0275fac = function NbTreeGridRowDefDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbTreeGridRowDefDirective)(\u0275\u0275directiveInject(TemplateRef), \u0275\u0275directiveInject(IterableDiffers), \u0275\u0275directiveInject(NbColumnsService));
};
_NbTreeGridRowDefDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbTreeGridRowDefDirective,
  selectors: [["", "nbTreeGridRowDef", ""]],
  inputs: {
    columns: [0, "nbTreeGridRowDefColumns", "columns"]
  },
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NbCdkRowDef,
    useExisting: _NbTreeGridRowDefDirective
  }]), \u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature]
});
var NbTreeGridRowDefDirective = _NbTreeGridRowDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridRowDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTreeGridRowDef]",
      providers: [{
        provide: NbCdkRowDef,
        useExisting: NbTreeGridRowDefDirective
      }],
      standalone: false
    }]
  }], () => [{
    type: TemplateRef
  }, {
    type: IterableDiffers
  }, {
    type: NbColumnsService
  }], {
    columns: [{
      type: Input,
      args: ["nbTreeGridRowDefColumns"]
    }]
  });
})();
var _NbTreeGridHeaderRowDefDirective = class _NbTreeGridHeaderRowDefDirective extends NbHeaderRowDefDirective {
  constructor(template, differs, columnsService) {
    super(template, differs);
    this.columnsService = columnsService;
  }
  ngOnChanges(changes) {
    super.ngOnChanges(changes);
    if (changes["columns"]) {
      this.updateColumns(this.columns);
    }
  }
  updateColumns(columns) {
    this.columnsService.setColumns(columns);
  }
  getVisibleColumns() {
    return this.columnsService.getVisibleColumns();
  }
  /** @docs-private */
  hideColumn(column) {
    this.columnsService.hideColumn(column);
  }
  /** @docs-private */
  showColumn(column) {
    this.columnsService.showColumn(column);
  }
};
_NbTreeGridHeaderRowDefDirective.\u0275fac = function NbTreeGridHeaderRowDefDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbTreeGridHeaderRowDefDirective)(\u0275\u0275directiveInject(TemplateRef), \u0275\u0275directiveInject(IterableDiffers), \u0275\u0275directiveInject(NbColumnsService));
};
_NbTreeGridHeaderRowDefDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbTreeGridHeaderRowDefDirective,
  selectors: [["", "nbTreeGridHeaderRowDef", ""]],
  inputs: {
    columns: [0, "nbTreeGridHeaderRowDef", "columns"]
  },
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NbCdkHeaderRowDef,
    useExisting: _NbTreeGridHeaderRowDefDirective
  }]), \u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature]
});
var NbTreeGridHeaderRowDefDirective = _NbTreeGridHeaderRowDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridHeaderRowDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTreeGridHeaderRowDef]",
      providers: [{
        provide: NbCdkHeaderRowDef,
        useExisting: NbTreeGridHeaderRowDefDirective
      }],
      standalone: false
    }]
  }], () => [{
    type: TemplateRef
  }, {
    type: IterableDiffers
  }, {
    type: NbColumnsService
  }], {
    columns: [{
      type: Input,
      args: ["nbTreeGridHeaderRowDef"]
    }]
  });
})();
var _NbTreeGridFooterRowDefDirective = class _NbTreeGridFooterRowDefDirective extends NbFooterRowDefDirective {
  constructor(template, differs, columnsService) {
    super(template, differs);
    this.columnsService = columnsService;
  }
  ngOnChanges(changes) {
    super.ngOnChanges(changes);
    if (changes["columns"]) {
      this.updateColumns(this.columns);
    }
  }
  updateColumns(columns) {
    this.columnsService.setColumns(columns);
  }
  getVisibleColumns() {
    return this.columnsService.getVisibleColumns();
  }
  /** @docs-private */
  hideColumn(column) {
    this.columnsService.hideColumn(column);
  }
  /** @docs-private */
  showColumn(column) {
    this.columnsService.showColumn(column);
  }
};
_NbTreeGridFooterRowDefDirective.\u0275fac = function NbTreeGridFooterRowDefDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbTreeGridFooterRowDefDirective)(\u0275\u0275directiveInject(TemplateRef), \u0275\u0275directiveInject(IterableDiffers), \u0275\u0275directiveInject(NbColumnsService));
};
_NbTreeGridFooterRowDefDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbTreeGridFooterRowDefDirective,
  selectors: [["", "nbTreeGridFooterRowDef", ""]],
  inputs: {
    columns: [0, "nbTreeGridFooterRowDef", "columns"]
  },
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NbCdkFooterRowDef,
    useExisting: _NbTreeGridFooterRowDefDirective
  }]), \u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature]
});
var NbTreeGridFooterRowDefDirective = _NbTreeGridFooterRowDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridFooterRowDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTreeGridFooterRowDef]",
      providers: [{
        provide: NbCdkFooterRowDef,
        useExisting: NbTreeGridFooterRowDefDirective
      }],
      standalone: false
    }]
  }], () => [{
    type: TemplateRef
  }, {
    type: IterableDiffers
  }, {
    type: NbColumnsService
  }], {
    columns: [{
      type: Input,
      args: ["nbTreeGridFooterRowDef"]
    }]
  });
})();
var _NbTreeGridCellDefDirective = class _NbTreeGridCellDefDirective extends NbCellDefDirective {
};
_NbTreeGridCellDefDirective.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NbTreeGridCellDefDirective_BaseFactory;
  return function NbTreeGridCellDefDirective_Factory(__ngFactoryType__) {
    return (\u0275NbTreeGridCellDefDirective_BaseFactory || (\u0275NbTreeGridCellDefDirective_BaseFactory = \u0275\u0275getInheritedFactory(_NbTreeGridCellDefDirective)))(__ngFactoryType__ || _NbTreeGridCellDefDirective);
  };
})();
_NbTreeGridCellDefDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbTreeGridCellDefDirective,
  selectors: [["", "nbTreeGridCellDef", ""]],
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NbCdkCellDef,
    useExisting: _NbTreeGridCellDefDirective
  }]), \u0275\u0275InheritDefinitionFeature]
});
var NbTreeGridCellDefDirective = _NbTreeGridCellDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridCellDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTreeGridCellDef]",
      providers: [{
        provide: NbCdkCellDef,
        useExisting: NbTreeGridCellDefDirective
      }],
      standalone: false
    }]
  }], null, null);
})();
var _NbTreeGridHeaderCellDefDirective = class _NbTreeGridHeaderCellDefDirective extends NbHeaderCellDefDirective {
};
_NbTreeGridHeaderCellDefDirective.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NbTreeGridHeaderCellDefDirective_BaseFactory;
  return function NbTreeGridHeaderCellDefDirective_Factory(__ngFactoryType__) {
    return (\u0275NbTreeGridHeaderCellDefDirective_BaseFactory || (\u0275NbTreeGridHeaderCellDefDirective_BaseFactory = \u0275\u0275getInheritedFactory(_NbTreeGridHeaderCellDefDirective)))(__ngFactoryType__ || _NbTreeGridHeaderCellDefDirective);
  };
})();
_NbTreeGridHeaderCellDefDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbTreeGridHeaderCellDefDirective,
  selectors: [["", "nbTreeGridHeaderCellDef", ""]],
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NbCdkHeaderCellDef,
    useExisting: _NbTreeGridHeaderCellDefDirective
  }]), \u0275\u0275InheritDefinitionFeature]
});
var NbTreeGridHeaderCellDefDirective = _NbTreeGridHeaderCellDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridHeaderCellDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTreeGridHeaderCellDef]",
      providers: [{
        provide: NbCdkHeaderCellDef,
        useExisting: NbTreeGridHeaderCellDefDirective
      }],
      standalone: false
    }]
  }], null, null);
})();
var _NbTreeGridFooterCellDefDirective = class _NbTreeGridFooterCellDefDirective extends NbFooterCellDefDirective {
};
_NbTreeGridFooterCellDefDirective.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NbTreeGridFooterCellDefDirective_BaseFactory;
  return function NbTreeGridFooterCellDefDirective_Factory(__ngFactoryType__) {
    return (\u0275NbTreeGridFooterCellDefDirective_BaseFactory || (\u0275NbTreeGridFooterCellDefDirective_BaseFactory = \u0275\u0275getInheritedFactory(_NbTreeGridFooterCellDefDirective)))(__ngFactoryType__ || _NbTreeGridFooterCellDefDirective);
  };
})();
_NbTreeGridFooterCellDefDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbTreeGridFooterCellDefDirective,
  selectors: [["", "nbTreeGridFooterCellDef", ""]],
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NbCdkFooterCellDef,
    useExisting: _NbTreeGridFooterCellDefDirective
  }]), \u0275\u0275InheritDefinitionFeature]
});
var NbTreeGridFooterCellDefDirective = _NbTreeGridFooterCellDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridFooterCellDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTreeGridFooterCellDef]",
      providers: [{
        provide: NbCdkFooterCellDef,
        useExisting: NbTreeGridFooterCellDefDirective
      }],
      standalone: false
    }]
  }], null, null);
})();
var NB_ROW_DOUBLE_CLICK_DELAY = 200;
var _NbTreeGridRowComponent = class _NbTreeGridRowComponent extends NbRowComponent {
  toggleIfEnabledNode() {
    if (!this.clickToToggle) {
      return;
    }
    timer(NB_ROW_DOUBLE_CLICK_DELAY).pipe(take(1), takeUntil(this.doubleClick$)).subscribe(() => this.tree.toggleRow(this));
  }
  toggleIfEnabledNodeDeep() {
    if (!this.clickToToggle) {
      return;
    }
    this.doubleClick$.next();
    this.tree.toggleRow(this, {
      deep: true
    });
  }
  constructor(tree2, elementRef) {
    super();
    this.elementRef = elementRef;
    this.doubleClick$ = new Subject();
    this.doubleClickDelay = NB_ROW_DOUBLE_CLICK_DELAY;
    this.clickToToggle = true;
    this.tree = tree2;
  }
  ngOnDestroy() {
    this.doubleClick$.complete();
  }
};
_NbTreeGridRowComponent.\u0275fac = function NbTreeGridRowComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbTreeGridRowComponent)(\u0275\u0275directiveInject(NB_TREE_GRID), \u0275\u0275directiveInject(ElementRef));
};
_NbTreeGridRowComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbTreeGridRowComponent,
  selectors: [["tr", "nbTreeGridRow", ""]],
  hostAttrs: ["role", "row", 1, "nb-tree-grid-row"],
  hostBindings: function NbTreeGridRowComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function NbTreeGridRowComponent_click_HostBindingHandler() {
        return ctx.toggleIfEnabledNode();
      })("dblclick", function NbTreeGridRowComponent_dblclick_HostBindingHandler() {
        return ctx.toggleIfEnabledNodeDeep();
      });
    }
  },
  inputs: {
    doubleClickDelay: "doubleClickDelay",
    clickToToggle: "clickToToggle"
  },
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NbCdkRow,
    useExisting: _NbTreeGridRowComponent
  }]), \u0275\u0275InheritDefinitionFeature],
  attrs: _c58,
  decls: 1,
  vars: 0,
  consts: [["nbCellOutlet", ""]],
  template: function NbTreeGridRowComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementContainer(0, 0);
    }
  },
  dependencies: [NbCellOutletDirective],
  encapsulation: 2
});
var NbTreeGridRowComponent = _NbTreeGridRowComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridRowComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "tr[nbTreeGridRow]",
      template: `<ng-container nbCellOutlet></ng-container>`,
      // eslint-disable-next-line @angular-eslint/no-host-metadata-property
      host: {
        class: "nb-tree-grid-row",
        role: "row"
      },
      providers: [{
        provide: NbCdkRow,
        useExisting: NbTreeGridRowComponent
      }],
      standalone: false
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_TREE_GRID]
    }]
  }, {
    type: ElementRef
  }], {
    doubleClickDelay: [{
      type: Input
    }],
    clickToToggle: [{
      type: Input
    }],
    toggleIfEnabledNode: [{
      type: HostListener,
      args: ["click"]
    }],
    toggleIfEnabledNodeDeep: [{
      type: HostListener,
      args: ["dblclick"]
    }]
  });
})();
var _NbTreeGridHeaderRowComponent = class _NbTreeGridHeaderRowComponent extends NbHeaderRowComponent {
};
_NbTreeGridHeaderRowComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NbTreeGridHeaderRowComponent_BaseFactory;
  return function NbTreeGridHeaderRowComponent_Factory(__ngFactoryType__) {
    return (\u0275NbTreeGridHeaderRowComponent_BaseFactory || (\u0275NbTreeGridHeaderRowComponent_BaseFactory = \u0275\u0275getInheritedFactory(_NbTreeGridHeaderRowComponent)))(__ngFactoryType__ || _NbTreeGridHeaderRowComponent);
  };
})();
_NbTreeGridHeaderRowComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbTreeGridHeaderRowComponent,
  selectors: [["tr", "nbTreeGridHeaderRow", ""]],
  hostAttrs: ["role", "row", 1, "nb-tree-grid-header-row"],
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NbCdkHeaderRow,
    useExisting: _NbTreeGridHeaderRowComponent
  }]), \u0275\u0275InheritDefinitionFeature],
  attrs: _c59,
  decls: 1,
  vars: 0,
  consts: [["nbCellOutlet", ""]],
  template: function NbTreeGridHeaderRowComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementContainer(0, 0);
    }
  },
  dependencies: [NbCellOutletDirective],
  encapsulation: 2
});
var NbTreeGridHeaderRowComponent = _NbTreeGridHeaderRowComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridHeaderRowComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "tr[nbTreeGridHeaderRow]",
      template: ` <ng-container nbCellOutlet></ng-container>`,
      // eslint-disable-next-line @angular-eslint/no-host-metadata-property
      host: {
        class: "nb-tree-grid-header-row",
        role: "row"
      },
      providers: [{
        provide: NbCdkHeaderRow,
        useExisting: NbTreeGridHeaderRowComponent
      }],
      standalone: false
    }]
  }], null, null);
})();
var _NbTreeGridFooterRowComponent = class _NbTreeGridFooterRowComponent extends NbFooterRowComponent {
};
_NbTreeGridFooterRowComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NbTreeGridFooterRowComponent_BaseFactory;
  return function NbTreeGridFooterRowComponent_Factory(__ngFactoryType__) {
    return (\u0275NbTreeGridFooterRowComponent_BaseFactory || (\u0275NbTreeGridFooterRowComponent_BaseFactory = \u0275\u0275getInheritedFactory(_NbTreeGridFooterRowComponent)))(__ngFactoryType__ || _NbTreeGridFooterRowComponent);
  };
})();
_NbTreeGridFooterRowComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbTreeGridFooterRowComponent,
  selectors: [["tr", "nbTreeGridFooterRow", ""]],
  hostAttrs: ["role", "row", 1, "nb-tree-grid-footer-row"],
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NbCdkFooterRow,
    useExisting: _NbTreeGridFooterRowComponent
  }]), \u0275\u0275InheritDefinitionFeature],
  attrs: _c60,
  decls: 1,
  vars: 0,
  consts: [["nbCellOutlet", ""]],
  template: function NbTreeGridFooterRowComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementContainer(0, 0);
    }
  },
  dependencies: [NbCellOutletDirective],
  encapsulation: 2
});
var NbTreeGridFooterRowComponent = _NbTreeGridFooterRowComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridFooterRowComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "tr[nbTreeGridFooterRow]",
      template: ` <ng-container nbCellOutlet></ng-container>`,
      // eslint-disable-next-line @angular-eslint/no-host-metadata-property
      host: {
        class: "nb-tree-grid-footer-row",
        role: "row"
      },
      providers: [{
        provide: NbCdkFooterRow,
        useExisting: NbTreeGridFooterRowComponent
      }],
      standalone: false
    }]
  }], null, null);
})();
var _NbTreeGridColumnDefDirective = class _NbTreeGridColumnDefDirective extends NbColumnDefDirective {
  constructor() {
    super(...arguments);
    this.hideOnValue = null;
    this.showOnValue = null;
  }
  /**
   * Column name
   */
  get name() {
    return this._name;
  }
  set name(value) {
    this._setNameInput(value);
  }
  /**
   * Amount of pixels of viewport at which column should be hidden.
   * type number
   */
  get hideOn() {
    return this.hideOnValue;
  }
  set hideOn(value) {
    this.hideOnValue = !value && value !== 0 ? null : parseInt(value, 10);
  }
  /**
   * Amount of pixels of viewport at which column should be shown.
   * type number
   */
  get showOn() {
    return this.showOnValue;
  }
  set showOn(value) {
    this.showOnValue = !value && value !== 0 ? null : parseInt(value, 10);
  }
  ngOnChanges() {
    if (this.hideOn != null && this.showOn != null) {
      throw new Error(`hideOn and showOn are mutually exclusive and can't be used simultaneously.`);
    }
  }
  shouldHide(width) {
    return !this.shouldShow(width);
  }
  shouldShow(width) {
    if (this.hideOn == null && this.showOn == null) {
      return true;
    }
    if (this.hideOn != null) {
      return width > this.hideOn;
    }
    return width >= this.showOn;
  }
};
_NbTreeGridColumnDefDirective.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NbTreeGridColumnDefDirective_BaseFactory;
  return function NbTreeGridColumnDefDirective_Factory(__ngFactoryType__) {
    return (\u0275NbTreeGridColumnDefDirective_BaseFactory || (\u0275NbTreeGridColumnDefDirective_BaseFactory = \u0275\u0275getInheritedFactory(_NbTreeGridColumnDefDirective)))(__ngFactoryType__ || _NbTreeGridColumnDefDirective);
  };
})();
_NbTreeGridColumnDefDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbTreeGridColumnDefDirective,
  selectors: [["", "nbTreeGridColumnDef", ""]],
  inputs: {
    name: [0, "nbTreeGridColumnDef", "name"],
    hideOn: "hideOn",
    showOn: "showOn"
  },
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NbCdkColumnDef,
    useExisting: _NbTreeGridColumnDefDirective
  }, {
    provide: NB_SORT_HEADER_COLUMN_DEF,
    useExisting: _NbTreeGridColumnDefDirective
  }]), \u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature]
});
var NbTreeGridColumnDefDirective = _NbTreeGridColumnDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridColumnDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTreeGridColumnDef]",
      providers: [{
        provide: NbCdkColumnDef,
        useExisting: NbTreeGridColumnDefDirective
      }, {
        provide: NB_SORT_HEADER_COLUMN_DEF,
        useExisting: NbTreeGridColumnDefDirective
      }],
      standalone: false
    }]
  }], null, {
    name: [{
      type: Input,
      args: ["nbTreeGridColumnDef"]
    }],
    hideOn: [{
      type: Input
    }],
    showOn: [{
      type: Input
    }]
  });
})();
var _NbTreeGridCellDirective = class _NbTreeGridCellDirective extends NbCellDirective {
  get columnWidth() {
    this.latestWidth = this.tree.getColumnWidth();
    if (this.latestWidth) {
      return this.latestWidth;
    }
    return null;
  }
  get leftPadding() {
    if (this.directionService.isLtr()) {
      return this.getStartPadding();
    }
    return null;
  }
  get rightPadding() {
    if (this.directionService.isRtl()) {
      return this.getStartPadding();
    }
    return null;
  }
  constructor(columnDef, elementRef, tree2, platformId, window2, sanitizer, directionService, columnService, cd) {
    super(columnDef, elementRef);
    this.platformId = platformId;
    this.window = window2;
    this.sanitizer = sanitizer;
    this.directionService = directionService;
    this.columnService = columnService;
    this.cd = cd;
    this.destroy$ = new Subject();
    this.initialLeftPadding = "";
    this.initialRightPadding = "";
    this.tree = tree2;
    this.columnDef = columnDef;
    this.elementRef = elementRef;
  }
  ngOnInit() {
    if (isPlatformBrowser(this.platformId)) {
      const style2 = this.window.getComputedStyle(this.elementRef.nativeElement);
      this.initialLeftPadding = style2.paddingLeft;
      this.initialRightPadding = style2.paddingRight;
    }
    this.columnService.onColumnsChange().pipe(filter(() => this.latestWidth !== this.tree.getColumnWidth()), takeUntil(this.destroy$)).subscribe(() => this.cd.detectChanges());
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  toggleRow() {
    this.tree.toggleCellRow(this);
  }
  get initialStartPadding() {
    return this.directionService.isLtr() ? this.initialLeftPadding : this.initialRightPadding;
  }
  getStartPadding() {
    const rowLevel = this.tree.getCellLevel(this, this.columnDef.name);
    if (rowLevel === NB_DEFAULT_ROW_LEVEL) {
      return null;
    }
    const nestingLevel = rowLevel + 1;
    let padding = "";
    if (this.tree.levelPadding) {
      padding = `calc(${this.tree.levelPadding} * ${nestingLevel})`;
    } else if (this.initialStartPadding) {
      padding = `calc(${this.initialStartPadding} * ${nestingLevel})`;
    }
    if (!padding) {
      return null;
    }
    return this.sanitizer.bypassSecurityTrustStyle(padding);
  }
};
_NbTreeGridCellDirective.\u0275fac = function NbTreeGridCellDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbTreeGridCellDirective)(\u0275\u0275directiveInject(NbTreeGridColumnDefDirective), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NB_TREE_GRID), \u0275\u0275directiveInject(PLATFORM_ID), \u0275\u0275directiveInject(NB_WINDOW), \u0275\u0275directiveInject(DomSanitizer), \u0275\u0275directiveInject(NbLayoutDirectionService), \u0275\u0275directiveInject(NbColumnsService), \u0275\u0275directiveInject(ChangeDetectorRef));
};
_NbTreeGridCellDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbTreeGridCellDirective,
  selectors: [["td", "nbTreeGridCell", ""]],
  hostAttrs: ["role", "gridcell", 1, "nb-tree-grid-cell"],
  hostVars: 6,
  hostBindings: function NbTreeGridCellDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275styleProp("width", ctx.columnWidth)("padding-left", ctx.leftPadding)("padding-right", ctx.rightPadding);
    }
  },
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NbCdkCell,
    useExisting: _NbTreeGridCellDirective
  }]), \u0275\u0275InheritDefinitionFeature]
});
var NbTreeGridCellDirective = _NbTreeGridCellDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridCellDirective, [{
    type: Directive,
    args: [{
      selector: "td[nbTreeGridCell]",
      host: {
        "class": "nb-tree-grid-cell",
        "role": "gridcell"
      },
      providers: [{
        provide: NbCdkCell,
        useExisting: NbTreeGridCellDirective
      }],
      standalone: false
    }]
  }], () => [{
    type: NbTreeGridColumnDefDirective
  }, {
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_TREE_GRID]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_WINDOW]
    }]
  }, {
    type: DomSanitizer
  }, {
    type: NbLayoutDirectionService
  }, {
    type: NbColumnsService
  }, {
    type: ChangeDetectorRef
  }], {
    columnWidth: [{
      type: HostBinding,
      args: ["style.width"]
    }],
    leftPadding: [{
      type: HostBinding,
      args: ["style.padding-left"]
    }],
    rightPadding: [{
      type: HostBinding,
      args: ["style.padding-right"]
    }]
  });
})();
var _NbTreeGridHeaderCellDirective = class _NbTreeGridHeaderCellDirective extends NbHeaderCellDirective {
  get columnWidth() {
    this.latestWidth = this.tree.getColumnWidth();
    return this.latestWidth || null;
  }
  constructor(columnDef, elementRef, tree2, columnService, cd) {
    super(columnDef, elementRef);
    this.columnService = columnService;
    this.cd = cd;
    this.destroy$ = new Subject();
    this.tree = tree2;
  }
  ngOnInit() {
    this.columnService.onColumnsChange().pipe(filter(() => this.latestWidth !== this.tree.getColumnWidth()), takeUntil(this.destroy$)).subscribe(() => this.cd.detectChanges());
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
};
_NbTreeGridHeaderCellDirective.\u0275fac = function NbTreeGridHeaderCellDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbTreeGridHeaderCellDirective)(\u0275\u0275directiveInject(NbTreeGridColumnDefDirective), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NB_TREE_GRID), \u0275\u0275directiveInject(NbColumnsService), \u0275\u0275directiveInject(ChangeDetectorRef));
};
_NbTreeGridHeaderCellDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbTreeGridHeaderCellDirective,
  selectors: [["th", "nbTreeGridHeaderCell", ""]],
  hostAttrs: ["role", "columnheader", 1, "nb-tree-grid-header-cell"],
  hostVars: 2,
  hostBindings: function NbTreeGridHeaderCellDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275styleProp("width", ctx.columnWidth);
    }
  },
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NbCdkHeaderCell,
    useExisting: _NbTreeGridHeaderCellDirective
  }]), \u0275\u0275InheritDefinitionFeature]
});
var NbTreeGridHeaderCellDirective = _NbTreeGridHeaderCellDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridHeaderCellDirective, [{
    type: Directive,
    args: [{
      selector: "th[nbTreeGridHeaderCell]",
      host: {
        "class": "nb-tree-grid-header-cell",
        "role": "columnheader"
      },
      providers: [{
        provide: NbCdkHeaderCell,
        useExisting: NbTreeGridHeaderCellDirective
      }],
      standalone: false
    }]
  }], () => [{
    type: NbTreeGridColumnDefDirective
  }, {
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_TREE_GRID]
    }]
  }, {
    type: NbColumnsService
  }, {
    type: ChangeDetectorRef
  }], {
    columnWidth: [{
      type: HostBinding,
      args: ["style.width"]
    }]
  });
})();
var _NbTreeGridFooterCellDirective = class _NbTreeGridFooterCellDirective extends NbFooterCellDirective {
  get columnWidth() {
    this.latestWidth = this.tree.getColumnWidth();
    return this.latestWidth || null;
  }
  constructor(columnDef, elementRef, tree2, columnService, cd) {
    super(columnDef, elementRef);
    this.columnService = columnService;
    this.cd = cd;
    this.destroy$ = new Subject();
    this.tree = tree2;
  }
  ngOnInit() {
    this.columnService.onColumnsChange().pipe(filter(() => this.latestWidth !== this.tree.getColumnWidth()), takeUntil(this.destroy$)).subscribe(() => this.cd.detectChanges());
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
};
_NbTreeGridFooterCellDirective.\u0275fac = function NbTreeGridFooterCellDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbTreeGridFooterCellDirective)(\u0275\u0275directiveInject(NbTreeGridColumnDefDirective), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NB_TREE_GRID), \u0275\u0275directiveInject(NbColumnsService), \u0275\u0275directiveInject(ChangeDetectorRef));
};
_NbTreeGridFooterCellDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbTreeGridFooterCellDirective,
  selectors: [["td", "nbTreeGridFooterCell", ""]],
  hostAttrs: ["role", "gridcell", 1, "nb-tree-grid-footer-cell"],
  hostVars: 2,
  hostBindings: function NbTreeGridFooterCellDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275styleProp("width", ctx.columnWidth);
    }
  },
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NbCdkFooterCell,
    useExisting: _NbTreeGridFooterCellDirective
  }]), \u0275\u0275InheritDefinitionFeature]
});
var NbTreeGridFooterCellDirective = _NbTreeGridFooterCellDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridFooterCellDirective, [{
    type: Directive,
    args: [{
      selector: "td[nbTreeGridFooterCell]",
      host: {
        "class": "nb-tree-grid-footer-cell",
        "role": "gridcell"
      },
      providers: [{
        provide: NbCdkFooterCell,
        useExisting: NbTreeGridFooterCellDirective
      }],
      standalone: false
    }]
  }], () => [{
    type: NbTreeGridColumnDefDirective
  }, {
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_TREE_GRID]
    }]
  }, {
    type: NbColumnsService
  }, {
    type: ChangeDetectorRef
  }], {
    columnWidth: [{
      type: HostBinding,
      args: ["style.width"]
    }]
  });
})();
var _NbFilterDirective = class _NbFilterDirective {
  filter(filterRequest) {
    this.filterable.filter(filterRequest);
  }
};
_NbFilterDirective.\u0275fac = function NbFilterDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbFilterDirective)();
};
_NbFilterDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbFilterDirective,
  selectors: [["", "nbFilter", ""]],
  inputs: {
    filterable: [0, "nbFilter", "filterable"]
  },
  standalone: false
});
var NbFilterDirective = _NbFilterDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFilterDirective, [{
    type: Directive,
    args: [{
      selector: "[nbFilter]",
      standalone: false
    }]
  }], null, {
    filterable: [{
      type: Input,
      args: ["nbFilter"]
    }]
  });
})();
var _NbFilterInputDirective = class _NbFilterInputDirective extends NbFilterDirective {
  constructor() {
    super(...arguments);
    this.search$ = new Subject();
    this.destroy$ = new Subject();
    this.debounceTime = 200;
  }
  ngOnInit() {
    this.search$.pipe(debounceTime(this.debounceTime), takeUntil(this.destroy$)).subscribe((query2) => {
      super.filter(query2);
    });
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
    this.search$.complete();
  }
  filter(event) {
    this.search$.next(event.target.value);
  }
};
_NbFilterInputDirective.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NbFilterInputDirective_BaseFactory;
  return function NbFilterInputDirective_Factory(__ngFactoryType__) {
    return (\u0275NbFilterInputDirective_BaseFactory || (\u0275NbFilterInputDirective_BaseFactory = \u0275\u0275getInheritedFactory(_NbFilterInputDirective)))(__ngFactoryType__ || _NbFilterInputDirective);
  };
})();
_NbFilterInputDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbFilterInputDirective,
  selectors: [["", "nbFilterInput", ""]],
  hostBindings: function NbFilterInputDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("input", function NbFilterInputDirective_input_HostBindingHandler($event) {
        return ctx.filter($event);
      });
    }
  },
  inputs: {
    filterable: [0, "nbFilterInput", "filterable"],
    debounceTime: "debounceTime"
  },
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NbFilterDirective,
    useExisting: _NbFilterInputDirective
  }]), \u0275\u0275InheritDefinitionFeature]
});
var NbFilterInputDirective = _NbFilterInputDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFilterInputDirective, [{
    type: Directive,
    args: [{
      selector: "[nbFilterInput]",
      providers: [{
        provide: NbFilterDirective,
        useExisting: NbFilterInputDirective
      }],
      standalone: false
    }]
  }], null, {
    filterable: [{
      type: Input,
      args: ["nbFilterInput"]
    }],
    debounceTime: [{
      type: Input
    }],
    filter: [{
      type: HostListener,
      args: ["input", ["$event"]]
    }]
  });
})();
var _NbTreeGridRowToggleDirective = class _NbTreeGridRowToggleDirective {
  toggleRow($event) {
    this.cell.toggleRow();
    $event.stopPropagation();
  }
  constructor(cell) {
    this.cell = cell;
  }
};
_NbTreeGridRowToggleDirective.\u0275fac = function NbTreeGridRowToggleDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbTreeGridRowToggleDirective)(\u0275\u0275directiveInject(NbTreeGridCellDirective));
};
_NbTreeGridRowToggleDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NbTreeGridRowToggleDirective,
  selectors: [["", "nbTreeGridRowToggle", ""]],
  hostBindings: function NbTreeGridRowToggleDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function NbTreeGridRowToggleDirective_click_HostBindingHandler($event) {
        return ctx.toggleRow($event);
      });
    }
  },
  standalone: false
});
var NbTreeGridRowToggleDirective = _NbTreeGridRowToggleDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridRowToggleDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTreeGridRowToggle]",
      standalone: false
    }]
  }], () => [{
    type: NbTreeGridCellDirective
  }], {
    toggleRow: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var _NbTreeGridRowToggleComponent = class _NbTreeGridRowToggleComponent {
  set expanded(value) {
    this.expandedValue = value;
  }
  get expanded() {
    return this.expandedValue;
  }
  toggleRow($event) {
    this.cell.toggleRow();
    $event.stopPropagation();
  }
  constructor(cell) {
    this.cell = cell;
  }
};
_NbTreeGridRowToggleComponent.\u0275fac = function NbTreeGridRowToggleComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbTreeGridRowToggleComponent)(\u0275\u0275directiveInject(NbTreeGridCellDirective));
};
_NbTreeGridRowToggleComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbTreeGridRowToggleComponent,
  selectors: [["nb-tree-grid-row-toggle"]],
  hostBindings: function NbTreeGridRowToggleComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function NbTreeGridRowToggleComponent_click_HostBindingHandler($event) {
        return ctx.toggleRow($event);
      });
    }
  },
  inputs: {
    expanded: "expanded"
  },
  standalone: false,
  decls: 2,
  vars: 2,
  consts: [[1, "row-toggle-button"], ["pack", "nebular-essentials", "aria-hidden", "true", 3, "icon"]],
  template: function NbTreeGridRowToggleComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "button", 0);
      \u0275\u0275element(1, "nb-icon", 1);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275attribute("aria-label", ctx.expanded ? "collapse" : "expand");
      \u0275\u0275advance();
      \u0275\u0275property("icon", ctx.expanded ? "chevron-down-outline" : "chevron-right-outline");
    }
  },
  dependencies: [NbIconComponent],
  styles: ["button[_ngcontent-%COMP%]{background:transparent;border:none;padding:0}"]
});
var NbTreeGridRowToggleComponent = _NbTreeGridRowToggleComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridRowToggleComponent, [{
    type: Component,
    args: [{
      selector: "nb-tree-grid-row-toggle",
      template: `
    <button class="row-toggle-button" [attr.aria-label]="expanded ? 'collapse' : 'expand'">
      <nb-icon [icon]="expanded ? 'chevron-down-outline' : 'chevron-right-outline'"
               pack="nebular-essentials"
               aria-hidden="true">
      </nb-icon>
    </button>
  `,
      standalone: false,
      styles: ["button{background:transparent;border:none;padding:0}\n"]
    }]
  }], () => [{
    type: NbTreeGridCellDirective
  }], {
    expanded: [{
      type: Input
    }],
    toggleRow: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var COMPONENTS = [
  // Tree Grid
  NbTreeGridComponent,
  NbTreeGridRowDefDirective,
  NbTreeGridRowComponent,
  NbTreeGridCellDefDirective,
  NbTreeGridCellDirective,
  NbTreeGridHeaderRowDefDirective,
  NbTreeGridHeaderRowComponent,
  NbTreeGridHeaderCellDefDirective,
  NbTreeGridHeaderCellDirective,
  NbTreeGridFooterRowDefDirective,
  NbTreeGridFooterRowComponent,
  NbTreeGridFooterCellDefDirective,
  NbTreeGridFooterCellDirective,
  NbTreeGridColumnDefDirective,
  // Sort directives
  NbSortDirective,
  NbSortHeaderComponent,
  NbSortIconComponent,
  // Filter directives
  NbFilterDirective,
  NbFilterInputDirective,
  NbTreeGridRowToggleDirective,
  NbTreeGridRowToggleComponent,
  NbSortHeaderIconDirective
];
var _NbTreeGridModule = class _NbTreeGridModule {
};
_NbTreeGridModule.\u0275fac = function NbTreeGridModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbTreeGridModule)();
};
_NbTreeGridModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbTreeGridModule,
  declarations: [
    // Tree Grid
    NbTreeGridComponent,
    NbTreeGridRowDefDirective,
    NbTreeGridRowComponent,
    NbTreeGridCellDefDirective,
    NbTreeGridCellDirective,
    NbTreeGridHeaderRowDefDirective,
    NbTreeGridHeaderRowComponent,
    NbTreeGridHeaderCellDefDirective,
    NbTreeGridHeaderCellDirective,
    NbTreeGridFooterRowDefDirective,
    NbTreeGridFooterRowComponent,
    NbTreeGridFooterCellDefDirective,
    NbTreeGridFooterCellDirective,
    NbTreeGridColumnDefDirective,
    // Sort directives
    NbSortDirective,
    NbSortHeaderComponent,
    NbSortIconComponent,
    // Filter directives
    NbFilterDirective,
    NbFilterInputDirective,
    NbTreeGridRowToggleDirective,
    NbTreeGridRowToggleComponent,
    NbSortHeaderIconDirective
  ],
  imports: [CommonModule, NbTableModule, NbIconModule],
  exports: [
    NbTableModule,
    // Tree Grid
    NbTreeGridComponent,
    NbTreeGridRowDefDirective,
    NbTreeGridRowComponent,
    NbTreeGridCellDefDirective,
    NbTreeGridCellDirective,
    NbTreeGridHeaderRowDefDirective,
    NbTreeGridHeaderRowComponent,
    NbTreeGridHeaderCellDefDirective,
    NbTreeGridHeaderCellDirective,
    NbTreeGridFooterRowDefDirective,
    NbTreeGridFooterRowComponent,
    NbTreeGridFooterCellDefDirective,
    NbTreeGridFooterCellDirective,
    NbTreeGridColumnDefDirective,
    // Sort directives
    NbSortDirective,
    NbSortHeaderComponent,
    NbSortIconComponent,
    // Filter directives
    NbFilterDirective,
    NbFilterInputDirective,
    NbTreeGridRowToggleDirective,
    NbTreeGridRowToggleComponent,
    NbSortHeaderIconDirective
  ]
});
_NbTreeGridModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [NbTreeGridSortService, NbTreeGridFilterService, NbTreeGridService, NbTreeGridDataService, NbTreeGridDataSourceBuilder],
  imports: [CommonModule, NbTableModule, NbIconModule, NbTableModule]
});
var NbTreeGridModule = _NbTreeGridModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NbTableModule, NbIconModule],
      declarations: [...COMPONENTS],
      exports: [NbTableModule, ...COMPONENTS],
      providers: [NbTreeGridSortService, NbTreeGridFilterService, NbTreeGridService, NbTreeGridDataService, NbTreeGridDataSourceBuilder]
    }]
  }], null, null);
})();
var _NbToggleComponent = class _NbToggleComponent {
  /**
   * Toggle checked
   * @type {boolean}
   */
  get checked() {
    return this._checked;
  }
  set checked(value) {
    this._checked = convertToBoolProperty(value);
  }
  /**
   * Controls input disabled state
   */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = convertToBoolProperty(value);
  }
  get primary() {
    return this.status === "primary";
  }
  get success() {
    return this.status === "success";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get info() {
    return this.status === "info";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  get labelLeft() {
    return this.labelPosition === "left";
  }
  get labelRight() {
    return this.labelPosition === "right";
  }
  get labelStart() {
    return this.labelPosition === "start";
  }
  get labelEnd() {
    return this.labelPosition === "end";
  }
  constructor(changeDetector, layoutDirection, renderer, hostElement, zone, statusService) {
    this.changeDetector = changeDetector;
    this.layoutDirection = layoutDirection;
    this.renderer = renderer;
    this.hostElement = hostElement;
    this.zone = zone;
    this.statusService = statusService;
    this.onChange = () => {
    };
    this.onTouched = () => {
    };
    this.destroy$ = new Subject();
    this._checked = false;
    this._disabled = false;
    this.status = "basic";
    this.labelPosition = "end";
    this.checkedChange = new EventEmitter();
  }
  ngOnInit() {
    this.layoutDirection.onDirectionChange().pipe(takeUntil(this.destroy$)).subscribe(() => this.changeDetector.detectChanges());
  }
  ngAfterViewInit() {
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this.hostElement.nativeElement, "nb-transition");
    }));
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  checkState() {
    if (this.checked) {
      return this.layoutDirection.isLtr() ? "right" : "left";
    }
    return this.layoutDirection.isLtr() ? "left" : "right";
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  writeValue(val) {
    this.checked = val;
    this.changeDetector.markForCheck();
  }
  setDisabledState(val) {
    this.disabled = convertToBoolProperty(val);
    this.changeDetector.markForCheck();
  }
  updateValue(event) {
    const input2 = event.target;
    this.checked = input2.checked;
    this.checkedChange.emit(this.checked);
    this.onChange(this.checked);
  }
  onInputClick(event) {
    event.stopPropagation();
  }
};
_NbToggleComponent.\u0275fac = function NbToggleComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbToggleComponent)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NbLayoutDirectionService), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(NbStatusService));
};
_NbToggleComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NbToggleComponent,
  selectors: [["nb-toggle"]],
  hostVars: 24,
  hostBindings: function NbToggleComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classMap(ctx.additionalClasses);
      \u0275\u0275classProp("status-primary", ctx.primary)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-info", ctx.info)("status-basic", ctx.basic)("status-control", ctx.control)("toggle-label-left", ctx.labelLeft)("toggle-label-right", ctx.labelRight)("toggle-label-start", ctx.labelStart)("toggle-label-end", ctx.labelEnd);
    }
  },
  inputs: {
    checked: "checked",
    disabled: "disabled",
    status: "status",
    labelPosition: "labelPosition"
  },
  outputs: {
    checkedChange: "checkedChange"
  },
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => _NbToggleComponent),
    multi: true
  }])],
  ngContentSelectors: _c0,
  decls: 7,
  vars: 7,
  consts: [[1, "toggle-label"], ["type", "checkbox", "role", "switch", 1, "native-input", "visually-hidden", 3, "change", "blur", "click", "disabled", "checked"], [1, "toggle"], [1, "toggle-switcher"], ["icon", "checkmark-bold-outline", "pack", "nebular-essentials", 4, "ngIf"], [1, "text"], ["icon", "checkmark-bold-outline", "pack", "nebular-essentials"]],
  template: function NbToggleComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275elementStart(0, "label", 0)(1, "input", 1);
      \u0275\u0275listener("change", function NbToggleComponent_Template_input_change_1_listener($event) {
        return ctx.updateValue($event);
      })("blur", function NbToggleComponent_Template_input_blur_1_listener() {
        return ctx.onTouched();
      })("click", function NbToggleComponent_Template_input_click_1_listener($event) {
        return ctx.onInputClick($event);
      });
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(2, "div", 2)(3, "span", 3);
      \u0275\u0275template(4, NbToggleComponent_nb_icon_4_Template, 1, 0, "nb-icon", 4);
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(5, "span", 5);
      \u0275\u0275projection(6);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275advance();
      \u0275\u0275property("disabled", ctx.disabled)("checked", ctx.checked);
      \u0275\u0275attribute("aria-checked", ctx.checked);
      \u0275\u0275advance();
      \u0275\u0275classProp("checked", ctx.checked);
      \u0275\u0275advance();
      \u0275\u0275property("@position", ctx.checkState());
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.checked);
    }
  },
  dependencies: [NgIf, NbIconComponent],
  styles: ["[_nghost-%COMP%]{display:inline-flex;outline:none}.toggle-label-left[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){padding-right:.6875rem}[dir=ltr]   .toggle-label-left[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){order:-1}[dir=rtl]   .toggle-label-left[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){order:1}.toggle-label-right[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){padding-left:.6875rem}[dir=ltr]   .toggle-label-right[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){order:1}[dir=rtl]   .toggle-label-right[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){order:-1}.toggle-label-start[_nghost-%COMP%]   .toggle-label[_ngcontent-%COMP%]{flex-direction:row-reverse}[dir=ltr]   .toggle-label-start[_nghost-%COMP%]   .toggle-label[_ngcontent-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){padding-right:.6875rem}[dir=rtl]   .toggle-label-start[_nghost-%COMP%]   .toggle-label[_ngcontent-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){padding-left:.6875rem}[dir=ltr]   .toggle-label-end[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){padding-left:.6875rem}[dir=rtl]   .toggle-label-end[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){padding-right:.6875rem}.nb-transition[_nghost-%COMP%]   .toggle[_ngcontent-%COMP%]{transition-duration:.15s;transition-property:background-color,border,box-shadow;transition-timing-function:ease-in}.toggle-label[_ngcontent-%COMP%]{position:relative;display:inline-flex;align-items:center}.toggle[_ngcontent-%COMP%]{position:relative;display:inline-flex;box-sizing:content-box}.toggle-switcher[_ngcontent-%COMP%]{position:absolute;border-radius:50%;margin:1px}.toggle-switcher[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%)}\n\n\n\n\n\n"],
  data: {
    animation: [trigger("position", [state("right", style({
      right: 0,
      left: "*"
    })), state("left", style({
      left: 0,
      right: "*"
    })), transition(":enter", [animate(0)]), transition("right <=> left", [animate("0.15s")])])]
  },
  changeDetection: 0
});
var NbToggleComponent = _NbToggleComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbToggleComponent, [{
    type: Component,
    args: [{
      selector: "nb-toggle",
      animations: [trigger("position", [state("right", style({
        right: 0,
        left: "*"
      })), state("left", style({
        left: 0,
        right: "*"
      })), transition(":enter", [animate(0)]), transition("right <=> left", [animate("0.15s")])])],
      template: `
    <label class="toggle-label">
      <input type="checkbox"
             class="native-input visually-hidden"
             role="switch"
             [attr.aria-checked]="checked"
             [disabled]="disabled"
             [checked]="checked"
             (change)="updateValue($event)"
             (blur)="onTouched()"
             (click)="onInputClick($event)">
      <div class="toggle" [class.checked]="checked">
        <span [@position]="checkState()" class="toggle-switcher">
          <nb-icon *ngIf="checked" icon="checkmark-bold-outline" pack="nebular-essentials"></nb-icon>
        </span>
      </div>
      <span class="text">
        <ng-content></ng-content>
      </span>
    </label>
  `,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NbToggleComponent),
        multi: true
      }],
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      styles: [":host{display:inline-flex;outline:none}:host(.toggle-label-left) .text:not(:empty){padding-right:.6875rem}[dir=ltr] :host(.toggle-label-left) .text:not(:empty){order:-1}[dir=rtl] :host(.toggle-label-left) .text:not(:empty){order:1}:host(.toggle-label-right) .text:not(:empty){padding-left:.6875rem}[dir=ltr] :host(.toggle-label-right) .text:not(:empty){order:1}[dir=rtl] :host(.toggle-label-right) .text:not(:empty){order:-1}:host(.toggle-label-start) .toggle-label{flex-direction:row-reverse}[dir=ltr] :host(.toggle-label-start) .toggle-label .text:not(:empty){padding-right:.6875rem}[dir=rtl] :host(.toggle-label-start) .toggle-label .text:not(:empty){padding-left:.6875rem}[dir=ltr] :host(.toggle-label-end) .text:not(:empty){padding-left:.6875rem}[dir=rtl] :host(.toggle-label-end) .text:not(:empty){padding-right:.6875rem}:host(.nb-transition) .toggle{transition-duration:.15s;transition-property:background-color,border,box-shadow;transition-timing-function:ease-in}.toggle-label{position:relative;display:inline-flex;align-items:center}.toggle{position:relative;display:inline-flex;box-sizing:content-box}.toggle-switcher{position:absolute;border-radius:50%;margin:1px}.toggle-switcher nb-icon{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%)}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: NbLayoutDirectionService
  }, {
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }], {
    checked: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    labelPosition: [{
      type: Input
    }],
    checkedChange: [{
      type: Output
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    labelLeft: [{
      type: HostBinding,
      args: ["class.toggle-label-left"]
    }],
    labelRight: [{
      type: HostBinding,
      args: ["class.toggle-label-right"]
    }],
    labelStart: [{
      type: HostBinding,
      args: ["class.toggle-label-start"]
    }],
    labelEnd: [{
      type: HostBinding,
      args: ["class.toggle-label-end"]
    }]
  });
})();
var _NbToggleModule = class _NbToggleModule {
};
_NbToggleModule.\u0275fac = function NbToggleModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbToggleModule)();
};
_NbToggleModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbToggleModule,
  declarations: [NbToggleComponent],
  imports: [CommonModule, NbIconModule],
  exports: [NbToggleComponent]
});
_NbToggleModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, NbIconModule]
});
var NbToggleModule = _NbToggleModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbToggleModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NbIconModule],
      declarations: [NbToggleComponent],
      exports: [NbToggleComponent]
    }]
  }], null, null);
})();

// src/app/app.component.ts
var AppComponent = class _AppComponent {
  static \u0275fac = function AppComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AppComponent)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _AppComponent, selectors: [["app-root"]], decls: 3, vars: 0, template: function AppComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "nb-layout")(1, "nb-layout-column");
      \u0275\u0275element(2, "router-outlet");
      \u0275\u0275elementEnd()();
    }
  }, dependencies: [
    RouterOutlet,
    NbLayoutModule,
    NbLayoutComponent,
    NbLayoutColumnComponent
  ], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AppComponent, [{
    type: Component,
    args: [{ selector: "app-root", imports: [
      RouterOutlet,
      NbLayoutModule,
      MatCard,
      MatCardTitle,
      MatCardContent,
      MatFormField,
      MatLabel,
      MatInput,
      MatSelect,
      MatOption,
      MatButton
    ], standalone: true, template: "<!-- <router-outlet></router-outlet> -->\r\n <nb-layout>\r\n  <nb-layout-column>\r\n    <router-outlet></router-outlet>\r\n  </nb-layout-column>\r\n</nb-layout>\r\n" }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(AppComponent, { className: "AppComponent", filePath: "src/app/app.component.ts", lineNumber: 28 });
})();

// src/app/app.component.routes.ts
var routes = [
  {
    path: "",
    loadComponent: () => import("./chunk-JYGWB5R6.js").then((m) => m.HomeComponent)
  },
  // '' 表示預設路徑
  { path: "**", redirectTo: "" }
  // 其他路徑導回首頁
];
var AppRoutingModule = class _AppRoutingModule {
  static \u0275fac = function AppRoutingModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AppRoutingModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({ type: _AppRoutingModule });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({ imports: [RouterModule.forRoot(routes), RouterModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AppRoutingModule, [{
    type: NgModule,
    args: [{
      imports: [RouterModule.forRoot(routes)],
      exports: [RouterModule]
    }]
  }], null, null);
})();

// node_modules/@nebular/eva-icons/fesm2022/nebular-eva-icons.mjs
var import_eva_icons = __toESM(require_eva(), 1);
var NbEvaSvgIcon = class extends NbSvgIcon {
  constructor(name, content) {
    super(name, "");
    this.name = name;
    this.content = content;
  }
  getContent(options) {
    return this.content.toSvg(__spreadValues({
      width: "100%",
      height: "100%",
      fill: "currentColor"
    }, options));
  }
};
var _NbEvaIconsModule = class _NbEvaIconsModule {
  constructor(iconLibrary) {
    this.NAME = "eva";
    iconLibrary.registerSvgPack(this.NAME, this.createIcons());
    iconLibrary.setDefaultPack(this.NAME);
  }
  createIcons() {
    return Object.entries(import_eva_icons.icons).map(([name, icon]) => {
      return [name, new NbEvaSvgIcon(name, icon)];
    }).reduce((newIcons, [name, icon]) => {
      newIcons[name] = icon;
      return newIcons;
    }, {});
  }
};
_NbEvaIconsModule.\u0275fac = function NbEvaIconsModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NbEvaIconsModule)(\u0275\u0275inject(NbIconLibraries));
};
_NbEvaIconsModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NbEvaIconsModule
});
_NbEvaIconsModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var NbEvaIconsModule = _NbEvaIconsModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbEvaIconsModule, [{
    type: NgModule,
    args: [{}]
  }], () => [{
    type: NbIconLibraries
  }], null);
})();

// node_modules/@angular/animations/fesm2022/util.mjs
var LINE_START = "\n - ";
function invalidTimingValue(exp) {
  return new RuntimeError(3e3, ngDevMode && `The provided timing value "${exp}" is invalid.`);
}
function negativeStepValue() {
  return new RuntimeError(3100, ngDevMode && "Duration values below 0 are not allowed for this animation step.");
}
function negativeDelayValue() {
  return new RuntimeError(3101, ngDevMode && "Delay values below 0 are not allowed for this animation step.");
}
function invalidStyleParams(varName) {
  return new RuntimeError(3001, ngDevMode && `Unable to resolve the local animation param ${varName} in the given list of values`);
}
function invalidParamValue(varName) {
  return new RuntimeError(3003, ngDevMode && `Please provide a value for the animation param ${varName}`);
}
function invalidNodeType(nodeType) {
  return new RuntimeError(3004, ngDevMode && `Unable to resolve animation metadata node #${nodeType}`);
}
function invalidCssUnitValue(userProvidedProperty, value) {
  return new RuntimeError(3005, ngDevMode && `Please provide a CSS unit value for ${userProvidedProperty}:${value}`);
}
function invalidTrigger() {
  return new RuntimeError(3006, ngDevMode && "animation triggers cannot be prefixed with an `@` sign (e.g. trigger('@foo', [...]))");
}
function invalidDefinition() {
  return new RuntimeError(3007, ngDevMode && "only state() and transition() definitions can sit inside of a trigger()");
}
function invalidState(metadataName, missingSubs) {
  return new RuntimeError(3008, ngDevMode && `state("${metadataName}", ...) must define default values for all the following style substitutions: ${missingSubs.join(", ")}`);
}
function invalidStyleValue(value) {
  return new RuntimeError(3002, ngDevMode && `The provided style string value ${value} is not allowed.`);
}
function invalidParallelAnimation(prop, firstStart, firstEnd, secondStart, secondEnd) {
  return new RuntimeError(3010, ngDevMode && `The CSS property "${prop}" that exists between the times of "${firstStart}ms" and "${firstEnd}ms" is also being animated in a parallel animation between the times of "${secondStart}ms" and "${secondEnd}ms"`);
}
function invalidKeyframes() {
  return new RuntimeError(3011, ngDevMode && `keyframes() must be placed inside of a call to animate()`);
}
function invalidOffset() {
  return new RuntimeError(3012, ngDevMode && `Please ensure that all keyframe offsets are between 0 and 1`);
}
function keyframeOffsetsOutOfOrder() {
  return new RuntimeError(3200, ngDevMode && `Please ensure that all keyframe offsets are in order`);
}
function keyframesMissingOffsets() {
  return new RuntimeError(3202, ngDevMode && `Not all style() steps within the declared keyframes() contain offsets`);
}
function invalidStagger() {
  return new RuntimeError(3013, ngDevMode && `stagger() can only be used inside of query()`);
}
function invalidQuery(selector) {
  return new RuntimeError(3014, ngDevMode && `\`query("${selector}")\` returned zero elements. (Use \`query("${selector}", { optional: true })\` if you wish to allow this.)`);
}
function invalidExpression(expr) {
  return new RuntimeError(3015, ngDevMode && `The provided transition expression "${expr}" is not supported`);
}
function invalidTransitionAlias(alias) {
  return new RuntimeError(3016, ngDevMode && `The transition alias value "${alias}" is not supported`);
}
function triggerBuildFailed(name, errors) {
  return new RuntimeError(3404, ngDevMode && `The animation trigger "${name}" has failed to build due to the following errors:
 - ${errors.map((err) => err.message).join("\n - ")}`);
}
function animationFailed(errors) {
  return new RuntimeError(3502, ngDevMode && `Unable to animate due to the following errors:${LINE_START}${errors.map((err) => err.message).join(LINE_START)}`);
}
function registerFailed(errors) {
  return new RuntimeError(3503, ngDevMode && `Unable to build the animation due to the following errors: ${errors.map((err) => err.message).join("\n")}`);
}
function missingOrDestroyedAnimation() {
  return new RuntimeError(3300, ngDevMode && "The requested animation doesn't exist or has already been destroyed");
}
function createAnimationFailed(errors) {
  return new RuntimeError(3504, ngDevMode && `Unable to create the animation due to the following errors:${errors.map((err) => err.message).join("\n")}`);
}
function missingPlayer(id) {
  return new RuntimeError(3301, ngDevMode && `Unable to find the timeline player referenced by ${id}`);
}
function missingTrigger(phase, name) {
  return new RuntimeError(3302, ngDevMode && `Unable to listen on the animation trigger event "${phase}" because the animation trigger "${name}" doesn't exist!`);
}
function missingEvent(name) {
  return new RuntimeError(3303, ngDevMode && `Unable to listen on the animation trigger "${name}" because the provided event is undefined!`);
}
function unsupportedTriggerEvent(phase, name) {
  return new RuntimeError(3400, ngDevMode && `The provided animation trigger event "${phase}" for the animation trigger "${name}" is not supported!`);
}
function unregisteredTrigger(name) {
  return new RuntimeError(3401, ngDevMode && `The provided animation trigger "${name}" has not been registered!`);
}
function triggerTransitionsFailed(errors) {
  return new RuntimeError(3402, ngDevMode && `Unable to process animations due to the following failed trigger transitions
 ${errors.map((err) => err.message).join("\n")}`);
}
function transitionFailed(name, errors) {
  return new RuntimeError(3505, ngDevMode && `@${name} has failed due to:
 ${errors.map((err) => err.message).join("\n- ")}`);
}
var ANIMATABLE_PROP_SET = /* @__PURE__ */ new Set([
  "-moz-outline-radius",
  "-moz-outline-radius-bottomleft",
  "-moz-outline-radius-bottomright",
  "-moz-outline-radius-topleft",
  "-moz-outline-radius-topright",
  "-ms-grid-columns",
  "-ms-grid-rows",
  "-webkit-line-clamp",
  "-webkit-text-fill-color",
  "-webkit-text-stroke",
  "-webkit-text-stroke-color",
  "accent-color",
  "all",
  "backdrop-filter",
  "background",
  "background-color",
  "background-position",
  "background-size",
  "block-size",
  "border",
  "border-block-end",
  "border-block-end-color",
  "border-block-end-width",
  "border-block-start",
  "border-block-start-color",
  "border-block-start-width",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-width",
  "border-color",
  "border-end-end-radius",
  "border-end-start-radius",
  "border-image-outset",
  "border-image-slice",
  "border-image-width",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-end-width",
  "border-inline-start",
  "border-inline-start-color",
  "border-inline-start-width",
  "border-left",
  "border-left-color",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-right-color",
  "border-right-width",
  "border-start-end-radius",
  "border-start-start-radius",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-width",
  "border-width",
  "bottom",
  "box-shadow",
  "caret-color",
  "clip",
  "clip-path",
  "color",
  "column-count",
  "column-gap",
  "column-rule",
  "column-rule-color",
  "column-rule-width",
  "column-width",
  "columns",
  "filter",
  "flex",
  "flex-basis",
  "flex-grow",
  "flex-shrink",
  "font",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-variation-settings",
  "font-weight",
  "gap",
  "grid-column-gap",
  "grid-gap",
  "grid-row-gap",
  "grid-template-columns",
  "grid-template-rows",
  "height",
  "inline-size",
  "input-security",
  "inset",
  "inset-block",
  "inset-block-end",
  "inset-block-start",
  "inset-inline",
  "inset-inline-end",
  "inset-inline-start",
  "left",
  "letter-spacing",
  "line-clamp",
  "line-height",
  "margin",
  "margin-block-end",
  "margin-block-start",
  "margin-bottom",
  "margin-inline-end",
  "margin-inline-start",
  "margin-left",
  "margin-right",
  "margin-top",
  "mask",
  "mask-border",
  "mask-position",
  "mask-size",
  "max-block-size",
  "max-height",
  "max-inline-size",
  "max-lines",
  "max-width",
  "min-block-size",
  "min-height",
  "min-inline-size",
  "min-width",
  "object-position",
  "offset",
  "offset-anchor",
  "offset-distance",
  "offset-path",
  "offset-position",
  "offset-rotate",
  "opacity",
  "order",
  "outline",
  "outline-color",
  "outline-offset",
  "outline-width",
  "padding",
  "padding-block-end",
  "padding-block-start",
  "padding-bottom",
  "padding-inline-end",
  "padding-inline-start",
  "padding-left",
  "padding-right",
  "padding-top",
  "perspective",
  "perspective-origin",
  "right",
  "rotate",
  "row-gap",
  "scale",
  "scroll-margin",
  "scroll-margin-block",
  "scroll-margin-block-end",
  "scroll-margin-block-start",
  "scroll-margin-bottom",
  "scroll-margin-inline",
  "scroll-margin-inline-end",
  "scroll-margin-inline-start",
  "scroll-margin-left",
  "scroll-margin-right",
  "scroll-margin-top",
  "scroll-padding",
  "scroll-padding-block",
  "scroll-padding-block-end",
  "scroll-padding-block-start",
  "scroll-padding-bottom",
  "scroll-padding-inline",
  "scroll-padding-inline-end",
  "scroll-padding-inline-start",
  "scroll-padding-left",
  "scroll-padding-right",
  "scroll-padding-top",
  "scroll-snap-coordinate",
  "scroll-snap-destination",
  "scrollbar-color",
  "shape-image-threshold",
  "shape-margin",
  "shape-outside",
  "tab-size",
  "text-decoration",
  "text-decoration-color",
  "text-decoration-thickness",
  "text-emphasis",
  "text-emphasis-color",
  "text-indent",
  "text-shadow",
  "text-underline-offset",
  "top",
  "transform",
  "transform-origin",
  "translate",
  "vertical-align",
  "visibility",
  "width",
  "word-spacing",
  "z-index",
  "zoom"
]);
function optimizeGroupPlayer(players) {
  switch (players.length) {
    case 0:
      return new NoopAnimationPlayer();
    case 1:
      return players[0];
    default:
      return new AnimationGroupPlayer(players);
  }
}
function normalizeKeyframes$1(normalizer, keyframes2, preStyles = /* @__PURE__ */ new Map(), postStyles = /* @__PURE__ */ new Map()) {
  const errors = [];
  const normalizedKeyframes = [];
  let previousOffset = -1;
  let previousKeyframe = null;
  keyframes2.forEach((kf) => {
    const offset = kf.get("offset");
    const isSameOffset = offset == previousOffset;
    const normalizedKeyframe = isSameOffset && previousKeyframe || /* @__PURE__ */ new Map();
    kf.forEach((val, prop) => {
      let normalizedProp = prop;
      let normalizedValue = val;
      if (prop !== "offset") {
        normalizedProp = normalizer.normalizePropertyName(normalizedProp, errors);
        switch (normalizedValue) {
          case \u0275PRE_STYLE:
            normalizedValue = preStyles.get(prop);
            break;
          case AUTO_STYLE:
            normalizedValue = postStyles.get(prop);
            break;
          default:
            normalizedValue = normalizer.normalizeStyleValue(prop, normalizedProp, normalizedValue, errors);
            break;
        }
      }
      normalizedKeyframe.set(normalizedProp, normalizedValue);
    });
    if (!isSameOffset) {
      normalizedKeyframes.push(normalizedKeyframe);
    }
    previousKeyframe = normalizedKeyframe;
    previousOffset = offset;
  });
  if (errors.length) {
    throw animationFailed(errors);
  }
  return normalizedKeyframes;
}
function listenOnPlayer(player, eventName, event, callback) {
  switch (eventName) {
    case "start":
      player.onStart(() => callback(event && copyAnimationEvent(event, "start", player)));
      break;
    case "done":
      player.onDone(() => callback(event && copyAnimationEvent(event, "done", player)));
      break;
    case "destroy":
      player.onDestroy(() => callback(event && copyAnimationEvent(event, "destroy", player)));
      break;
  }
}
function copyAnimationEvent(e, phaseName, player) {
  const totalTime = player.totalTime;
  const disabled = player.disabled ? true : false;
  const event = makeAnimationEvent(e.element, e.triggerName, e.fromState, e.toState, phaseName || e.phaseName, totalTime == void 0 ? e.totalTime : totalTime, disabled);
  const data = e["_data"];
  if (data != null) {
    event["_data"] = data;
  }
  return event;
}
function makeAnimationEvent(element, triggerName, fromState, toState, phaseName = "", totalTime = 0, disabled) {
  return { element, triggerName, fromState, toState, phaseName, totalTime, disabled: !!disabled };
}
function getOrSetDefaultValue(map2, key, defaultValue) {
  let value = map2.get(key);
  if (!value) {
    map2.set(key, value = defaultValue);
  }
  return value;
}
function parseTimelineCommand(command) {
  const separatorPos = command.indexOf(":");
  const id = command.substring(1, separatorPos);
  const action = command.slice(separatorPos + 1);
  return [id, action];
}
var documentElement = /* @__PURE__ */ (() => typeof document === "undefined" ? null : document.documentElement)();
function getParentElement(element) {
  const parent = element.parentNode || element.host || null;
  if (parent === documentElement) {
    return null;
  }
  return parent;
}
function containsVendorPrefix(prop) {
  return prop.substring(1, 6) == "ebkit";
}
var _CACHED_BODY = null;
var _IS_WEBKIT = false;
function validateStyleProperty(prop) {
  if (!_CACHED_BODY) {
    _CACHED_BODY = getBodyNode() || {};
    _IS_WEBKIT = _CACHED_BODY.style ? "WebkitAppearance" in _CACHED_BODY.style : false;
  }
  let result = true;
  if (_CACHED_BODY.style && !containsVendorPrefix(prop)) {
    result = prop in _CACHED_BODY.style;
    if (!result && _IS_WEBKIT) {
      const camelProp = "Webkit" + prop.charAt(0).toUpperCase() + prop.slice(1);
      result = camelProp in _CACHED_BODY.style;
    }
  }
  return result;
}
function validateWebAnimatableStyleProperty(prop) {
  return ANIMATABLE_PROP_SET.has(prop);
}
function getBodyNode() {
  if (typeof document != "undefined") {
    return document.body;
  }
  return null;
}
function containsElement(elm1, elm2) {
  while (elm2) {
    if (elm2 === elm1) {
      return true;
    }
    elm2 = getParentElement(elm2);
  }
  return false;
}
function invokeQuery(element, selector, multi) {
  if (multi) {
    return Array.from(element.querySelectorAll(selector));
  }
  const elem = element.querySelector(selector);
  return elem ? [elem] : [];
}
var ONE_SECOND = 1e3;
var SUBSTITUTION_EXPR_START = "{{";
var SUBSTITUTION_EXPR_END = "}}";
var ENTER_CLASSNAME = "ng-enter";
var LEAVE_CLASSNAME = "ng-leave";
var NG_TRIGGER_CLASSNAME = "ng-trigger";
var NG_TRIGGER_SELECTOR = ".ng-trigger";
var NG_ANIMATING_CLASSNAME = "ng-animating";
var NG_ANIMATING_SELECTOR = ".ng-animating";
function resolveTimingValue(value) {
  if (typeof value == "number")
    return value;
  const matches = value.match(/^(-?[\.\d]+)(m?s)/);
  if (!matches || matches.length < 2)
    return 0;
  return _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);
}
function _convertTimeValueToMS(value, unit) {
  switch (unit) {
    case "s":
      return value * ONE_SECOND;
    default:
      return value;
  }
}
function resolveTiming(timings, errors, allowNegativeValues) {
  return timings.hasOwnProperty("duration") ? timings : parseTimeExpression(timings, errors, allowNegativeValues);
}
var PARSE_TIME_EXPRESSION_REGEX = /^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i;
function parseTimeExpression(exp, errors, allowNegativeValues) {
  let duration;
  let delay2 = 0;
  let easing = "";
  if (typeof exp === "string") {
    const matches = exp.match(PARSE_TIME_EXPRESSION_REGEX);
    if (matches === null) {
      errors.push(invalidTimingValue(exp));
      return { duration: 0, delay: 0, easing: "" };
    }
    duration = _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);
    const delayMatch = matches[3];
    if (delayMatch != null) {
      delay2 = _convertTimeValueToMS(parseFloat(delayMatch), matches[4]);
    }
    const easingVal = matches[5];
    if (easingVal) {
      easing = easingVal;
    }
  } else {
    duration = exp;
  }
  if (!allowNegativeValues) {
    let containsErrors = false;
    let startIndex = errors.length;
    if (duration < 0) {
      errors.push(negativeStepValue());
      containsErrors = true;
    }
    if (delay2 < 0) {
      errors.push(negativeDelayValue());
      containsErrors = true;
    }
    if (containsErrors) {
      errors.splice(startIndex, 0, invalidTimingValue(exp));
    }
  }
  return { duration, delay: delay2, easing };
}
function normalizeKeyframes(keyframes2) {
  if (!keyframes2.length) {
    return [];
  }
  if (keyframes2[0] instanceof Map) {
    return keyframes2;
  }
  return keyframes2.map((kf) => new Map(Object.entries(kf)));
}
function setStyles(element, styles, formerStyles) {
  styles.forEach((val, prop) => {
    const camelProp = dashCaseToCamelCase(prop);
    if (formerStyles && !formerStyles.has(prop)) {
      formerStyles.set(prop, element.style[camelProp]);
    }
    element.style[camelProp] = val;
  });
}
function eraseStyles(element, styles) {
  styles.forEach((_, prop) => {
    const camelProp = dashCaseToCamelCase(prop);
    element.style[camelProp] = "";
  });
}
function normalizeAnimationEntry(steps) {
  if (Array.isArray(steps)) {
    if (steps.length == 1)
      return steps[0];
    return sequence(steps);
  }
  return steps;
}
function validateStyleParams(value, options, errors) {
  const params = options.params || {};
  const matches = extractStyleParams(value);
  if (matches.length) {
    matches.forEach((varName) => {
      if (!params.hasOwnProperty(varName)) {
        errors.push(invalidStyleParams(varName));
      }
    });
  }
}
var PARAM_REGEX = /* @__PURE__ */ new RegExp(`${SUBSTITUTION_EXPR_START}\\s*(.+?)\\s*${SUBSTITUTION_EXPR_END}`, "g");
function extractStyleParams(value) {
  let params = [];
  if (typeof value === "string") {
    let match2;
    while (match2 = PARAM_REGEX.exec(value)) {
      params.push(match2[1]);
    }
    PARAM_REGEX.lastIndex = 0;
  }
  return params;
}
function interpolateParams(value, params, errors) {
  const original = `${value}`;
  const str = original.replace(PARAM_REGEX, (_, varName) => {
    let localVal = params[varName];
    if (localVal == null) {
      errors.push(invalidParamValue(varName));
      localVal = "";
    }
    return localVal.toString();
  });
  return str == original ? value : str;
}
var DASH_CASE_REGEXP = /-+([a-z0-9])/g;
function dashCaseToCamelCase(input2) {
  return input2.replace(DASH_CASE_REGEXP, (...m) => m[1].toUpperCase());
}
function camelCaseToDashCase(input2) {
  return input2.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function allowPreviousPlayerStylesMerge(duration, delay2) {
  return duration === 0 || delay2 === 0;
}
function balancePreviousStylesIntoKeyframes(element, keyframes2, previousStyles) {
  if (previousStyles.size && keyframes2.length) {
    let startingKeyframe = keyframes2[0];
    let missingStyleProps = [];
    previousStyles.forEach((val, prop) => {
      if (!startingKeyframe.has(prop)) {
        missingStyleProps.push(prop);
      }
      startingKeyframe.set(prop, val);
    });
    if (missingStyleProps.length) {
      for (let i = 1; i < keyframes2.length; i++) {
        let kf = keyframes2[i];
        missingStyleProps.forEach((prop) => kf.set(prop, computeStyle(element, prop)));
      }
    }
  }
  return keyframes2;
}
function visitDslNode(visitor, node, context) {
  switch (node.type) {
    case AnimationMetadataType.Trigger:
      return visitor.visitTrigger(node, context);
    case AnimationMetadataType.State:
      return visitor.visitState(node, context);
    case AnimationMetadataType.Transition:
      return visitor.visitTransition(node, context);
    case AnimationMetadataType.Sequence:
      return visitor.visitSequence(node, context);
    case AnimationMetadataType.Group:
      return visitor.visitGroup(node, context);
    case AnimationMetadataType.Animate:
      return visitor.visitAnimate(node, context);
    case AnimationMetadataType.Keyframes:
      return visitor.visitKeyframes(node, context);
    case AnimationMetadataType.Style:
      return visitor.visitStyle(node, context);
    case AnimationMetadataType.Reference:
      return visitor.visitReference(node, context);
    case AnimationMetadataType.AnimateChild:
      return visitor.visitAnimateChild(node, context);
    case AnimationMetadataType.AnimateRef:
      return visitor.visitAnimateRef(node, context);
    case AnimationMetadataType.Query:
      return visitor.visitQuery(node, context);
    case AnimationMetadataType.Stagger:
      return visitor.visitStagger(node, context);
    default:
      throw invalidNodeType(node.type);
  }
}
function computeStyle(element, prop) {
  return window.getComputedStyle(element)[prop];
}

// node_modules/@angular/animations/fesm2022/browser.mjs
var NoopAnimationDriver = class _NoopAnimationDriver {
  /**
   * @returns Whether `prop` is a valid CSS property
   */
  validateStyleProperty(prop) {
    return validateStyleProperty(prop);
  }
  /**
   *
   * @returns Whether elm1 contains elm2.
   */
  containsElement(elm1, elm2) {
    return containsElement(elm1, elm2);
  }
  /**
   * @returns Rhe parent of the given element or `null` if the element is the `document`
   */
  getParentElement(element) {
    return getParentElement(element);
  }
  /**
   * @returns The result of the query selector on the element. The array will contain up to 1 item
   *     if `multi` is  `false`.
   */
  query(element, selector, multi) {
    return invokeQuery(element, selector, multi);
  }
  /**
   * @returns The `defaultValue` or empty string
   */
  computeStyle(element, prop, defaultValue) {
    return defaultValue || "";
  }
  /**
   * @returns An `NoopAnimationPlayer`
   */
  animate(element, keyframes2, duration, delay2, easing, previousPlayers = [], scrubberAccessRequested) {
    return new NoopAnimationPlayer(duration, delay2);
  }
  static \u0275fac = function NoopAnimationDriver_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NoopAnimationDriver)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _NoopAnimationDriver,
    factory: _NoopAnimationDriver.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NoopAnimationDriver, [{
    type: Injectable
  }], null, null);
})();
var AnimationDriver = class {
  /**
   * @deprecated Use the NoopAnimationDriver class.
   */
  static NOOP = new NoopAnimationDriver();
};
var AnimationStyleNormalizer = class {
};
var DIMENSIONAL_PROP_SET = /* @__PURE__ */ new Set(["width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "left", "top", "bottom", "right", "fontSize", "outlineWidth", "outlineOffset", "paddingTop", "paddingLeft", "paddingBottom", "paddingRight", "marginTop", "marginLeft", "marginBottom", "marginRight", "borderRadius", "borderWidth", "borderTopWidth", "borderLeftWidth", "borderRightWidth", "borderBottomWidth", "textIndent", "perspective"]);
var WebAnimationsStyleNormalizer = class extends AnimationStyleNormalizer {
  normalizePropertyName(propertyName, errors) {
    return dashCaseToCamelCase(propertyName);
  }
  normalizeStyleValue(userProvidedProperty, normalizedProperty, value, errors) {
    let unit = "";
    const strVal = value.toString().trim();
    if (DIMENSIONAL_PROP_SET.has(normalizedProperty) && value !== 0 && value !== "0") {
      if (typeof value === "number") {
        unit = "px";
      } else {
        const valAndSuffixMatch = value.match(/^[+-]?[\d\.]+([a-z]*)$/);
        if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {
          errors.push(invalidCssUnitValue(userProvidedProperty, value));
        }
      }
    }
    return strVal + unit;
  }
};
function createListOfWarnings(warnings) {
  const LINE_START2 = "\n - ";
  return `${LINE_START2}${warnings.filter(Boolean).map((warning) => warning).join(LINE_START2)}`;
}
function warnTriggerBuild(name, warnings) {
  console.warn(`The animation trigger "${name}" has built with the following warnings:${createListOfWarnings(warnings)}`);
}
function warnRegister(warnings) {
  console.warn(`Animation built with the following warnings:${createListOfWarnings(warnings)}`);
}
function pushUnrecognizedPropertiesWarning(warnings, props) {
  if (props.length) {
    warnings.push(`The following provided properties are not recognized: ${props.join(", ")}`);
  }
}
var ANY_STATE = "*";
function parseTransitionExpr(transitionValue, errors) {
  const expressions = [];
  if (typeof transitionValue == "string") {
    transitionValue.split(/\s*,\s*/).forEach((str) => parseInnerTransitionStr(str, expressions, errors));
  } else {
    expressions.push(transitionValue);
  }
  return expressions;
}
function parseInnerTransitionStr(eventStr, expressions, errors) {
  if (eventStr[0] == ":") {
    const result = parseAnimationAlias(eventStr, errors);
    if (typeof result == "function") {
      expressions.push(result);
      return;
    }
    eventStr = result;
  }
  const match2 = eventStr.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);
  if (match2 == null || match2.length < 4) {
    errors.push(invalidExpression(eventStr));
    return expressions;
  }
  const fromState = match2[1];
  const separator = match2[2];
  const toState = match2[3];
  expressions.push(makeLambdaFromStates(fromState, toState));
  const isFullAnyStateExpr = fromState == ANY_STATE && toState == ANY_STATE;
  if (separator[0] == "<" && !isFullAnyStateExpr) {
    expressions.push(makeLambdaFromStates(toState, fromState));
  }
  return;
}
function parseAnimationAlias(alias, errors) {
  switch (alias) {
    case ":enter":
      return "void => *";
    case ":leave":
      return "* => void";
    case ":increment":
      return (fromState, toState) => parseFloat(toState) > parseFloat(fromState);
    case ":decrement":
      return (fromState, toState) => parseFloat(toState) < parseFloat(fromState);
    default:
      errors.push(invalidTransitionAlias(alias));
      return "* => *";
  }
}
var TRUE_BOOLEAN_VALUES = /* @__PURE__ */ new Set(["true", "1"]);
var FALSE_BOOLEAN_VALUES = /* @__PURE__ */ new Set(["false", "0"]);
function makeLambdaFromStates(lhs, rhs) {
  const LHS_MATCH_BOOLEAN = TRUE_BOOLEAN_VALUES.has(lhs) || FALSE_BOOLEAN_VALUES.has(lhs);
  const RHS_MATCH_BOOLEAN = TRUE_BOOLEAN_VALUES.has(rhs) || FALSE_BOOLEAN_VALUES.has(rhs);
  return (fromState, toState) => {
    let lhsMatch = lhs == ANY_STATE || lhs == fromState;
    let rhsMatch = rhs == ANY_STATE || rhs == toState;
    if (!lhsMatch && LHS_MATCH_BOOLEAN && typeof fromState === "boolean") {
      lhsMatch = fromState ? TRUE_BOOLEAN_VALUES.has(lhs) : FALSE_BOOLEAN_VALUES.has(lhs);
    }
    if (!rhsMatch && RHS_MATCH_BOOLEAN && typeof toState === "boolean") {
      rhsMatch = toState ? TRUE_BOOLEAN_VALUES.has(rhs) : FALSE_BOOLEAN_VALUES.has(rhs);
    }
    return lhsMatch && rhsMatch;
  };
}
var SELF_TOKEN = ":self";
var SELF_TOKEN_REGEX = /* @__PURE__ */ new RegExp(`s*${SELF_TOKEN}s*,?`, "g");
function buildAnimationAst(driver, metadata, errors, warnings) {
  return new AnimationAstBuilderVisitor(driver).build(metadata, errors, warnings);
}
var ROOT_SELECTOR = "";
var AnimationAstBuilderVisitor = class {
  _driver;
  constructor(_driver) {
    this._driver = _driver;
  }
  build(metadata, errors, warnings) {
    const context = new AnimationAstBuilderContext(errors);
    this._resetContextStyleTimingState(context);
    const ast = visitDslNode(this, normalizeAnimationEntry(metadata), context);
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (context.unsupportedCSSPropertiesFound.size) {
        pushUnrecognizedPropertiesWarning(warnings, [...context.unsupportedCSSPropertiesFound.keys()]);
      }
    }
    return ast;
  }
  _resetContextStyleTimingState(context) {
    context.currentQuerySelector = ROOT_SELECTOR;
    context.collectedStyles = /* @__PURE__ */ new Map();
    context.collectedStyles.set(ROOT_SELECTOR, /* @__PURE__ */ new Map());
    context.currentTime = 0;
  }
  visitTrigger(metadata, context) {
    let queryCount = context.queryCount = 0;
    let depCount = context.depCount = 0;
    const states = [];
    const transitions = [];
    if (metadata.name.charAt(0) == "@") {
      context.errors.push(invalidTrigger());
    }
    metadata.definitions.forEach((def) => {
      this._resetContextStyleTimingState(context);
      if (def.type == AnimationMetadataType.State) {
        const stateDef = def;
        const name = stateDef.name;
        name.toString().split(/\s*,\s*/).forEach((n) => {
          stateDef.name = n;
          states.push(this.visitState(stateDef, context));
        });
        stateDef.name = name;
      } else if (def.type == AnimationMetadataType.Transition) {
        const transition2 = this.visitTransition(def, context);
        queryCount += transition2.queryCount;
        depCount += transition2.depCount;
        transitions.push(transition2);
      } else {
        context.errors.push(invalidDefinition());
      }
    });
    return {
      type: AnimationMetadataType.Trigger,
      name: metadata.name,
      states,
      transitions,
      queryCount,
      depCount,
      options: null
    };
  }
  visitState(metadata, context) {
    const styleAst = this.visitStyle(metadata.styles, context);
    const astParams = metadata.options && metadata.options.params || null;
    if (styleAst.containsDynamicStyles) {
      const missingSubs = /* @__PURE__ */ new Set();
      const params = astParams || {};
      styleAst.styles.forEach((style2) => {
        if (style2 instanceof Map) {
          style2.forEach((value) => {
            extractStyleParams(value).forEach((sub) => {
              if (!params.hasOwnProperty(sub)) {
                missingSubs.add(sub);
              }
            });
          });
        }
      });
      if (missingSubs.size) {
        context.errors.push(invalidState(metadata.name, [...missingSubs.values()]));
      }
    }
    return {
      type: AnimationMetadataType.State,
      name: metadata.name,
      style: styleAst,
      options: astParams ? {
        params: astParams
      } : null
    };
  }
  visitTransition(metadata, context) {
    context.queryCount = 0;
    context.depCount = 0;
    const animation2 = visitDslNode(this, normalizeAnimationEntry(metadata.animation), context);
    const matchers = parseTransitionExpr(metadata.expr, context.errors);
    return {
      type: AnimationMetadataType.Transition,
      matchers,
      animation: animation2,
      queryCount: context.queryCount,
      depCount: context.depCount,
      options: normalizeAnimationOptions(metadata.options)
    };
  }
  visitSequence(metadata, context) {
    return {
      type: AnimationMetadataType.Sequence,
      steps: metadata.steps.map((s) => visitDslNode(this, s, context)),
      options: normalizeAnimationOptions(metadata.options)
    };
  }
  visitGroup(metadata, context) {
    const currentTime = context.currentTime;
    let furthestTime = 0;
    const steps = metadata.steps.map((step) => {
      context.currentTime = currentTime;
      const innerAst = visitDslNode(this, step, context);
      furthestTime = Math.max(furthestTime, context.currentTime);
      return innerAst;
    });
    context.currentTime = furthestTime;
    return {
      type: AnimationMetadataType.Group,
      steps,
      options: normalizeAnimationOptions(metadata.options)
    };
  }
  visitAnimate(metadata, context) {
    const timingAst = constructTimingAst(metadata.timings, context.errors);
    context.currentAnimateTimings = timingAst;
    let styleAst;
    let styleMetadata = metadata.styles ? metadata.styles : style({});
    if (styleMetadata.type == AnimationMetadataType.Keyframes) {
      styleAst = this.visitKeyframes(styleMetadata, context);
    } else {
      let styleMetadata2 = metadata.styles;
      let isEmpty = false;
      if (!styleMetadata2) {
        isEmpty = true;
        const newStyleData = {};
        if (timingAst.easing) {
          newStyleData["easing"] = timingAst.easing;
        }
        styleMetadata2 = style(newStyleData);
      }
      context.currentTime += timingAst.duration + timingAst.delay;
      const _styleAst = this.visitStyle(styleMetadata2, context);
      _styleAst.isEmptyStep = isEmpty;
      styleAst = _styleAst;
    }
    context.currentAnimateTimings = null;
    return {
      type: AnimationMetadataType.Animate,
      timings: timingAst,
      style: styleAst,
      options: null
    };
  }
  visitStyle(metadata, context) {
    const ast = this._makeStyleAst(metadata, context);
    this._validateStyleAst(ast, context);
    return ast;
  }
  _makeStyleAst(metadata, context) {
    const styles = [];
    const metadataStyles = Array.isArray(metadata.styles) ? metadata.styles : [metadata.styles];
    for (let styleTuple of metadataStyles) {
      if (typeof styleTuple === "string") {
        if (styleTuple === AUTO_STYLE) {
          styles.push(styleTuple);
        } else {
          context.errors.push(invalidStyleValue(styleTuple));
        }
      } else {
        styles.push(new Map(Object.entries(styleTuple)));
      }
    }
    let containsDynamicStyles = false;
    let collectedEasing = null;
    styles.forEach((styleData) => {
      if (styleData instanceof Map) {
        if (styleData.has("easing")) {
          collectedEasing = styleData.get("easing");
          styleData.delete("easing");
        }
        if (!containsDynamicStyles) {
          for (let value of styleData.values()) {
            if (value.toString().indexOf(SUBSTITUTION_EXPR_START) >= 0) {
              containsDynamicStyles = true;
              break;
            }
          }
        }
      }
    });
    return {
      type: AnimationMetadataType.Style,
      styles,
      easing: collectedEasing,
      offset: metadata.offset,
      containsDynamicStyles,
      options: null
    };
  }
  _validateStyleAst(ast, context) {
    const timings = context.currentAnimateTimings;
    let endTime = context.currentTime;
    let startTime = context.currentTime;
    if (timings && startTime > 0) {
      startTime -= timings.duration + timings.delay;
    }
    ast.styles.forEach((tuple) => {
      if (typeof tuple === "string") return;
      tuple.forEach((value, prop) => {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          if (!this._driver.validateStyleProperty(prop)) {
            tuple.delete(prop);
            context.unsupportedCSSPropertiesFound.add(prop);
            return;
          }
        }
        const collectedStyles = context.collectedStyles.get(context.currentQuerySelector);
        const collectedEntry = collectedStyles.get(prop);
        let updateCollectedStyle = true;
        if (collectedEntry) {
          if (startTime != endTime && startTime >= collectedEntry.startTime && endTime <= collectedEntry.endTime) {
            context.errors.push(invalidParallelAnimation(prop, collectedEntry.startTime, collectedEntry.endTime, startTime, endTime));
            updateCollectedStyle = false;
          }
          startTime = collectedEntry.startTime;
        }
        if (updateCollectedStyle) {
          collectedStyles.set(prop, {
            startTime,
            endTime
          });
        }
        if (context.options) {
          validateStyleParams(value, context.options, context.errors);
        }
      });
    });
  }
  visitKeyframes(metadata, context) {
    const ast = {
      type: AnimationMetadataType.Keyframes,
      styles: [],
      options: null
    };
    if (!context.currentAnimateTimings) {
      context.errors.push(invalidKeyframes());
      return ast;
    }
    const MAX_KEYFRAME_OFFSET = 1;
    let totalKeyframesWithOffsets = 0;
    const offsets = [];
    let offsetsOutOfOrder = false;
    let keyframesOutOfRange = false;
    let previousOffset = 0;
    const keyframes2 = metadata.steps.map((styles) => {
      const style2 = this._makeStyleAst(styles, context);
      let offsetVal = style2.offset != null ? style2.offset : consumeOffset(style2.styles);
      let offset = 0;
      if (offsetVal != null) {
        totalKeyframesWithOffsets++;
        offset = style2.offset = offsetVal;
      }
      keyframesOutOfRange = keyframesOutOfRange || offset < 0 || offset > 1;
      offsetsOutOfOrder = offsetsOutOfOrder || offset < previousOffset;
      previousOffset = offset;
      offsets.push(offset);
      return style2;
    });
    if (keyframesOutOfRange) {
      context.errors.push(invalidOffset());
    }
    if (offsetsOutOfOrder) {
      context.errors.push(keyframeOffsetsOutOfOrder());
    }
    const length = metadata.steps.length;
    let generatedOffset = 0;
    if (totalKeyframesWithOffsets > 0 && totalKeyframesWithOffsets < length) {
      context.errors.push(keyframesMissingOffsets());
    } else if (totalKeyframesWithOffsets == 0) {
      generatedOffset = MAX_KEYFRAME_OFFSET / (length - 1);
    }
    const limit = length - 1;
    const currentTime = context.currentTime;
    const currentAnimateTimings = context.currentAnimateTimings;
    const animateDuration = currentAnimateTimings.duration;
    keyframes2.forEach((kf, i) => {
      const offset = generatedOffset > 0 ? i == limit ? 1 : generatedOffset * i : offsets[i];
      const durationUpToThisFrame = offset * animateDuration;
      context.currentTime = currentTime + currentAnimateTimings.delay + durationUpToThisFrame;
      currentAnimateTimings.duration = durationUpToThisFrame;
      this._validateStyleAst(kf, context);
      kf.offset = offset;
      ast.styles.push(kf);
    });
    return ast;
  }
  visitReference(metadata, context) {
    return {
      type: AnimationMetadataType.Reference,
      animation: visitDslNode(this, normalizeAnimationEntry(metadata.animation), context),
      options: normalizeAnimationOptions(metadata.options)
    };
  }
  visitAnimateChild(metadata, context) {
    context.depCount++;
    return {
      type: AnimationMetadataType.AnimateChild,
      options: normalizeAnimationOptions(metadata.options)
    };
  }
  visitAnimateRef(metadata, context) {
    return {
      type: AnimationMetadataType.AnimateRef,
      animation: this.visitReference(metadata.animation, context),
      options: normalizeAnimationOptions(metadata.options)
    };
  }
  visitQuery(metadata, context) {
    const parentSelector = context.currentQuerySelector;
    const options = metadata.options || {};
    context.queryCount++;
    context.currentQuery = metadata;
    const [selector, includeSelf] = normalizeSelector(metadata.selector);
    context.currentQuerySelector = parentSelector.length ? parentSelector + " " + selector : selector;
    getOrSetDefaultValue(context.collectedStyles, context.currentQuerySelector, /* @__PURE__ */ new Map());
    const animation2 = visitDslNode(this, normalizeAnimationEntry(metadata.animation), context);
    context.currentQuery = null;
    context.currentQuerySelector = parentSelector;
    return {
      type: AnimationMetadataType.Query,
      selector,
      limit: options.limit || 0,
      optional: !!options.optional,
      includeSelf,
      animation: animation2,
      originalSelector: metadata.selector,
      options: normalizeAnimationOptions(metadata.options)
    };
  }
  visitStagger(metadata, context) {
    if (!context.currentQuery) {
      context.errors.push(invalidStagger());
    }
    const timings = metadata.timings === "full" ? {
      duration: 0,
      delay: 0,
      easing: "full"
    } : resolveTiming(metadata.timings, context.errors, true);
    return {
      type: AnimationMetadataType.Stagger,
      animation: visitDslNode(this, normalizeAnimationEntry(metadata.animation), context),
      timings,
      options: null
    };
  }
};
function normalizeSelector(selector) {
  const hasAmpersand = selector.split(/\s*,\s*/).find((token) => token == SELF_TOKEN) ? true : false;
  if (hasAmpersand) {
    selector = selector.replace(SELF_TOKEN_REGEX, "");
  }
  selector = selector.replace(/@\*/g, NG_TRIGGER_SELECTOR).replace(/@\w+/g, (match2) => NG_TRIGGER_SELECTOR + "-" + match2.slice(1)).replace(/:animating/g, NG_ANIMATING_SELECTOR);
  return [selector, hasAmpersand];
}
function normalizeParams(obj) {
  return obj ? __spreadValues({}, obj) : null;
}
var AnimationAstBuilderContext = class {
  errors;
  queryCount = 0;
  depCount = 0;
  currentTransition = null;
  currentQuery = null;
  currentQuerySelector = null;
  currentAnimateTimings = null;
  currentTime = 0;
  collectedStyles = /* @__PURE__ */ new Map();
  options = null;
  unsupportedCSSPropertiesFound = /* @__PURE__ */ new Set();
  constructor(errors) {
    this.errors = errors;
  }
};
function consumeOffset(styles) {
  if (typeof styles == "string") return null;
  let offset = null;
  if (Array.isArray(styles)) {
    styles.forEach((styleTuple) => {
      if (styleTuple instanceof Map && styleTuple.has("offset")) {
        const obj = styleTuple;
        offset = parseFloat(obj.get("offset"));
        obj.delete("offset");
      }
    });
  } else if (styles instanceof Map && styles.has("offset")) {
    const obj = styles;
    offset = parseFloat(obj.get("offset"));
    obj.delete("offset");
  }
  return offset;
}
function constructTimingAst(value, errors) {
  if (value.hasOwnProperty("duration")) {
    return value;
  }
  if (typeof value == "number") {
    const duration = resolveTiming(value, errors).duration;
    return makeTimingAst(duration, 0, "");
  }
  const strValue = value;
  const isDynamic = strValue.split(/\s+/).some((v) => v.charAt(0) == "{" && v.charAt(1) == "{");
  if (isDynamic) {
    const ast = makeTimingAst(0, 0, "");
    ast.dynamic = true;
    ast.strValue = strValue;
    return ast;
  }
  const timings = resolveTiming(strValue, errors);
  return makeTimingAst(timings.duration, timings.delay, timings.easing);
}
function normalizeAnimationOptions(options) {
  if (options) {
    options = __spreadValues({}, options);
    if (options["params"]) {
      options["params"] = normalizeParams(options["params"]);
    }
  } else {
    options = {};
  }
  return options;
}
function makeTimingAst(duration, delay2, easing) {
  return {
    duration,
    delay: delay2,
    easing
  };
}
function createTimelineInstruction(element, keyframes2, preStyleProps, postStyleProps, duration, delay2, easing = null, subTimeline = false) {
  return {
    type: 1,
    element,
    keyframes: keyframes2,
    preStyleProps,
    postStyleProps,
    duration,
    delay: delay2,
    totalTime: duration + delay2,
    easing,
    subTimeline
  };
}
var ElementInstructionMap = class {
  _map = /* @__PURE__ */ new Map();
  get(element) {
    return this._map.get(element) || [];
  }
  append(element, instructions) {
    let existingInstructions = this._map.get(element);
    if (!existingInstructions) {
      this._map.set(element, existingInstructions = []);
    }
    existingInstructions.push(...instructions);
  }
  has(element) {
    return this._map.has(element);
  }
  clear() {
    this._map.clear();
  }
};
var ONE_FRAME_IN_MILLISECONDS = 1;
var ENTER_TOKEN = ":enter";
var ENTER_TOKEN_REGEX = /* @__PURE__ */ new RegExp(ENTER_TOKEN, "g");
var LEAVE_TOKEN = ":leave";
var LEAVE_TOKEN_REGEX = /* @__PURE__ */ new RegExp(LEAVE_TOKEN, "g");
function buildAnimationTimelines(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles = /* @__PURE__ */ new Map(), finalStyles = /* @__PURE__ */ new Map(), options, subInstructions, errors = []) {
  return new AnimationTimelineBuilderVisitor().buildKeyframes(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles, finalStyles, options, subInstructions, errors);
}
var AnimationTimelineBuilderVisitor = class {
  buildKeyframes(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles, finalStyles, options, subInstructions, errors = []) {
    subInstructions = subInstructions || new ElementInstructionMap();
    const context = new AnimationTimelineContext(driver, rootElement, subInstructions, enterClassName, leaveClassName, errors, []);
    context.options = options;
    const delay2 = options.delay ? resolveTimingValue(options.delay) : 0;
    context.currentTimeline.delayNextStep(delay2);
    context.currentTimeline.setStyles([startingStyles], null, context.errors, options);
    visitDslNode(this, ast, context);
    const timelines = context.timelines.filter((timeline) => timeline.containsAnimation());
    if (timelines.length && finalStyles.size) {
      let lastRootTimeline;
      for (let i = timelines.length - 1; i >= 0; i--) {
        const timeline = timelines[i];
        if (timeline.element === rootElement) {
          lastRootTimeline = timeline;
          break;
        }
      }
      if (lastRootTimeline && !lastRootTimeline.allowOnlyTimelineStyles()) {
        lastRootTimeline.setStyles([finalStyles], null, context.errors, options);
      }
    }
    return timelines.length ? timelines.map((timeline) => timeline.buildKeyframes()) : [createTimelineInstruction(rootElement, [], [], [], 0, delay2, "", false)];
  }
  visitTrigger(ast, context) {
  }
  visitState(ast, context) {
  }
  visitTransition(ast, context) {
  }
  visitAnimateChild(ast, context) {
    const elementInstructions = context.subInstructions.get(context.element);
    if (elementInstructions) {
      const innerContext = context.createSubContext(ast.options);
      const startTime = context.currentTimeline.currentTime;
      const endTime = this._visitSubInstructions(elementInstructions, innerContext, innerContext.options);
      if (startTime != endTime) {
        context.transformIntoNewTimeline(endTime);
      }
    }
    context.previousNode = ast;
  }
  visitAnimateRef(ast, context) {
    const innerContext = context.createSubContext(ast.options);
    innerContext.transformIntoNewTimeline();
    this._applyAnimationRefDelays([ast.options, ast.animation.options], context, innerContext);
    this.visitReference(ast.animation, innerContext);
    context.transformIntoNewTimeline(innerContext.currentTimeline.currentTime);
    context.previousNode = ast;
  }
  _applyAnimationRefDelays(animationsRefsOptions, context, innerContext) {
    for (const animationRefOptions of animationsRefsOptions) {
      const animationDelay = animationRefOptions?.delay;
      if (animationDelay) {
        const animationDelayValue = typeof animationDelay === "number" ? animationDelay : resolveTimingValue(interpolateParams(animationDelay, animationRefOptions?.params ?? {}, context.errors));
        innerContext.delayNextStep(animationDelayValue);
      }
    }
  }
  _visitSubInstructions(instructions, context, options) {
    const startTime = context.currentTimeline.currentTime;
    let furthestTime = startTime;
    const duration = options.duration != null ? resolveTimingValue(options.duration) : null;
    const delay2 = options.delay != null ? resolveTimingValue(options.delay) : null;
    if (duration !== 0) {
      instructions.forEach((instruction) => {
        const instructionTimings = context.appendInstructionToTimeline(instruction, duration, delay2);
        furthestTime = Math.max(furthestTime, instructionTimings.duration + instructionTimings.delay);
      });
    }
    return furthestTime;
  }
  visitReference(ast, context) {
    context.updateOptions(ast.options, true);
    visitDslNode(this, ast.animation, context);
    context.previousNode = ast;
  }
  visitSequence(ast, context) {
    const subContextCount = context.subContextCount;
    let ctx = context;
    const options = ast.options;
    if (options && (options.params || options.delay)) {
      ctx = context.createSubContext(options);
      ctx.transformIntoNewTimeline();
      if (options.delay != null) {
        if (ctx.previousNode.type == AnimationMetadataType.Style) {
          ctx.currentTimeline.snapshotCurrentStyles();
          ctx.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
        }
        const delay2 = resolveTimingValue(options.delay);
        ctx.delayNextStep(delay2);
      }
    }
    if (ast.steps.length) {
      ast.steps.forEach((s) => visitDslNode(this, s, ctx));
      ctx.currentTimeline.applyStylesToKeyframe();
      if (ctx.subContextCount > subContextCount) {
        ctx.transformIntoNewTimeline();
      }
    }
    context.previousNode = ast;
  }
  visitGroup(ast, context) {
    const innerTimelines = [];
    let furthestTime = context.currentTimeline.currentTime;
    const delay2 = ast.options && ast.options.delay ? resolveTimingValue(ast.options.delay) : 0;
    ast.steps.forEach((s) => {
      const innerContext = context.createSubContext(ast.options);
      if (delay2) {
        innerContext.delayNextStep(delay2);
      }
      visitDslNode(this, s, innerContext);
      furthestTime = Math.max(furthestTime, innerContext.currentTimeline.currentTime);
      innerTimelines.push(innerContext.currentTimeline);
    });
    innerTimelines.forEach((timeline) => context.currentTimeline.mergeTimelineCollectedStyles(timeline));
    context.transformIntoNewTimeline(furthestTime);
    context.previousNode = ast;
  }
  _visitTiming(ast, context) {
    if (ast.dynamic) {
      const strValue = ast.strValue;
      const timingValue = context.params ? interpolateParams(strValue, context.params, context.errors) : strValue;
      return resolveTiming(timingValue, context.errors);
    } else {
      return {
        duration: ast.duration,
        delay: ast.delay,
        easing: ast.easing
      };
    }
  }
  visitAnimate(ast, context) {
    const timings = context.currentAnimateTimings = this._visitTiming(ast.timings, context);
    const timeline = context.currentTimeline;
    if (timings.delay) {
      context.incrementTime(timings.delay);
      timeline.snapshotCurrentStyles();
    }
    const style2 = ast.style;
    if (style2.type == AnimationMetadataType.Keyframes) {
      this.visitKeyframes(style2, context);
    } else {
      context.incrementTime(timings.duration);
      this.visitStyle(style2, context);
      timeline.applyStylesToKeyframe();
    }
    context.currentAnimateTimings = null;
    context.previousNode = ast;
  }
  visitStyle(ast, context) {
    const timeline = context.currentTimeline;
    const timings = context.currentAnimateTimings;
    if (!timings && timeline.hasCurrentStyleProperties()) {
      timeline.forwardFrame();
    }
    const easing = timings && timings.easing || ast.easing;
    if (ast.isEmptyStep) {
      timeline.applyEmptyStep(easing);
    } else {
      timeline.setStyles(ast.styles, easing, context.errors, context.options);
    }
    context.previousNode = ast;
  }
  visitKeyframes(ast, context) {
    const currentAnimateTimings = context.currentAnimateTimings;
    const startTime = context.currentTimeline.duration;
    const duration = currentAnimateTimings.duration;
    const innerContext = context.createSubContext();
    const innerTimeline = innerContext.currentTimeline;
    innerTimeline.easing = currentAnimateTimings.easing;
    ast.styles.forEach((step) => {
      const offset = step.offset || 0;
      innerTimeline.forwardTime(offset * duration);
      innerTimeline.setStyles(step.styles, step.easing, context.errors, context.options);
      innerTimeline.applyStylesToKeyframe();
    });
    context.currentTimeline.mergeTimelineCollectedStyles(innerTimeline);
    context.transformIntoNewTimeline(startTime + duration);
    context.previousNode = ast;
  }
  visitQuery(ast, context) {
    const startTime = context.currentTimeline.currentTime;
    const options = ast.options || {};
    const delay2 = options.delay ? resolveTimingValue(options.delay) : 0;
    if (delay2 && (context.previousNode.type === AnimationMetadataType.Style || startTime == 0 && context.currentTimeline.hasCurrentStyleProperties())) {
      context.currentTimeline.snapshotCurrentStyles();
      context.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
    }
    let furthestTime = startTime;
    const elms = context.invokeQuery(ast.selector, ast.originalSelector, ast.limit, ast.includeSelf, options.optional ? true : false, context.errors);
    context.currentQueryTotal = elms.length;
    let sameElementTimeline = null;
    elms.forEach((element, i) => {
      context.currentQueryIndex = i;
      const innerContext = context.createSubContext(ast.options, element);
      if (delay2) {
        innerContext.delayNextStep(delay2);
      }
      if (element === context.element) {
        sameElementTimeline = innerContext.currentTimeline;
      }
      visitDslNode(this, ast.animation, innerContext);
      innerContext.currentTimeline.applyStylesToKeyframe();
      const endTime = innerContext.currentTimeline.currentTime;
      furthestTime = Math.max(furthestTime, endTime);
    });
    context.currentQueryIndex = 0;
    context.currentQueryTotal = 0;
    context.transformIntoNewTimeline(furthestTime);
    if (sameElementTimeline) {
      context.currentTimeline.mergeTimelineCollectedStyles(sameElementTimeline);
      context.currentTimeline.snapshotCurrentStyles();
    }
    context.previousNode = ast;
  }
  visitStagger(ast, context) {
    const parentContext = context.parentContext;
    const tl = context.currentTimeline;
    const timings = ast.timings;
    const duration = Math.abs(timings.duration);
    const maxTime = duration * (context.currentQueryTotal - 1);
    let delay2 = duration * context.currentQueryIndex;
    let staggerTransformer = timings.duration < 0 ? "reverse" : timings.easing;
    switch (staggerTransformer) {
      case "reverse":
        delay2 = maxTime - delay2;
        break;
      case "full":
        delay2 = parentContext.currentStaggerTime;
        break;
    }
    const timeline = context.currentTimeline;
    if (delay2) {
      timeline.delayNextStep(delay2);
    }
    const startingTime = timeline.currentTime;
    visitDslNode(this, ast.animation, context);
    context.previousNode = ast;
    parentContext.currentStaggerTime = tl.currentTime - startingTime + (tl.startTime - parentContext.currentTimeline.startTime);
  }
};
var DEFAULT_NOOP_PREVIOUS_NODE = {};
var AnimationTimelineContext = class _AnimationTimelineContext {
  _driver;
  element;
  subInstructions;
  _enterClassName;
  _leaveClassName;
  errors;
  timelines;
  parentContext = null;
  currentTimeline;
  currentAnimateTimings = null;
  previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
  subContextCount = 0;
  options = {};
  currentQueryIndex = 0;
  currentQueryTotal = 0;
  currentStaggerTime = 0;
  constructor(_driver, element, subInstructions, _enterClassName, _leaveClassName, errors, timelines, initialTimeline) {
    this._driver = _driver;
    this.element = element;
    this.subInstructions = subInstructions;
    this._enterClassName = _enterClassName;
    this._leaveClassName = _leaveClassName;
    this.errors = errors;
    this.timelines = timelines;
    this.currentTimeline = initialTimeline || new TimelineBuilder(this._driver, element, 0);
    timelines.push(this.currentTimeline);
  }
  get params() {
    return this.options.params;
  }
  updateOptions(options, skipIfExists) {
    if (!options) return;
    const newOptions = options;
    let optionsToUpdate = this.options;
    if (newOptions.duration != null) {
      optionsToUpdate.duration = resolveTimingValue(newOptions.duration);
    }
    if (newOptions.delay != null) {
      optionsToUpdate.delay = resolveTimingValue(newOptions.delay);
    }
    const newParams = newOptions.params;
    if (newParams) {
      let paramsToUpdate = optionsToUpdate.params;
      if (!paramsToUpdate) {
        paramsToUpdate = this.options.params = {};
      }
      Object.keys(newParams).forEach((name) => {
        if (!skipIfExists || !paramsToUpdate.hasOwnProperty(name)) {
          paramsToUpdate[name] = interpolateParams(newParams[name], paramsToUpdate, this.errors);
        }
      });
    }
  }
  _copyOptions() {
    const options = {};
    if (this.options) {
      const oldParams = this.options.params;
      if (oldParams) {
        const params = options["params"] = {};
        Object.keys(oldParams).forEach((name) => {
          params[name] = oldParams[name];
        });
      }
    }
    return options;
  }
  createSubContext(options = null, element, newTime) {
    const target = element || this.element;
    const context = new _AnimationTimelineContext(this._driver, target, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(target, newTime || 0));
    context.previousNode = this.previousNode;
    context.currentAnimateTimings = this.currentAnimateTimings;
    context.options = this._copyOptions();
    context.updateOptions(options);
    context.currentQueryIndex = this.currentQueryIndex;
    context.currentQueryTotal = this.currentQueryTotal;
    context.parentContext = this;
    this.subContextCount++;
    return context;
  }
  transformIntoNewTimeline(newTime) {
    this.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
    this.currentTimeline = this.currentTimeline.fork(this.element, newTime);
    this.timelines.push(this.currentTimeline);
    return this.currentTimeline;
  }
  appendInstructionToTimeline(instruction, duration, delay2) {
    const updatedTimings = {
      duration: duration != null ? duration : instruction.duration,
      delay: this.currentTimeline.currentTime + (delay2 != null ? delay2 : 0) + instruction.delay,
      easing: ""
    };
    const builder = new SubTimelineBuilder(this._driver, instruction.element, instruction.keyframes, instruction.preStyleProps, instruction.postStyleProps, updatedTimings, instruction.stretchStartingKeyframe);
    this.timelines.push(builder);
    return updatedTimings;
  }
  incrementTime(time) {
    this.currentTimeline.forwardTime(this.currentTimeline.duration + time);
  }
  delayNextStep(delay2) {
    if (delay2 > 0) {
      this.currentTimeline.delayNextStep(delay2);
    }
  }
  invokeQuery(selector, originalSelector, limit, includeSelf, optional, errors) {
    let results = [];
    if (includeSelf) {
      results.push(this.element);
    }
    if (selector.length > 0) {
      selector = selector.replace(ENTER_TOKEN_REGEX, "." + this._enterClassName);
      selector = selector.replace(LEAVE_TOKEN_REGEX, "." + this._leaveClassName);
      const multi = limit != 1;
      let elements = this._driver.query(this.element, selector, multi);
      if (limit !== 0) {
        elements = limit < 0 ? elements.slice(elements.length + limit, elements.length) : elements.slice(0, limit);
      }
      results.push(...elements);
    }
    if (!optional && results.length == 0) {
      errors.push(invalidQuery(originalSelector));
    }
    return results;
  }
};
var TimelineBuilder = class _TimelineBuilder {
  _driver;
  element;
  startTime;
  _elementTimelineStylesLookup;
  duration = 0;
  easing = null;
  _previousKeyframe = /* @__PURE__ */ new Map();
  _currentKeyframe = /* @__PURE__ */ new Map();
  _keyframes = /* @__PURE__ */ new Map();
  _styleSummary = /* @__PURE__ */ new Map();
  _localTimelineStyles = /* @__PURE__ */ new Map();
  _globalTimelineStyles;
  _pendingStyles = /* @__PURE__ */ new Map();
  _backFill = /* @__PURE__ */ new Map();
  _currentEmptyStepKeyframe = null;
  constructor(_driver, element, startTime, _elementTimelineStylesLookup) {
    this._driver = _driver;
    this.element = element;
    this.startTime = startTime;
    this._elementTimelineStylesLookup = _elementTimelineStylesLookup;
    if (!this._elementTimelineStylesLookup) {
      this._elementTimelineStylesLookup = /* @__PURE__ */ new Map();
    }
    this._globalTimelineStyles = this._elementTimelineStylesLookup.get(element);
    if (!this._globalTimelineStyles) {
      this._globalTimelineStyles = this._localTimelineStyles;
      this._elementTimelineStylesLookup.set(element, this._localTimelineStyles);
    }
    this._loadKeyframe();
  }
  containsAnimation() {
    switch (this._keyframes.size) {
      case 0:
        return false;
      case 1:
        return this.hasCurrentStyleProperties();
      default:
        return true;
    }
  }
  hasCurrentStyleProperties() {
    return this._currentKeyframe.size > 0;
  }
  get currentTime() {
    return this.startTime + this.duration;
  }
  delayNextStep(delay2) {
    const hasPreStyleStep = this._keyframes.size === 1 && this._pendingStyles.size;
    if (this.duration || hasPreStyleStep) {
      this.forwardTime(this.currentTime + delay2);
      if (hasPreStyleStep) {
        this.snapshotCurrentStyles();
      }
    } else {
      this.startTime += delay2;
    }
  }
  fork(element, currentTime) {
    this.applyStylesToKeyframe();
    return new _TimelineBuilder(this._driver, element, currentTime || this.currentTime, this._elementTimelineStylesLookup);
  }
  _loadKeyframe() {
    if (this._currentKeyframe) {
      this._previousKeyframe = this._currentKeyframe;
    }
    this._currentKeyframe = this._keyframes.get(this.duration);
    if (!this._currentKeyframe) {
      this._currentKeyframe = /* @__PURE__ */ new Map();
      this._keyframes.set(this.duration, this._currentKeyframe);
    }
  }
  forwardFrame() {
    this.duration += ONE_FRAME_IN_MILLISECONDS;
    this._loadKeyframe();
  }
  forwardTime(time) {
    this.applyStylesToKeyframe();
    this.duration = time;
    this._loadKeyframe();
  }
  _updateStyle(prop, value) {
    this._localTimelineStyles.set(prop, value);
    this._globalTimelineStyles.set(prop, value);
    this._styleSummary.set(prop, {
      time: this.currentTime,
      value
    });
  }
  allowOnlyTimelineStyles() {
    return this._currentEmptyStepKeyframe !== this._currentKeyframe;
  }
  applyEmptyStep(easing) {
    if (easing) {
      this._previousKeyframe.set("easing", easing);
    }
    for (let [prop, value] of this._globalTimelineStyles) {
      this._backFill.set(prop, value || AUTO_STYLE);
      this._currentKeyframe.set(prop, AUTO_STYLE);
    }
    this._currentEmptyStepKeyframe = this._currentKeyframe;
  }
  setStyles(input2, easing, errors, options) {
    if (easing) {
      this._previousKeyframe.set("easing", easing);
    }
    const params = options && options.params || {};
    const styles = flattenStyles(input2, this._globalTimelineStyles);
    for (let [prop, value] of styles) {
      const val = interpolateParams(value, params, errors);
      this._pendingStyles.set(prop, val);
      if (!this._localTimelineStyles.has(prop)) {
        this._backFill.set(prop, this._globalTimelineStyles.get(prop) ?? AUTO_STYLE);
      }
      this._updateStyle(prop, val);
    }
  }
  applyStylesToKeyframe() {
    if (this._pendingStyles.size == 0) return;
    this._pendingStyles.forEach((val, prop) => {
      this._currentKeyframe.set(prop, val);
    });
    this._pendingStyles.clear();
    this._localTimelineStyles.forEach((val, prop) => {
      if (!this._currentKeyframe.has(prop)) {
        this._currentKeyframe.set(prop, val);
      }
    });
  }
  snapshotCurrentStyles() {
    for (let [prop, val] of this._localTimelineStyles) {
      this._pendingStyles.set(prop, val);
      this._updateStyle(prop, val);
    }
  }
  getFinalKeyframe() {
    return this._keyframes.get(this.duration);
  }
  get properties() {
    const properties = [];
    for (let prop in this._currentKeyframe) {
      properties.push(prop);
    }
    return properties;
  }
  mergeTimelineCollectedStyles(timeline) {
    timeline._styleSummary.forEach((details1, prop) => {
      const details0 = this._styleSummary.get(prop);
      if (!details0 || details1.time > details0.time) {
        this._updateStyle(prop, details1.value);
      }
    });
  }
  buildKeyframes() {
    this.applyStylesToKeyframe();
    const preStyleProps = /* @__PURE__ */ new Set();
    const postStyleProps = /* @__PURE__ */ new Set();
    const isEmpty = this._keyframes.size === 1 && this.duration === 0;
    let finalKeyframes = [];
    this._keyframes.forEach((keyframe, time) => {
      const finalKeyframe = new Map([...this._backFill, ...keyframe]);
      finalKeyframe.forEach((value, prop) => {
        if (value === \u0275PRE_STYLE) {
          preStyleProps.add(prop);
        } else if (value === AUTO_STYLE) {
          postStyleProps.add(prop);
        }
      });
      if (!isEmpty) {
        finalKeyframe.set("offset", time / this.duration);
      }
      finalKeyframes.push(finalKeyframe);
    });
    const preProps = [...preStyleProps.values()];
    const postProps = [...postStyleProps.values()];
    if (isEmpty) {
      const kf0 = finalKeyframes[0];
      const kf1 = new Map(kf0);
      kf0.set("offset", 0);
      kf1.set("offset", 1);
      finalKeyframes = [kf0, kf1];
    }
    return createTimelineInstruction(this.element, finalKeyframes, preProps, postProps, this.duration, this.startTime, this.easing, false);
  }
};
var SubTimelineBuilder = class extends TimelineBuilder {
  keyframes;
  preStyleProps;
  postStyleProps;
  _stretchStartingKeyframe;
  timings;
  constructor(driver, element, keyframes2, preStyleProps, postStyleProps, timings, _stretchStartingKeyframe = false) {
    super(driver, element, timings.delay);
    this.keyframes = keyframes2;
    this.preStyleProps = preStyleProps;
    this.postStyleProps = postStyleProps;
    this._stretchStartingKeyframe = _stretchStartingKeyframe;
    this.timings = {
      duration: timings.duration,
      delay: timings.delay,
      easing: timings.easing
    };
  }
  containsAnimation() {
    return this.keyframes.length > 1;
  }
  buildKeyframes() {
    let keyframes2 = this.keyframes;
    let {
      delay: delay2,
      duration,
      easing
    } = this.timings;
    if (this._stretchStartingKeyframe && delay2) {
      const newKeyframes = [];
      const totalTime = duration + delay2;
      const startingGap = delay2 / totalTime;
      const newFirstKeyframe = new Map(keyframes2[0]);
      newFirstKeyframe.set("offset", 0);
      newKeyframes.push(newFirstKeyframe);
      const oldFirstKeyframe = new Map(keyframes2[0]);
      oldFirstKeyframe.set("offset", roundOffset(startingGap));
      newKeyframes.push(oldFirstKeyframe);
      const limit = keyframes2.length - 1;
      for (let i = 1; i <= limit; i++) {
        let kf = new Map(keyframes2[i]);
        const oldOffset = kf.get("offset");
        const timeAtKeyframe = delay2 + oldOffset * duration;
        kf.set("offset", roundOffset(timeAtKeyframe / totalTime));
        newKeyframes.push(kf);
      }
      duration = totalTime;
      delay2 = 0;
      easing = "";
      keyframes2 = newKeyframes;
    }
    return createTimelineInstruction(this.element, keyframes2, this.preStyleProps, this.postStyleProps, duration, delay2, easing, true);
  }
};
function roundOffset(offset, decimalPoints = 3) {
  const mult = Math.pow(10, decimalPoints - 1);
  return Math.round(offset * mult) / mult;
}
function flattenStyles(input2, allStyles) {
  const styles = /* @__PURE__ */ new Map();
  let allProperties;
  input2.forEach((token) => {
    if (token === "*") {
      allProperties ??= allStyles.keys();
      for (let prop of allProperties) {
        styles.set(prop, AUTO_STYLE);
      }
    } else {
      for (let [prop, val] of token) {
        styles.set(prop, val);
      }
    }
  });
  return styles;
}
function createTransitionInstruction(element, triggerName, fromState, toState, isRemovalTransition, fromStyles, toStyles, timelines, queriedElements, preStyleProps, postStyleProps, totalTime, errors) {
  return {
    type: 0,
    element,
    triggerName,
    isRemovalTransition,
    fromState,
    fromStyles,
    toState,
    toStyles,
    timelines,
    queriedElements,
    preStyleProps,
    postStyleProps,
    totalTime,
    errors
  };
}
var EMPTY_OBJECT = {};
var AnimationTransitionFactory = class {
  _triggerName;
  ast;
  _stateStyles;
  constructor(_triggerName, ast, _stateStyles) {
    this._triggerName = _triggerName;
    this.ast = ast;
    this._stateStyles = _stateStyles;
  }
  match(currentState, nextState, element, params) {
    return oneOrMoreTransitionsMatch(this.ast.matchers, currentState, nextState, element, params);
  }
  buildStyles(stateName, params, errors) {
    let styler = this._stateStyles.get("*");
    if (stateName !== void 0) {
      styler = this._stateStyles.get(stateName?.toString()) || styler;
    }
    return styler ? styler.buildStyles(params, errors) : /* @__PURE__ */ new Map();
  }
  build(driver, element, currentState, nextState, enterClassName, leaveClassName, currentOptions, nextOptions, subInstructions, skipAstBuild) {
    const errors = [];
    const transitionAnimationParams = this.ast.options && this.ast.options.params || EMPTY_OBJECT;
    const currentAnimationParams = currentOptions && currentOptions.params || EMPTY_OBJECT;
    const currentStateStyles = this.buildStyles(currentState, currentAnimationParams, errors);
    const nextAnimationParams = nextOptions && nextOptions.params || EMPTY_OBJECT;
    const nextStateStyles = this.buildStyles(nextState, nextAnimationParams, errors);
    const queriedElements = /* @__PURE__ */ new Set();
    const preStyleMap = /* @__PURE__ */ new Map();
    const postStyleMap = /* @__PURE__ */ new Map();
    const isRemoval = nextState === "void";
    const animationOptions = {
      params: applyParamDefaults(nextAnimationParams, transitionAnimationParams),
      delay: this.ast.options?.delay
    };
    const timelines = skipAstBuild ? [] : buildAnimationTimelines(driver, element, this.ast.animation, enterClassName, leaveClassName, currentStateStyles, nextStateStyles, animationOptions, subInstructions, errors);
    let totalTime = 0;
    timelines.forEach((tl) => {
      totalTime = Math.max(tl.duration + tl.delay, totalTime);
    });
    if (errors.length) {
      return createTransitionInstruction(element, this._triggerName, currentState, nextState, isRemoval, currentStateStyles, nextStateStyles, [], [], preStyleMap, postStyleMap, totalTime, errors);
    }
    timelines.forEach((tl) => {
      const elm = tl.element;
      const preProps = getOrSetDefaultValue(preStyleMap, elm, /* @__PURE__ */ new Set());
      tl.preStyleProps.forEach((prop) => preProps.add(prop));
      const postProps = getOrSetDefaultValue(postStyleMap, elm, /* @__PURE__ */ new Set());
      tl.postStyleProps.forEach((prop) => postProps.add(prop));
      if (elm !== element) {
        queriedElements.add(elm);
      }
    });
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      checkNonAnimatableInTimelines(timelines, this._triggerName, driver);
    }
    return createTransitionInstruction(element, this._triggerName, currentState, nextState, isRemoval, currentStateStyles, nextStateStyles, timelines, [...queriedElements.values()], preStyleMap, postStyleMap, totalTime);
  }
};
function checkNonAnimatableInTimelines(timelines, triggerName, driver) {
  if (!driver.validateAnimatableStyleProperty) {
    return;
  }
  const allowedNonAnimatableProps = /* @__PURE__ */ new Set([
    // 'easing' is a utility/synthetic prop we use to represent
    // easing functions, it represents a property of the animation
    // which is not animatable but different values can be used
    // in different steps
    "easing"
  ]);
  const invalidNonAnimatableProps = /* @__PURE__ */ new Set();
  timelines.forEach(({
    keyframes: keyframes2
  }) => {
    const nonAnimatablePropsInitialValues = /* @__PURE__ */ new Map();
    keyframes2.forEach((keyframe) => {
      const entriesToCheck = Array.from(keyframe.entries()).filter(([prop]) => !allowedNonAnimatableProps.has(prop));
      for (const [prop, value] of entriesToCheck) {
        if (!driver.validateAnimatableStyleProperty(prop)) {
          if (nonAnimatablePropsInitialValues.has(prop) && !invalidNonAnimatableProps.has(prop)) {
            const propInitialValue = nonAnimatablePropsInitialValues.get(prop);
            if (propInitialValue !== value) {
              invalidNonAnimatableProps.add(prop);
            }
          } else {
            nonAnimatablePropsInitialValues.set(prop, value);
          }
        }
      }
    });
  });
  if (invalidNonAnimatableProps.size > 0) {
    console.warn(`Warning: The animation trigger "${triggerName}" is attempting to animate the following not animatable properties: ` + Array.from(invalidNonAnimatableProps).join(", ") + "\n(to check the list of all animatable properties visit https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties)");
  }
}
function oneOrMoreTransitionsMatch(matchFns, currentState, nextState, element, params) {
  return matchFns.some((fn) => fn(currentState, nextState, element, params));
}
function applyParamDefaults(userParams, defaults) {
  const result = __spreadValues({}, defaults);
  Object.entries(userParams).forEach(([key, value]) => {
    if (value != null) {
      result[key] = value;
    }
  });
  return result;
}
var AnimationStateStyles = class {
  styles;
  defaultParams;
  normalizer;
  constructor(styles, defaultParams, normalizer) {
    this.styles = styles;
    this.defaultParams = defaultParams;
    this.normalizer = normalizer;
  }
  buildStyles(params, errors) {
    const finalStyles = /* @__PURE__ */ new Map();
    const combinedParams = applyParamDefaults(params, this.defaultParams);
    this.styles.styles.forEach((value) => {
      if (typeof value !== "string") {
        value.forEach((val, prop) => {
          if (val) {
            val = interpolateParams(val, combinedParams, errors);
          }
          const normalizedProp = this.normalizer.normalizePropertyName(prop, errors);
          val = this.normalizer.normalizeStyleValue(prop, normalizedProp, val, errors);
          finalStyles.set(prop, val);
        });
      }
    });
    return finalStyles;
  }
};
function buildTrigger(name, ast, normalizer) {
  return new AnimationTrigger(name, ast, normalizer);
}
var AnimationTrigger = class {
  name;
  ast;
  _normalizer;
  transitionFactories = [];
  fallbackTransition;
  states = /* @__PURE__ */ new Map();
  constructor(name, ast, _normalizer) {
    this.name = name;
    this.ast = ast;
    this._normalizer = _normalizer;
    ast.states.forEach((ast2) => {
      const defaultParams = ast2.options && ast2.options.params || {};
      this.states.set(ast2.name, new AnimationStateStyles(ast2.style, defaultParams, _normalizer));
    });
    balanceProperties(this.states, "true", "1");
    balanceProperties(this.states, "false", "0");
    ast.transitions.forEach((ast2) => {
      this.transitionFactories.push(new AnimationTransitionFactory(name, ast2, this.states));
    });
    this.fallbackTransition = createFallbackTransition(name, this.states);
  }
  get containsQueries() {
    return this.ast.queryCount > 0;
  }
  matchTransition(currentState, nextState, element, params) {
    const entry = this.transitionFactories.find((f) => f.match(currentState, nextState, element, params));
    return entry || null;
  }
  matchStyles(currentState, params, errors) {
    return this.fallbackTransition.buildStyles(currentState, params, errors);
  }
};
function createFallbackTransition(triggerName, states, normalizer) {
  const matchers = [(fromState, toState) => true];
  const animation2 = {
    type: AnimationMetadataType.Sequence,
    steps: [],
    options: null
  };
  const transition2 = {
    type: AnimationMetadataType.Transition,
    animation: animation2,
    matchers,
    options: null,
    queryCount: 0,
    depCount: 0
  };
  return new AnimationTransitionFactory(triggerName, transition2, states);
}
function balanceProperties(stateMap, key1, key2) {
  if (stateMap.has(key1)) {
    if (!stateMap.has(key2)) {
      stateMap.set(key2, stateMap.get(key1));
    }
  } else if (stateMap.has(key2)) {
    stateMap.set(key1, stateMap.get(key2));
  }
}
var EMPTY_INSTRUCTION_MAP = /* @__PURE__ */ new ElementInstructionMap();
var TimelineAnimationEngine = class {
  bodyNode;
  _driver;
  _normalizer;
  _animations = /* @__PURE__ */ new Map();
  _playersById = /* @__PURE__ */ new Map();
  players = [];
  constructor(bodyNode, _driver, _normalizer) {
    this.bodyNode = bodyNode;
    this._driver = _driver;
    this._normalizer = _normalizer;
  }
  register(id, metadata) {
    const errors = [];
    const warnings = [];
    const ast = buildAnimationAst(this._driver, metadata, errors, warnings);
    if (errors.length) {
      throw registerFailed(errors);
    } else {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        if (warnings.length) {
          warnRegister(warnings);
        }
      }
      this._animations.set(id, ast);
    }
  }
  _buildPlayer(i, preStyles, postStyles) {
    const element = i.element;
    const keyframes2 = normalizeKeyframes$1(this._normalizer, i.keyframes, preStyles, postStyles);
    return this._driver.animate(element, keyframes2, i.duration, i.delay, i.easing, [], true);
  }
  create(id, element, options = {}) {
    const errors = [];
    const ast = this._animations.get(id);
    let instructions;
    const autoStylesMap = /* @__PURE__ */ new Map();
    if (ast) {
      instructions = buildAnimationTimelines(this._driver, element, ast, ENTER_CLASSNAME, LEAVE_CLASSNAME, /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), options, EMPTY_INSTRUCTION_MAP, errors);
      instructions.forEach((inst) => {
        const styles = getOrSetDefaultValue(autoStylesMap, inst.element, /* @__PURE__ */ new Map());
        inst.postStyleProps.forEach((prop) => styles.set(prop, null));
      });
    } else {
      errors.push(missingOrDestroyedAnimation());
      instructions = [];
    }
    if (errors.length) {
      throw createAnimationFailed(errors);
    }
    autoStylesMap.forEach((styles, element2) => {
      styles.forEach((_, prop) => {
        styles.set(prop, this._driver.computeStyle(element2, prop, AUTO_STYLE));
      });
    });
    const players = instructions.map((i) => {
      const styles = autoStylesMap.get(i.element);
      return this._buildPlayer(i, /* @__PURE__ */ new Map(), styles);
    });
    const player = optimizeGroupPlayer(players);
    this._playersById.set(id, player);
    player.onDestroy(() => this.destroy(id));
    this.players.push(player);
    return player;
  }
  destroy(id) {
    const player = this._getPlayer(id);
    player.destroy();
    this._playersById.delete(id);
    const index = this.players.indexOf(player);
    if (index >= 0) {
      this.players.splice(index, 1);
    }
  }
  _getPlayer(id) {
    const player = this._playersById.get(id);
    if (!player) {
      throw missingPlayer(id);
    }
    return player;
  }
  listen(id, element, eventName, callback) {
    const baseEvent = makeAnimationEvent(element, "", "", "");
    listenOnPlayer(this._getPlayer(id), eventName, baseEvent, callback);
    return () => {
    };
  }
  command(id, element, command, args) {
    if (command == "register") {
      this.register(id, args[0]);
      return;
    }
    if (command == "create") {
      const options = args[0] || {};
      this.create(id, element, options);
      return;
    }
    const player = this._getPlayer(id);
    switch (command) {
      case "play":
        player.play();
        break;
      case "pause":
        player.pause();
        break;
      case "reset":
        player.reset();
        break;
      case "restart":
        player.restart();
        break;
      case "finish":
        player.finish();
        break;
      case "init":
        player.init();
        break;
      case "setPosition":
        player.setPosition(parseFloat(args[0]));
        break;
      case "destroy":
        this.destroy(id);
        break;
    }
  }
};
var QUEUED_CLASSNAME = "ng-animate-queued";
var QUEUED_SELECTOR = ".ng-animate-queued";
var DISABLED_CLASSNAME = "ng-animate-disabled";
var DISABLED_SELECTOR = ".ng-animate-disabled";
var STAR_CLASSNAME = "ng-star-inserted";
var STAR_SELECTOR = ".ng-star-inserted";
var EMPTY_PLAYER_ARRAY = [];
var NULL_REMOVAL_STATE = {
  namespaceId: "",
  setForRemoval: false,
  setForMove: false,
  hasAnimation: false,
  removedBeforeQueried: false
};
var NULL_REMOVED_QUERIED_STATE = {
  namespaceId: "",
  setForMove: false,
  setForRemoval: false,
  hasAnimation: false,
  removedBeforeQueried: true
};
var REMOVAL_FLAG = "__ng_removed";
var StateValue = class {
  namespaceId;
  value;
  options;
  get params() {
    return this.options.params;
  }
  constructor(input2, namespaceId = "") {
    this.namespaceId = namespaceId;
    const isObj = input2 && input2.hasOwnProperty("value");
    const value = isObj ? input2["value"] : input2;
    this.value = normalizeTriggerValue(value);
    if (isObj) {
      const _a = input2, {
        value: value2
      } = _a, options = __objRest(_a, [
        "value"
      ]);
      this.options = options;
    } else {
      this.options = {};
    }
    if (!this.options.params) {
      this.options.params = {};
    }
  }
  absorbOptions(options) {
    const newParams = options.params;
    if (newParams) {
      const oldParams = this.options.params;
      Object.keys(newParams).forEach((prop) => {
        if (oldParams[prop] == null) {
          oldParams[prop] = newParams[prop];
        }
      });
    }
  }
};
var VOID_VALUE = "void";
var DEFAULT_STATE_VALUE = /* @__PURE__ */ new StateValue(VOID_VALUE);
var AnimationTransitionNamespace = class {
  id;
  hostElement;
  _engine;
  players = [];
  _triggers = /* @__PURE__ */ new Map();
  _queue = [];
  _elementListeners = /* @__PURE__ */ new Map();
  _hostClassName;
  constructor(id, hostElement, _engine) {
    this.id = id;
    this.hostElement = hostElement;
    this._engine = _engine;
    this._hostClassName = "ng-tns-" + id;
    addClass(hostElement, this._hostClassName);
  }
  listen(element, name, phase, callback) {
    if (!this._triggers.has(name)) {
      throw missingTrigger(phase, name);
    }
    if (phase == null || phase.length == 0) {
      throw missingEvent(name);
    }
    if (!isTriggerEventValid(phase)) {
      throw unsupportedTriggerEvent(phase, name);
    }
    const listeners = getOrSetDefaultValue(this._elementListeners, element, []);
    const data = {
      name,
      phase,
      callback
    };
    listeners.push(data);
    const triggersWithStates = getOrSetDefaultValue(this._engine.statesByElement, element, /* @__PURE__ */ new Map());
    if (!triggersWithStates.has(name)) {
      addClass(element, NG_TRIGGER_CLASSNAME);
      addClass(element, NG_TRIGGER_CLASSNAME + "-" + name);
      triggersWithStates.set(name, DEFAULT_STATE_VALUE);
    }
    return () => {
      this._engine.afterFlush(() => {
        const index = listeners.indexOf(data);
        if (index >= 0) {
          listeners.splice(index, 1);
        }
        if (!this._triggers.has(name)) {
          triggersWithStates.delete(name);
        }
      });
    };
  }
  register(name, ast) {
    if (this._triggers.has(name)) {
      return false;
    } else {
      this._triggers.set(name, ast);
      return true;
    }
  }
  _getTrigger(name) {
    const trigger2 = this._triggers.get(name);
    if (!trigger2) {
      throw unregisteredTrigger(name);
    }
    return trigger2;
  }
  trigger(element, triggerName, value, defaultToFallback = true) {
    const trigger2 = this._getTrigger(triggerName);
    const player = new TransitionAnimationPlayer(this.id, triggerName, element);
    let triggersWithStates = this._engine.statesByElement.get(element);
    if (!triggersWithStates) {
      addClass(element, NG_TRIGGER_CLASSNAME);
      addClass(element, NG_TRIGGER_CLASSNAME + "-" + triggerName);
      this._engine.statesByElement.set(element, triggersWithStates = /* @__PURE__ */ new Map());
    }
    let fromState = triggersWithStates.get(triggerName);
    const toState = new StateValue(value, this.id);
    const isObj = value && value.hasOwnProperty("value");
    if (!isObj && fromState) {
      toState.absorbOptions(fromState.options);
    }
    triggersWithStates.set(triggerName, toState);
    if (!fromState) {
      fromState = DEFAULT_STATE_VALUE;
    }
    const isRemoval = toState.value === VOID_VALUE;
    if (!isRemoval && fromState.value === toState.value) {
      if (!objEquals(fromState.params, toState.params)) {
        const errors = [];
        const fromStyles = trigger2.matchStyles(fromState.value, fromState.params, errors);
        const toStyles = trigger2.matchStyles(toState.value, toState.params, errors);
        if (errors.length) {
          this._engine.reportError(errors);
        } else {
          this._engine.afterFlush(() => {
            eraseStyles(element, fromStyles);
            setStyles(element, toStyles);
          });
        }
      }
      return;
    }
    const playersOnElement = getOrSetDefaultValue(this._engine.playersByElement, element, []);
    playersOnElement.forEach((player2) => {
      if (player2.namespaceId == this.id && player2.triggerName == triggerName && player2.queued) {
        player2.destroy();
      }
    });
    let transition2 = trigger2.matchTransition(fromState.value, toState.value, element, toState.params);
    let isFallbackTransition = false;
    if (!transition2) {
      if (!defaultToFallback) return;
      transition2 = trigger2.fallbackTransition;
      isFallbackTransition = true;
    }
    this._engine.totalQueuedPlayers++;
    this._queue.push({
      element,
      triggerName,
      transition: transition2,
      fromState,
      toState,
      player,
      isFallbackTransition
    });
    if (!isFallbackTransition) {
      addClass(element, QUEUED_CLASSNAME);
      player.onStart(() => {
        removeClass(element, QUEUED_CLASSNAME);
      });
    }
    player.onDone(() => {
      let index = this.players.indexOf(player);
      if (index >= 0) {
        this.players.splice(index, 1);
      }
      const players = this._engine.playersByElement.get(element);
      if (players) {
        let index2 = players.indexOf(player);
        if (index2 >= 0) {
          players.splice(index2, 1);
        }
      }
    });
    this.players.push(player);
    playersOnElement.push(player);
    return player;
  }
  deregister(name) {
    this._triggers.delete(name);
    this._engine.statesByElement.forEach((stateMap) => stateMap.delete(name));
    this._elementListeners.forEach((listeners, element) => {
      this._elementListeners.set(element, listeners.filter((entry) => {
        return entry.name != name;
      }));
    });
  }
  clearElementCache(element) {
    this._engine.statesByElement.delete(element);
    this._elementListeners.delete(element);
    const elementPlayers = this._engine.playersByElement.get(element);
    if (elementPlayers) {
      elementPlayers.forEach((player) => player.destroy());
      this._engine.playersByElement.delete(element);
    }
  }
  _signalRemovalForInnerTriggers(rootElement, context) {
    const elements = this._engine.driver.query(rootElement, NG_TRIGGER_SELECTOR, true);
    elements.forEach((elm) => {
      if (elm[REMOVAL_FLAG]) return;
      const namespaces = this._engine.fetchNamespacesByElement(elm);
      if (namespaces.size) {
        namespaces.forEach((ns) => ns.triggerLeaveAnimation(elm, context, false, true));
      } else {
        this.clearElementCache(elm);
      }
    });
    this._engine.afterFlushAnimationsDone(() => elements.forEach((elm) => this.clearElementCache(elm)));
  }
  triggerLeaveAnimation(element, context, destroyAfterComplete, defaultToFallback) {
    const triggerStates = this._engine.statesByElement.get(element);
    const previousTriggersValues = /* @__PURE__ */ new Map();
    if (triggerStates) {
      const players = [];
      triggerStates.forEach((state2, triggerName) => {
        previousTriggersValues.set(triggerName, state2.value);
        if (this._triggers.has(triggerName)) {
          const player = this.trigger(element, triggerName, VOID_VALUE, defaultToFallback);
          if (player) {
            players.push(player);
          }
        }
      });
      if (players.length) {
        this._engine.markElementAsRemoved(this.id, element, true, context, previousTriggersValues);
        if (destroyAfterComplete) {
          optimizeGroupPlayer(players).onDone(() => this._engine.processLeaveNode(element));
        }
        return true;
      }
    }
    return false;
  }
  prepareLeaveAnimationListeners(element) {
    const listeners = this._elementListeners.get(element);
    const elementStates = this._engine.statesByElement.get(element);
    if (listeners && elementStates) {
      const visitedTriggers = /* @__PURE__ */ new Set();
      listeners.forEach((listener) => {
        const triggerName = listener.name;
        if (visitedTriggers.has(triggerName)) return;
        visitedTriggers.add(triggerName);
        const trigger2 = this._triggers.get(triggerName);
        const transition2 = trigger2.fallbackTransition;
        const fromState = elementStates.get(triggerName) || DEFAULT_STATE_VALUE;
        const toState = new StateValue(VOID_VALUE);
        const player = new TransitionAnimationPlayer(this.id, triggerName, element);
        this._engine.totalQueuedPlayers++;
        this._queue.push({
          element,
          triggerName,
          transition: transition2,
          fromState,
          toState,
          player,
          isFallbackTransition: true
        });
      });
    }
  }
  removeNode(element, context) {
    const engine = this._engine;
    if (element.childElementCount) {
      this._signalRemovalForInnerTriggers(element, context);
    }
    if (this.triggerLeaveAnimation(element, context, true)) return;
    let containsPotentialParentTransition = false;
    if (engine.totalAnimations) {
      const currentPlayers = engine.players.length ? engine.playersByQueriedElement.get(element) : [];
      if (currentPlayers && currentPlayers.length) {
        containsPotentialParentTransition = true;
      } else {
        let parent = element;
        while (parent = parent.parentNode) {
          const triggers = engine.statesByElement.get(parent);
          if (triggers) {
            containsPotentialParentTransition = true;
            break;
          }
        }
      }
    }
    this.prepareLeaveAnimationListeners(element);
    if (containsPotentialParentTransition) {
      engine.markElementAsRemoved(this.id, element, false, context);
    } else {
      const removalFlag = element[REMOVAL_FLAG];
      if (!removalFlag || removalFlag === NULL_REMOVAL_STATE) {
        engine.afterFlush(() => this.clearElementCache(element));
        engine.destroyInnerAnimations(element);
        engine._onRemovalComplete(element, context);
      }
    }
  }
  insertNode(element, parent) {
    addClass(element, this._hostClassName);
  }
  drainQueuedTransitions(microtaskId) {
    const instructions = [];
    this._queue.forEach((entry) => {
      const player = entry.player;
      if (player.destroyed) return;
      const element = entry.element;
      const listeners = this._elementListeners.get(element);
      if (listeners) {
        listeners.forEach((listener) => {
          if (listener.name == entry.triggerName) {
            const baseEvent = makeAnimationEvent(element, entry.triggerName, entry.fromState.value, entry.toState.value);
            baseEvent["_data"] = microtaskId;
            listenOnPlayer(entry.player, listener.phase, baseEvent, listener.callback);
          }
        });
      }
      if (player.markedForDestroy) {
        this._engine.afterFlush(() => {
          player.destroy();
        });
      } else {
        instructions.push(entry);
      }
    });
    this._queue = [];
    return instructions.sort((a, b) => {
      const d0 = a.transition.ast.depCount;
      const d1 = b.transition.ast.depCount;
      if (d0 == 0 || d1 == 0) {
        return d0 - d1;
      }
      return this._engine.driver.containsElement(a.element, b.element) ? 1 : -1;
    });
  }
  destroy(context) {
    this.players.forEach((p) => p.destroy());
    this._signalRemovalForInnerTriggers(this.hostElement, context);
  }
};
var TransitionAnimationEngine = class {
  bodyNode;
  driver;
  _normalizer;
  players = [];
  newHostElements = /* @__PURE__ */ new Map();
  playersByElement = /* @__PURE__ */ new Map();
  playersByQueriedElement = /* @__PURE__ */ new Map();
  statesByElement = /* @__PURE__ */ new Map();
  disabledNodes = /* @__PURE__ */ new Set();
  totalAnimations = 0;
  totalQueuedPlayers = 0;
  _namespaceLookup = {};
  _namespaceList = [];
  _flushFns = [];
  _whenQuietFns = [];
  namespacesByHostElement = /* @__PURE__ */ new Map();
  collectedEnterElements = [];
  collectedLeaveElements = [];
  // this method is designed to be overridden by the code that uses this engine
  onRemovalComplete = (element, context) => {
  };
  /** @internal */
  _onRemovalComplete(element, context) {
    this.onRemovalComplete(element, context);
  }
  constructor(bodyNode, driver, _normalizer) {
    this.bodyNode = bodyNode;
    this.driver = driver;
    this._normalizer = _normalizer;
  }
  get queuedPlayers() {
    const players = [];
    this._namespaceList.forEach((ns) => {
      ns.players.forEach((player) => {
        if (player.queued) {
          players.push(player);
        }
      });
    });
    return players;
  }
  createNamespace(namespaceId, hostElement) {
    const ns = new AnimationTransitionNamespace(namespaceId, hostElement, this);
    if (this.bodyNode && this.driver.containsElement(this.bodyNode, hostElement)) {
      this._balanceNamespaceList(ns, hostElement);
    } else {
      this.newHostElements.set(hostElement, ns);
      this.collectEnterElement(hostElement);
    }
    return this._namespaceLookup[namespaceId] = ns;
  }
  _balanceNamespaceList(ns, hostElement) {
    const namespaceList = this._namespaceList;
    const namespacesByHostElement = this.namespacesByHostElement;
    const limit = namespaceList.length - 1;
    if (limit >= 0) {
      let found = false;
      let ancestor = this.driver.getParentElement(hostElement);
      while (ancestor) {
        const ancestorNs = namespacesByHostElement.get(ancestor);
        if (ancestorNs) {
          const index = namespaceList.indexOf(ancestorNs);
          namespaceList.splice(index + 1, 0, ns);
          found = true;
          break;
        }
        ancestor = this.driver.getParentElement(ancestor);
      }
      if (!found) {
        namespaceList.unshift(ns);
      }
    } else {
      namespaceList.push(ns);
    }
    namespacesByHostElement.set(hostElement, ns);
    return ns;
  }
  register(namespaceId, hostElement) {
    let ns = this._namespaceLookup[namespaceId];
    if (!ns) {
      ns = this.createNamespace(namespaceId, hostElement);
    }
    return ns;
  }
  registerTrigger(namespaceId, name, trigger2) {
    let ns = this._namespaceLookup[namespaceId];
    if (ns && ns.register(name, trigger2)) {
      this.totalAnimations++;
    }
  }
  destroy(namespaceId, context) {
    if (!namespaceId) return;
    this.afterFlush(() => {
    });
    this.afterFlushAnimationsDone(() => {
      const ns = this._fetchNamespace(namespaceId);
      this.namespacesByHostElement.delete(ns.hostElement);
      const index = this._namespaceList.indexOf(ns);
      if (index >= 0) {
        this._namespaceList.splice(index, 1);
      }
      ns.destroy(context);
      delete this._namespaceLookup[namespaceId];
    });
  }
  _fetchNamespace(id) {
    return this._namespaceLookup[id];
  }
  fetchNamespacesByElement(element) {
    const namespaces = /* @__PURE__ */ new Set();
    const elementStates = this.statesByElement.get(element);
    if (elementStates) {
      for (let stateValue of elementStates.values()) {
        if (stateValue.namespaceId) {
          const ns = this._fetchNamespace(stateValue.namespaceId);
          if (ns) {
            namespaces.add(ns);
          }
        }
      }
    }
    return namespaces;
  }
  trigger(namespaceId, element, name, value) {
    if (isElementNode(element)) {
      const ns = this._fetchNamespace(namespaceId);
      if (ns) {
        ns.trigger(element, name, value);
        return true;
      }
    }
    return false;
  }
  insertNode(namespaceId, element, parent, insertBefore) {
    if (!isElementNode(element)) return;
    const details = element[REMOVAL_FLAG];
    if (details && details.setForRemoval) {
      details.setForRemoval = false;
      details.setForMove = true;
      const index = this.collectedLeaveElements.indexOf(element);
      if (index >= 0) {
        this.collectedLeaveElements.splice(index, 1);
      }
    }
    if (namespaceId) {
      const ns = this._fetchNamespace(namespaceId);
      if (ns) {
        ns.insertNode(element, parent);
      }
    }
    if (insertBefore) {
      this.collectEnterElement(element);
    }
  }
  collectEnterElement(element) {
    this.collectedEnterElements.push(element);
  }
  markElementAsDisabled(element, value) {
    if (value) {
      if (!this.disabledNodes.has(element)) {
        this.disabledNodes.add(element);
        addClass(element, DISABLED_CLASSNAME);
      }
    } else if (this.disabledNodes.has(element)) {
      this.disabledNodes.delete(element);
      removeClass(element, DISABLED_CLASSNAME);
    }
  }
  removeNode(namespaceId, element, context) {
    if (isElementNode(element)) {
      const ns = namespaceId ? this._fetchNamespace(namespaceId) : null;
      if (ns) {
        ns.removeNode(element, context);
      } else {
        this.markElementAsRemoved(namespaceId, element, false, context);
      }
      const hostNS = this.namespacesByHostElement.get(element);
      if (hostNS && hostNS.id !== namespaceId) {
        hostNS.removeNode(element, context);
      }
    } else {
      this._onRemovalComplete(element, context);
    }
  }
  markElementAsRemoved(namespaceId, element, hasAnimation, context, previousTriggersValues) {
    this.collectedLeaveElements.push(element);
    element[REMOVAL_FLAG] = {
      namespaceId,
      setForRemoval: context,
      hasAnimation,
      removedBeforeQueried: false,
      previousTriggersValues
    };
  }
  listen(namespaceId, element, name, phase, callback) {
    if (isElementNode(element)) {
      return this._fetchNamespace(namespaceId).listen(element, name, phase, callback);
    }
    return () => {
    };
  }
  _buildInstruction(entry, subTimelines, enterClassName, leaveClassName, skipBuildAst) {
    return entry.transition.build(this.driver, entry.element, entry.fromState.value, entry.toState.value, enterClassName, leaveClassName, entry.fromState.options, entry.toState.options, subTimelines, skipBuildAst);
  }
  destroyInnerAnimations(containerElement) {
    let elements = this.driver.query(containerElement, NG_TRIGGER_SELECTOR, true);
    elements.forEach((element) => this.destroyActiveAnimationsForElement(element));
    if (this.playersByQueriedElement.size == 0) return;
    elements = this.driver.query(containerElement, NG_ANIMATING_SELECTOR, true);
    elements.forEach((element) => this.finishActiveQueriedAnimationOnElement(element));
  }
  destroyActiveAnimationsForElement(element) {
    const players = this.playersByElement.get(element);
    if (players) {
      players.forEach((player) => {
        if (player.queued) {
          player.markedForDestroy = true;
        } else {
          player.destroy();
        }
      });
    }
  }
  finishActiveQueriedAnimationOnElement(element) {
    const players = this.playersByQueriedElement.get(element);
    if (players) {
      players.forEach((player) => player.finish());
    }
  }
  whenRenderingDone() {
    return new Promise((resolve) => {
      if (this.players.length) {
        return optimizeGroupPlayer(this.players).onDone(() => resolve());
      } else {
        resolve();
      }
    });
  }
  processLeaveNode(element) {
    const details = element[REMOVAL_FLAG];
    if (details && details.setForRemoval) {
      element[REMOVAL_FLAG] = NULL_REMOVAL_STATE;
      if (details.namespaceId) {
        this.destroyInnerAnimations(element);
        const ns = this._fetchNamespace(details.namespaceId);
        if (ns) {
          ns.clearElementCache(element);
        }
      }
      this._onRemovalComplete(element, details.setForRemoval);
    }
    if (element.classList?.contains(DISABLED_CLASSNAME)) {
      this.markElementAsDisabled(element, false);
    }
    this.driver.query(element, DISABLED_SELECTOR, true).forEach((node) => {
      this.markElementAsDisabled(node, false);
    });
  }
  flush(microtaskId = -1) {
    let players = [];
    if (this.newHostElements.size) {
      this.newHostElements.forEach((ns, element) => this._balanceNamespaceList(ns, element));
      this.newHostElements.clear();
    }
    if (this.totalAnimations && this.collectedEnterElements.length) {
      for (let i = 0; i < this.collectedEnterElements.length; i++) {
        const elm = this.collectedEnterElements[i];
        addClass(elm, STAR_CLASSNAME);
      }
    }
    if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) {
      const cleanupFns = [];
      try {
        players = this._flushAnimations(cleanupFns, microtaskId);
      } finally {
        for (let i = 0; i < cleanupFns.length; i++) {
          cleanupFns[i]();
        }
      }
    } else {
      for (let i = 0; i < this.collectedLeaveElements.length; i++) {
        const element = this.collectedLeaveElements[i];
        this.processLeaveNode(element);
      }
    }
    this.totalQueuedPlayers = 0;
    this.collectedEnterElements.length = 0;
    this.collectedLeaveElements.length = 0;
    this._flushFns.forEach((fn) => fn());
    this._flushFns = [];
    if (this._whenQuietFns.length) {
      const quietFns = this._whenQuietFns;
      this._whenQuietFns = [];
      if (players.length) {
        optimizeGroupPlayer(players).onDone(() => {
          quietFns.forEach((fn) => fn());
        });
      } else {
        quietFns.forEach((fn) => fn());
      }
    }
  }
  reportError(errors) {
    throw triggerTransitionsFailed(errors);
  }
  _flushAnimations(cleanupFns, microtaskId) {
    const subTimelines = new ElementInstructionMap();
    const skippedPlayers = [];
    const skippedPlayersMap = /* @__PURE__ */ new Map();
    const queuedInstructions = [];
    const queriedElements = /* @__PURE__ */ new Map();
    const allPreStyleElements = /* @__PURE__ */ new Map();
    const allPostStyleElements = /* @__PURE__ */ new Map();
    const disabledElementsSet = /* @__PURE__ */ new Set();
    this.disabledNodes.forEach((node) => {
      disabledElementsSet.add(node);
      const nodesThatAreDisabled = this.driver.query(node, QUEUED_SELECTOR, true);
      for (let i2 = 0; i2 < nodesThatAreDisabled.length; i2++) {
        disabledElementsSet.add(nodesThatAreDisabled[i2]);
      }
    });
    const bodyNode = this.bodyNode;
    const allTriggerElements = Array.from(this.statesByElement.keys());
    const enterNodeMap = buildRootMap(allTriggerElements, this.collectedEnterElements);
    const enterNodeMapIds = /* @__PURE__ */ new Map();
    let i = 0;
    enterNodeMap.forEach((nodes, root) => {
      const className = ENTER_CLASSNAME + i++;
      enterNodeMapIds.set(root, className);
      nodes.forEach((node) => addClass(node, className));
    });
    const allLeaveNodes = [];
    const mergedLeaveNodes = /* @__PURE__ */ new Set();
    const leaveNodesWithoutAnimations = /* @__PURE__ */ new Set();
    for (let i2 = 0; i2 < this.collectedLeaveElements.length; i2++) {
      const element = this.collectedLeaveElements[i2];
      const details = element[REMOVAL_FLAG];
      if (details && details.setForRemoval) {
        allLeaveNodes.push(element);
        mergedLeaveNodes.add(element);
        if (details.hasAnimation) {
          this.driver.query(element, STAR_SELECTOR, true).forEach((elm) => mergedLeaveNodes.add(elm));
        } else {
          leaveNodesWithoutAnimations.add(element);
        }
      }
    }
    const leaveNodeMapIds = /* @__PURE__ */ new Map();
    const leaveNodeMap = buildRootMap(allTriggerElements, Array.from(mergedLeaveNodes));
    leaveNodeMap.forEach((nodes, root) => {
      const className = LEAVE_CLASSNAME + i++;
      leaveNodeMapIds.set(root, className);
      nodes.forEach((node) => addClass(node, className));
    });
    cleanupFns.push(() => {
      enterNodeMap.forEach((nodes, root) => {
        const className = enterNodeMapIds.get(root);
        nodes.forEach((node) => removeClass(node, className));
      });
      leaveNodeMap.forEach((nodes, root) => {
        const className = leaveNodeMapIds.get(root);
        nodes.forEach((node) => removeClass(node, className));
      });
      allLeaveNodes.forEach((element) => {
        this.processLeaveNode(element);
      });
    });
    const allPlayers = [];
    const erroneousTransitions = [];
    for (let i2 = this._namespaceList.length - 1; i2 >= 0; i2--) {
      const ns = this._namespaceList[i2];
      ns.drainQueuedTransitions(microtaskId).forEach((entry) => {
        const player = entry.player;
        const element = entry.element;
        allPlayers.push(player);
        if (this.collectedEnterElements.length) {
          const details = element[REMOVAL_FLAG];
          if (details && details.setForMove) {
            if (details.previousTriggersValues && details.previousTriggersValues.has(entry.triggerName)) {
              const previousValue = details.previousTriggersValues.get(entry.triggerName);
              const triggersWithStates = this.statesByElement.get(entry.element);
              if (triggersWithStates && triggersWithStates.has(entry.triggerName)) {
                const state2 = triggersWithStates.get(entry.triggerName);
                state2.value = previousValue;
                triggersWithStates.set(entry.triggerName, state2);
              }
            }
            player.destroy();
            return;
          }
        }
        const nodeIsOrphaned = !bodyNode || !this.driver.containsElement(bodyNode, element);
        const leaveClassName = leaveNodeMapIds.get(element);
        const enterClassName = enterNodeMapIds.get(element);
        const instruction = this._buildInstruction(entry, subTimelines, enterClassName, leaveClassName, nodeIsOrphaned);
        if (instruction.errors && instruction.errors.length) {
          erroneousTransitions.push(instruction);
          return;
        }
        if (nodeIsOrphaned) {
          player.onStart(() => eraseStyles(element, instruction.fromStyles));
          player.onDestroy(() => setStyles(element, instruction.toStyles));
          skippedPlayers.push(player);
          return;
        }
        if (entry.isFallbackTransition) {
          player.onStart(() => eraseStyles(element, instruction.fromStyles));
          player.onDestroy(() => setStyles(element, instruction.toStyles));
          skippedPlayers.push(player);
          return;
        }
        const timelines = [];
        instruction.timelines.forEach((tl) => {
          tl.stretchStartingKeyframe = true;
          if (!this.disabledNodes.has(tl.element)) {
            timelines.push(tl);
          }
        });
        instruction.timelines = timelines;
        subTimelines.append(element, instruction.timelines);
        const tuple = {
          instruction,
          player,
          element
        };
        queuedInstructions.push(tuple);
        instruction.queriedElements.forEach((element2) => getOrSetDefaultValue(queriedElements, element2, []).push(player));
        instruction.preStyleProps.forEach((stringMap, element2) => {
          if (stringMap.size) {
            let setVal = allPreStyleElements.get(element2);
            if (!setVal) {
              allPreStyleElements.set(element2, setVal = /* @__PURE__ */ new Set());
            }
            stringMap.forEach((_, prop) => setVal.add(prop));
          }
        });
        instruction.postStyleProps.forEach((stringMap, element2) => {
          let setVal = allPostStyleElements.get(element2);
          if (!setVal) {
            allPostStyleElements.set(element2, setVal = /* @__PURE__ */ new Set());
          }
          stringMap.forEach((_, prop) => setVal.add(prop));
        });
      });
    }
    if (erroneousTransitions.length) {
      const errors = [];
      erroneousTransitions.forEach((instruction) => {
        errors.push(transitionFailed(instruction.triggerName, instruction.errors));
      });
      allPlayers.forEach((player) => player.destroy());
      this.reportError(errors);
    }
    const allPreviousPlayersMap = /* @__PURE__ */ new Map();
    const animationElementMap = /* @__PURE__ */ new Map();
    queuedInstructions.forEach((entry) => {
      const element = entry.element;
      if (subTimelines.has(element)) {
        animationElementMap.set(element, element);
        this._beforeAnimationBuild(entry.player.namespaceId, entry.instruction, allPreviousPlayersMap);
      }
    });
    skippedPlayers.forEach((player) => {
      const element = player.element;
      const previousPlayers = this._getPreviousPlayers(element, false, player.namespaceId, player.triggerName, null);
      previousPlayers.forEach((prevPlayer) => {
        getOrSetDefaultValue(allPreviousPlayersMap, element, []).push(prevPlayer);
        prevPlayer.destroy();
      });
    });
    const replaceNodes = allLeaveNodes.filter((node) => {
      return replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements);
    });
    const postStylesMap = /* @__PURE__ */ new Map();
    const allLeaveQueriedNodes = cloakAndComputeStyles(postStylesMap, this.driver, leaveNodesWithoutAnimations, allPostStyleElements, AUTO_STYLE);
    allLeaveQueriedNodes.forEach((node) => {
      if (replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements)) {
        replaceNodes.push(node);
      }
    });
    const preStylesMap = /* @__PURE__ */ new Map();
    enterNodeMap.forEach((nodes, root) => {
      cloakAndComputeStyles(preStylesMap, this.driver, new Set(nodes), allPreStyleElements, \u0275PRE_STYLE);
    });
    replaceNodes.forEach((node) => {
      const post = postStylesMap.get(node);
      const pre = preStylesMap.get(node);
      postStylesMap.set(node, new Map([...post?.entries() ?? [], ...pre?.entries() ?? []]));
    });
    const rootPlayers = [];
    const subPlayers = [];
    const NO_PARENT_ANIMATION_ELEMENT_DETECTED = {};
    queuedInstructions.forEach((entry) => {
      const {
        element,
        player,
        instruction
      } = entry;
      if (subTimelines.has(element)) {
        if (disabledElementsSet.has(element)) {
          player.onDestroy(() => setStyles(element, instruction.toStyles));
          player.disabled = true;
          player.overrideTotalTime(instruction.totalTime);
          skippedPlayers.push(player);
          return;
        }
        let parentWithAnimation = NO_PARENT_ANIMATION_ELEMENT_DETECTED;
        if (animationElementMap.size > 1) {
          let elm = element;
          const parentsToAdd = [];
          while (elm = elm.parentNode) {
            const detectedParent = animationElementMap.get(elm);
            if (detectedParent) {
              parentWithAnimation = detectedParent;
              break;
            }
            parentsToAdd.push(elm);
          }
          parentsToAdd.forEach((parent) => animationElementMap.set(parent, parentWithAnimation));
        }
        const innerPlayer = this._buildAnimation(player.namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap, postStylesMap);
        player.setRealPlayer(innerPlayer);
        if (parentWithAnimation === NO_PARENT_ANIMATION_ELEMENT_DETECTED) {
          rootPlayers.push(player);
        } else {
          const parentPlayers = this.playersByElement.get(parentWithAnimation);
          if (parentPlayers && parentPlayers.length) {
            player.parentPlayer = optimizeGroupPlayer(parentPlayers);
          }
          skippedPlayers.push(player);
        }
      } else {
        eraseStyles(element, instruction.fromStyles);
        player.onDestroy(() => setStyles(element, instruction.toStyles));
        subPlayers.push(player);
        if (disabledElementsSet.has(element)) {
          skippedPlayers.push(player);
        }
      }
    });
    subPlayers.forEach((player) => {
      const playersForElement = skippedPlayersMap.get(player.element);
      if (playersForElement && playersForElement.length) {
        const innerPlayer = optimizeGroupPlayer(playersForElement);
        player.setRealPlayer(innerPlayer);
      }
    });
    skippedPlayers.forEach((player) => {
      if (player.parentPlayer) {
        player.syncPlayerEvents(player.parentPlayer);
      } else {
        player.destroy();
      }
    });
    for (let i2 = 0; i2 < allLeaveNodes.length; i2++) {
      const element = allLeaveNodes[i2];
      const details = element[REMOVAL_FLAG];
      removeClass(element, LEAVE_CLASSNAME);
      if (details && details.hasAnimation) continue;
      let players = [];
      if (queriedElements.size) {
        let queriedPlayerResults = queriedElements.get(element);
        if (queriedPlayerResults && queriedPlayerResults.length) {
          players.push(...queriedPlayerResults);
        }
        let queriedInnerElements = this.driver.query(element, NG_ANIMATING_SELECTOR, true);
        for (let j = 0; j < queriedInnerElements.length; j++) {
          let queriedPlayers = queriedElements.get(queriedInnerElements[j]);
          if (queriedPlayers && queriedPlayers.length) {
            players.push(...queriedPlayers);
          }
        }
      }
      const activePlayers = players.filter((p) => !p.destroyed);
      if (activePlayers.length) {
        removeNodesAfterAnimationDone(this, element, activePlayers);
      } else {
        this.processLeaveNode(element);
      }
    }
    allLeaveNodes.length = 0;
    rootPlayers.forEach((player) => {
      this.players.push(player);
      player.onDone(() => {
        player.destroy();
        const index = this.players.indexOf(player);
        this.players.splice(index, 1);
      });
      player.play();
    });
    return rootPlayers;
  }
  afterFlush(callback) {
    this._flushFns.push(callback);
  }
  afterFlushAnimationsDone(callback) {
    this._whenQuietFns.push(callback);
  }
  _getPreviousPlayers(element, isQueriedElement, namespaceId, triggerName, toStateValue) {
    let players = [];
    if (isQueriedElement) {
      const queriedElementPlayers = this.playersByQueriedElement.get(element);
      if (queriedElementPlayers) {
        players = queriedElementPlayers;
      }
    } else {
      const elementPlayers = this.playersByElement.get(element);
      if (elementPlayers) {
        const isRemovalAnimation = !toStateValue || toStateValue == VOID_VALUE;
        elementPlayers.forEach((player) => {
          if (player.queued) return;
          if (!isRemovalAnimation && player.triggerName != triggerName) return;
          players.push(player);
        });
      }
    }
    if (namespaceId || triggerName) {
      players = players.filter((player) => {
        if (namespaceId && namespaceId != player.namespaceId) return false;
        if (triggerName && triggerName != player.triggerName) return false;
        return true;
      });
    }
    return players;
  }
  _beforeAnimationBuild(namespaceId, instruction, allPreviousPlayersMap) {
    const triggerName = instruction.triggerName;
    const rootElement = instruction.element;
    const targetNameSpaceId = instruction.isRemovalTransition ? void 0 : namespaceId;
    const targetTriggerName = instruction.isRemovalTransition ? void 0 : triggerName;
    for (const timelineInstruction of instruction.timelines) {
      const element = timelineInstruction.element;
      const isQueriedElement = element !== rootElement;
      const players = getOrSetDefaultValue(allPreviousPlayersMap, element, []);
      const previousPlayers = this._getPreviousPlayers(element, isQueriedElement, targetNameSpaceId, targetTriggerName, instruction.toState);
      previousPlayers.forEach((player) => {
        const realPlayer = player.getRealPlayer();
        if (realPlayer.beforeDestroy) {
          realPlayer.beforeDestroy();
        }
        player.destroy();
        players.push(player);
      });
    }
    eraseStyles(rootElement, instruction.fromStyles);
  }
  _buildAnimation(namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap, postStylesMap) {
    const triggerName = instruction.triggerName;
    const rootElement = instruction.element;
    const allQueriedPlayers = [];
    const allConsumedElements = /* @__PURE__ */ new Set();
    const allSubElements = /* @__PURE__ */ new Set();
    const allNewPlayers = instruction.timelines.map((timelineInstruction) => {
      const element = timelineInstruction.element;
      allConsumedElements.add(element);
      const details = element[REMOVAL_FLAG];
      if (details && details.removedBeforeQueried) return new NoopAnimationPlayer(timelineInstruction.duration, timelineInstruction.delay);
      const isQueriedElement = element !== rootElement;
      const previousPlayers = flattenGroupPlayers((allPreviousPlayersMap.get(element) || EMPTY_PLAYER_ARRAY).map((p) => p.getRealPlayer())).filter((p) => {
        const pp = p;
        return pp.element ? pp.element === element : false;
      });
      const preStyles = preStylesMap.get(element);
      const postStyles = postStylesMap.get(element);
      const keyframes2 = normalizeKeyframes$1(this._normalizer, timelineInstruction.keyframes, preStyles, postStyles);
      const player2 = this._buildPlayer(timelineInstruction, keyframes2, previousPlayers);
      if (timelineInstruction.subTimeline && skippedPlayersMap) {
        allSubElements.add(element);
      }
      if (isQueriedElement) {
        const wrappedPlayer = new TransitionAnimationPlayer(namespaceId, triggerName, element);
        wrappedPlayer.setRealPlayer(player2);
        allQueriedPlayers.push(wrappedPlayer);
      }
      return player2;
    });
    allQueriedPlayers.forEach((player2) => {
      getOrSetDefaultValue(this.playersByQueriedElement, player2.element, []).push(player2);
      player2.onDone(() => deleteOrUnsetInMap(this.playersByQueriedElement, player2.element, player2));
    });
    allConsumedElements.forEach((element) => addClass(element, NG_ANIMATING_CLASSNAME));
    const player = optimizeGroupPlayer(allNewPlayers);
    player.onDestroy(() => {
      allConsumedElements.forEach((element) => removeClass(element, NG_ANIMATING_CLASSNAME));
      setStyles(rootElement, instruction.toStyles);
    });
    allSubElements.forEach((element) => {
      getOrSetDefaultValue(skippedPlayersMap, element, []).push(player);
    });
    return player;
  }
  _buildPlayer(instruction, keyframes2, previousPlayers) {
    if (keyframes2.length > 0) {
      return this.driver.animate(instruction.element, keyframes2, instruction.duration, instruction.delay, instruction.easing, previousPlayers);
    }
    return new NoopAnimationPlayer(instruction.duration, instruction.delay);
  }
};
var TransitionAnimationPlayer = class {
  namespaceId;
  triggerName;
  element;
  _player = new NoopAnimationPlayer();
  _containsRealPlayer = false;
  _queuedCallbacks = /* @__PURE__ */ new Map();
  destroyed = false;
  parentPlayer = null;
  markedForDestroy = false;
  disabled = false;
  queued = true;
  totalTime = 0;
  constructor(namespaceId, triggerName, element) {
    this.namespaceId = namespaceId;
    this.triggerName = triggerName;
    this.element = element;
  }
  setRealPlayer(player) {
    if (this._containsRealPlayer) return;
    this._player = player;
    this._queuedCallbacks.forEach((callbacks, phase) => {
      callbacks.forEach((callback) => listenOnPlayer(player, phase, void 0, callback));
    });
    this._queuedCallbacks.clear();
    this._containsRealPlayer = true;
    this.overrideTotalTime(player.totalTime);
    this.queued = false;
  }
  getRealPlayer() {
    return this._player;
  }
  overrideTotalTime(totalTime) {
    this.totalTime = totalTime;
  }
  syncPlayerEvents(player) {
    const p = this._player;
    if (p.triggerCallback) {
      player.onStart(() => p.triggerCallback("start"));
    }
    player.onDone(() => this.finish());
    player.onDestroy(() => this.destroy());
  }
  _queueEvent(name, callback) {
    getOrSetDefaultValue(this._queuedCallbacks, name, []).push(callback);
  }
  onDone(fn) {
    if (this.queued) {
      this._queueEvent("done", fn);
    }
    this._player.onDone(fn);
  }
  onStart(fn) {
    if (this.queued) {
      this._queueEvent("start", fn);
    }
    this._player.onStart(fn);
  }
  onDestroy(fn) {
    if (this.queued) {
      this._queueEvent("destroy", fn);
    }
    this._player.onDestroy(fn);
  }
  init() {
    this._player.init();
  }
  hasStarted() {
    return this.queued ? false : this._player.hasStarted();
  }
  play() {
    !this.queued && this._player.play();
  }
  pause() {
    !this.queued && this._player.pause();
  }
  restart() {
    !this.queued && this._player.restart();
  }
  finish() {
    this._player.finish();
  }
  destroy() {
    this.destroyed = true;
    this._player.destroy();
  }
  reset() {
    !this.queued && this._player.reset();
  }
  setPosition(p) {
    if (!this.queued) {
      this._player.setPosition(p);
    }
  }
  getPosition() {
    return this.queued ? 0 : this._player.getPosition();
  }
  /** @internal */
  triggerCallback(phaseName) {
    const p = this._player;
    if (p.triggerCallback) {
      p.triggerCallback(phaseName);
    }
  }
};
function deleteOrUnsetInMap(map2, key, value) {
  let currentValues = map2.get(key);
  if (currentValues) {
    if (currentValues.length) {
      const index = currentValues.indexOf(value);
      currentValues.splice(index, 1);
    }
    if (currentValues.length == 0) {
      map2.delete(key);
    }
  }
  return currentValues;
}
function normalizeTriggerValue(value) {
  return value != null ? value : null;
}
function isElementNode(node) {
  return node && node["nodeType"] === 1;
}
function isTriggerEventValid(eventName) {
  return eventName == "start" || eventName == "done";
}
function cloakElement(element, value) {
  const oldValue = element.style.display;
  element.style.display = value != null ? value : "none";
  return oldValue;
}
function cloakAndComputeStyles(valuesMap, driver, elements, elementPropsMap, defaultStyle) {
  const cloakVals = [];
  elements.forEach((element) => cloakVals.push(cloakElement(element)));
  const failedElements = [];
  elementPropsMap.forEach((props, element) => {
    const styles = /* @__PURE__ */ new Map();
    props.forEach((prop) => {
      const value = driver.computeStyle(element, prop, defaultStyle);
      styles.set(prop, value);
      if (!value || value.length == 0) {
        element[REMOVAL_FLAG] = NULL_REMOVED_QUERIED_STATE;
        failedElements.push(element);
      }
    });
    valuesMap.set(element, styles);
  });
  let i = 0;
  elements.forEach((element) => cloakElement(element, cloakVals[i++]));
  return failedElements;
}
function buildRootMap(roots, nodes) {
  const rootMap = /* @__PURE__ */ new Map();
  roots.forEach((root) => rootMap.set(root, []));
  if (nodes.length == 0) return rootMap;
  const NULL_NODE = 1;
  const nodeSet = new Set(nodes);
  const localRootMap = /* @__PURE__ */ new Map();
  function getRoot(node) {
    if (!node) return NULL_NODE;
    let root = localRootMap.get(node);
    if (root) return root;
    const parent = node.parentNode;
    if (rootMap.has(parent)) {
      root = parent;
    } else if (nodeSet.has(parent)) {
      root = NULL_NODE;
    } else {
      root = getRoot(parent);
    }
    localRootMap.set(node, root);
    return root;
  }
  nodes.forEach((node) => {
    const root = getRoot(node);
    if (root !== NULL_NODE) {
      rootMap.get(root).push(node);
    }
  });
  return rootMap;
}
function addClass(element, className) {
  element.classList?.add(className);
}
function removeClass(element, className) {
  element.classList?.remove(className);
}
function removeNodesAfterAnimationDone(engine, element, players) {
  optimizeGroupPlayer(players).onDone(() => engine.processLeaveNode(element));
}
function flattenGroupPlayers(players) {
  const finalPlayers = [];
  _flattenGroupPlayersRecur(players, finalPlayers);
  return finalPlayers;
}
function _flattenGroupPlayersRecur(players, finalPlayers) {
  for (let i = 0; i < players.length; i++) {
    const player = players[i];
    if (player instanceof AnimationGroupPlayer) {
      _flattenGroupPlayersRecur(player.players, finalPlayers);
    } else {
      finalPlayers.push(player);
    }
  }
}
function objEquals(a, b) {
  const k1 = Object.keys(a);
  const k2 = Object.keys(b);
  if (k1.length != k2.length) return false;
  for (let i = 0; i < k1.length; i++) {
    const prop = k1[i];
    if (!b.hasOwnProperty(prop) || a[prop] !== b[prop]) return false;
  }
  return true;
}
function replacePostStylesAsPre(element, allPreStyleElements, allPostStyleElements) {
  const postEntry = allPostStyleElements.get(element);
  if (!postEntry) return false;
  let preEntry = allPreStyleElements.get(element);
  if (preEntry) {
    postEntry.forEach((data) => preEntry.add(data));
  } else {
    allPreStyleElements.set(element, postEntry);
  }
  allPostStyleElements.delete(element);
  return true;
}
var AnimationEngine = class {
  _driver;
  _normalizer;
  _transitionEngine;
  _timelineEngine;
  _triggerCache = {};
  // this method is designed to be overridden by the code that uses this engine
  onRemovalComplete = (element, context) => {
  };
  constructor(doc, _driver, _normalizer) {
    this._driver = _driver;
    this._normalizer = _normalizer;
    this._transitionEngine = new TransitionAnimationEngine(doc.body, _driver, _normalizer);
    this._timelineEngine = new TimelineAnimationEngine(doc.body, _driver, _normalizer);
    this._transitionEngine.onRemovalComplete = (element, context) => this.onRemovalComplete(element, context);
  }
  registerTrigger(componentId, namespaceId, hostElement, name, metadata) {
    const cacheKey = componentId + "-" + name;
    let trigger2 = this._triggerCache[cacheKey];
    if (!trigger2) {
      const errors = [];
      const warnings = [];
      const ast = buildAnimationAst(this._driver, metadata, errors, warnings);
      if (errors.length) {
        throw triggerBuildFailed(name, errors);
      }
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        if (warnings.length) {
          warnTriggerBuild(name, warnings);
        }
      }
      trigger2 = buildTrigger(name, ast, this._normalizer);
      this._triggerCache[cacheKey] = trigger2;
    }
    this._transitionEngine.registerTrigger(namespaceId, name, trigger2);
  }
  register(namespaceId, hostElement) {
    this._transitionEngine.register(namespaceId, hostElement);
  }
  destroy(namespaceId, context) {
    this._transitionEngine.destroy(namespaceId, context);
  }
  onInsert(namespaceId, element, parent, insertBefore) {
    this._transitionEngine.insertNode(namespaceId, element, parent, insertBefore);
  }
  onRemove(namespaceId, element, context) {
    this._transitionEngine.removeNode(namespaceId, element, context);
  }
  disableAnimations(element, disable) {
    this._transitionEngine.markElementAsDisabled(element, disable);
  }
  process(namespaceId, element, property, value) {
    if (property.charAt(0) == "@") {
      const [id, action] = parseTimelineCommand(property);
      const args = value;
      this._timelineEngine.command(id, element, action, args);
    } else {
      this._transitionEngine.trigger(namespaceId, element, property, value);
    }
  }
  listen(namespaceId, element, eventName, eventPhase, callback) {
    if (eventName.charAt(0) == "@") {
      const [id, action] = parseTimelineCommand(eventName);
      return this._timelineEngine.listen(id, element, action, callback);
    }
    return this._transitionEngine.listen(namespaceId, element, eventName, eventPhase, callback);
  }
  flush(microtaskId = -1) {
    this._transitionEngine.flush(microtaskId);
  }
  get players() {
    return [...this._transitionEngine.players, ...this._timelineEngine.players];
  }
  whenRenderingDone() {
    return this._transitionEngine.whenRenderingDone();
  }
  afterFlushAnimationsDone(cb) {
    this._transitionEngine.afterFlushAnimationsDone(cb);
  }
};
function packageNonAnimatableStyles(element, styles) {
  let startStyles = null;
  let endStyles = null;
  if (Array.isArray(styles) && styles.length) {
    startStyles = filterNonAnimatableStyles(styles[0]);
    if (styles.length > 1) {
      endStyles = filterNonAnimatableStyles(styles[styles.length - 1]);
    }
  } else if (styles instanceof Map) {
    startStyles = filterNonAnimatableStyles(styles);
  }
  return startStyles || endStyles ? new SpecialCasedStyles(element, startStyles, endStyles) : null;
}
var SpecialCasedStyles = class _SpecialCasedStyles {
  _element;
  _startStyles;
  _endStyles;
  static initialStylesByElement = /* @__PURE__ */ new WeakMap();
  _state = 0;
  _initialStyles;
  constructor(_element, _startStyles, _endStyles) {
    this._element = _element;
    this._startStyles = _startStyles;
    this._endStyles = _endStyles;
    let initialStyles = _SpecialCasedStyles.initialStylesByElement.get(_element);
    if (!initialStyles) {
      _SpecialCasedStyles.initialStylesByElement.set(_element, initialStyles = /* @__PURE__ */ new Map());
    }
    this._initialStyles = initialStyles;
  }
  start() {
    if (this._state < 1) {
      if (this._startStyles) {
        setStyles(this._element, this._startStyles, this._initialStyles);
      }
      this._state = 1;
    }
  }
  finish() {
    this.start();
    if (this._state < 2) {
      setStyles(this._element, this._initialStyles);
      if (this._endStyles) {
        setStyles(this._element, this._endStyles);
        this._endStyles = null;
      }
      this._state = 1;
    }
  }
  destroy() {
    this.finish();
    if (this._state < 3) {
      _SpecialCasedStyles.initialStylesByElement.delete(this._element);
      if (this._startStyles) {
        eraseStyles(this._element, this._startStyles);
        this._endStyles = null;
      }
      if (this._endStyles) {
        eraseStyles(this._element, this._endStyles);
        this._endStyles = null;
      }
      setStyles(this._element, this._initialStyles);
      this._state = 3;
    }
  }
};
function filterNonAnimatableStyles(styles) {
  let result = null;
  styles.forEach((val, prop) => {
    if (isNonAnimatableStyle(prop)) {
      result = result || /* @__PURE__ */ new Map();
      result.set(prop, val);
    }
  });
  return result;
}
function isNonAnimatableStyle(prop) {
  return prop === "display" || prop === "position";
}
var WebAnimationsPlayer = class {
  element;
  keyframes;
  options;
  _specialStyles;
  _onDoneFns = [];
  _onStartFns = [];
  _onDestroyFns = [];
  _duration;
  _delay;
  _initialized = false;
  _finished = false;
  _started = false;
  _destroyed = false;
  _finalKeyframe;
  // the following original fns are persistent copies of the _onStartFns and _onDoneFns
  // and are used to reset the fns to their original values upon reset()
  // (since the _onStartFns and _onDoneFns get deleted after they are called)
  _originalOnDoneFns = [];
  _originalOnStartFns = [];
  domPlayer = null;
  time = 0;
  parentPlayer = null;
  currentSnapshot = /* @__PURE__ */ new Map();
  constructor(element, keyframes2, options, _specialStyles) {
    this.element = element;
    this.keyframes = keyframes2;
    this.options = options;
    this._specialStyles = _specialStyles;
    this._duration = options["duration"];
    this._delay = options["delay"] || 0;
    this.time = this._duration + this._delay;
  }
  _onFinish() {
    if (!this._finished) {
      this._finished = true;
      this._onDoneFns.forEach((fn) => fn());
      this._onDoneFns = [];
    }
  }
  init() {
    if (!this._buildPlayer()) {
      return;
    }
    this._preparePlayerBeforeStart();
  }
  _buildPlayer() {
    if (this._initialized) return this.domPlayer;
    this._initialized = true;
    const keyframes2 = this.keyframes;
    const animation2 = this._triggerWebAnimation(this.element, keyframes2, this.options);
    if (!animation2) {
      this._onFinish();
      return null;
    }
    this.domPlayer = animation2;
    this._finalKeyframe = keyframes2.length ? keyframes2[keyframes2.length - 1] : /* @__PURE__ */ new Map();
    const onFinish = () => this._onFinish();
    animation2.addEventListener("finish", onFinish);
    this.onDestroy(() => {
      animation2.removeEventListener("finish", onFinish);
    });
    return animation2;
  }
  _preparePlayerBeforeStart() {
    if (this._delay) {
      this._resetDomPlayerState();
    } else {
      this.domPlayer?.pause();
    }
  }
  _convertKeyframesToObject(keyframes2) {
    const kfs = [];
    keyframes2.forEach((frame) => {
      kfs.push(Object.fromEntries(frame));
    });
    return kfs;
  }
  /** @internal */
  _triggerWebAnimation(element, keyframes2, options) {
    const keyframesObject = this._convertKeyframesToObject(keyframes2);
    try {
      return element.animate(keyframesObject, options);
    } catch {
      return null;
    }
  }
  onStart(fn) {
    this._originalOnStartFns.push(fn);
    this._onStartFns.push(fn);
  }
  onDone(fn) {
    this._originalOnDoneFns.push(fn);
    this._onDoneFns.push(fn);
  }
  onDestroy(fn) {
    this._onDestroyFns.push(fn);
  }
  play() {
    const player = this._buildPlayer();
    if (!player) {
      return;
    }
    if (!this.hasStarted()) {
      this._onStartFns.forEach((fn) => fn());
      this._onStartFns = [];
      this._started = true;
      if (this._specialStyles) {
        this._specialStyles.start();
      }
    }
    player.play();
  }
  pause() {
    this.init();
    this.domPlayer?.pause();
  }
  finish() {
    this.init();
    if (!this.domPlayer) return;
    if (this._specialStyles) {
      this._specialStyles.finish();
    }
    this._onFinish();
    this.domPlayer.finish();
  }
  reset() {
    this._resetDomPlayerState();
    this._destroyed = false;
    this._finished = false;
    this._started = false;
    this._onStartFns = this._originalOnStartFns;
    this._onDoneFns = this._originalOnDoneFns;
  }
  _resetDomPlayerState() {
    this.domPlayer?.cancel();
  }
  restart() {
    this.reset();
    this.play();
  }
  hasStarted() {
    return this._started;
  }
  destroy() {
    if (!this._destroyed) {
      this._destroyed = true;
      this._resetDomPlayerState();
      this._onFinish();
      if (this._specialStyles) {
        this._specialStyles.destroy();
      }
      this._onDestroyFns.forEach((fn) => fn());
      this._onDestroyFns = [];
    }
  }
  setPosition(p) {
    if (!this.domPlayer) {
      this.init();
    }
    if (this.domPlayer) {
      this.domPlayer.currentTime = p * this.time;
    }
  }
  getPosition() {
    if (!this.domPlayer) {
      return this._initialized ? 1 : 0;
    }
    return +(this.domPlayer.currentTime ?? 0) / this.time;
  }
  get totalTime() {
    return this._delay + this._duration;
  }
  beforeDestroy() {
    const styles = /* @__PURE__ */ new Map();
    if (this.hasStarted()) {
      const finalKeyframe = this._finalKeyframe;
      finalKeyframe.forEach((val, prop) => {
        if (prop !== "offset") {
          styles.set(prop, this._finished ? val : computeStyle(this.element, prop));
        }
      });
    }
    this.currentSnapshot = styles;
  }
  /** @internal */
  triggerCallback(phaseName) {
    const methods = phaseName === "start" ? this._onStartFns : this._onDoneFns;
    methods.forEach((fn) => fn());
    methods.length = 0;
  }
};
var WebAnimationsDriver = class {
  validateStyleProperty(prop) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      return validateStyleProperty(prop);
    }
    return true;
  }
  validateAnimatableStyleProperty(prop) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      const cssProp = camelCaseToDashCase(prop);
      return validateWebAnimatableStyleProperty(cssProp);
    }
    return true;
  }
  containsElement(elm1, elm2) {
    return containsElement(elm1, elm2);
  }
  getParentElement(element) {
    return getParentElement(element);
  }
  query(element, selector, multi) {
    return invokeQuery(element, selector, multi);
  }
  computeStyle(element, prop, defaultValue) {
    return computeStyle(element, prop);
  }
  animate(element, keyframes2, duration, delay2, easing, previousPlayers = []) {
    const fill = delay2 == 0 ? "both" : "forwards";
    const playerOptions = {
      duration,
      delay: delay2,
      fill
    };
    if (easing) {
      playerOptions["easing"] = easing;
    }
    const previousStyles = /* @__PURE__ */ new Map();
    const previousWebAnimationPlayers = previousPlayers.filter((player) => player instanceof WebAnimationsPlayer);
    if (allowPreviousPlayerStylesMerge(duration, delay2)) {
      previousWebAnimationPlayers.forEach((player) => {
        player.currentSnapshot.forEach((val, prop) => previousStyles.set(prop, val));
      });
    }
    let _keyframes = normalizeKeyframes(keyframes2).map((styles) => new Map(styles));
    _keyframes = balancePreviousStylesIntoKeyframes(element, _keyframes, previousStyles);
    const specialStyles = packageNonAnimatableStyles(element, _keyframes);
    return new WebAnimationsPlayer(element, _keyframes, playerOptions, specialStyles);
  }
};
var ANIMATION_PREFIX = "@";
var DISABLE_ANIMATIONS_FLAG = "@.disabled";
var BaseAnimationRenderer = class {
  namespaceId;
  delegate;
  engine;
  _onDestroy;
  // We need to explicitly type this property because of an api-extractor bug
  // See https://github.com/microsoft/rushstack/issues/4390
  \u0275type = 0;
  constructor(namespaceId, delegate, engine, _onDestroy) {
    this.namespaceId = namespaceId;
    this.delegate = delegate;
    this.engine = engine;
    this._onDestroy = _onDestroy;
  }
  get data() {
    return this.delegate.data;
  }
  destroyNode(node) {
    this.delegate.destroyNode?.(node);
  }
  destroy() {
    this.engine.destroy(this.namespaceId, this.delegate);
    this.engine.afterFlushAnimationsDone(() => {
      queueMicrotask(() => {
        this.delegate.destroy();
      });
    });
    this._onDestroy?.();
  }
  createElement(name, namespace) {
    return this.delegate.createElement(name, namespace);
  }
  createComment(value) {
    return this.delegate.createComment(value);
  }
  createText(value) {
    return this.delegate.createText(value);
  }
  appendChild(parent, newChild) {
    this.delegate.appendChild(parent, newChild);
    this.engine.onInsert(this.namespaceId, newChild, parent, false);
  }
  insertBefore(parent, newChild, refChild, isMove = true) {
    this.delegate.insertBefore(parent, newChild, refChild);
    this.engine.onInsert(this.namespaceId, newChild, parent, isMove);
  }
  // TODO(thePunderWoman): remove the requireSynchronousElementRemoval flag after the
  // animations package has been fully deleted post v23.
  removeChild(parent, oldChild, isHostElement, requireSynchronousElementRemoval) {
    if (requireSynchronousElementRemoval) {
      this.delegate.removeChild(parent, oldChild, isHostElement, requireSynchronousElementRemoval);
      return;
    }
    if (this.parentNode(oldChild)) {
      this.engine.onRemove(this.namespaceId, oldChild, this.delegate);
    }
  }
  selectRootElement(selectorOrNode, preserveContent) {
    return this.delegate.selectRootElement(selectorOrNode, preserveContent);
  }
  parentNode(node) {
    return this.delegate.parentNode(node);
  }
  nextSibling(node) {
    return this.delegate.nextSibling(node);
  }
  setAttribute(el, name, value, namespace) {
    this.delegate.setAttribute(el, name, value, namespace);
  }
  removeAttribute(el, name, namespace) {
    this.delegate.removeAttribute(el, name, namespace);
  }
  addClass(el, name) {
    this.delegate.addClass(el, name);
  }
  removeClass(el, name) {
    this.delegate.removeClass(el, name);
  }
  setStyle(el, style2, value, flags) {
    this.delegate.setStyle(el, style2, value, flags);
  }
  removeStyle(el, style2, flags) {
    this.delegate.removeStyle(el, style2, flags);
  }
  setProperty(el, name, value) {
    if (name.charAt(0) == ANIMATION_PREFIX && name == DISABLE_ANIMATIONS_FLAG) {
      this.disableAnimations(el, !!value);
    } else {
      this.delegate.setProperty(el, name, value);
    }
  }
  setValue(node, value) {
    this.delegate.setValue(node, value);
  }
  listen(target, eventName, callback, options) {
    return this.delegate.listen(target, eventName, callback, options);
  }
  disableAnimations(element, value) {
    this.engine.disableAnimations(element, value);
  }
};
var AnimationRenderer = class extends BaseAnimationRenderer {
  factory;
  constructor(factory, namespaceId, delegate, engine, onDestroy) {
    super(namespaceId, delegate, engine, onDestroy);
    this.factory = factory;
    this.namespaceId = namespaceId;
  }
  setProperty(el, name, value) {
    if (name.charAt(0) == ANIMATION_PREFIX) {
      if (name.charAt(1) == "." && name == DISABLE_ANIMATIONS_FLAG) {
        value = value === void 0 ? true : !!value;
        this.disableAnimations(el, value);
      } else {
        this.engine.process(this.namespaceId, el, name.slice(1), value);
      }
    } else {
      this.delegate.setProperty(el, name, value);
    }
  }
  listen(target, eventName, callback, options) {
    if (eventName.charAt(0) == ANIMATION_PREFIX) {
      const element = resolveElementFromTarget(target);
      let name = eventName.slice(1);
      let phase = "";
      if (name.charAt(0) != ANIMATION_PREFIX) {
        [name, phase] = parseTriggerCallbackName(name);
      }
      return this.engine.listen(this.namespaceId, element, name, phase, (event) => {
        const countId = event["_data"] || -1;
        this.factory.scheduleListenerCallback(countId, callback, event);
      });
    }
    return this.delegate.listen(target, eventName, callback, options);
  }
};
function resolveElementFromTarget(target) {
  switch (target) {
    case "body":
      return document.body;
    case "document":
      return document;
    case "window":
      return window;
    default:
      return target;
  }
}
function parseTriggerCallbackName(triggerName) {
  const dotIndex = triggerName.indexOf(".");
  const trigger2 = triggerName.substring(0, dotIndex);
  const phase = triggerName.slice(dotIndex + 1);
  return [trigger2, phase];
}
var AnimationRendererFactory = class {
  delegate;
  engine;
  _zone;
  _currentId = 0;
  _microtaskId = 1;
  _animationCallbacksBuffer = [];
  _rendererCache = /* @__PURE__ */ new Map();
  _cdRecurDepth = 0;
  constructor(delegate, engine, _zone) {
    this.delegate = delegate;
    this.engine = engine;
    this._zone = _zone;
    engine.onRemovalComplete = (element, delegate2) => {
      delegate2?.removeChild(null, element);
    };
  }
  createRenderer(hostElement, type) {
    const EMPTY_NAMESPACE_ID = "";
    const delegate = this.delegate.createRenderer(hostElement, type);
    if (!hostElement || !type?.data?.["animation"]) {
      const cache = this._rendererCache;
      let renderer = cache.get(delegate);
      if (!renderer) {
        const onRendererDestroy = () => cache.delete(delegate);
        renderer = new BaseAnimationRenderer(EMPTY_NAMESPACE_ID, delegate, this.engine, onRendererDestroy);
        cache.set(delegate, renderer);
      }
      return renderer;
    }
    const componentId = type.id;
    const namespaceId = type.id + "-" + this._currentId;
    this._currentId++;
    this.engine.register(namespaceId, hostElement);
    const registerTrigger = (trigger2) => {
      if (Array.isArray(trigger2)) {
        trigger2.forEach(registerTrigger);
      } else {
        this.engine.registerTrigger(componentId, namespaceId, hostElement, trigger2.name, trigger2);
      }
    };
    const animationTriggers = type.data["animation"];
    animationTriggers.forEach(registerTrigger);
    return new AnimationRenderer(this, namespaceId, delegate, this.engine);
  }
  begin() {
    this._cdRecurDepth++;
    if (this.delegate.begin) {
      this.delegate.begin();
    }
  }
  _scheduleCountTask() {
    queueMicrotask(() => {
      this._microtaskId++;
    });
  }
  /** @internal */
  scheduleListenerCallback(count, fn, data) {
    if (count >= 0 && count < this._microtaskId) {
      this._zone.run(() => fn(data));
      return;
    }
    const animationCallbacksBuffer = this._animationCallbacksBuffer;
    if (animationCallbacksBuffer.length == 0) {
      queueMicrotask(() => {
        this._zone.run(() => {
          animationCallbacksBuffer.forEach((tuple) => {
            const [fn2, data2] = tuple;
            fn2(data2);
          });
          this._animationCallbacksBuffer = [];
        });
      });
    }
    animationCallbacksBuffer.push([fn, data]);
  }
  end() {
    this._cdRecurDepth--;
    if (this._cdRecurDepth == 0) {
      this._zone.runOutsideAngular(() => {
        this._scheduleCountTask();
        this.engine.flush(this._microtaskId);
      });
    }
    if (this.delegate.end) {
      this.delegate.end();
    }
  }
  whenRenderingDone() {
    return this.engine.whenRenderingDone();
  }
  /**
   * Used during HMR to clear any cached data about a component.
   * @param componentId ID of the component that is being replaced.
   */
  componentReplaced(componentId) {
    this.engine.flush();
    this.delegate.componentReplaced?.(componentId);
  }
};

// node_modules/@angular/platform-browser/fesm2022/animations.mjs
var InjectableAnimationEngine = class _InjectableAnimationEngine extends AnimationEngine {
  // The `ApplicationRef` is injected here explicitly to force the dependency ordering.
  // Since the `ApplicationRef` should be created earlier before the `AnimationEngine`, they
  // both have `ngOnDestroy` hooks and `flush()` must be called after all views are destroyed.
  constructor(doc, driver, normalizer) {
    super(doc, driver, normalizer);
  }
  ngOnDestroy() {
    this.flush();
  }
  static \u0275fac = function InjectableAnimationEngine_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _InjectableAnimationEngine)(\u0275\u0275inject(DOCUMENT), \u0275\u0275inject(AnimationDriver), \u0275\u0275inject(AnimationStyleNormalizer));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _InjectableAnimationEngine,
    factory: _InjectableAnimationEngine.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InjectableAnimationEngine, [{
    type: Injectable
  }], () => [{
    type: Document,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: AnimationDriver
  }, {
    type: AnimationStyleNormalizer
  }], null);
})();
function instantiateDefaultStyleNormalizer() {
  return new WebAnimationsStyleNormalizer();
}
function instantiateRendererFactory(renderer, engine, zone) {
  return new AnimationRendererFactory(renderer, engine, zone);
}
var SHARED_ANIMATION_PROVIDERS = [{
  provide: AnimationStyleNormalizer,
  useFactory: instantiateDefaultStyleNormalizer
}, {
  provide: AnimationEngine,
  useClass: InjectableAnimationEngine
}, {
  provide: RendererFactory2,
  useFactory: instantiateRendererFactory,
  deps: [DomRendererFactory2, AnimationEngine, NgZone]
}];
var BROWSER_NOOP_ANIMATIONS_PROVIDERS = [{
  provide: AnimationDriver,
  useClass: NoopAnimationDriver
}, {
  provide: ANIMATION_MODULE_TYPE,
  useValue: "NoopAnimations"
}, ...SHARED_ANIMATION_PROVIDERS];
var BROWSER_ANIMATIONS_PROVIDERS = [
  // Note: the `ngServerMode` happen inside factories to give the variable time to initialize.
  {
    provide: AnimationDriver,
    useFactory: () => false ? new NoopAnimationDriver() : new WebAnimationsDriver()
  },
  {
    provide: ANIMATION_MODULE_TYPE,
    useFactory: () => false ? "NoopAnimations" : "BrowserAnimations"
  },
  ...SHARED_ANIMATION_PROVIDERS
];
var BrowserAnimationsModule = class _BrowserAnimationsModule {
  /**
   * Configures the module based on the specified object.
   *
   * @param config Object used to configure the behavior of the `BrowserAnimationsModule`.
   * @see {@link BrowserAnimationsModuleConfig}
   *
   * @usageNotes
   * When registering the `BrowserAnimationsModule`, you can use the `withConfig`
   * function as follows:
   * ```ts
   * @NgModule({
   *   imports: [BrowserAnimationsModule.withConfig(config)]
   * })
   * class MyNgModule {}
   * ```
   */
  static withConfig(config) {
    return {
      ngModule: _BrowserAnimationsModule,
      providers: config.disableAnimations ? BROWSER_NOOP_ANIMATIONS_PROVIDERS : BROWSER_ANIMATIONS_PROVIDERS
    };
  }
  static \u0275fac = function BrowserAnimationsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BrowserAnimationsModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _BrowserAnimationsModule,
    exports: [BrowserModule]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    providers: BROWSER_ANIMATIONS_PROVIDERS,
    imports: [BrowserModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BrowserAnimationsModule, [{
    type: NgModule,
    args: [{
      exports: [BrowserModule],
      providers: BROWSER_ANIMATIONS_PROVIDERS
    }]
  }], null, null);
})();
function provideAnimations() {
  performanceMarkFeature("NgEagerAnimations");
  return [...BROWSER_ANIMATIONS_PROVIDERS];
}
var NoopAnimationsModule = class _NoopAnimationsModule {
  static \u0275fac = function NoopAnimationsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NoopAnimationsModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _NoopAnimationsModule,
    exports: [BrowserModule]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    providers: BROWSER_NOOP_ANIMATIONS_PROVIDERS,
    imports: [BrowserModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NoopAnimationsModule, [{
    type: NgModule,
    args: [{
      exports: [BrowserModule],
      providers: BROWSER_NOOP_ANIMATIONS_PROVIDERS
    }]
  }], null, null);
})();

// src/environment/environment.ts
var environment = {
  production: false,
  firebase: {
    apiKey: "AIzaSyBZDMon3ozRz19QTHmqCE4j43RbRIr6Nns",
    authDomain: "uxwork-89519.firebaseapp.com",
    projectId: "uxwork-89519",
    storageBucket: "uxwork-89519.appspot.com",
    messagingSenderId: "506525676287",
    appId: "1:506525676287:web:52aaaa40e0e3c8d2efd2ca"
  }
};

// src/main.ts
bootstrapApplication(AppComponent, {
  providers: [
    provideRouter(routes),
    provideAnimations(),
    provideFirebaseApp(() => initializeApp(environment.firebase)),
    provideFirestore(() => getFirestore()),
    importProvidersFrom(
      NbThemeModule.forRoot({ name: "default" }),
      // 初始化主題
      NbLayoutModule,
      // 提供版面元件
      NbButtonModule,
      // 按鈕模組
      NbEvaIconsModule
      // Nebular 圖示支援
    )
  ]
});
/*! Bundled license information:

eva-icons/eva.js:
  (*!
    Copyright (c) 2017 Jed Watson.
    Licensed under the MIT License (MIT), see
    http://jedwatson.github.io/classnames
  *)
  (*! Isomorphic Style Loader | MIT License | https://github.com/kriasoft/isomorphic-style-loader *)
  (**
   * @license
   * Copyright Akveo. All Rights Reserved.
   * Licensed under the MIT License. See License.txt in the project root for license information.
   *)

@angular/platform-browser/fesm2022/dom_renderer.mjs:
@angular/platform-browser/fesm2022/browser.mjs:
@angular/platform-browser/fesm2022/platform-browser.mjs:
@angular/router/fesm2022/router2.mjs:
@angular/router/fesm2022/router_module.mjs:
@angular/router/fesm2022/router.mjs:
@angular/animations/fesm2022/private_export.mjs:
@angular/animations/fesm2022/animations.mjs:
@angular/animations/fesm2022/util.mjs:
@angular/animations/fesm2022/browser.mjs:
@angular/platform-browser/fesm2022/animations.mjs:
  (**
   * @license Angular v20.3.7
   * (c) 2010-2025 Google LLC. https://angular.dev/
   * License: MIT
   *)

@nebular/theme/fesm2022/nebular-theme.mjs:
@nebular/theme/fesm2022/nebular-theme.mjs:
@nebular/theme/fesm2022/nebular-theme.mjs:
  (**
   * @license
   * Copyright Akveo. All Rights Reserved.
   * Licensed under the MIT License. See License.txt in the project root for license information.
   *)

@nebular/theme/fesm2022/nebular-theme.mjs:
@nebular/theme/fesm2022/nebular-theme.mjs:
  (*
   * @license
   * Copyright Akveo. All Rights Reserved.
   * Licensed under the MIT License. See License.txt in the project root for license information.
   *)
  (**
   * @license
   * Copyright Akveo. All Rights Reserved.
   * Licensed under the MIT License. See License.txt in the project root for license information.
   *)

@nebular/theme/fesm2022/nebular-theme.mjs:
  (*
   * @license
   * Copyright Akveo. All Rights Reserved.
   * Licensed under the MIT License. See License.txt in the project root for license infornbion.
   *)
  (**
   * @license
   * Copyright Akveo. All Rights Reserved.
   * Licensed under the MIT License. See License.txt in the project root for license information.
   *)

@nebular/eva-icons/fesm2022/nebular-eva-icons.mjs:
  (*
   * @license
   * Copyright Akveo. All Rights Reserved.
   * Licensed under the MIT License. See License.txt in the project root for license information.
   *)
*/
//# sourceMappingURL=main.js.map
